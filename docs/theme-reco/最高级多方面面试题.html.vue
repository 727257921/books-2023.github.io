<template><div><h1 id="一-操作系统面试题" tabindex="-1"><a class="header-anchor" href="#一-操作系统面试题" aria-hidden="true">#</a> 一.操作系统面试题</h1>
<h3 id="_1-简述windows内存管理的几种方式和优缺点" tabindex="-1"><a class="header-anchor" href="#_1-简述windows内存管理的几种方式和优缺点" aria-hidden="true">#</a> 1：简述Windows内存管理的几种方式和优缺点：</h3>
<p>—–Windows内存管理方式主要分为：页式管理， 段式管理， 段页式管理。</p>
<h6 id="一、页式管理的基本原理" tabindex="-1"><a class="header-anchor" href="#一、页式管理的基本原理" aria-hidden="true">#</a> 一、页式管理的基本原理：</h6>
<p>将各进程的虚拟空间划分成若干个长度相等的页（page）;
页式管理把内存空间按页的大小划分成片或者页面，然后把页式虚拟地址与内存地址建立一一对应的页表；并用相应的硬件地址变换机构来解决离散地址变换问题。
页式管理采用请求调页或预调页技术来实现内外存存储器的统一管理。
优点是：没有外碎片，每个内碎片不超过页 的大小。
缺点：程序全部装入内存，要求有相应的硬件支持。
例如地址变换机构缺页中断的产生和选择淘汰页面等都要求有相应的硬件支持。这增加了机器成本，增加了系统开销。</p>
<h6 id="二、段式管理" tabindex="-1"><a class="header-anchor" href="#二、段式管理" aria-hidden="true">#</a> 二、段式管理：</h6>
<p>基本思想：把程序按内容或过程函数关系分成段，每段有自己的名字。
一个用户作业或进程所包含的段对应一个二维线性虚拟空间，也就是一个二维虚拟存储器。
段式管理程序以段为单位分配内存，然后通过地址映射机构把段式虚拟地址转换为实际内存物理地址。
优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位来进行共享，包括通过动态链接进行代码共享。
缺点：会产生碎片。</p>
<h6 id="三、段页式管理" tabindex="-1"><a class="header-anchor" href="#三、段页式管理" aria-hidden="true">#</a> 三、段页式管理：</h6>
<p>为了实现段页式管理，系统必须为每个作业或进程建立一张段表以管理内存分配与释放，缺段处理等。另外由于一个段又被划分成了若干页，每个段又必须建立一张页表以把段中的虚页变换成内存中的实际页面。显然与页式管理时相同，页表中也有相应的实现缺页中断处理和页面保护等功能的表项。
段页式管理是段式管理与页式管理方案结合而成的，所以具有它们两者的优点。但反过来说，由于管理软件的增加，复杂性和开销也就随之增加了。另外需要的硬件以及占用的内存也有所增加，使得执行速度下降。</p>
<h3 id="_2、进程与线程" tabindex="-1"><a class="header-anchor" href="#_2、进程与线程" aria-hidden="true">#</a> 2、进程与线程</h3>
<h6 id="_1、简单说说进程、线程以及它们的区别" tabindex="-1"><a class="header-anchor" href="#_1、简单说说进程、线程以及它们的区别" aria-hidden="true">#</a> 1、简单说说进程、线程以及它们的区别</h6>
<p>进程： 是系统进行资源分配和调度的一个独立单位，是最小的资源管理单位。</p>
<p>线程： 是进程的一个实体，是 CPU 调度和分派的基本单位，是最小的 CPU 执行单元。线程自己不拥有任何系统资源，但是它可以访问其隶属进程的全部资源。所以线程创建、撤销、切换的开销远小于进程，一个进程可以拥有多个线程。</p>
<p>根本区别：进程是操作系统资源分配的基本单位，而线程是任务调度和执行的基本单位。</p>
<p>开销方面：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</p>
<p>所处环境：在操作系统中能同时运行多个进程（程序）；而在同一个进程中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。</p>
<p>内存分配方面：系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言，除了CPU外，系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源），线程组之间只能共享资源。
包含关系：一个进程最少由一条线程组成。</p>
<p>地址空间：同一进程的线程共享本进程的地址空间，而进程之间则是独立的地址空间。</p>
<p>资源拥有：同一进程内的线程共享本进程的资源如内存、I/O、cpu等，但是进程之间的资源是独立的。</p>
<p>一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p>
<p>进程切换时，消耗的资源大，效率高。所以涉及到频繁的切换时，使用线程要好于进程。 同样如果要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</p>
<p>在多线程环境中，一个进程被定义成资源分配的单位和一个被保护的单位，与进程相关联的有：</p>
<p>（1）存放进程映像（程序、数据、栈和进程控制块中定义的属性的集合）的虚拟地址空间</p>
<p>（2）受保护的对处理器、其他进程（用于进程间通信）、文件和IO资源（设备和通道）的访问</p>
<p>在一个进程中，可能有一个或多个线程，每个线程有：</p>
<p>​		线程执行状态（运行、就绪等）</p>
<p>​		在未运行时保存的线程上下文</p>
<p>​		一个执行栈</p>
<p>​		用于每个线程局部变量的静态存储空间</p>
<p>​		与进程内的其他线程共享的对进程的内存和资源的访问</p>
<p>在多线程进程中，每个线程都有一个独立的栈，还有独立的线程控制块用于包含寄存器值、优先级和其他与线程相关的状态信息。</p>
<p>在大多数操作系统中，独立进程间的通信需要内核的介入，以提供保护和通信所需要的机制。但是，由于在同一个进程中的线程共享内存和文件，他们无需调用内核就可以相互通信。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211220223711016.png" alt="image-20211220223711016"></p>
<h6 id="_2、进程的状态和转换" tabindex="-1"><a class="header-anchor" href="#_2、进程的状态和转换" aria-hidden="true">#</a> 2、进程的状态和转换</h6>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217173518823.png" alt="image-20211217173518823"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218120625120.png" alt="image-20211218120625120"></p>
<p>三态模型： 一个进程从创建而产生至撤销而消亡的整个生命周期，可以用一组状态加以划分，根据三态模型，进程的生命周期可分为如下三种进程状态：</p>
<p>运行态(running)：占有处理器正在运行；</p>
<p>就绪态(ready)：具备运行条件，等待系统分配处理器以便运行；</p>
<p>阻塞态(blocked)：不具备运行条件，正在等待某个事件的完成。等待阻塞进程的事件完成。</p>
<p><strong>新建态</strong>：刚刚创建的进程，操作系统还没有把它加入到可执行进程组中，通常是进程控制块已经创建但是还没有加载到内存中的进程。</p>
<p><strong>退出态</strong>：操作系统从可执行进程组中释放出的进程，或由于自身或某种原因停止运行。</p>
<p>处于运行态的进程由于出现等待事件而进入阻塞态，直到事件结束则由阻塞态进入就绪态，而处理器的调度策略有会引起运行态和就绪态之间的切换【比如进程被选中进入运行态，时间片用完进入就绪态】</p>
<p>（2）上图显示了导致进程状态转换的事件类型，可能的转换如下：</p>
<p>空-&gt;新建：创建执行一个程序的新进程，可能的事件有：新的批处理作业、交互登录（终端用户登录到系统）、操作系统因为提供一项服务而创建、由现有的进程派生等。</p>
<p>新建-&gt;就绪：操作系统准备好再接纳一个进程时，把一个进程从新建态转换为就绪态。</p>
<p>就绪-&gt;运行：需要选择一个新进程运行时，操作系统的调度器或分配器根据某种调度算法选择一个处于就绪态的进程。</p>
<p>运行-&gt;退出：导致进程终止的原因有：正常完成、超过时限、系统无法满足进程需要的内存空间、进程试图访问不允许访问的内存单元（越界）、算术错误（如除以0或存储大于硬件可以接纳的数字）、父进程终止（操作系统可能会自动终止该进程所有的后代进程）、父进程请求终止后代进程等。</p>
<p>运行-&gt;就绪：最常见的原因是，正在运行的进程到达了“允许不中断执行”的最大时间段，该把处理器的资源释放给其他在就绪态的进程使用了；还有一中原因可能是由于具有更改优先级的就绪态进程抢占了该进程的资源，使其被中断转换到就绪态。</p>
<p>运行-&gt;阻塞：如果进程请求它必须等待的某些事件，例如一个无法立即得到的资源（如I/O操作），只有在获得等待的资源后才能继续进程的执行，则进入等待态（阻塞态）。</p>
<p>阻塞-&gt;就绪：当等待的事件发生时，处于阻塞态的进程转换到就绪态。</p>
<p>就绪-&gt;退出：在上图中没有标出这种转换，在某些进程中，父进程可以在任何时刻终止一个子进程，如果一个父进程终止，所有相关的子进程都被终止。</p>
<p>阻塞-&gt;退出：跟上一项原因类似。</p>
<h6 id="_3、进程间的通信方式有哪些" tabindex="-1"><a class="header-anchor" href="#_3、进程间的通信方式有哪些" aria-hidden="true">#</a> 3、进程间的通信方式有哪些</h6>
<p>管道、命名管道、消息队列、信号量、信号、共享内存、套接字</p>
<p>进程间通信主要包括<strong>管道, 系统IPC(包括消息队列,信号量,共享存储), SOCKET</strong>。</p>
<p>进程间通信
    每个进程都各自拥有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程A把数据从用户空间拷到内核缓冲区，进程B再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。</p>
<p>3.1、管道( pipe )
    管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。【是由内核管理的一个缓冲区，速度慢，容量有限】</p>
<p>3.2、命名管道 (named pipe)
    命名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。</p>
<p>3.3、消息队列( message queue )
    消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p>
<p>是用于两个进程之间的通讯，首先在一个进程中创建一个消息队列，然后再往消息队列中写数据，而另一个进程则从那个消息队列中取数据。需要注意的是，消息队列是用创建文件的方式建立的，如果一个进程向某个消息队列中写入了数据之后，另一个进程并没有取出数据，即使向消息队列中写数据的进程已经结束，保存在消息队列中的数据并没有消失，也就是说下次再从这个消息队列读数据的时候，就是上次的数据。</p>
<p>3.4、信号量( semophore )
    信号量是一个计数器，可以用来控制多个进程对共享资源的访问。</p>
<p>它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p>
<p>3.5、信号 ( sinal )
    用于通知接收进程某个事件已经发生。</p>
<p>3.6、共享内存( shared memory )
    共享内存由一个进程创建，但多个进程都可以访问。【两个不同进程 A、B 共享内存的意思是：同一块物理内存被映射到进程 A、B 各自的进程地址空间。进程 A 可以即时看到进程 B 对共享内存中数据的更新，反之亦然】</p>
<p>共享内存是最快的 IPC(进程间通信) 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p>3.7、套接字( socket )
    套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
<h6 id="_4、进程-或作业-的调度算法有哪些" tabindex="-1"><a class="header-anchor" href="#_4、进程-或作业-的调度算法有哪些" aria-hidden="true">#</a> 4、进程（或作业）的调度算法有哪些</h6>
<p>先来先服务、短进程优先、优先权调度算法、高响应比优先调度算法、时间片轮转调度算法、多级队列调度算法
4.1、先来先服务（FCFS，First-Come-First-Served）
    按照进程进入就绪队列的先后次序来选择进程。</p>
<p>4.2、短进程优先（SPF,Shortest Process Next）
    从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它。</p>
<p>4.3、优先权调度算法(Priority)
    按照进程的优先权大小来调度。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>进程cpu资源分配就是指进程的优先权（priority）。优先权高的进程有优先执行权利。配置进程优先权对多任务环境的Linux很有用，可以改善系统性能。还可以把进程运行到指定的CPU上，这样一来，把不重要的进程安排到某个CPU，可以大大改善系统整体性能。

1. 查询进程优先级

[root@dbbak root]# ps –l                                                                                        --- 这里用的是linux测试
F S   UID   PID  PPID  C PRI  NI ADDR    SZ WCHAN  TTY          TIME CMD
4 S     0 20538 20534  0  75   0    -  1063 wait4  pts/2    00:00:00 bash
4 R     0 20663 20538  0  75   0    -   828 -      pts/2    00:00:00 ps

我们很容易注意到其中的几个重要信息，有下：

UID : 代表执行者的身份
PID : 代表这个进程的代号
PPID ：代表这个进程是由哪个进程发展衍生而来的，亦即父进程的代号
PRI ：代表这个进程可被执行的优先级，其值越小越早被执行
NI ：代表这个进程的nice值
这里的前面的三个信息，我们都是比较好容易理解的，但是后面的两个奇怪的信息，一个是PRI，一个是NI，这到底是什么东西？相对而言，PRI也还是比较好理解的，即进程的优先级，或者通俗点说就是程序被CPU执行的先后顺序，此值越小进程的优先级别越高。那NI呢？就是我们所要说的nice值了，其表示进程可被执行的优先级的修正数值。如前面所说，PRI值越小越快被执行，那么加入nice值后，将会使得PRI变为：PRI(new)=PRI(old)+nice。这样，当nice值为负值的时候，那么该程序将会优先级值将变小，即其优先级会变高，则其越快被执行。

到目前为止，更需要强调一点的是，进程的nice值不是进程的优先级，他们不是一个概念，但是进程nice值会影响到进程的优先级变化。

通过 ps -l -p pid 可以查询指定进程的相关信息。

2. 修改进程优先级
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.4、高响应比优先调度算法（HRRN，Highest Response Ratio Next）
    按照高响应比（（已等待时间＋要求运行时间）/ 要求运行时间）优先的原则【等待时间长和运行时间短都会增加其优先值】，每次先计算就绪队列中每个进程的响应比，然后选择其值最大的进程投入运行。</p>
<p>4.5、时间片轮转调度算法（RR，Round-Robin）
    当某个进程执行的时间片用完时，调度程序便停止该进程的执行，并将它送就绪队列的末尾，等待分配下一时间片再执行。然后把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程，在一给定的时间内，均能获得一时间片处理机执行时间。</p>
<p>4.6、多级队列调度算法
    多队列调度是根据进程的性质和类型的不同，将就绪队列再分为若干个子队列，所有的进程按其性质排入相应的队列中，而不同的就绪队列采用不同的调度算法。</p>
<h6 id="_13-进程调度算法。-周转时间-程序结束时间-开始服务时间-带权周转时间-周转时间-要求服务时间" tabindex="-1"><a class="header-anchor" href="#_13-进程调度算法。-周转时间-程序结束时间-开始服务时间-带权周转时间-周转时间-要求服务时间" aria-hidden="true">#</a> 13.进程调度算法。(周转时间=程序结束时间--开始服务时间，带权周转时间=周转时间/ 要求服务时间)</h6>
<p>（1）先来先服务和短作业（进程）优先调度算法</p>
<p>1）先来先服务调度算法：先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。FCFS算法比较有利于长作业（进程），而不利于短作业（进程）。由此可知，本算法适合于CPU繁忙型作业，而不利于I/O繁忙型的作业（进程）。</p>
<p>2）短作业（进程）优先调度算法：短作业（进程）优先调度算法（SJ/PF）是指对短作业或短进程优先调度的算法，该算法既可用于作业调度， 也可用于进程调度。但其对长作业不利；不能保证紧迫性作业（进程）被及时处理；作业的长短只是被估算出来的。</p>
<p>（2）高优先权优先调度算法</p>
<p>1） 优先权调度算法的类型：为了照顾紧迫性作业，使之进入系统后便获得优先处理，引入了最高优先权优先（FPF）调度算法。此算法常被用在批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度，还可以用于实时系统中。当其用于作业调度，将后备队列中若干个优先权最高的作业装入内存。当其用于进程调度时，把处理机分配给就绪队列中优先权最高的进程，此时，又可以进一步把该算法分成以下两种：</p>
<p>非抢占式优先权算法</p>
<p>抢占式优先权调度算法（高性能计算机操作系统）</p>
<p>2）优先权类型 。对于最高优先权优先调度算法，其核心在于：它是使用静态优先权还是动态优先权，以及如何确定进程的优先权。</p>
<p>3）高响应比优先调度算法</p>
<p>为了弥补短作业优先算法的不足，我们引入动态优先权，使作业的优先等级随着等待时间的增加而以速率a提高。 该优先权变化规律可描述为：优先权=（等待时间+要求服务时间）/要求服务时间；即 =（响应时间）/要求服务时间</p>
<p>（3）基于时间片的轮转调度算法</p>
<p>1）时间片轮转法。时间片轮转法一般用于进程调度，每次调度，把CPU分配队首进程，并令其执行一个时间片。 当执行的时间片用完时，由一个记时器发出一个时钟中断请求，该进程被停止，并被送往就绪队列末尾；依次循环。</p>
<p>2)多级反馈队列调度算法</p>
<p>不必事先知道各种进程所需要执行的时间，它是目前被公认的一种较好的进程调度算法。 其实施过程如下：</p>
<p>a.设置多个就绪队列，并为各个队列赋予不同的优先级。在优先权越高的队列中，为每个进程所规定的执行时间片就越小。</p>
<p>b.当一个新进程进入内存后，首先放入第一队列的末尾，按FCFS原则排队等候调度。 如果他能在一个时间片中完成，便可撤离；如果未完成，就转入第二队列的末尾，在同样等待调度…… 如此下去，当一个长作业（进程）从第一队列依次将到第n队列（最后队列）后，便按第n队列时间片轮转运行。</p>
<p>c.仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第1到第（i-1）队列空时， 才会调度第i队列中的进程运行，并执行相应的时间片轮转。</p>
<p>d.如果处理机正在处理第i队列中某进程，又有新进程进入优先权较高的队列， 则此新队列抢占正在运行的处理机，并把正在运行的进程放在第i队列的队尾。
————————————————</p>
<h6 id="_5、同步和互斥的区别-同步、异步、阻塞、非阻塞的区别" tabindex="-1"><a class="header-anchor" href="#_5、同步和互斥的区别-同步、异步、阻塞、非阻塞的区别" aria-hidden="true">#</a> 5、同步和互斥的区别，同步、异步、阻塞、非阻塞的区别</h6>
<p>5.1、同步和互斥【同步体现的是一种协作性，互斥体现的是一种排他性】
同步：就是并发的线程在一些关键点上可能需要互相等待与互通信息，这种相互制约的等待与互通信息称为进程（线程）同步。</p>
<p>互斥：是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性。但互斥无法限制访问者对资源的访问顺序，即访问是无序的。</p>
<p>5.2、同步、异步【关注的是消息通信机制】
同步： 就是指调用者会主动等待调用的返回结果。</p>
<p>异步： 就是指调用者不会主动等待调用结果，而是在调用发生后，被调用者通过状态、通知来通知调用者。</p>
<p>5.3、阻塞、非阻塞 【关注的是程序在等待调用结果（消息，返回值）时的状态】
阻塞： 是指调用结果返回前，当前线程会被挂起，即阻塞。</p>
<p>非阻塞： 是指即使调用结果没返回，也不会阻塞当前线程。</p>
<h6 id="_6、线程【进程】同步的方式有哪些-一定要会写生产者、消费者问题-完全消化理解" tabindex="-1"><a class="header-anchor" href="#_6、线程【进程】同步的方式有哪些-一定要会写生产者、消费者问题-完全消化理解" aria-hidden="true">#</a> 6、线程【进程】同步的方式有哪些(一定要会写生产者、消费者问题，完全消化理解)</h6>
<p>6.1、线程同步的基本概念
    所谓同步，就是并发的线程在一些关键点上可能需要互相等待与互通信息，这种相互制约的等待与互通信息称为进程（线程）同步。</p>
<p>“同”其实是协同，而不是同时，同步体现的是一种协作性。
互斥（指某一资源同时只允许一个访问者对其进行访问）体现的是一种排他性。一般情况下，同步已经实现了互斥，特别是写入资源的情况必定是互斥的。</p>
<p>临界资源是指一次仅允许一个线程使用的资源。</p>
<p>临界区指的是一个访问共用资源（被多个线程共享的临界资源）的程序片段，而这些共用资源又无法同时被多个线程访问的特性。当有线程进入临界区段时，其他线程或是进程必须等待（例如：bounded waiting 等待法），有一些同步的机制必须在临界区段的进入点与离开点实现，以确保这些共用资源是被互斥获得使用，例如：semaphore。只能被单一线程访问的设备，例如：打印机。</p>
<p>6.2、线程同步的方式。
    临界区用于单个进程中线程间的同步；互斥量、信号量、事件用于多个进程间的各个线程间实现同步。</p>
<p>具体应用方式：</p>
<p>（1、 定义临界区对象</p>
<p>（2、 在访问共享资源（代码或变量）之前，先获得临界区对象</p>
<p>（3、 访问共享资源后，则放弃临界区对象</p>
<p>1、临界区：</p>
<p>使用临界区对象。拥有临界区对象的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区对象的线程放弃临界区对象为止【只用于同一进程】</p>
<p>2、互斥量：</p>
<p>采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以可以保证公共资源不会同时被多个线程访问。【互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制于同一进程的各个线程之间使用】</p>
<p>3、信号量：</p>
<p>它允许多个线程同一时刻访问同一资源，但是需要限制同一时刻访问此资源的最大线程数目。</p>
<p>信号量（semaphore）的数据结构为一个值和一个指针，指针指向等待该信号量的下一个进程。信号量的值 S 与相应资源的使用情况有关。当 S 大于 0 时，表示当前可用资源的数量；当 S 小于 0 时，其绝对值表示等待使用该资源的进程个数。注意，信号量的值仅能由 PV 操作来改变。</p>
<p>执行一次 P 操作意味着请求分配一个单位资源，因此S的值减1；当 S &lt; 0 时，表示已经没有可用资源，请求者必须等待别的进程释放该类资源，它才能运行下去。</p>
<p>而执行一个 V 操作意味着释放一个单位资源，因此 S 的值加 1；若 S &lt; 0，表示有某些进程正在等待该资源，因此要唤醒一个等待状态的进程，使之运行下去。</p>
<p>4、事件（信号）：</p>
<p>事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。【进程间通信中唯一的一个异步机制】</p>
<p>生产者-消费者模型：</p>
<p>要理解生产消费者问题，首先应弄清PV操作的含义：PV操作是由P操作原语和V操作原语组成（原语是不可中断的过程），对信号量进行操作，具体定义如下：</p>
<p>P（S）：①将信号量S的值减1，即S=S-1；</p>
<pre><code>  ②如果S&gt;0，则该进程继续执行；否则该进程置为等待状态，排入等待队列。
</code></pre>
<p>V（S）：①将信号量S的值加1，即S=S+1；</p>
<pre><code>  ②如果S&gt;0，则该进程继续执行；否则释放队列中第一个等待信号量的进程。
</code></pre>
<p>P操作相当于申请资源，而V操作相当于释放资源。</p>
<p>生产者-消费者问题是一个有代表性的进程同步问题，生产者-消费者问题，也称作有界缓冲区问题，两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，用于将消息放入缓冲区；另外一个是消费者，用于从缓冲区中取出消息。问题出现在当缓冲区已经满了，而此时生产者还想向其中放入一个新的数据项的情形，或者当缓冲区空时，消费者还要从中取出数据项的问题。为了保证这种情况不会发生，我们通常使用信号量和消息传递来解决生产者-消费者问题。</p>
<p>（1）使用信号量解决生产者-消费者问题
一个信号量的取值可以为 0（表示没有保存下来的唤醒操作）或者为正值（表示有一个或多个唤醒操作）。
并且设立了两种操作：down和 up（也是一般教科书上说的 P/V向量）。对一个信号量执行 down操作，表示检查其值是否大于 0，如果该值大于 0，则将其值减 1（即用掉一个保存的唤醒信号）并继续；如果为 0，则进程休眠，而且此时 down操作并未结束。另外，就是检查数值，修改变量值以及可能发生的休眠操作都作为单一的，不可分割的原子操作来完成。</p>
<p>下面开始考虑用信号量来解决生产者-消费者问题了。
#define N 100                           // 缓冲区中的槽数目
typedef int semaphore;               // 信号量一般被定义为特殊的整型数据
semaphore mutex = 1;               // 控制对临界区的访问
semaphore empty = N;               // 计数缓冲区中的空槽数目
semaphore full = 0;                 // 计数缓冲区中的满槽数目</p>
<p>————————————————</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>/* 生产者进程 */
void proceducer(void)
{
        int item;
        while(1)
        {
               item = procedure_item();       // 生成数据
               down(&amp;empty);                              // 将空槽数目减 1
               down(&amp;mutex);                              // 进入临界区
               insert_item(item);                       // 将新数据放入缓冲区
               up(&amp;mutex);                                      // 离开临界区
               up(&amp;full);                                      // 将满槽的数目加 1
        }
}

/* 消费者进程 */
void consumer(voi)
{
        int item;
        while(1)
        {
               down(&amp;full);                              // 将满槽数目减 1
               down(&amp;mutex);                              // 进入临界区
               item = remove_item();               // 从缓冲区中取出数据项
               up(&amp;mutex);                                      // 离开临界区
               up(&amp;empty);                                      // 将空槽数目加 1
               consumer_item(item);               // 处理数据项
        }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>该解决方案使用了三个信号量：一个为 full，用来记录充满的缓冲槽的数目，一个为 empty，记录空的缓冲槽总数，一个为 mutex，用来确保生产者和消费者不会同时访问缓冲区。mutex的初始值为 1，供两个或者多个进程使用的信号量，保证同一个时刻只有一个进程可以进入临界区，称为二元信号量（binary semaphore）。如果每一个进程在进入临界区前都执行一个 down(...)，在刚刚退出临界区时执行一个 up(...)，就能够实现互斥。</p>
<p>另外，通常是将 down和 up操作作为系统调用来实现，而且 OS只需要在执行以下操作时暂时禁止全部中断：测试信号量，更新信号量以及在需要时使某个进程休眠。</p>
<p>这里使用了三个信号量，但是它们的目的却不相同，其中 full和 empty用来同步（synchronization），而 mutex用来实现互斥。
————————————————
（2）使用消息传递解决生产者-消费者问题
这种 IPC方式使用两条原语 send和 receive，也是系统调用。如：
send(dest, &amp;msg)       // 将消息 msg发送到目标（进程）dest中
receive(src, &amp;msg)     // 接收由 src过来的 msg,如果没有消息可用，则可能阻塞接收者</p>
<p>消息传递系统会面临位于网络中不同机器上的通信进程的情形，所以会更加的复杂。如：消息可能被网络丢失，一般使用确认（ACK）消息。如果发送方在一定的时间段内没有收到确认消息，则重发消息。</p>
<p>如果消息本身被正确接收，但是返回的 ACK消息丢失，发送方则重发消息，这样接收方就会收到两份同样的消息。一般使用在每条原始消息的头部嵌入一个连续的序号来解决这个问题。</p>
<p>另外，消息传递系统还需要解决进程命名的问题，在 send和 receive系统调用中指定的进程必须没有二义性的。还有其他的一些问题，如性能问题，身份认证等等，不过那个就会扯多了，还是看看如果解决这个生产者-消费者的问题吧：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>#define N 100                              // 缓冲区中的槽数目
/* 生产者进程 */
void proceducer(void)
{
        int item;
        messagemsg;                       // 消息缓冲区
        while(1)
        {
               item = procedure_item();       // 生成数据
               receive(consumer, &amp;msg);       // 等待消费者发送空的缓冲区
               build_msg(&amp;msg, item);               // 创建待发送消息
               send(consumer, &amp;msg);               // 发送数据项给消费者
        }
}

/* 消费者进程 */
void consumer(voi)
{
        int item,i;
        messagemsg;
        for(i=0;i&lt;N; i++)
               send(producer, &amp;msg);               // 发送给生产者 N 个空缓冲区
        
        while(1)
        {
               receive(producer, &amp;msg);       // 接收包含数据项的消息
               item = extract_item(&amp;msg);       // 解析消息，并组装成数据项
               send(proceduer, &amp;msg);               // 然后又将空缓冲区发送回生产者
               consumer_item(item);               // 处理数据项
        }
}


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在这个解决方案中，共使用了 N条消息，有点类似于上一个的共享内存缓冲区的 N个槽，消费者进程这边首先通过一个 for循环将 N条空消息发送给生产者。当生产者向消费者传递一个数据项时，是通过取走每一条接收到的空消息，然后送回填充了内容的消息给消费者的。通过这种方式，整个消息传递系统中的总的消息数（包括空的消息 + 存了数据项的消息 == N）是不变的。</p>
<p>如果运行过程中，生产者进程的速度比消费者快，则所有的消息最终都会塞满，然后生产者进程就会等待消费者（即使调用 procedure也是阻塞在 receive处），直到消费者返回一条空的消息；反之亦然。</p>
<p>下面再来看一下消息传递方式的两种变体。一种是：为每一个进程分配一个唯一的地址，让消息按照这个进程的地址进行编址。也就是 send和 receive调用的第一个参数指定为具体的进程地址。另一种是：引入信箱（mailbox），可以信箱就像一个盒子，里面装了很多的信件，这个信件就是我们要传递的消息，当然信箱是有容量限制的。当使用信箱时，send和 receive系统调用中的地址参数就是信箱的地址，而不是进程的地址。当一个进程尝试向一个容量爆满的信箱发送消息时，它将会被挂起，直到信箱中有消息被取走。
————————————————</p>
<h6 id="_7、什么是缓冲区溢出-有什么危害-原因是什么" tabindex="-1"><a class="header-anchor" href="#_7、什么是缓冲区溢出-有什么危害-原因是什么" aria-hidden="true">#</a> 7、什么是缓冲区溢出，有什么危害，原因是什么？</h6>
<p>1、缓冲区溢出：</p>
<p>是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>2、危害：</p>
<p>在当前网络与分布式系统安全中，被广泛利用的 50% 以上都是缓冲区溢出。缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到 shell，然后为所欲为。</p>
<p>通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。</p>
<p>3、造成缓冲区溢出的主原因：</p>
<p>是程序中没有仔细检查用户输入的参数。</p>
<h6 id="_8-线程的实现方式-也就是用户线程与内核线程的区别" tabindex="-1"><a class="header-anchor" href="#_8-线程的实现方式-也就是用户线程与内核线程的区别" aria-hidden="true">#</a> 8.线程的实现方式. (也就是用户线程与内核线程的区别)</h6>
<p>线程的实现可分为两大类，用户级线程（user-levelthread，ULT）和内核级线程（kernel-levelthread，KLT）。后者又称为内核支持的线程或轻量级进程。</p>
<h6 id="_1-用户级线程" tabindex="-1"><a class="header-anchor" href="#_1-用户级线程" aria-hidden="true">#</a> （1）用户级线程</h6>
<p>在一个纯粹的用户级线程软件中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。</p>
<p>使用用户级线程而不是内核级线程的优点有：</p>
<ul>
<li>
<p>​		线程切换不需要内核态特权，进程并不需要为了线程管理而切换到内核态</p>
</li>
<li>
<p>​		可以为应用程序量身定做调度算法而不扰乱底层的操作系统调度程序</p>
</li>
<li>
<p>​		用户级线程可以在任何操作系统中运行，不需要对底层内核进行修改以支持用户级线程</p>
</li>
</ul>
<p>相比内核级线程，用户级线程有两个明显的缺点：</p>
<ul>
<li>
<p>​		许多系统调用都会引起阻塞，当用户级线程执行一个系统调用时，不仅这个线程会被阻塞，进程中的所有线程都会被阻塞</p>
</li>
<li>
<p>​		在纯粹的用户级线程策略中，一个多线程应用程序不能利用多处理技术</p>
</li>
</ul>
<h6 id="_2-内核级线程" tabindex="-1"><a class="header-anchor" href="#_2-内核级线程" aria-hidden="true">#</a> （2）内核级线程</h6>
<p>在一个纯粹的内核级线程软件中，有关线程管理的所有工作都是由内核完成的，应用程序部分没有进行线程管理的代码，只有一个到内核线程设施的应用程序编程接口（API）。</p>
<p>该方法克服了用户级线程方法的两个基本缺陷：内核可以同时把同一个进程的多个线程调度到多个处理器中；如果进程中的一个线程被阻塞，内核可以调度同一个进程中的另一个线程。相比用户级线程它的主要缺点是：把控制从一个线程传送到进程中的另一个线程时，需要到内核的状态切换。</p>
<p>某些操作系统采用组合用户级线程和内核级线程的方法，同一个应用程序中的多个线程可以在多个处理器上并行的运行，某个会引起阻塞的系统调用不会阻塞整个进程。如果设计正确，该方法会结合两种线程的优点，同时减少他们的缺点。</p>
<h3 id="_3、死锁" tabindex="-1"><a class="header-anchor" href="#_3、死锁" aria-hidden="true">#</a> 3、死锁</h3>
<h6 id="_2-1-什么是死锁" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是死锁" aria-hidden="true">#</a> 2.1 什么是死锁？</h6>
<p>由于系统中存在一些不可剥夺资源，而当两个或两个以上进程占有自身资源，并请求对方资源时，会导致每个进程都无法向前推进，这就是死锁。</p>
<h6 id="_2-2-死锁产生的原因" tabindex="-1"><a class="header-anchor" href="#_2-2-死锁产生的原因" aria-hidden="true">#</a> 2.2 死锁产生的原因？</h6>
<p>1、竞争资源；</p>
<p>2、进程推进顺序不当（比如 a，b 互相等待对方发信息）。</p>
<h6 id="_2-3-死锁产生的必要条件" tabindex="-1"><a class="header-anchor" href="#_2-3-死锁产生的必要条件" aria-hidden="true">#</a> 2.3 死锁产生的必要条件？</h6>
<p>1、互斥： 一个资源一次只能被一个进程所使用，即是排它性使用。</p>
<p>2、不剥夺： 一个资源仅能被占有它的进程所释放，而不能被别的进程强制剥夺。</p>
<p>3、请求与保持： 指进程占有自身本来拥有的资源并要求其他资源。</p>
<p>4、循环等待： 存在进程资源的循环等待链，链中每一个进程已获得的资源同时被下一个进程所请求。</p>
<h6 id="_2-4-怎么处理死锁" tabindex="-1"><a class="header-anchor" href="#_2-4-怎么处理死锁" aria-hidden="true">#</a> 2.4 怎么处理死锁？</h6>
<p>即死锁的处理策略：可分为预防死锁、避免死锁和死锁的检测及解除。</p>
<p>2.4.1、预防死锁：破坏四个必要条件之一</p>
<ol>
<li>破坏互斥条件</li>
</ol>
<p>即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等。所以，这种办法并无实用价值。</p>
<ol start="2">
<li>破坏不可剥夺条件</li>
</ol>
<p>当一个进程已占有了某些资源，它又申请新的资源，但不能立即被满足时，它必须释放所占有的全部资源，以后再重新申请。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的方法实现起来困难，会降低系统性能。</p>
<ol start="3">
<li>破坏请求与保持条件</li>
</ol>
<p>可以实行资源预先分配策略。即进程在运行前，一次性地向系统申请它所需要的全部资源。</p>
<p>如果某个进程所需的全部资源得不到满足，则不分配任何资源，此进程暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将所申请的资源全部分配给该进程。由于运行的进程已占有了它所需的全部资源，所以不会发生占有资源又申请资源的现象，因此不会发生死锁。</p>
<p>4.破坏循环等待条件：实行顺序资源分配法</p>
<p>首先给系统中的资源编号，规定每个进程，必须按编号递增的顺序请求资源，同类资源一次申请完。也就是说，只要进程提出申请分配资源Ri，则该进程在以后的资源申请中，只能申请编号大于Ri的资源。</p>
<p>2.4.2、避免死锁
银行家算法【在动态分配资源的过程中，银行家算法防止系统进入不安全状态，从而避免死锁】
银行家算法：</p>
<p>当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。</p>
<p>当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源。若没超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若满足则按当前的申请量分配资源，否则也要推迟分配。</p>
<p>安全序列：</p>
<p>是指系统能按某种进程推进顺序（P1, P2, P3, …, Pn），为每个进程 Pi 分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序地完成。这种推进顺序就叫安全序列【银行家算法的核心就是找到一个安全序列】。</p>
<p>系统安全状态 ：</p>
<p>如果系统能找到一个安全序列，就称系统处于安全状态，否则，就称系统处于不安全状态</p>
<p>2.4.3、死锁的检测和解除
    即在死锁产生前不采取任何措施，只检测当前系统有没有发生死锁，若有，则采取一些措施解除死锁。</p>
<h6 id="死锁的检测" tabindex="-1"><a class="header-anchor" href="#死锁的检测" aria-hidden="true">#</a> 死锁的检测：</h6>
<p>根据死锁定理：S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件称为死锁定理。</p>
<h6 id="死锁的解除" tabindex="-1"><a class="header-anchor" href="#死锁的解除" aria-hidden="true">#</a> 死锁的解除：</h6>
<p>1、资源剥夺：挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他死锁进程。（但应该防止被挂起的进程长时间得不到资源）；</p>
<p>2、撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源。（撤销的原则可以按进程优先级和撤销进程代价的高低进行）；</p>
<p>3、进程回退：让一个或多个进程回退到足以避免死锁的地步。【进程回退时自愿释放资源而不是被剥夺。要求系统保持进程的历史信息，设置还原点。】</p>
<h3 id="_3-2-处理死锁的四种方式。" tabindex="-1"><a class="header-anchor" href="#_3-2-处理死锁的四种方式。" aria-hidden="true">#</a> 3.2 处理死锁的四种方式。</h3>
<p>1）死锁预防</p>
<p>2）死锁避免</p>
<p>3）死锁检测</p>
<p>4）一种综合的死锁策略</p>
<pre><code>所有的解决死锁的策略都有其优缺点，在不同的情况下使用不同的策略比将操作系统机制设计为只采用其中一种策略更有效。
</code></pre>
<ul>
<li>
<p>把资源分成几组不同的资源类</p>
</li>
<li>
<p>为预防在资源类之间由于循环等待产生死锁，可使用线性排序策略</p>
</li>
<li>
<h4 id="在一个资源类中-使用该类资源最适合的算法" tabindex="-1"><a class="header-anchor" href="#在一个资源类中-使用该类资源最适合的算法" aria-hidden="true">#</a> 在一个资源类中，使用该类资源最适合的算法</h4>
</li>
</ul>
<p>作为这种技术的一个例子，考虑下列资源类：</p>
<ul>
<li>可交换空间：在进程交换中所使用的外存中的存储块。对于可交换空间，通过要求一次性分配所有请求的资源来预防死锁</li>
<li>进程资源：可分配设备，如磁带设备和文件。 对于这类资源，死锁避免策略常常很有效，因为进程可以事先声明他们将需要的这类资源，采用资源排序的预防策略也是可能的</li>
<li>内存：可以按页或按段分配给进程。对于内存，基于抢占的预防是最合适的策略。当一个进程被抢占后，它仅仅是被换到外存，释放空间以解决死锁</li>
<li>内部资源：诸如I/O通道。可以使用基于资源排序的预防策略
————————————————</li>
</ul>
<h3 id="_3-3-预防死锁的方法、避免死锁的方法。" tabindex="-1"><a class="header-anchor" href="#_3-3-预防死锁的方法、避免死锁的方法。" aria-hidden="true">#</a> 3.3 预防死锁的方法、避免死锁的方法。</h3>
<p><strong>死锁预防策略</strong></p>
<p>在死锁预防策略中，试图设计一种系统来排除发生死锁的可能性，方法分为两类：间接的死锁预防方法（防止前面三个列出的三个必要条件中的任何一个的发生）；直接的死锁的预防方法（防止循环等待的发生）。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218133507887.png" alt="image-20211218133507887"></p>
<p><strong>死锁避免策略</strong></p>
<p>在死锁预防中，通过约束资源请求，防止4个条件中至少一个的发生，可以通过直接或间接预防方法，但是这都会导致低效的资源使用和低效的进程执行。</p>
<p>死锁避免则相反，它允许前三个必要条件，但是通过明智的选择，确保永远不会到达死锁点，因此死锁避免比死锁预防允许更多的并发。在死锁避免中，是否允许当前资源分配请求是通过判断该请求是否可能导致死锁来决定的。因此，死锁避免需要知道将来的进程资源请求的情况。</p>
<p>死锁避免策略并不能确切的预测死锁，它仅仅是预测死锁的可能性并确保永远不会出现这种可能性。</p>
<p>有两种死锁避免的办法：</p>
<ul>
<li>如果一个进程的请求会导致死锁，则不启动此进程</li>
<li>如果一个进程增加的资源请求会导致死锁，则不允许这次分配</li>
</ul>
<p>银行家算法：首先需要定义状态和安全状态的概念。系统的状态是当前给进程分配的资源情况。因此，状态包含两个向量Resource（系统中每种资源的总量）和Available（未分配给进程的每种资源的总量）及两个矩阵Claim（表示进程对资源的需求）和Allocation（表示当前分配给进程的资源）。安全状态是指至少有一个资源分配序列不会导致死锁。当进程请求一组资源时，假设同意该请求，从而改变了系统的状态，然后确定其结果是否还处于安全状态。如果是，同意这个请求；如果不是，阻塞该进程直到同意该请求后系统状态仍然是安全的。</p>
<p><strong>死锁检测策略</strong></p>
<p>死锁预防策略是非常保守的，他们通过限制访问资源和在进程上强加约束来解决死锁的问题。死锁检测则是完全相反，它不限制资源访问或约束进程行为，只要有可能，被请求的资源就被授权给进程。操作系统周期性地执行一个算法检测前面的循环等待的条件。</p>
<h3 id="_4、内存" tabindex="-1"><a class="header-anchor" href="#_4、内存" aria-hidden="true">#</a> 4、内存</h3>
<p>3.1、固定分区、动态分区、分段式存储管理和分页式存储管理的区别</p>
<h4 id="内存分配分为连续分配和非连续分配管理两种。" tabindex="-1"><a class="header-anchor" href="#内存分配分为连续分配和非连续分配管理两种。" aria-hidden="true">#</a> 内存分配分为连续分配和非连续分配管理两种。</h4>
<h4 id="_3-1-1、内存连续分配" tabindex="-1"><a class="header-anchor" href="#_3-1-1、内存连续分配" aria-hidden="true">#</a> 3.1.1、内存连续分配</h4>
<p>1、单一连续分配：分为系统区和用户区，系统区供给操作系统使用，用户区供给用户使用，内存中永远只有一道程序。</p>
<p>2、固定分区分配：最简单的一种多道程序管理方式，它将用户内存空间划分为若干个固定大小的区域，每个分区只装入一道作业。【方法一：分区大小相等；方法二：分区大小不等，划分为含有多个较小的分区，适量的中等分区及少量的大分区】</p>
<p>3、动态分区分配：又称为可变分区分配，是一种动态划分内存的方法。这种分区方法不预先将内存划分，而是在进程装入内存时，根据进程的大小动态的建立分区，并使分区的大小正好适合进程的需要。因此系统中分区的大小和数目是可变的。</p>
<h4 id="_3-1-2、非连续分配" tabindex="-1"><a class="header-anchor" href="#_3-1-2、非连续分配" aria-hidden="true">#</a> 3.1.2、非连续分配</h4>
<p>1、分页式存储管理：分页存储管理是将一个进程的地址（逻辑地址空间）空间划分成若干个大小相等的区域，称为页，相应地，将内存空间划分成与页相同大小（为了保证页内偏移一致）的若干个物理块，称为块或页框（页架）。在为进程分配内存时，将进程中的若干页分别装入多个不相邻接的块中。【只需给出一个地址，所以是一维】</p>
<p>分页系统中，允许将进程的每一页离散地存储在内存的任一物理块中，为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页面映射表，简称页表。页表的作用是实现从页号到物理块号的地址映射。【若给定一个逻辑地址为 A，页面大小为 L，则页号 P = INT[A / L]，页内地址 W=A MOD L】</p>
<p>分页系统中，CPU每次要存取一个数据，都要两次访问内存（访问页表、访问实际物理地址）。为提高地址变换速度，增设一个具有并行查询能力的特殊高速缓冲存储器，称为“联想存储器”或“快表”，存放当前访问的页表项。</p>
<p>2、分段式存储管理：在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，如有主程序段、子程序段、数据段及堆栈段等，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。【因为每段的长度是不确定的，所以不能只给一个逻辑地址通过整数除法得到段号，求余得出段内偏移，所以一定要显式给出（段号，段内偏移），因此分段管理的地址空间是二维的】</p>
<p>3.1.3、两者的区别
1.分页式管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提升计算机性能，且分页通过硬件机制实现，对用户完全透明；</p>
<p>2.分段式管理方式的提出则是考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。</p>
<p>3.分页式存储管理的作业地址空间是一维的，分段式的存储管理的作业管理地址空间是二维的。【页式系统中，逻辑地址的页号和页内偏移量对用户是透明的【用户提供一个逻辑地址即可】，但在段氏系统中，段号和段内偏移量必须由用户显式提供（在高级程序设计语言中，这个工作由编译程序完成）】</p>
<p>3.2、页面置换算法有哪些？
    最佳置换算法、先进先出置换算法、最近最久为使用置换算法 LRU、时钟置换算法、最少使用置换算法</p>
<p>1、最佳置换算法（Optimal）：即选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。（它是一种理想化的算法，性能最好，但在实际上难于实现）；</p>
<p>2、先进先出置换算法 FIFO：总是淘汰最先进入内存的页面；</p>
<p>3、最近最久未使用置换算法 LRU（Least Recently Used）：即选择最近最久未使用的页面予以淘汰。【系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间 T，当要淘汰一个页面时，选择 T 最大的页面。】</p>
<p>4、时钟（Clock）置换算法：也叫最近未用算法 NRU（Not RecentlyUsed）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。当某页被访问时，其访问位置“1”。在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止。由于该算法只有一位访问位，只能用它表示该页是否已经使用过，而置换时是将未使用过的页面换出去，所以把该算法称为最近未用算法。</p>
<p>5、最少使用置换算法LFU：该算法选择最近时期使用最少的页面作为淘汰页。</p>
<p>3.3、逻辑地址、物理地址、虚拟内存、操作系统的内容</p>
<h5 id="_1、物理地址" tabindex="-1"><a class="header-anchor" href="#_1、物理地址" aria-hidden="true">#</a> 1、物理地址：</h5>
<p>它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。</p>
<h5 id="_2、逻辑地址" tabindex="-1"><a class="header-anchor" href="#_2、逻辑地址" aria-hidden="true">#</a> 2、逻辑地址：</h5>
<p>是指从应用程序角度看到的内存地址，又叫相对地址。编译后，每个目标模块都是从 0 号单元开始编址，称为该目标模块的相对地址或逻辑地址。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。用户和程序员只需要知道逻辑地址。</p>
<h5 id="_3、虚拟内存" tabindex="-1"><a class="header-anchor" href="#_3、虚拟内存" aria-hidden="true">#</a> 3、虚拟内存：</h5>
<p>虚拟内存是一些系统页文件，存放在磁盘上，每个系统页文件大小为 4K，物理内存也被分页，每个页大小也为 4K，这样虚拟页文件和物理内存页就可以对应，实际上虚拟内存就是用于物理内存的临时存放的磁盘空间。页文件就是内存页，物理内存中每页叫物理页，磁盘上的页文件叫虚拟页，物理页+虚拟页就是系统所有使用的页文件的总和。</p>
<h5 id="虚拟内存技术" tabindex="-1"><a class="header-anchor" href="#虚拟内存技术" aria-hidden="true">#</a> 虚拟内存技术：</h5>
<p>允许将一个作业分多次调入内存。可以用分页式、分段式、段页式存储管理来实现。</p>
<p>基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间放入将要调入内存的信息。这样，系统就好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</p>
<h3 id="_5、操作系统主要包括-进程和线程的管理、存储管理、设备管理、文件管理" tabindex="-1"><a class="header-anchor" href="#_5、操作系统主要包括-进程和线程的管理、存储管理、设备管理、文件管理" aria-hidden="true">#</a> 5、操作系统主要包括：进程和线程的管理、存储管理、设备管理、文件管理</h3>
<h5 id="_3-4、动态链接库和静态链接库的区别" tabindex="-1"><a class="header-anchor" href="#_3-4、动态链接库和静态链接库的区别" aria-hidden="true">#</a> 3.4、动态链接库和静态链接库的区别</h5>
<p>静态连接库： 一种是 LIB 包含函数代码本身，在编译时直接将代码加入程序当中，称为静态链接库。</p>
<p>静态链接： 静态链接使用静态链接库，链接器从静态链接库 LIB 获取所有被引用函数，并将库同代码一起放到可执行文件中。</p>
<p>动态链接库： 一种是 LIB 包含了函数所在的DLL文件和文件中函数位置的信息（入口），代码由运行时加载在进程空间中的 DLL 提供，称为动态链接库。</p>
<p>动态链接： 使用动态链接库，允许可执行模块（.dll 文件或 .exe 文件）仅包含在运行时定位 DLL 中函数的可执行代码所需的信息。</p>
<p>二者的区别：</p>
<p>静态库本身就包含了代码，地址符号表等，而对于导入库而言，其实际的执行代码位于动态库中，导入库只包含了地址符号表等，确保程序找到对应函数的一些基本地址信息；</p>
<p>静态链接库是一个或多个 obj 文件的打包，所以有人干脆把从 obj 文件生成lib的过程称为 Archive 即合并到一起。当我们应用工程在使用静态链接库的时候，静态链接库要参与编译，在生成执行文件之前的链接过程中，将静态链接库的全部指令直接链接如可执行文件中，故而，在可执行文件生成以后，静态链接库 .lib 可以弃之不用；</p>
<p>动态链接库是作为共享函数库的可执行文件，动态链接库提供了一种方法，是进程可以调用不属于其可执行代码的函数。dll 还有助于共享数据和资源。多个应用程序可同时访问内存中单个dll副本的内容。</p>
<p>使用动态链接库代替静态链接库优点：dll 节省内存，减少交换操作，节省磁盘空间，更易于升级（不需要重链接和重编译），提供售后支持，提供 MFC 库类的机制，支持多语言支持。</p>
<p>静态链接库与动态链接库都是共享代码的方式，如果采用静态链接库，lib中的指令都全部被直接包含在最终生成的exe文件中了。但是若使用dll动态链接库，该dll不必被包含在最终的exe文件中，执行文件执行时可以动态地引用和卸载这个与exe独立的dll文件。</p>
<p>另一个区别是，静态链接库不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。</p>
<p>静态链接库动态链接库使用的区别在于它允许可执行模块（dll或exe文件）仅包含在运行时定位dll函数的可执行代码的所需信息。静态链接库的使用中，连接器从静态链接库获取所有被引用的函数，并将库同代码一起放到可执行文件中。</p>
<h5 id="_16-动态链接及静态链接" tabindex="-1"><a class="header-anchor" href="#_16-动态链接及静态链接" aria-hidden="true">#</a> 16.动态链接及静态链接</h5>
<p>静态链接就是在编译链接时直接将需要的执行代码拷贝到调用处，优点就是在程序发布的时候就不需要的依赖库，也就是不再需要带着库一块发布，程序可以独立执行，但是体积可能会相对大一些。</p>
<p>动态链接就是在编译的时候不直接拷贝可执行代码，而是通过记录一系列符号和参数，在程序运行或加载时将这些信息传递给操作系统，操作系统负责将需要的动态库加载到内存中，然后程序在运行到指定的代码时，去共享执行内存中已经加载的动态库可执行代码，最终达到运行时连接的目的。优点是多个程序可以共享同一段代码，而不需要在磁盘上存储多个拷贝，缺点是由于是运行时加载，可能会影响程序的前期执行性能。</p>
<p>动态链接库的两种链接方法：</p>
<p>(1) 装载时动态链接(Load-time Dynamic Linking)：这种用法的前提是在编译之前已经明确知道要调用DLL中的哪几个函数，编译时在目标文件中只保留必要的链接信息，而不含DLL函数的代码；当程序执行时，调用函数的时候利用链接信息加载DLL函数代码并在内存中将其链接入调用程序的执行空间中(全部函数加载进内存），其主要目的是便于代码共享。（动态加载程序，处在加载阶段，主要为了共享代码，共享代码内存）</p>
<p>(2) 运行时动态链接(Run-time Dynamic Linking)：这种方式是指在编译之前并不知道将会调用哪些DLL函数，完全是在运行过程中根据需要决定应调用哪个函数，将其加载到内存中（只加载调用的函数进内存），并标识内存地址，其他程序也可以使用该程序，并用LoadLibrary和GetProcAddress动态获得DLL函数的入口地址。（dll在内存中只存在一份，处在运行阶段）</p>
<p>上述的区别主要在于阶段不同，编译器是否知道进程要调用的dll函数。动态加载在编译时知道所调用的函数，而在运行态时则必须不知道。</p>
<h5 id="_3-5、局部性原理" tabindex="-1"><a class="header-anchor" href="#_3-5、局部性原理" aria-hidden="true">#</a> 3.5、局部性原理</h5>
<p>时间局部性： 如果程序中某条指令一旦执行，不久后该指令可能再次执行；如果某数据被访问过，不久后该数据可能再次被访问。【原因：因为在程序中存在着大量的循环操作】</p>
<p>空间局部性： 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问。【原因：因为指令通常是顺序存放、顺序执行的；数据也一般是以向量、数组、表等形式簇聚存储的】</p>
<h5 id="_3-6、中断、系统调用、库函数" tabindex="-1"><a class="header-anchor" href="#_3-6、中断、系统调用、库函数" aria-hidden="true">#</a> 3.6、中断、系统调用、库函数</h5>
<p>1、中断
    就是指在计算机执行程序的过程中，由于出现了某些特殊事情，使得 CPU 暂停对程序的执行，转而去执行处理这一事件的程序。等这些特殊事情处理完之后再回去执行之前的程序。中断一般分为三类：</p>
<p>1.内部异常中断：由计算机硬件异常或故障引起的中断；</p>
<p>2.软中断：由程序中执行了引起中断的指令而造成的中断；</p>
<p>3.外部中断：由外部设备请求引起的中断；</p>
<p>2、系统调用
    系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程与硬件设备(如CPU、磁盘、打印机等)进行交互。</p>
<p>用户进程需要发生系统调用时，内核将调用内核相关函数来实现（如sys_read(),sys_write(),sys_fork()）。用户程序不能直接调用这些函数，这些函数运行在内核态，CPU 通过软中断切换到内核态开始执行内核系统调用函数。</p>
<p>系统调用和中断的关系就在于，当进程发出系统调用申请的时候，会产生一个软中断。产生这个软中断以后，系统会去对这个软中断进行处理，这个时候进程就处于核心态了。</p>
<p>3、库函数
    库函数是把函数放到库里，供别人使用的一种方式。【系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便。】</p>
<h3 id="_6-不同进程打开了同一个文件-那么这两个进程得到的文件描述符-fd-相同吗" tabindex="-1"><a class="header-anchor" href="#_6-不同进程打开了同一个文件-那么这两个进程得到的文件描述符-fd-相同吗" aria-hidden="true">#</a> 6.不同进程打开了同一个文件，那么这两个进程得到的文件描述符（fd）相同吗？</h3>
<p>两个进程中分别产生生成两个独立的 fd。文件描述符与打开文件的关系？</p>
<p>内核中，对应于每个进程都有一个文件描述符表，表示这个进程打开的所有文件。文件描述表中每一项都是一个指针，指向一个用 于描述打开的文件的数据块———file对象，file对象中描述了文件的打开模式，读写位置等重要信息，当进程打开一个文件时，内核就会创建一个新的file对象。需要注意的是，file对象不是专属于某个进程的，不同进程的文件描述符表中的指针可以指向相同的file对象，从而共享这个打开的文件。file对象有引用计数，记录了引用这个对象的文件描述符个数，只有当引用计数为0时，内核才销毁file对象，因此某个进程关闭文件，不影响与之共享同一个file对象的进程。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217173540463.png" alt="image-20211217173540463">————————————————</p>
<h3 id="_6-请简述linux、freebsd、soalaris、mac-os、windows几种系统下进程与线程的内核实现方式、管理机制的异同-暂无答案" tabindex="-1"><a class="header-anchor" href="#_6-请简述linux、freebsd、soalaris、mac-os、windows几种系统下进程与线程的内核实现方式、管理机制的异同-暂无答案" aria-hidden="true">#</a> 6.请简述Linux、FreeBSD、Soalaris、Mac OS、Windows几种系统下进程与线程的内核实现方式、管理机制的异同（暂无答案）</h3>
<h3 id="_7-请简述linux-bsd系统下进程间通讯的方式有哪些-并具体说明在php下如何实现" tabindex="-1"><a class="header-anchor" href="#_7-请简述linux-bsd系统下进程间通讯的方式有哪些-并具体说明在php下如何实现" aria-hidden="true">#</a> 7.请简述Linux/BSD系统下进程间通讯的方式有哪些，并具体说明在PHP下如何实现</h3>
<p>**管道（Pipe）及有名管道（namedpipe）：**管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
**信号（Signal）：**信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）；
**报文（Message）队列（消息队列）：**消息队列是消息的链接表，包括Posix消息队列systemV消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。
**共享内存：**使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
**信号量（semaphore）：**主要作为进程间以及同一进程不同线程之间的同步手段。
套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和SystemV的变种都支持套接字。</p>
<p>具体实现：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>一、引言
进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。换句话说就是，在系统调度多个cpu的时候，一个程序的基本单元。进程对于大多数的语言都不是一个陌生的概念，作为"世界上最好的语言PHP"当然也例外。

二、环境
php中的进程是以扩展的形式来完成。通过这些扩展，我们能够很轻松的完成进程的一系列动作。

pcntl扩展：主要的进程扩展，完成进程创建于等待操作。
posix扩展：完成posix兼容机通用api,如获取进程id,杀死进程等。
sysvmsg扩展：实现system v方式的进程间通信之消息队列。
sysvsem扩展：实现system v方式的信号量。
sysvshm扩展：实现system v方式的共享内存。
sockets扩展：实现socket通信。
这些扩展只能在linux/mac中使用，window下是不支持。最后建议php版本为5.5+。

一个简单的PHP多进程例子，该例子中，一个子进程，一个父进程。子进程输出5次，退出程序。
$parentPid = posix_getpid();
echo "parent progress pid:{$parentPid}\n";
$childList = array();
$pid = pcntl_fork();
if ( $pid == -1) {
    // 创建失败
    exit("fork progress error!\n");
} else if ($pid == 0) {
    // 子进程执行程序
    $pid = posix_getpid();
    $repeatNum = 5;
    for ( $i = 1; $i&lt;= $repeatNum; $i++) {
        echo "({$pid})child progress is running! {$i} \n";
        $rand = rand(1,3);
        sleep($rand);
    }
    exit("({$pid})child progress end!\n");
} else {
    // 父进程执行程序
    $childList[$pid] = 1;
}
// 等待子进程结束
pcntl_wait($status);
echo "({$parentPid})main progress end!";
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>终于创建了一个子进程，一个父进程。完了么？没有，各个进程之间相互独立的，没有任何交集，使用范围严重受到现在。怎么办，哪就进程间通信(interprogress communication)呗。</p>
<h4 id="_1-消息队列" tabindex="-1"><a class="header-anchor" href="#_1-消息队列" aria-hidden="true">#</a> 1.消息队列</h4>
<p>消息队列是存放在内存中的一个队列。如下代码将创建3个生产者子进程，2个消费者子进程。这5个进程将通过消息队列通信。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>$parentPid = posix_getpid();
echo "parent progress pid:{$parentPid}\n";$childList = array();
// 创建消息队列,以及定义消息类型(类似于数据库中的库)
$id = ftok(__FILE__,'m');
$msgQueue = msg_get_queue($id);
const MSG_TYPE = 1;
// 生产者
function producer(){
    global $msgQueue;
    $pid = posix_getpid();
    $repeatNum = 5;
    for ( $i = 1; $i&lt;= $repeatNum; $i++) {
        $str = "({$pid})progress create! {$i}";
        msg_send($msgQueue,MSG_TYPE,$str);
        $rand = rand(1,3);
        sleep($rand);
    }
}
// 消费者
function consumer(){
    global $msgQueue;
    $pid = posix_getpid();
    $repeatNum = 6;
    for ( $i = 1; $i&lt;= $repeatNum; $i++) {
        $rel = msg_receive($msgQueue,MSG_TYPE,$msgType,1024,$message);
        echo "{$message} | consumer({$pid}) destroy \n";
        $rand = rand(1,3);
        sleep($rand);
    }
}
function createProgress($callback){
    $pid = pcntl_fork();
    if ( $pid == -1) {
        // 创建失败
        exit("fork progress error!\n");
    } else if ($pid == 0) {
        // 子进程执行程序
        $pid = posix_getpid();
        $callback();
        exit("({$pid})child progress end!\n");
    }else{
        // 父进程执行程序
        return $pid;
    }
}
// 3个写进程
for ($i = 0; $i&lt;3; $i ++ ) {
    $pid = createProgress('producer');
    $childList[$pid] = 1;
    echo "create producer child progress: {$pid} \n";
}
// 2个写进程
for ($i = 0; $i&lt;2; $i ++ ) {
    $pid = createProgress('consumer');
    $childList[$pid] = 1;
    echo "create consumer child progress: {$pid} \n";
}
// 等待所有子进程结束
while(!empty($childList)){
    $childPid = pcntl_wait($status);
    if ($childPid &amp;gt; 0){
        unset($childList[$childPid]);
    }
}
echo "({$parentPid})main progress end!\n";
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于消息队列去数据是，只有一个进程能去到，所以不需要额外的锁或信号量。</p>
<h4 id="_2-信号量与共享内存" tabindex="-1"><a class="header-anchor" href="#_2-信号量与共享内存" aria-hidden="true">#</a> 2. 信号量与共享内存</h4>
<p><code v-pre>信号量</code>：是系统提供的一种原子操作，一个信号量，同时只有你个进程能操作。一个进程获得了某个信号量，就必须被该进程释放掉。</p>
<p><code v-pre>共享内存</code>：是系统在内存中开辟的一块公共的内存区域，任何一个进程都可以访问，在同一时刻，可以有多个进程访问该区域，为了保证数据的一致性，需要对该内存区域加锁或信号量。</p>
<p>以下，创建多个进程修改内存中的同一个值。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>$parentPid = posix_getpid();
echo "parent progress pid:{$parentPid}\n";
$childList = array();

// 创建共享内存,创建信号量,定义共享key
$shm_id = ftok(__FILE__,'m');
$sem_id = ftok(__FILE__,'s');
$shareMemory = shm_attach($shm_id);
$signal = sem_get($sem_id);
const SHARE_KEY = 1;
// 生产者
function producer(){
    global $shareMemory;
    global $signal;
    $pid = posix_getpid();
    $repeatNum = 5;
    for ( $i = 1; $i &lt;= $repeatNum; $i++) {
        // 获得信号量
        sem_acquire($signal);
        
        if (shm_has_var($shareMemory,SHARE_KEY)){
            // 有值,加一
            $count = shm_get_var($shareMemory,SHARE_KEY);
            $count ++;
            shm_put_var($shareMemory,SHARE_KEY,$count);
            echo "({$pid}) count: {$count}\n";
        }else{
            // 无值,初始化
            shm_put_var($shareMemory,SHARE_KEY,0);
            echo "({$pid}) count: 0\n";
        }
        // 用完释放
        sem_release($signal);
        
        $rand = rand(1,3);
        sleep($rand);
    }
}
function createProgress($callback){
    $pid = pcntl_fork();
    if ( $pid == -1) {
        // 创建失败
        exit("fork progress error!\n");
    } else if ($pid == 0) {
        // 子进程执行程序
        $pid = posix_getpid();
        $callback();
        exit("({$pid})child progress end!\n");
    }else{
        // 父进程执行程序
        return $pid;
    }
}
// 3个写进程
for ($i = 0; $i&lt;3; $i ++ ) {
    $pid = createProgress('producer');
    $childList[$pid] = 1;
    echo "create producer child progress: {$pid} \n";
}
// 等待所有子进程结束
while(!empty($childList)){
    $childPid = pcntl_wait($status);
    if ($childPid &amp;gt; 0){
        unset($childList[$childPid]);
    }
}
// 释放共享内存与信号量
shm_remove($shareMemory);
sem_remove($signal);
echo "({$parentPid})main progress end!\n";


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-信号" tabindex="-1"><a class="header-anchor" href="#_3-信号" aria-hidden="true">#</a> 3.信号</h4>
<p>信号是一种系统调用。通常我们用的kill命令就是发送某个信号给某个进程的。具体有哪些信号可以在liunx/mac中运行<code v-pre>kill -l</code>查看。下面这个例子中，父进程等待5秒钟，向子进程发送sigint信号。子进程捕获信号，掉信号处理函数处理。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>$parentPid = posix_getpid();
echo "parent progress pid:{$parentPid}\n";

// 定义一个信号处理函数
function sighandler($signo) {
    $pid = posix_getpid();
    echo "{$pid} progress,oh no ,I'm killed!\n";
    exit(1);
}

$pid = pcntl_fork();
if ( $pid == -1) {
    // 创建失败
    exit("fork progress error!\n");
} else if ($pid == 0) {
    // 子进程执行程序
    // 注册信号处理函数
    declare(ticks=10);
    pcntl_signal(SIGINT, "sighandler");
    $pid = posix_getpid();
    while(true){
        echo "{$pid} child progress is running!\n";
        sleep(1);
    }
    exit("({$pid})child progress end!\n");
}else{
    // 父进程执行程序
    $childList[$pid] = 1;
    // 5秒后,父进程向子进程发送sigint信号.
    sleep(5);
    posix_kill($pid,SIGINT);
    sleep(5);
}
echo "({$parentPid})main progress end!\n";
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-socket" tabindex="-1"><a class="header-anchor" href="#_5-socket" aria-hidden="true">#</a> 5.socket</h4>
<p>服务器端：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
error_reporting(E_ALL);
set_time_limit(0);
ob_implicit_flush();
//本地IP
$address = 'localhost';
//设置用111端口进行通信
$port = 111;
//创建SOCKET
if (($sock = socket_create(AF_INET, SOCK_STREAM, SOL_TCP)) &lt; 0) {
		echo "socket创建失败原因 " . socket_strerror($sock) . "\n";
}
 
if (($ret = socket_bind($sock, $address, $port)) &lt; 0) {
		echo "创建套接字失败原因 " . socket_strerror($ret) . "\n";
}
//监听
if (($ret = socket_listen($sock, 5)) &lt; 0) {
		echo "监听失败原因 " . socket_strerror($ret) . "\n";
}
do {
	//接收命令 
	if (($msgsock = @socket_accept($sock)) &lt; 0) {
		echo "命令接收失败原因: " . socket_strerror($msgsock) . "\n";
		break;
	}
	$msg = "\nPHP Test Server. \n" ."用quit,shutdown,sun...等命令测试.\n";
 
	@socket_write($msgsock, $msg, strlen($msg));
 
	do {
		if (false === ($buf = @socket_read($msgsock, 2048, PHP_NORMAL_READ))) {
				echo "socket_read() failed: reason: " . socket_strerror($ret) . "\n";
				break 2;
		}
		if (!$buf = trim($buf)) {
				continue;
		}
		if ($buf == 'quit') {
				break;
		}
		if ($buf == 'shutdown') {
				socket_close($msgsock);
				break 2;
		}
		if ($buf == 'sun') {
				echo'what are you doing?';
		}
		$talkback = "Backinformation : '$buf'.\n";
		socket_write($msgsock, $talkback, strlen($talkback));
		echo "$buf\n";
	} while (true);
 
	socket_close($msgsock);
 
} while (true);
 
socket_close($sock);
?>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>客户端：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
error_reporting(E_ALL);
//端口111
$service_port = 111;
//本地
$address = 'localhost';
//创建 TCP/IP socket
$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
if ($socket &lt; 0) {
		echo "socket创建失败原因: " . socket_strerror($socket) . "\n";
} else {
		echo "OK，HE HE.\n";
}
$result = socket_connect($socket, $address, $service_port);
if ($result &lt; 0) {
		echo "SOCKET连接失败原因: ($result) " . socket_strerror($result) . "\n";
} else {
		echo "OK.\n";
}
//发送命令
$in = "HEAD / HTTP/1.1\r\n";
$in .= "Connection: Close\r\n\r\n";
$out = '';
echo "Send Command..........";
$in = "sun\n";
socket_write($socket, $in, strlen($in));
echo "OK.\n";
echo "Reading Backinformatin:\n\n";
while ($out = socket_read($socket, 2048)) {
		echo $out;
}
echo "Close socket........";
socket_close($socket);
echo "OK,He He.\n\n";
?>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-请简述linux-bsd系统下系统的消息-事件异步通知机制有几种-并加以比较。" tabindex="-1"><a class="header-anchor" href="#_8-请简述linux-bsd系统下系统的消息-事件异步通知机制有几种-并加以比较。" aria-hidden="true">#</a> 8.请简述Linux/BSD系统下系统的消息/事件异步通知机制有几种，并加以比较。</h3>
<p>轮询</p>
<p>当应用程序以非阻塞的方式访问设备时，会一遍一遍的去查询我们的设备是否可以访问，这个查询操作就叫做轮询。内核中提供了<strong>poll，epoll，select</strong>函数来处理轮询操作。当应用程序在上层通过poll，epoll，select函数来查询设备时，驱动程序中的poll，epoll，select函数就要在底层实现查询，如果可以操作的话，就会从读取设备的数据或者向设备写入数据。</p>
<p>select</p>
<p>poll</p>
<p>epoll</p>
<p>在单个线程中， select函数能够监视的文件描述符数量有最大的限制，一般为1024，可以修改内核将监视的文件描述符数量改大，但是这样会降低效率！这个时候就可以使用poll函数， poll函数本质上和 select没有太大的差别，但是poll函数<strong>没有最大文件描述符限制</strong></p>
<p>传统的 selcet和poll函数都会随着所监听的fd数量的增加，出现效率低下的问题，而且poll函数每次必须遍历所有的描述符来检查就绪的描述符，这个过程很浪费时间。为此，epoll因运而生，epoll就是为处理大并发而准备的，一般常常在网络编程中使用epoll函数。应用程序需要先使用 epoll_create函数创建一个 epoll句柄</p>
<h3 id="_9-简单比较tcp-udp协议的异同-对于php的socket扩展与stream扩展-试比较两者基于tcp-udp协议的socket编程差异-暂无答案" tabindex="-1"><a class="header-anchor" href="#_9-简单比较tcp-udp协议的异同-对于php的socket扩展与stream扩展-试比较两者基于tcp-udp协议的socket编程差异-暂无答案" aria-hidden="true">#</a> 9.简单比较TCP/UDP协议的异同，对于PHP的Socket扩展与Stream扩展，试比较两者基于TCP/UDP协议的SOCKET编程差异？(暂无答案)</h3>
<h3 id="_10-为什么会出现僵死进程-孤儿进程-怎样查看僵死进程-如何解决僵死进程问题" tabindex="-1"><a class="header-anchor" href="#_10-为什么会出现僵死进程-孤儿进程-怎样查看僵死进程-如何解决僵死进程问题" aria-hidden="true">#</a> 10.为什么会出现僵死进程（孤儿进程）？怎样查看僵死进程？如何解决僵死进程问题？</h3>
<p>答：僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。
查看：使用ps aux
删除：ps aux | grep -e ‘^[Zz]’ | awk ‘{print $2}’ | xargs kill -9</p>
<p>通过PS命令可以查看其带有defunct的标志，<strong>僵尸进程是一个早已死亡的进程，但在进程表中仍占据一个位置</strong>；</p>
<p>但是如果该进程的父进程已经先结束了，那么该进程就不会变成僵尸进程。因为每个进程结束的时候，系统都会扫描当前系统中所运行的所有进程，看看有没有哪个进程是刚刚结束的这个进程的子进程，如果是的话，就由init进程来接管他，成为他的父进程，从而保证每个进程都会有一个父进程。而init进程会自动wait其子进程，因此被Init接管的所有进程都不会变成僵尸进程。
————————————————
一个进程在调用exit命令结束自己的生命时候，其实它没有真正的被销毁，而是留下一个称为僵尸进程的数据结构（系统调用exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记录在进程的退出状态等信息供其他进程收集，除此之外，僵尸进程不在占有任何内存空间。</p>
<p>它需要父进程来为它收尸…如果父进程结束了，那么init进程会自动接手这个子进程，为它收尸，它还是能被清除的，但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是为什么系统有时候会有很多的僵尸进程；</p>
<p>为什么windows不会有僵尸进程？
创建进程的方式在Windows(CreateProcess)和Linux（Fork）下的差异还是有的，但是也不是完全不能统一，麻烦点的就是Windows没有僵尸进程的概念导致进程ID不能真正区别出一个进程，比如说一个ID100的进程关闭了，然后一个新的进程启动后ID为100，并且父子进程之间的联系比Linux下要弱的多。
进程之间相互独立；要进行等待需要显式写代码。
————————————————</p>
<p>查看僵尸进程
top&gt;&gt; task (line)&gt;&gt; zombie..</p>
<p>清除僵尸进程
把父进程杀掉，父进程死后，僵尸进程称为“孤儿进程”，过继给1号进程init，init始终负责清理僵尸进程，它产生的所有僵尸进程跟着消失；</p>
<p>kill
kill命令可以带信号号码选项，也可以不带。如果没有信号号码，kill命令就会发出终止信号(15)</p>
<p>killall 　　kill -15 　kill -9
　　一般都不能杀掉 defunct进程..　用了kill -15,kill -9以后 之后反而会多出更多的僵尸进程</p>
<p>停止和重启进程
有时候只想简单的停止和重启进程。如下：
kill -HUP PID
该命令让Linux和缓的执行进程关闭，然后立即重启。在配置应用程序的时候，这个命令很方便，在对配置文件修改后需要重启进程时就可以执行此命令。</p>
<p>很多时候，会有人建议你，如果kill杀不掉一个进程，就用kill -9. 为什么？
kill是Linux下常见的命令。其man手册的功能定义如下：</p>
<p>kill – send a signal to a process</p>
<p>明朗了，其实kill就是给某个进程id发送了一个信号。默认发送的信号是SIGTERM，而kill -9发送的信号是SIGKILL，即exit。exit信号不会被系统阻塞，所以kill -9能顺利杀掉进程。当然你也可以使用kill发送其他信号给进程。</p>
<p>Linux系统寻找和杀掉僵尸进程
Linux服务器上，多少会出现一些僵尸进程，下面介绍如何快速寻找和消灭这些僵尸进程的方法：</p>
<p>首先，可以使用top命令来查看服务器当前是否有僵尸进程，下图中可以看到僵尸进程的提示，如果数字大于0，那么意味着服务器当前存在僵尸进程：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/SouthEast" alt="这里写图片描述"></p>
<p>下面，用ps 命令和 grep命令寻找僵尸进程：</p>
<p>ps -A -ostat,ppid,pid,cmd | grep -e '^[Zz]'</p>
<p>命令注解：
-A 参数列出所有进程
-o 自定义输出字段，我们设定显示字段为stat（状态），ppid（父进程pid），pid（进程pid），cmd（命令行）这四个参数</p>
<p>因为状态为 z 或者 Z的进程为僵尸进程，所以我们使用grep 抓取stat 状态为zZ进程；</p>
<p>运行结果如下所示：</p>
<p>Z 12334 12339 /path/cmd</p>
<p>这时，我们可以使用kill -HUP 12339 来杀掉这个僵尸进程；</p>
<p>运行后，在此运行ps -A -ostat,ppid,pid,cmd | grep -e '^[Zz]' 来确认是否将僵尸进程杀死；</p>
<p>如果kill 子进程的无效，可以尝试kill 其父进程来解决问题，例如上面父进程pid 为12334，那么我们就运行 kill -HUP 12334 来解决问题；</p>
<h3 id="_11-对于system-v消息队列-如何解决系统本身对于消息队列条数、总容量-字节数-的限制-如何设置消息的优先级别-请比较阻塞模式和非阻塞模式的异同-并说明如何避免非阻塞模式下的消息队列堵塞-暂无答案" tabindex="-1"><a class="header-anchor" href="#_11-对于system-v消息队列-如何解决系统本身对于消息队列条数、总容量-字节数-的限制-如何设置消息的优先级别-请比较阻塞模式和非阻塞模式的异同-并说明如何避免非阻塞模式下的消息队列堵塞-暂无答案" aria-hidden="true">#</a> 11.对于System-V消息队列，如何解决系统本身对于消息队列条数、总容量（字节数）的限制？如何设置消息的优先级别？请比较阻塞模式和非阻塞模式的异同，并说明如何避免非阻塞模式下的消息队列堵塞？(暂无答案)</h3>
<h3 id="_12-请描述apache-2-x版本的mpm-multi-processing-module-机制-并具体说明在不同的mpm机制下如何支持php" tabindex="-1"><a class="header-anchor" href="#_12-请描述apache-2-x版本的mpm-multi-processing-module-机制-并具体说明在不同的mpm机制下如何支持php" aria-hidden="true">#</a> 12.请描述Apache 2.x版本的MPM（Multi-Processing Module）机制，并具体说明在不同的MPM机制下如何支持PHP？</h3>
<p>答：常用的应该就只有3个：worker|prefork|perchild
**prefork：**在功能上就是使用Apache的运行方式，一个父进程，然后根据设置以及连接情况生成相应的子进程数。这种模式可靠性和健壮性都是最好的。但是在性能上，开销过大。达不到我们这些“吸血鬼”的要求了^^。如果连接数过多的话，会导致我们无法远程登陆，一定要等到连接数下降后才能连接，这也是最让我头痛的事情。
**worker：**混合线程/进程的MPM。一个父进程，后面是带有线程的子进程。每个子进程的线程数是固定且相同的。这是最“平庸”的一个模式，但也是使用人最多的一种模式。因为它性能等各方面比较均衡。性能上要比prefork好一些，只是牺牲了一点点的健壮性和可靠性而已。一般推荐使用这个选项。
**perchild：*<em>也是混合线程/进程的MPM。当启动perchild MPM时，它会建立指定数量的子进程，且每个子进程都具有指定数量的线程，如负载增加了，那它不会建立新的进程（子进程是固定的），只是在子进程下建立新的线程。它还有一个特点就是可以为每一个子进程配置不同的用户和组。也可以为每个虚拟主机指定一个子进程。这种模式性能是最佳的，但是可靠性和健壮性就相对是最差的。各取所需，我个人觉得这种模式也不错，如果你不用第三方的模块的话^^。</em></p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>一般apache采用prefork和worker机制，通过apachectl -l命令查看默认使用的prefork机制。需要修改prefork策略 

    那么需要做如下修改： 

    1，/usr/local/apache2/conf/http.conf 引入(include)prefork配置文件/usr/local/apache2/conf/extra/httpd-mpm.conf， 
    2，修改httpd-mpm.conf配置文件的prefork配置部分 

# prefork MPM 
# StartServers: number of server processes to start 
# MinSpareServers: minimum number of server processes which are kept spare 
# MaxSpareServers: maximum number of server processes which are kept spare 
# MaxClients: maximum number of server processes allowed to start 
# MaxRequestsPerChild: maximum number of requests a server process serves 
&lt;IfModule mpm_prefork_module> 
    StartServers          5 
    MinSpareServers       5 
    MaxSpareServers      10 
    ServerLimit         1000  ##必须放在MaxClients上面 且值>=MaxCliens 
    MaxClients          1000 
    MaxRequestsPerChild   10000 
&lt;/IfModule> 
注意： 
1，默认情况下prefork配置部分没有ServerLimit配置，其在/usr/loca/apache2/bin/httpd（16进制）中编译，一般会报错如下 
MaxClients of 1000 exceeds ServerLimit value of 256 servers, 
lowering MaxClients to 256.  To increase, please see the ServerLimit directive. 
2，修改conf文件后，需要重新启动 

3， 
prefork采用预派生子进程方式，用单独的子进程来处理 不同的请求，进程之间彼此独立。 
相对于prefork，worker全新的支持多线程和多进程混合模型的MPM。由于 使用线程来处理，所以可以处理相对海量的请求，而系统资源的开销要小于基于进程的服务器。但是，worker也使用了多进程，每个进程又生成多个线程，以 获得基于进程服务器的稳定性。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_15-请列举你能想到的unix信号-并说明信号用途。-重点" tabindex="-1"><a class="header-anchor" href="#_15-请列举你能想到的unix信号-并说明信号用途。-重点" aria-hidden="true">#</a> 15.请列举你能想到的UNIX信号，并说明信号用途。（重点）</h3>
<p>答：
Unix信号量也可以在文件/usr/include/sys/signal.h中查看</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>信号是一种软中断，是一种处理异步事件的方法。一般来说，操作系统都支持许多信号。尤其是UNIX，比较重要应用程序一般都会处理信号。 

UNIX定义了许多信号，比如SIGINT表示中断字符信号，也就是Ctrl+C的信号，SIGBUS表示硬件故障的信号；SIGCHLD表示子进程状态改变信号；SIGKILL表示终止程序运行的信号，等等。信号量编程是UNIX下非常重要的一种技术。 

Unix信号量也可以在文件/usr/include/sys/signal.h中查看 
#define SIGHUP  进程由於控制终端死去或者控制终端发出起命令 
#define SIGINT  键盘中断所产生的信号 
#define SIGQUIT  键盘终止 
#define SIGILL  非法的指令 
#define SIGTRAP   进程遇到一个追踪(trace)或者是一个中断嵌套 
#define SIGABRT  由abort系统调用所产生的中断信号 
#define SIGIOT  类似於SIGABRT 
#define SIGBUS   进程试图使用不合理的记忆体 
#define SIGFPE  浮点异常 
#define SIGKILL  KILL 
#define SIGUSR1  用户自定义 
#define SIGSEGV  段错误 
#define SIGUSR2  用户自定义 
#define SIGPIPE  管道操作时没有读只写 
#define SIGALRM 由alarm系统调用产生的timer时钟信号 
#define SIGTERM 收到终端信号的进程 
#define SIGSTKFLT 堆叠错误 
#define SIGCHLD  子进程向父进程发出的子进程已经stop或者终止的信号 
#define SIGCONT  继续运行的信号 
#define SIGSTOP  stop 
#define SIGTSTP  键盘所产生的stop信号 
#define SIGTTIN   当运行在後状态时却需要读取stdin的资料 
#define SIGTTOU   当运行在後状态时却需要写向stdout 
#define SIGURG   socket的紧急情况 
#define SIGXCPU  进程超额使用CPU分配的时间 
#define SIGXFSZ  进程使用了超出系统规定文件长度的文件 
#define SIGVTALRM  内部的alarm时钟过期 
#define SIGPROF  在一个程式段中描绘时钟集过期 
#define SIGWINCH 终端视窗的改变 
#define SIGIO 非同步IO 
#define SIGPOLL  SIGIO pollable事件发生 

通过结合trap命令使用：trap &lt;command-list>  &lt;signal-list> 

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_16-tcp滑动窗口控制流量的原理" tabindex="-1"><a class="header-anchor" href="#_16-tcp滑动窗口控制流量的原理" aria-hidden="true">#</a> 16.TCP滑动窗口控制流量的原理</h3>
<p>TCP的滑动窗口机制
TCP这个协议是网络中使用的比较广泛，他是一个面向连接的可靠的传输协议。既然是一个可靠的传输协议就需要对数据进行确认。TCP协议里窗口机制有2种：一种是固定的窗口大小；一种是滑动的窗口。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。这样通过调整发送方窗口和接收方窗口的大小可以实现流量控制。</p>
<p>​    TCP滑动窗口技术通过动态改变窗口大小来调节两台主机间数据传输。每个TCP/IP主机支持全双工数据传输，因此TCP有两个滑动窗口：一个用于接收数据，另一个用于发送数据。TCP使用肯定确认技术，其确认号指的是下一个所期待的字节。 假定发送方设备以每一次三个数据包的方式发送数据，也就是说，窗口大小为3。发送方发送序列号为1、2、3的三个数据包，接收方设备成功接收数据包，用序列号4确认。发送方设备收到确认，继续以窗口大小3发送数据。当接收方设备要求降低或者增大网络流量时，可以对窗口大小进行减小或者增加，本例降低窗口大小为2，每一次发送两个数据包。当接收方设备要求窗口大小为0，表明接收方已经接收了全部数据，或者接收方应用程序没有时间读取数据，要求暂停发送。发送方接收到携带窗口号为0的确认，停止这一方向的数据传输。</p>
<p>我们可以看下面一张图来分析一下固定窗口大小有什么问题。
<img src="https://images2015.cnblogs.com/blog/821276/201510/821276-20151016203951304-1098134686.png" alt="img">
这里我们可以看到假设窗口的大小是1，也是就每次只能发送一个数据只有接受方对这个数据进行确认了以后才能发送第2个数据。我们可以看到发送方每发送一个数据接受方就要给发送方一个ACK对这个数据进行确认。只有接受到了这个确认数据以后发送方才能传输下个数据。 这样我们考虑一下如果说窗口过小，那么当传输比较大的数据的时候需要不停的对数据进行确认，这个时候就会造成很大的延迟。如果说窗口的大小定义的过大。我们假设发送方一次发送100个数据。但是接收方只能处理50个数据。这样每次都会只对这50个数据进行确认。发送方下一次还是发送100个数据，但是接受方还是只能处理50个数据。这样就避免了不必要的数据来拥塞我们的链路。所以我们就引入了滑动窗口机制，窗口的大小并不是固定的而是根据我们之间的链路的带宽的大小，这个时候链路是否拥护塞。接受方是否能处理这么多数据了。
我们看看滑动窗口是如何工作的。我们看下面几张图。</p>
<p><img src="https://images2015.cnblogs.com/blog/821276/201510/821276-20151016204014366-54723588.png" alt="img"></p>
<p>首先是<strong>第一次发送数据这个时候的窗口大小是根据链路带宽的大小来决定的</strong>。我们假设这个时候窗口的大小是3。这个时候接受方收到数据以后会对数据进行确认告诉发送方我下次希望手到的是数据是多少。这里我们看到<strong>接收方发送的ACK=3(这是发送方发送序列2的回答确认，下一次接收方期望接收到的是3序列信号)</strong>。这个时候发送方收到这个数据以后就知道我第一次发送的3个数据对方<strong>只收到了2个</strong>。就知道第3个数据对方没有收到。下次在发送的时候就从第3个数据开始发。
<img src="https://images2015.cnblogs.com/blog/821276/201510/821276-20151016204048116-416445314.png" alt="img"></p>
<p>这个时候发送方发送2个数据。</p>
<p><img src="https://images2015.cnblogs.com/blog/821276/201510/821276-20151016204148366-1896687312.png" alt="img"></p>
<p>看到接收方发送的ACK是5就表示他下一次希望收到的数据是5，发送方就知道我刚才发送的2个数据对方收了这个时候开始发送第5个数据。
这就是滑动窗口的工作机制，当链路变好了或者变差了这个窗口还会发生变话，并不是第一次协商好了以后就永远不变了。<br>
滑动窗口协议
滑动窗口协议，是TCP使用的一种流量控制方法。该协议允许发送方在停止并等待确认前可以连续发送多个分组。由于发送方不必每发一个分组就停下来等待确认，因此该协议可以加速数据的传输。
只有在接收窗口向前滑动时（与此同时也发送了确认），发送窗口才有可能向前滑动。<br>
收发两端的窗口按照以上规律不断地向前滑动，因此这种协议又称为滑动窗口协议。<br>
当发送窗口和接收窗口的大小都等于1时，就是停止等待协议。</p>
<h3 id="_17-用户态和核心态的区别。" tabindex="-1"><a class="header-anchor" href="#_17-用户态和核心态的区别。" aria-hidden="true">#</a> 17.用户态和核心态的区别。</h3>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态）。即此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>特权级显然是非常有效的管理和控制程序执行的手段，因此在硬件上对特权级做了很多支持，就Intel x86架构的CPU来说一共有0~3四个特权级，0级最高，3级最低，硬件上在执行每条指令时都会对指令所具有的特权级做相应的检查。虽然用户态下和内核态下工作的程序有很多差别，但最重要的差别就在于特权级的不同，即权力的不同。运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p>
<p>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态。</p>
<p>用户态和内核态的转换</p>
<p>1）用户态切换到内核态的3种方式</p>
<p>a. 系统调用</p>
<p>这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
<p>b. 异常</p>
<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
<p>c. 外围设备的中断</p>
<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
<p>这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。</p>
<p>2）具体的切换操作</p>
<p>从触发方式上看，可以认为存在前述3种不同的类型，但是从最终实际完成由用户态到内核态的切换操作上来说，涉及的关键步骤是完全一致的，没有任何区别，都相当于执行了一个中断响应的过程，因为系统调用实际上最终是中断机制实现的，而异常和中断的处理机制基本上也是一致的，涉及到由用户态切换到内核态的步骤主要包括：</p>
<p>[1] 从当前进程的描述符中提取其内核栈的ss0及esp0信息。</p>
<p>[2] 使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。</p>
<p>[3] 将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。</p>
<h3 id="_18-用户栈和内核栈的区别。" tabindex="-1"><a class="header-anchor" href="#_18-用户栈和内核栈的区别。" aria-hidden="true">#</a> 18.用户栈和内核栈的区别。</h3>
<p>（1.当进程运行在内核态时，CPU堆栈指针寄存器指向的是内核堆栈地址，使用的是内核堆栈。</p>
<p>当进程运行在用户态时。CPU堆栈指针寄存器指向的是用户堆栈地址，使用的是用户堆栈。</p>
<p>当进程由于中断进入内核态时，系统会把一些用户态的数据信息保存到内核栈中，当返回到用户态时，取出内核栈中得信息恢复出来，返回到程序原来执行的地方。
用户栈就是进程在用户空间时创建的栈，比如一般的函数调用，将会用到用户栈。</p>
<p>（2.内核栈是属于操作系统空间的一块固定区域，可以用于保存中断现场、保存操作系统子程序间相互调用的参数、返回值等。</p>
<p>用户栈是属于用户进程空间的一块区域，用户保存用户进程子程序间的相互调用的参数、返回值等。</p>
<p>（3.每个Windows 都有4g的进程空间，系统栈使用进程空间的低端部分，用户栈是高端部分。如果用户要直接访问系统栈部分，需要有特殊的方式。</p>
<p>进程用户栈和内核栈之间的切换</p>
<p>当进程由于中断或系统调用从用户态转换到内核态时，进程所使用的栈也要从用户栈切换到内核栈。系统调用实质就是通过指令产生中断，称为软中断。进程因为中断（软中断或硬件产生中断），使得CPU切换到特权工作模式，此时进程陷入内核态，进程进入内核态后，首先把用户态的堆栈地址保存在内核堆栈中，然后设置堆栈指针寄存器的地址为内核栈地址，这样就完成了用户栈向内核栈的切换。</p>
<p>当进程从内核态切换到用户态时，最后把保存在内核栈中的用户栈地址恢复到CPU栈指针寄存器即可，这样就完成了内核栈向用户栈的切换。</p>
<p>这里要理解一下内核堆栈。前面我们讲到，进程从用户态进入内核态时，需要在内核栈中保存用户栈的地址。那么进入内核态时，从哪里获得内核栈的栈指针呢？</p>
<p>要解决这个问题，先要理解从用户态刚切换到内核态以后，进程的内核栈总是空的。这点很好理解，当进程在用户空间运行时，使用的是用户栈；当进程在内核态运行时，内核栈中保存进程在内核态运行的相关信息，但是当进程完成了内核态的运行，重新回到用户态时，此时内核栈中保存的信息全部恢复，也就是说，进程在内核态中的代码执行完成回到用户态时，内核栈是空的。</p>
<p>因为内核栈是空的，那当进程从用户态切换到内核态后，把内核栈的栈顶地址设置给CPU的栈指针寄存器就可以了。</p>
<h3 id="_19-内存池、进程池、线程池。-c-程序员必须掌握" tabindex="-1"><a class="header-anchor" href="#_19-内存池、进程池、线程池。-c-程序员必须掌握" aria-hidden="true">#</a> 19.内存池、进程池、线程池。(c++程序员必须掌握)</h3>
<p>首先介绍一个概念“池化技术 ”。池化技术就是：提前保存大量的资源，以备不时之需以及重复使用。池化技术应用广泛，如内存池，线程池，连接池等等。内存池相关的内容，建议看看Apache、Nginx等开源web服务器的内存池实现。
由于在实际应用当做，分配内存、创建进程、线程都会设计到一些系统调用，系统调用需要导致程序从用户态切换到内核态，是非常耗时的操作。因此，当程序中需要频繁的进行内存申请释放，进程、线程创建销毁等操作时，通常会使用内存池、进程池、线程池技术来提升程序的性能。</p>
<p>线程池：线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：先启动若干数量的线程，并让这些线程都处于睡眠状态，当需要一个开辟一个线程去做具体的工作时，就会唤醒线程池中的某一个睡眠线程，让它去做具体工作，当工作完成后，线程又处于睡眠状态，而不是将线程销毁。</p>
<p>进程池与线程池同理。</p>
<p>内存池：内存池是指程序预先从操作系统申请一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不真正将内存返回给操作系统，而是返回内存池。当程序退出(或者特定时间)时，内存池才将之前申请的内存真正释放。</p>
<h3 id="_14-windows内存管理的方式-块式、页式、段式、段页式" tabindex="-1"><a class="header-anchor" href="#_14-windows内存管理的方式-块式、页式、段式、段页式" aria-hidden="true">#</a> 14.Windows内存管理的方式(块式、页式、段式、段页式</h3>
<p>Windows中的内存分为两类：</p>
<p>物理内存即实际内存，实存储器。
虚拟内存：用硬盘空间做内存来弥补计算机RAM空间的缺乏。
虚拟内存可行性的理论基础：</p>
<p>（1）进程中的所有内存访问地址都是逻辑地址，这些逻辑地址在运行时动态的被转换为物理地址，这意味着一个进程可以被换入或换出内存，使得进程可以执行过程中的不同时刻占据内存中的不同区域。</p>
<p>（2）一个进程可以划分成许多块，在执行过程中，这些块不需要连续的存放在内存中。</p>
<h6 id="使用虚拟内存的好处" tabindex="-1"><a class="header-anchor" href="#使用虚拟内存的好处" aria-hidden="true">#</a> 使用虚拟内存的好处：</h6>
<p>1、在内存中保留多个进程。由于对任何特定的进程都仅仅装入它的某些块，因此就有足够的空间来放置更多的进程。</p>
<p>2、进程可以比内存的全部空间还大。程序占用的内存空间的大小是程序设计中最大的限制之一。通过基于分页或分段的虚拟内存，这些分块可以按某种覆盖策略分别加载。</p>
<h6 id="常用内存管理技术" tabindex="-1"><a class="header-anchor" href="#常用内存管理技术" aria-hidden="true">#</a> 常用内存管理技术：</h6>
<p>（1）固定分区</p>
<p>说明：在系统生成阶段，内存被划分成许多静态分区。进程可以被装入到大于或等于自身大小的分区。</p>
<p>优势：实现简单，只需要极少的操作系统开销。</p>
<p>缺点：由于有内部碎片，对内存的使用不充分；活动进程的最大数目是固定的。</p>
<p>（2）动态分区</p>
<p>说明：分区是动态创建的，因而使得每个进程可以被装入与自身大小正好相等的分区中。</p>
<p>优势：没有内部碎片；可以更充分的使用内存。</p>
<p>缺点：由于需要压缩外部碎片，处理器利用率低。</p>
<p>（3）虚拟内存分页</p>
<p>说明：内存被划分为许多大小相等的页框；每个进程被划分成许多大小与页框相等的页；不需要装入一个进程的所有页，每次只需将进程运行需要的页装入到内存中不一定连续的页框中。非驻留页在以后需要时自动调入内存。</p>
<p>优势：没有外部碎片；支持更高道数的多道程序设计；巨大的虚拟地址空间。</p>
<p>缺点：复杂的内存管理开销。</p>
<p>使用分页技术在内存中为每个进程浪费的空间仅仅是进程最后一页的一小部分形成的内部碎片，没有任何外部碎片。</p>
<p>操作系统维护空闲页框的列表，为每个进程维护一个页表，页表给出了该进程的每一页对应的页框的位置，在程序中，每个逻辑地址包括一个页号和在该页中的偏移量。根据进程页表中页号和对应页框的位置，由对应的页框号和偏移量计算出物理地址。</p>
<p>（4）虚拟内存分段</p>
<p>说明：每个进程被划分为许多段；不需要装入一个进程的所有页，每次只需将进程运行需要的段装入到内存中不一定连续的某些动态分区中；非驻留段在以后需要时自动调入内存。</p>
<p>优势：没有内部碎片；支持更高道数的多道程序设计；巨大的虚拟地址空间；支持保护与共享</p>
<p>缺点：复杂的内存管理开销，分段消除了内部碎片，但是会产生外部碎片</p>
<p>在简单的分段方案中，每个进程都有一个段表，系统也会维护一个内存中的空闲块列表。每个段表项必须给出相应的段在内存中的起始地址，还必须指明段的长度，以确保不会使用无效的地址。</p>
<p>（5）段页式</p>
<p>分段和分页都有它们的长处。分页对程序员是透明的，它消除了外部碎片，因而可以更有效地使用内存，并且移入或移出内存的块是固定的，大小相等的。分段对程序员是可见的，它具有处理不断增长的数据结构的能力以及支持共享和保护的能力。</p>
<p>在段页式的系统中，用户的地址空间被程序员划分成许多段。每个段一次划分成许多固定大小的页，页的长度等于内存中页框的大小。从程序员的角度看，逻辑地址仍然由段号和段偏移量组成，从系统的角度看，段偏移量可视为指定段中的一个页号和页偏移。</p>
<h3 id="_15-内存连续分配方式采用的几种算法及各自优劣。" tabindex="-1"><a class="header-anchor" href="#_15-内存连续分配方式采用的几种算法及各自优劣。" aria-hidden="true">#</a> 15.内存连续分配方式采用的几种算法及各自优劣。</h3>
<p>常见内存分配算法及优缺点如下：
　　（1）首次适应算法。使用该算法进行内存分配时，从空闲分区链首开始查找，直至找到一个能满足其大小需求的空闲分区为止。然后再按照作业的大小，从该分区中划出一块内存分配给请求者，余下的空闲分区仍留在空闲分区链中。
　　该算法倾向于使用内存中低地址部分的空闲分区，在高地址部分的空闲分区非常少被利用，从而保留了高地址部分的大空闲区。显然为以后到达的大作业分配大的内存空间创造了条件。缺点在于低址部分不断被划分，留下许多难以利用、非常小的空闲区，而每次查找又都从低址部分开始，这无疑会增加查找的开销。
　　（2）循环首次适应算法。该算法是由首次适应算法演变而成的。在为进程分配内存空间时，不再每次从链首开始查找，而是从上次找到的空闲分区开始查找，直至找到一个能满足需求的空闲分区，并从中划出一块来分给作业。该算法能使空闲中的内存分区分布得更加均匀，缺点是将会缺乏大的空闲分区。
　　（3）最佳适应算法。该算法总是把既能满足需求，又是最小的空闲分区分配给作业。
　　为了加速查找，该算法需求将所有的空闲区按其大小排序后，以递增顺序形成一个空白链。这样每次找到的第一个满足需求的空闲区，必然是最优的。孤立地看，该算法似乎是最优的，但事实上并不一定。因为每次分配后剩余的空间一定是最小的，缺点是在存储器中将留下许多难以利用的小空闲区。同时每次分配后必须重新排序，这也带来了一定的开销。
　　（4）最差适应算法。最差适应算法中，该算法按大小递减的顺序形成空闲区链，分配时直接从空闲区链的第一个空闲分区中分配（不能满足需要则不分配）。非常显然，如果第一个空闲分区不能满足，那么再没有空闲分区能满足需要。这种分配方法初看起来不太合理，但他也有非常强的直观吸引力：在大空闲区中放入程式后，剩下的空闲区常常也非常大，于是还能装下一个较大的新程式。
　　最坏适应算法和最佳适应算法的排序正好相反，他的队列指针总是指向最大的空闲区，在进行分配时，总是从最大的空闲区开始查寻。
　　该算法克服了最佳适应算法留下的许多小的碎片的不足，但缺点是保留大的空闲区的可能性减小了，而且空闲区回收也和最佳适应算法相同复杂。</p>
<p>————————————————</p>
<h3 id="_17-基本分页、请求分页储存管理方式。" tabindex="-1"><a class="header-anchor" href="#_17-基本分页、请求分页储存管理方式。" aria-hidden="true">#</a> 17.基本分页、请求分页储存管理方式。</h3>
<p>基本分页储存管理方式具有如下特征：</p>
<ol>
<li>
<p>一次性。要求将作业全部装入内存后方能运行。许多作业在每次运行时，并非其全部程序和数据都要用到。如果一次性地装入其全部程序，造成内存空间的浪费。</p>
</li>
<li>
<p>驻留性。作业装入内存后，便一直驻留在内存中，直至作业运行结束。尽管运行中的进程会因I/O而长期等待，或有的程序模块在运行过一次后就不再需要(运行)了，但它们都仍将继续占用宝贵的内存资源。</p>
</li>
</ol>
<p>请求分页储存管理：</p>
<p>它是实现虚拟存储器的一种常用方式，它是在基本分页储存管理的基础上实现的。其基本思想是：在进程开始运行之前，仅装入当前要执行的部分页面即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的页面；当内存空间已满，而又需要装入新的页面时，者根据置换功能适当调出某个页面，以便腾出空间而装入新的页面。为实现请求分页，需要一定的硬件支持，包括：页表机制、缺页中断机构、地址变换机构。
————————————————</p>
<h3 id="_18-基本分段、请求分段储存管理方式。" tabindex="-1"><a class="header-anchor" href="#_18-基本分段、请求分段储存管理方式。" aria-hidden="true">#</a> 18.基本分段、请求分段储存管理方式。</h3>
<p>分页管理方式是从计算机的角度考虑设计的，以提高内存的利用率，提高计算机的性能，提升计算机的性能，且分页通过硬件机制实现，对用户完全透明；</p>
<p>而分段管理方式的提出则是考虑用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。</p>
<p>基本分段储存管理：</p>
<p>段式管理方式是按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序、两个子程序、栈和一段数据组成，于是可以把这个用户进程划分为5个段，每段从0开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的）。其逻辑地址由段号S与段内偏移量W两部分组成。</p>
<p>与分页管理类似，分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保存。地址越界保护是利用段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度则产生越界中断；再利用段表项中的段长和逻辑地址中的段内位移进行比较，若段内位移大于段长，也会产生越界中断。</p>
<p>基本分段储存管理方式就像基本分页储存管理方式一样，将作业需要的数据段一次性的全部装入内存中，作业装入内存后，便一直驻留在内存中，直至作业运行结束。</p>
<p>请求分段储存管理方式就如同请求分页储存管理方式一样，在进程开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。
————————————————</p>
<h3 id="_19-分段分页方式的比较各自优缺点。" tabindex="-1"><a class="header-anchor" href="#_19-分段分页方式的比较各自优缺点。" aria-hidden="true">#</a> 19.分段分页方式的比较各自优缺点。</h3>
<p>分段和分页其实都是一种对地址的划分或者映射的方式。 两者的区别主要有以下几点：</p>
<p>1)页是信息的物理单位，分页是为实现离散分配方式，以消减内存的外零头，提高内存的利用率；或者说，分页仅仅是由于系统管理的需要，而不是用户的需要（也是对用户透明的）。段是信息的逻辑单位，它含有一组其意义相对完整的信息（比如数据段、代码段和堆栈段等）。分段的目的是为了能更好的满足用户的需要（用户也是可以使用的）。</p>
<p>2)页的大小固定且由系统确定，把逻辑地址划分为页号和页内地址两部分，是由机器硬件实现的，因而一个系统只能有一种大小的页面。段的长度却不固定，决定于用户所编写的程序，通常由编辑程序在对源程序进行编辑时，根据信息的性质来划分。</p>
<p>3)分页的作业地址空间是维一的，即单一的线性空间，程序员只须利用一个记忆符（线性地址的16进制表示），即可表示一地址。分段的作业地址空间是二维的，程序员在标识一个地址时，既需给出段名（比如数据段、代码段和堆栈段等），又需给出段内地址。</p>
<p>4)页和段都有存储保护机制。但存取权限不同：段有读、写和执行三种权限；而页只有读和写两种权限</p>
<p>————————————————</p>
<h3 id="_20-几种页面置换算法-会算所需换页数。-lru用程序如何实现" tabindex="-1"><a class="header-anchor" href="#_20-几种页面置换算法-会算所需换页数。-lru用程序如何实现" aria-hidden="true">#</a> 20.几种页面置换算法，会算所需换页数。(LRU用程序如何实现？)</h3>
<h6 id="_1-最佳置换算法-opt-optimalreplacement理想置换算法" tabindex="-1"><a class="header-anchor" href="#_1-最佳置换算法-opt-optimalreplacement理想置换算法" aria-hidden="true">#</a> 1）最佳置换算法（OPT）（OPTimalreplacement理想置换算法）</h6>
<p>这是一种理想情况下的页面置换算法，但实际上是不可能实现的。该算法的基本思想是：发生缺页时，有些页面在内存中，其中有一页将很快被访问（也包含紧接着的下一条指令的那页），而其他页面则可能要到10、100或者1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数进行标记。最佳页面置换算法只是简单地规定：标记最大的页应该被置换，选择下次访问距当前时间最长的那些页。这个算法唯一的一个问题就是它无法实现。当缺页发生时，操作系统无法知道各个页面下一次是在什么时候被访问。虽然这个算法不可能实现，但是最佳页面置换算法可以用于对可实现算法的性能进行衡量比较。</p>
<h6 id="_2-先进先出置换算法-fifo" tabindex="-1"><a class="header-anchor" href="#_2-先进先出置换算法-fifo" aria-hidden="true">#</a> 2）先进先出置换算法（FIFO）</h6>
<p>最简单的页面置换算法是先入先出（FIFO）法。这种算法的实质是，总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。理由是：最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。建立一个FIFO队列，收容所有在内存中的页。被置换页面总是在队列头上进行。当一个页面被放入内存时，就把它插在队尾上。
这种算法只是在按线性顺序访问地址空间时才是理想的，否则效率不高。因为那些常被访问的页，往往在主存中也停留得最久，结果它们因变“老”而不得不被置换出去。
FIFO的另一个缺点是，它有一种异常现象，即在增加存储块的情况下，反而使缺页中断率增加了。当然，导致这种异常现象的页面走向实际上是很少见的。</p>
<h6 id="_3-最近最久未使用-lru-算法" tabindex="-1"><a class="header-anchor" href="#_3-最近最久未使用-lru-算法" aria-hidden="true">#</a> 3）最近最久未使用（LRU）算法</h6>
<p>FIFO算法和OPT算法之间的主要差别是，FIFO算法利用页面进入内存后的时间长短作为置换依据，而OPT算法的依据是将来使用页面的时间。如果以最近的过去作为不久将来的近似，那么就可以把过去最长一段时间里不曾被使用的页面置换掉。它的实质是，当需要置换一页时，选择在最近一段时间里最久没有使用过的页面予以置换。这种算法就称为最久未使用算法（Least Recently Used，LRU）。
LRU算法是与每个页面最后使用的时间有关的。当必须置换一个页面时，LRU算法选择过去一段时间里最久未被使用的页面。虽然LRU策略的性能接近OPT策略，但是问题在于这种策略比较难实现。
————————————————</p>
<h3 id="_21-虚拟内存的定义及实现方式。" tabindex="-1"><a class="header-anchor" href="#_21-虚拟内存的定义及实现方式。" aria-hidden="true">#</a> 21.虚拟内存的定义及实现方式。</h3>
<p>虚拟内存是指为了扩充主存空间而在外存上开辟的一块存储空间.虚拟内存用来保存实际内存中暂时不用的程序或数据,使实际内存有更多的空闲空间来存放将要执行的程序或访问的数据,当需要执行的程序或访问的数据不在主存时,就从虚拟内存将其调入到主存,以便处理器执行或访问,这样就扩大了内存空间,操作系统对实际内存和虚拟内存统一编址和统一管理,这就是虚拟内存技术.
大多数的多任务操作系统都采用分页存储方式,使用虚拟内存技术。UNIX操作系统采用页面存储方式,Windows NT采用请求分页的虚拟存储方式,Linux系统采用按需调页的模式。在AIX系统中，也使用分页的存储方式管理存储器,并将虚拟内存称为页面空间(Paging Space)，所有对实际物理内存和虚拟内存的访问都是由虚拟内存管理器(VMM)完成的。
————————————————</p>
<h3 id="_22-操作系统的四个特性。" tabindex="-1"><a class="header-anchor" href="#_22-操作系统的四个特性。" aria-hidden="true">#</a> 22.操作系统的四个特性。</h3>
<p>1）并发（concurrence）</p>
<p>并行性与并发性这两个概念是既相似又区别的两个概念。并行性是指两个或者多个事件在同一时刻发生，这是一个具有微观意义的概念，即在物理上这些事件是同时发生的；而并发性是指两个或者多个事件在同一时间的间隔内发生，它是一个较为宏观的概念。在多道程序环境下，并发性是指在一段时间内有多道程序在同时运行，但在单处理机的系统中，每一时刻仅能执行一道程序，故微观上这些程序是在交替执行的。</p>
<p>应当指出，通常的程序是静态实体，它们是不能并发执行的。为了使程序能并发执行，系统必须分别为每个程序建立进程。进程，又称任务，简单来说，是指在系统中能独立运行并作为资源分配的基本单位，它是一个活动的实体。多个进程之间可以并发执行和交换信息。一个进程在运行时需要运行时需要一定的资源，如cpu,存储空间，及i/o设备等。在操作系统中引入进程的目的是使程序能并发执行。</p>
<p>2）共享 (sharin)</p>
<p>所谓共享是指，系统中的资源可供内存中多个并发执行的进程共同使用。由于资源的属性不同，故多个进程对资源的共享方式也不同，可以分为：互斥共享方式和同时访问方式。</p>
<p>3）虚拟 (virtual)</p>
<p>是指通过技术把一个物理实体变成若干个逻辑上的对应物。在操作系统中虚拟的实现主要是通过分时的使用方法。显然，如果n是某一个物理设备所对应的虚拟逻辑设备数，则虚拟设备的速度必然是物理设备速度的1/n。</p>
<p>4）异步 (asynchronism)</p>
<p>在多道程序设计环境下，允许多个进程并发执行，由于资源等因素的限制，通常，进程的执行并非“一气呵成”，而是以“走走停停”的方式运行。内存中每个进程在何时执行，何时暂停，以怎样的方式向前推进，每道程序总共需要多少时间才能完成，都是不可预知的。或者说，进程是以一步的方式运行的。尽管如此，但只要运行环境相同，作业经过多次运行，都会获得完全相同的结果。
————————————————</p>
<h3 id="_23-dma-直接内存存取" tabindex="-1"><a class="header-anchor" href="#_23-dma-直接内存存取" aria-hidden="true">#</a> 23.DMA(直接内存存取)</h3>
<p>DMA是指外部设备不通过CPU而直接与系统内存交换数据的接口技术。</p>
<p>要把外设的数据读入内存或把内存的数据传送到外设，一般都要通过CPU控制完成，如CPU程序查询或中断方式。利用中断进行数据传送，可以大大提高CPU的利用率。</p>
<p>但是采用中断传送有它的缺点，对于一个高速I/O设备，以及批量交换数据的情况，只能采用DMA方式，才能解决效率和速度问题。DMA在外设与内存间直接进行数据交换，而不通过CPU，这样数据传送的速度就取决于存储器和外设的工作速度。</p>
<p>通常系统的总线是由CPU管理的。在DMA方式时，就希望CPU把这些总线让出来，即CPU连到这些总线上的线处于第三态--高阻状态，而由DMA控制器接管，控制传送的字节数，判断DMA是否结束，以及发出DMA结束信号。DMA控制器必须有以下功能：</p>
<p>1）能向CPU发出系统保持（HOLD）信号，提出总线接管请求；</p>
<p>2）当CPU发出允许接管信号后，负责对总线的控制，进入DMA方式；</p>
<p>3）能对存储器寻址及能修改地址指针，实现对内存的读写操作；</p>
<p>4）能决定本次DMA传送的字节数，判断DMA传送是否结束</p>
<p>5）发出DMA结束信号，使CPU恢复正常工作状态。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218134108639.png" alt="image-20211218134108639"></p>
<p>————————————————</p>
<h3 id="_24-spooling。" tabindex="-1"><a class="header-anchor" href="#_24-spooling。" aria-hidden="true">#</a> 24.Spooling。</h3>
<p>SPOOLING技术（Simultaneous Peripheral Operating On Line)</p>
<p>同时联机外围操作技术，它是关于慢速字符设备如何与计算机主机进行数据交换的一种技术，通常又称假脱机技术。</p>
<p>在多道程序环境下，利用多道程序中的一道或者两道程序来模拟脱机输入/输出中的外围控制机的功能，以达到“脱机”输入/输出的目的。</p>
<p>利用这种技术可把独占设备转变成共享的虚拟设备，从而提高独占设备的利用率和进程的推进速度。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218134136579.png" alt="image-20211218134136579"></p>
<p>SPOOLING系统 是对脱机输入/输出工作的模拟，它必须有大容量的且可随机存取的存储器
的支持。</p>
<p>其主要思想是在联机的条件下，进行两个方向的操作，在数据输入时，将数据从输入设备传送到磁盘或磁带（块设备），然后把这些块设备与主机相连；反过来，在数据输出时，将输出数据传送到磁盘或磁带上，再从磁盘或磁带传送到输出设备。</p>
<p>这样，可以将一台独占的物理设备虚拟为并行使用的多态逻辑设备，从而使该物理设备被多个进程共享。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218134146015.png" alt="image-20211218134146015"></p>
<p>输入进程SPI是模拟脱机输入时的外围控制机，它将用户要求处理的数据从输入设备通过输入缓冲区再送到输入井（磁盘上开辟的一块区域），当CPU处理这些数据数据时，就直接从输入井读入内存。</p>
<p>输出进程SPO是模拟脱机输出时的外围控制机，把用户要求输出的数据，先从内存送到输出井，待输出设备空闲时，再将输出井中的数据通过输出缓冲区（内存中一块区域）传送到输出设备上。</p>
<p>实例——利用打印机实现打印机共享</p>
<p>已经被广泛用于多用户系统和计算机网络中，它实际上就是利用SPOOLING技术将独占的打印机改造为一台供做个用户共享的设备，只要有足够的外存空间和多道程序操作系统的支持即可。</p>
<p>1、当用户进程请求打印输出时，SPOOLING系统立即同意为该进程执行打印输出，但并不是真正地把打印机分配给该用户进程，而只是为该进程做两项工作：一项是由输出进程SPO在输出井中为之申请一个空闲的存储空间，并将要打印的数据传送其中存放；另一项工作就是由输出进程SPO再为用户进程申请一张空白的用户请求打印表，并将用户的打印请求填入其中，然后将该表挂到打印机的请求队列上。这时，如果还有另一个进程请求打印机时，则系统仍同意为该进程执行打印输出，当然，系统所做的工作仍是以上两项内容。</p>
<p>2、在打印机执行实际打印时，如果打印机空闲，输出进程SPO将从请求打印队列的队首取出一张打印表，根据打印表中的要求将要打印的数据从输出井传送到内存输出缓冲区，再传送到打印机打印。打印完后，输出进程SPO将再检查请求打印队列中是否还有待打印的请求表，若有则再取出一张请求打印表，将新的但因要求继续打印。如此反复，直到请求打印队列空为止，输出进程才将自己阻塞起来，并在下次再有打印请求
————————————————</p>
<h3 id="_25-外存分配的几种方式-及各种优劣。" tabindex="-1"><a class="header-anchor" href="#_25-外存分配的几种方式-及各种优劣。" aria-hidden="true">#</a> 25.外存分配的几种方式，及各种优劣。</h3>
<p>外存，指的是除了cpu缓存和内存以外的存储器，硬盘、光盘、U盘都可以被称为外存。所有的数据，也都存在这里面，故他的分配方式变得极其重要，这直接影响到了计算机的运行速度。</p>
<pre><code>外存分配方式主要有这几种：连续分配，链式分配，索引分配。
</code></pre>
<p>（1） 连续分配</p>
<pre><code>原理：创建文件时，分配一组连续的块；FAT（文件分配表）中每个文件只要一项，说明起始块和文件长度。对于顺序文件有利。

优点：1.简便。适用于一次性写入操作。2.支持顺序存取和随机存取，顺序存取速度快。3.所需的磁盘寻道次数和寻道时间最少。（因为空间的连续性，当访问下一个磁盘块时，一般无需移动磁头，当需要移动磁头时，只需要移动一个磁道。）

缺点：1.文件不能动态增长。（可能文件末尾处的空块已经分配给了别的文件）2.不利于文件的插入和删除。3.外部碎片问题。（反复增删文件后，很难找到空间大小足够的连续块，需要进行紧缩。）4.在创建文件时需声明文件大小。

如图：
</code></pre>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218134224918.png" alt="image-20211218134224918"></p>
<p>（2）链式分配</p>
<pre><code>原理：一个文件的信息存放在若干个不连续的物理块中，各块之间通过指针连接，前一个物理块指向下一个物理块。fat中每个文件同样只需要一项，包括文件名、起始块号和最后块号。任何一个自由块都可以加入到链中。

优点：1.提高磁盘的空间利用率，不存在外部碎片问题。2.有利于文件的插入和删除。3.有利于文件的动态扩充。

缺点：1.存取速度慢，一般只适用于信息的顺序存取，不适于随机存取。2.查找某一块必须从头到尾沿着指针进行。3.可靠性问题，如指针出错。4.更多的寻道次数和寻道时间。5.链接指针占一定的空间，将多个块组成簇，按簇进行分配而不是按块进行分配。（增加了磁盘碎片）

如图：
</code></pre>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218134234056.png" alt="image-20211218134234056"></p>
<p>（3）索引分配</p>
<pre><code>原理：每个文件在FAT中有一个一级索引，索引包含分配给文件的每个分区的入口。文件的索引保存在单独的一个块中，FAT中该文件的入口指向这一块。

优点：1.保持了链接结构的优点，又解决了其缺点：按快分配可以消除外部碎片。按大小可改变的分区分配可以提高局部性。索引分配支持顺序访问文件和直接访问文件，是普遍采用的一种方式。2.满足了文件动态增长，插入删除的要求。（只要有空闲块）3.能充分利用外存空间。

缺点：1.较多的寻道次数和寻道空间。2.索引表本身带来了系统开销，如：内外存空间、存取时间。

如图：
</code></pre>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218134241202.png" alt="image-20211218134241202"></p>
<p>（4）连续分配和索引分配相结合</p>
<pre><code>原理：对于小文件（3、4块），采用连续分配；当文件大时，自动切换到索引分配。

文件的直接访问：使用连续分配方式。

文件的顺序访问：采用链接分配。

对于这些系统，所使用的访问类型，必须在文件创建时加以说明。
</code></pre>
<p>（5）多重索引</p>
<pre><code>原理：首先，多重索引也是索引分配的一种，只不过它是将一个大文件的所有索引表（二级索引）的地址放在另一个索引表（一级索引）中。ps：跟数据库第四范式非常像。
</code></pre>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218134247553.png" alt="image-20211218134247553"></p>
<pre><code>大文件：设一个盘块大小为1kb，长度100kb的文件就需要100个盘块，索引表至少需要100项；若文件大小为1000kb，则索引表项就要有1000项。设盘块号用4个字节表示，则该索引表至少占用4000bye（约4k）。

当文件很大时，存在的问题：1.需要很多磁盘块。2.索引表很大。3.不能将整个索引表放在内存。

解决途径：采用多重索引表结构。

如图：
</code></pre>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218134254509.png" alt="image-20211218134254509"></p>
<pre><code>多重索引表结构图示：
</code></pre>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218134300170.png" alt="image-20211218134300170"></p>
<h1 id="二-计算机网络面试题" tabindex="-1"><a class="header-anchor" href="#二-计算机网络面试题" aria-hidden="true">#</a> 二.计算机网络面试题</h1>
<h3 id="_1、传输层主要有哪些协议" tabindex="-1"><a class="header-anchor" href="#_1、传输层主要有哪些协议" aria-hidden="true">#</a> 1、传输层主要有哪些协议？</h3>
<p>答：主要有 TCP 和 UDP 协议。他们的区别是 TCP 是需要连接的 会经过三次握手，而且可以保证消息的可靠性。UDP 是不需要连接的，不保证消息的可靠性。</p>
<h3 id="_2、为什么需要三次握手" tabindex="-1"><a class="header-anchor" href="#_2、为什么需要三次握手" aria-hidden="true">#</a> 2、为什么需要三次握手？</h3>
<p>答:主要是为了确认双方接收是否正常。</p>
<p>第一次：客户端什么都不能确认。服务端能确认客户端的发送正常，自己的接收正常</p>
<p>第二次：客户端能确认自己的发送和接收正常，服务端的发送和接收正常。服务端能确认自己接收正常，客户端的发送正常。</p>
<p>第三次：全部都能确认了。</p>
<h3 id="_3、谈下你对五层网络协议体系结构的理解" tabindex="-1"><a class="header-anchor" href="#_3、谈下你对五层网络协议体系结构的理解" aria-hidden="true">#</a> 3、谈下你对五层网络协议体系结构的理解？</h3>
<p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p>
<p>“<em>arp协议在TCP/IP模型中属于IP层（网络层），在OSI模型中属于链路层。</em></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217174129181.png" alt="image-20211217174129181"></p>
<ol>
<li>应用层</li>
</ol>
<p>应用层（application-layer）的任务是通过应用进程间的交互来完成特定网络应用。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如域名系统 DNS，支持万维网应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。我们把应用层交互的数据单元称为报文。</p>
<ol start="2">
<li>传输层</li>
</ol>
<p>运输层（transport layer）的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p>由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<ol start="3">
<li>网络层</li>
</ol>
<p>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP / IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<ol start="4">
<li>数据链路层</li>
</ol>
<p>数据链路层（data link layer）通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如：同步信息，地址信息，差错控制等）。</p>
<p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。控制信息还使接收端能够检测到所收到的帧中有无差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p>
<ol start="5">
<li>物理层</li>
</ol>
<p>在物理层上所传送的数据单位是比特。物理层（physical layer）的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<h3 id="_4、简单说下每一层对应的网络协议有哪些" tabindex="-1"><a class="header-anchor" href="#_4、简单说下每一层对应的网络协议有哪些" aria-hidden="true">#</a> 4、简单说下每一层对应的网络协议有哪些？</h3>
<p>计算机五层网络体系中涉及的协议非常多，下面就常用的做了列举：</p>
<p>“<em>arp协议在TCP/IP模型中属于IP层（网络层），在OSI模型中属于链路层。</em></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217174405836.png" alt="image-20211217174405836"></p>
<h3 id="_5、arp-协议的工作原理" tabindex="-1"><a class="header-anchor" href="#_5、arp-协议的工作原理" aria-hidden="true">#</a> 5、ARP 协议的工作原理？</h3>
<p>网络层的 ARP 协议完成了 IP 地址与物理地址的映射。首先，每台主机都会在自己的 ARP 缓冲区中建立一个 ARP 列表，以表示 IP 地址和 MAC 地址的对应关系。当源主机需要将一个数据包要发送到目的主机时，会首先检查自己 ARP 列表中是否存在该 IP 地址对应的 MAC 地址：如果有，就直接将数据包发送到这个 MAC 地址；如果没有，就向本地网段发起一个 ARP 请求的广播包，查询此目的主机对应的 MAC 地址。</p>
<p>此 ARP 请求数据包里包括源主机的 IP 地址、硬件地址、以及目的主机的 IP 地址。网络中所有的主机收到这个 ARP 请求后，会检查数据包中的目的 IP 是否和自己的 IP 地址一致。如果不相同就忽略此数据包；如果相同，该主机首先将发送端的 MAC 地址和 IP 地址添加到自己的 ARP 列表中，如果 ARP 表中已经存在该 IP 的信息，则将其覆盖，然后给源主机发送一个 ARP 响应数据包，告诉对方自己是它需要查找的 MAC 地址；源主机收到这个 ARP 响应数据包后，将得到的目的主机的 IP 地址和 MAC 地址添加到自己的 ARP 列表中，并利用此信息开始数据的传输。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败。</p>
<h3 id="_6、谈下你对-ip-地址分类的理解" tabindex="-1"><a class="header-anchor" href="#_6、谈下你对-ip-地址分类的理解" aria-hidden="true">#</a> 6、谈下你对 IP 地址分类的理解？</h3>
<p>IP 地址是指互联网协议地址，是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址编址方案将 IP 地址空间划分为 A、B、C、D、E 五类，其中 A、B、C 是基本类，D、E 类作为多播和保留使用，为特殊地址。</p>
<p>每个 IP 地址包括两个标识码（ID），即网络 ID 和主机 ID。同一个物理网络上的所有主机都使用同一个网络 ID，网络上的一个主机（包括网络上工作站，服务器和路由器等）有一个主机 ID 与其对应。A~E 类地址的特点如下：</p>
<p>A 类地址：以 0 开头，第一个字节范围：0~127；</p>
<p>B 类地址：以 10 开头，第一个字节范围：128~191；</p>
<p>C 类地址：以 110 开头，第一个字节范围：192~223；</p>
<p>D 类地址：以 1110 开头，第一个字节范围为 224~239；</p>
<p>E 类地址：以 1111 开头，保留地址</p>
<p>1). A类地址：1字节的网络地址 + 3字节主机地址，网络地址的最高位必须是“0”</p>
<p>一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”。A类IP地址中网络的标识长度为8位，主机标识的长度为24位，A类网络地址数量较少，有126个网络，每个网络可以容纳主机数达1600多万台。</p>
<p>A类IP地址的地址范围1.0.0.0到127.255.255.255（二进制表示为：00000001 00000000 00000000 00000000 - 01111110 11111111 11111111 11111111），最后一个是广播地址。A类IP地址的子网掩码为255.0.0.0，每个网络支持的最大主机数为256的3次方-2=16777214台。</p>
<p>2). B类地址: 2字节的网络地址 + 2字节主机地址，网络地址的最高位必须是“10”</p>
<p>一个B类IP地址是指，在IP地址的四段号码中，前两段号码为网络号码。如果用二进制表示IP地址的话，B类IP地址就由2字节的网络地址和2字节主机地址组成，网络地址的最高位必须是“10”。B类IP地址中网络的标识长度为16位，主机标识的长度为16位，B类网络地址适用于中等规模的网络，有16384个网络，每个网络所能容纳的计算机数为6万多台。</p>
<p>B类IP地址地址范围128.0.0.0-191.255.255.255（二进制表示为：10000000 00000000 00000000 00000000—-10111111 11111111 11111111 11111111），最后一个是广播地址。B类IP地址的子网掩码为255.255.0.0，每个网络支持的最大主机数为256的2次方-2=65534台。</p>
<p>3). C类地址: 3字节的网络地址 + 1字节主机地址，网络地址的最高位必须是“110”</p>
<p>一个C类IP地址是指，在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码。如果用二进制表示IP地址的话，C类IP地址就由3字节的网络地址和1字节主机地址组成，网络地址的最高位必须是“110”。C类IP地址中网络的标识长度为24位，主机标识的长度为8位，C类网络地址数量较多，有209万余个网络。适用于小规模的局域网络，每个网络最多只能包含254台计算机。</p>
<p>C类IP地址范围192.0.0.0-223.255.255.255（二进制表示为: 11000000 00000000 00000000 00000000 - 11011111 11111111 11111111 11111111）。C类IP地址的子网掩码为255.255.255.0，每个网络支持的最大主机数为256-2=254台。</p>
<p>4). D类地址:多播地址，用于1对多通信，最高位必须是“1110”</p>
<p>D类IP地址在历史上被叫做多播地址(multicast address)，即组播地址。在以太网中，多播地址命名了一组应该在这个网络中应用接收到一个分组的站点。多播地址的最高位必须是“1110”，范围从224.0.0.0到239.255.255.255。</p>
<p>5). E类地址:为保留地址，最高位必须是“1111”</p>
<h3 id="_7、tcp-的主要特点是什么" tabindex="-1"><a class="header-anchor" href="#_7、tcp-的主要特点是什么" aria-hidden="true">#</a> 7、TCP 的主要特点是什么？</h3>
<ol>
<li>
<p>TCP 是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；</p>
</li>
<li>
<p>每一条 TCP 连接只能有两个端点，每一条 TCP 连接只能是点对点的（一对一）；</p>
</li>
<li>
<p>TCP 提供可靠交付的服务。通过 TCP 连接传送的数据，无差错、不丢失、不重复、并且按序到达；</p>
</li>
<li>
<p>TCP 提供全双工通信。TCP 允许通信双方的应用进程在任何时候都能发送数据。TCP 连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</p>
</li>
<li>
<p>面向字节流。TCP 中的“流”（Stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。</p>
</li>
</ol>
<h3 id="_8、udp-的主要特点是什么" tabindex="-1"><a class="header-anchor" href="#_8、udp-的主要特点是什么" aria-hidden="true">#</a> 8、UDP 的主要特点是什么？</h3>
<ol>
<li>
<p>UDP 是无连接的；</p>
</li>
<li>
<p>UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；</p>
</li>
<li>
<p>UDP 是面向报文的；</p>
</li>
<li>
<p>UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如 直播，实时视频会议等）；</p>
</li>
<li>
<p>UDP 支持一对一、一对多、多对一和多对多的交互通信；</p>
</li>
<li>
<p>UDP 的首部开销小，只有 8 个字节，比 TCP 的 20 个字节的首部要短。</p>
</li>
</ol>
<h3 id="_8-2、tcp-和-udp-的区别" tabindex="-1"><a class="header-anchor" href="#_8-2、tcp-和-udp-的区别" aria-hidden="true">#</a> 8.2、TCP 和 UDP 的区别？</h3>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217174423082.png" alt="image-20211217174423082"></p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的运输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。</p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如：QQ 语音、 QQ 视频 、直播等等。</p>
<p>TCP与UDP的区别</p>
<p>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：</p>
<p>TCP是面向连接的，UDP是无连接的；</p>
<p>TCP是可靠的，UDP是不可靠的；</p>
<p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</p>
<p>TCP是面向字节流的，UDP是面向报文的；</p>
<p>TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；</p>
<p>TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；</p>
<h3 id="_8-3、tcp-和-udp-分别对应的常见应用层协议有哪些" tabindex="-1"><a class="header-anchor" href="#_8-3、tcp-和-udp-分别对应的常见应用层协议有哪些" aria-hidden="true">#</a> 8.3、TCP 和 UDP 分别对应的常见应用层协议有哪些？</h3>
<ol>
<li>TCP 对应的应用层协议</li>
</ol>
<p>FTP：定义了文件传输协议，使用 21 端口。常说某某计算机开了 FTP 服务便是启动了文件传输服务。下载文件，上传主页，都要用到 FTP 服务。</p>
<p>Telnet：它是一种用于远程登陆的端口，用户可以以自己的身份远程连接到计算机上，通过这种端口可以提供一种基于 DOS 模式下的通信服务。如以前的 BBS 是-纯字符界面的，支持 BBS 的服务器将 23 端口打开，对外提供服务。</p>
<p>SMTP：定义了简单邮件传送协议，现在很多邮件服务器都用的是这个协议，用于发送邮件。如常见的免费邮件服务中用的就是这个邮件服务端口，所以在电子邮件设置-中常看到有这么 SMTP 端口设置这个栏，服务器开放的是 25 号端口。</p>
<p>POP3：它是和 SMTP 对应，POP3 用于接收邮件。通常情况下，POP3 协议所用的是 110 端口。也是说，只要你有相应的使用 POP3 协议的程序（例如 Fo-xmail 或 Outlook），就可以不以 Web 方式登陆进邮箱界面，直接用邮件程序就可以收到邮件（如是163 邮箱就没有必要先进入网易网站，再进入自己的邮-箱来收信）。</p>
<p>HTTP：从 Web 服务器传输超文本到本地浏览器的传送协议。</p>
<ol start="2">
<li>UDP 对应的应用层协议</li>
</ol>
<p>DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是 53 号端口。</p>
<p>SNMP：简单网络管理协议，使用 161 号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。</p>
<p>TFTP(Trival File Transfer Protocal)：简单文件传输协议，该协议在熟知端口 69 上使用 UDP 服务。</p>
<h3 id="_9、详细说下-tcp-三次握手的过程" tabindex="-1"><a class="header-anchor" href="#_9、详细说下-tcp-三次握手的过程" aria-hidden="true">#</a> 9、详细说下 TCP 三次握手的过程？</h3>
<ol>
<li>三次握手</li>
</ol>
<p>TCP 建立连接的过程叫做握手，握手需要在客户和服务器之间交换三个 TCP 报文段。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217174437173.png" alt="image-20211217174437173"></p>
<p>最初客户端和服务端都处于 CLOSED(关闭) 状态。本例中 A（Client） 主动打开连接，B（Server） 被动打开连接。</p>
<p>一开始，B 的 TCP 服务器进程首先创建传输控制块TCB，准备接受客户端进程的连接请求。然后服务端进程就处于 LISTEN(监听) 状态，等待客户端的连接请求。如有，立即作出响应。</p>
<p>第一次握手：A 的 TCP 客户端进程也是首先创建传输控制块 TCB。然后，在打算建立 TCP 连接时，向 B 发出连接请求报文段，这时首部中的同步位 SYN=1，同时选择一个初始序号 seq = x。TCP 规定，SYN 报文段（即 SYN = 1 的报文段）不能携带数据，但要消耗掉一个序号。这时，TCP 客户进程进入 SYN-SENT（同步已发送）状态。</p>
<p>第二次握手：B 收到连接请求报文后，如果同意建立连接，则向 A 发送确认。在确认报文段中应把 SYN 位和 ACK 位都置 1，确认号是 ack = x + 1，同时也为自己选择一个初始序号 seq = y。请注意，这个报文段也不能携带数据，但同样要消耗掉一个序号。这时 TCP 服务端进程进入 SYN-RCVD（同步收到）状态。</p>
<p>第三次握手：TCP 客户进程收到 B 的确认后，还要向 B 给出确认。确认报文段的 ACK 置 1，确认号 ack = y +  1，而自己的序号 seq = x + 1。这时 ACK 报文段可以携带数据。但如果不携带数据则不消耗序号，这种情况下，下一个数据报文段的序号仍是 seq = x + 1。这时，TCP 连接已经建立，A 进入 ESTABLISHED（已建立连接）状态。</p>
<p>TCP首部有6个标志比特。</p>
<p>SYN是其中之一，它是个同步序号，当TCP连接建立时会把SYN置1。</p>
<p>一般请求端会发送一个报文，其中包含这样的字段SYN 1415531521：1415531521(0)。</p>
<p>然后服务端收到后会返回一个ack 1415531522，ack表示确认收到。
SYN，ACK是标志位。</p>
<p>SEQ，AN是数据包序号。</p>
<p>SYN=1, ACK=0, SEQ=200 的意思是：发送的为一个SYN请求，发送端的初始数据包序号为200</p>
<p>SYN=1, ACK=1, SEQ=4800, AN=201 的意思是：接收端的确认信息，且接收端的初始数据包。序号为4800。</p>
<h3 id="_10、三次握手与四次挥手" tabindex="-1"><a class="header-anchor" href="#_10、三次握手与四次挥手" aria-hidden="true">#</a> 10、三次握手与四次挥手</h3>
<p>(1). 三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)：</p>
<p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。</p>
<p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。</p>
<p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217181508730.png" alt="image-20211217181508730"></p>
<p>(2). 四次挥手(我要和你断开链接；好的，断吧。我也要和你断开链接；好的，断吧)：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217181519476.png" alt="image-20211217181519476"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/774f5f51373635983fbf84da29e2dae3.png" alt="774f5f51373635983fbf84da29e2dae3.png"></p>
<p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>
<p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。</p>
<p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
<p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<p>另一个回答：</p>
<p>刚开始双方处于ESTABLISHED状态。</p>
<p>客户端要断开了，向服务器发送 FIN 报文，在 TCP 报文中的位置如下图:</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/0131ee7eaa5beea346068e7f73c1245a.png" alt="0131ee7eaa5beea346068e7f73c1245a.png"></p>
<p>发送后客户端变成了FIN-WAIT-1状态。注意, 这时候客户端同时也变成了half-close(半关闭)状态，即无法向服务端发送报文，只能接收。</p>
<p>服务端接收后向客户端确认，变成了CLOSED-WAIT状态。</p>
<p>客户端接收到了服务端的确认，变成了FIN-WAIT2状态。</p>
<p>随后，服务端向客户端发送FIN，自己进入LAST-ACK状态，</p>
<p>客户端收到服务端发来的FIN后，自己变成了TIME-WAIT状态，然后发送 ACK 给服务端。</p>
<p>注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。</p>
<h5 id="等待2msl的意义如果不等待会怎样" tabindex="-1"><a class="header-anchor" href="#等待2msl的意义如果不等待会怎样" aria-hidden="true">#</a> 等待2MSL的意义如果不等待会怎样？</h5>
<p>如果不等待，客户端直接跑路，当服务端还有很多数据包要给客户端发，且还在路上的时候，若客户端的端口此时刚好被新的应用占用，那么就接收到了无用数据包，造成数据包混乱。所以，最保险的做法是等服务器发来的数据包都死翘翘再启动新的应用。</p>
<h5 id="那-照这样说一个-msl-不就不够了吗-为什么要等待-2-msl" tabindex="-1"><a class="header-anchor" href="#那-照这样说一个-msl-不就不够了吗-为什么要等待-2-msl" aria-hidden="true">#</a> 那，照这样说一个 MSL 不就不够了吗，为什么要等待 2 MSL?</h5>
<p>1 个 MSL 确保四次挥手中主动关闭方最后的 ACK 报文最终能达到对端
1 个 MSL 确保对端没有收到 ACK 重传的 FIN 报文可以到达
这就是等待 2MSL 的意义。
————————————————</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>MSL是Maximum Segment Lifetime英文的缩写，中文可以译为“报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为tcp报文（segment）是ip数据报（datagram）的数据部分，具体称谓请参见《数据在网络各层中的称呼》一文，而ip头中有一个TTL域，TTL是time to live的缩写，中文可以译为“生存时间”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃，同时发送ICMP报文通知源主机。RFC 793中规定MSL为2分钟，实际应用中常用的是30秒，1分钟和2分钟等。

    2MSL即两倍的MSL，TCP的TIME_WAIT状态也称为2MSL等待状态，当TCP的一端发起主动关闭，在发出最后一个ACK包后，即第3次握手完成后发送了第四次握手的ACK包后就进入了TIME_WAIT状态，必须在此状态上停留两倍的MSL时间，等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次握手的FIN包，主动关闭端接到重发的FIN包后可以再发一个ACK应答包。在TIME_WAIT状态时两端的端口不能使用，要等到2MSL时间结束才可继续使用。当连接处于2MSL等待阶段时任何迟到的报文段都将被丢弃。不过在实际应用中可以通过设置SO_REUSEADDR选项达到不必等待2MSL时间结束再使用此端口。


    TTL与MSL是有关系的但不是简单的相等的关系，MSL要大于等于TTL。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="tcp端口状态说明established、time-wait" tabindex="-1"><a class="header-anchor" href="#tcp端口状态说明established、time-wait" aria-hidden="true">#</a> TCP端口状态说明ESTABLISHED、TIME_WAIT</h3>
<p>TCP状态转移要点
TCP协议规定，对于已经建立的连接，网络双方要进行四次握手才能成功断开连接，如果缺少了其中某个步骤，将会使连接处于假死状态，连接本身占用的资源不 会被释放。网络服务器程序要同时管理大量连接，所以很有必要保证无用连接完全断开，否则大量僵死的连接会浪费许多服务器资源。在众多TCP状态中，最值得 注意的状态有两个：CLOSE_WAIT和TIME_WAIT。</p>
<p>1、LISTENING状态
FTP服务启动后首先处于侦听（LISTENING）状态。</p>
<p>2、ESTABLISHED状态
ESTABLISHED的意思是<strong>建立连接。表示两台机器正在通信</strong>。</p>
<p>3、CLOSE_WAIT</p>
<p>对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭</p>
<p>4、TIME_WAIT</p>
<p><strong>我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT</strong>。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分 段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情 况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。</p>
<p>目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。</p>
<p>5、SYN_SENT状态</p>
<p>SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波 之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多 SYN_SENT的原因。</p>
<p>根据TCP协议定义的3次握手断开连接规定,发起socket主动关闭的一方 socket将进入TIME_WAIT状态,TIME_WAIT状态将持续2个MSL(Max Segment Lifetime),在Windows下默认为4分钟,即240秒,TIME_WAIT状态下的socket不能被回收使用. 具体现象是对于一个处理大量短连接的服务器,如果是由服务器主动关闭客户端的连接,将导致服务器端存在大量的处于TIME_WAIT状态的socket, 甚至比处于Established状态下的socket多的多,严重影响服务器的处理能力,甚至耗尽可用的socket,停止服务. TIME_WAIT是TCP协议用以保证被重新分配的socket不会受到之前残留的延迟重发报文影响的机制,是必要的逻辑保证.</p>
<p>windows 机器设置
在HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters,右键添加名为TcpTimedWaitDelay的
DWORD键,设置为60,以缩短TIME_WAIT的等待时间</p>
<p>ubuntu机器设置</p>
<p>vi /etc/sysctl.conf</p>
<p>编辑文件，加入以下内容：
<code v-pre>net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30</code></p>
<p>然后执行 <code v-pre>/sbin/sysctl -p</code> 让参数生效。</p>
<p><strong>net.ipv4.tcp_syncookies = 1</strong> 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；</p>
<p><strong>net.ipv4.tcp_tw_reuse = 1</strong> 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；</p>
<p><strong>net.ipv4.tcp_tw_recycle = 1</strong> 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。</p>
<p><strong>net.ipv4.tcp_fin_timeout</strong> 修改系統默认的 TIMEOUT 时间</p>
<p>查看系统TCP连接资源命令</p>
<p><strong>netstat</strong></p>
<p><strong>netstat -n | awk '/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}'</strong></p>
<p>一般情况下，系统的socket资源默认5000个。（非官方）</p>
<p>TCP协议中有TIME_WAIT这个状态
<strong>主要有两个原因</strong>
1。防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）
2。可靠的关闭TCP连接。在主动关闭方发送的最后一个 ack(fin) ，有可能丢失，这时被动方会重新发
fin, 如果这时主动方处于 CLOSED 状态 ，就会响应 rst 而不是 ack。所以主动方要处于 TIME_WAIT 状态，而不能是 CLOSED 。</p>
<h3 id="_10-2、为什么两次握手不可以呢" tabindex="-1"><a class="header-anchor" href="#_10-2、为什么两次握手不可以呢" aria-hidden="true">#</a> 10.2、为什么两次握手不可以呢？</h3>
<p>为了防止 已失效的链接请求报文突然又传送到了服务端，因而产生错误。</p>
<p>客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。</p>
<p>另一种回答：</p>
<p>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。</p>
<h3 id="_11-1、为什么不需要四次握手" tabindex="-1"><a class="header-anchor" href="#_11-1、为什么不需要四次握手" aria-hidden="true">#</a> 11.1、为什么不需要四次握手？</h3>
<p>有人可能会说 A 发出第三次握手的信息后在没有接收到 B 的请求就已经进入了连接状态，那如果 A 的这个确认包丢失或者滞留了怎么办？</p>
<p>我们需要明白一点，完全可靠的通信协议是不存在的。在经过三次握手之后，客户端和服务端已经可以确认之前的通信状况，都收到了确认信息。所以即便再增加握手次数也不能保证后面的通信完全可靠，所以是没有必要的。</p>
<h3 id="_11-2-为什么断开连接需要四次" tabindex="-1"><a class="header-anchor" href="#_11-2-为什么断开连接需要四次" aria-hidden="true">#</a> 11.2.为什么断开连接需要四次</h3>
<p>根据状态流程图，我们可以看出服务端响应断开连接的请求时，其ACK和FIN包并不是一起发送给客户端的，因为第一次由客户端-&gt;服务端的FIN信号表示的是客户端想要断开连接。服务端先给出ACK确认信号，表示已经收到FIN请求，然后当自己也可以结束的时候，再次发送FIN信号，所以需要挥手交互需要四次。</p>
<h3 id="_11-3-四次挥手主动方为什么需要等待2msl" tabindex="-1"><a class="header-anchor" href="#_11-3-四次挥手主动方为什么需要等待2msl" aria-hidden="true">#</a> 11.3.四次挥手主动方为什么需要等待2MSL</h3>
<p>主动关闭方在收到被动一方发出的FIN信号，会立马发送ACK确认信号，之后状态转变为TIME_WAIT，等待2MSL后才会进入CLOSE状态。</p>
<p><strong>MSL</strong>表示最大报文生存周期，任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。主动关闭方需要等待2MSL是为了，防止最后一次ACK没有被正确的传给被动方，被动关闭方会再次发送第三次的FIN信号。</p>
<h3 id="_12、server-端收到-client-端的-syn-后-为什么还要传回-syn" tabindex="-1"><a class="header-anchor" href="#_12、server-端收到-client-端的-syn-后-为什么还要传回-syn" aria-hidden="true">#</a> 12、Server 端收到 Client 端的 SYN 后，为什么还要传回 SYN？</h3>
<p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p>
<p>SYN 是 TCP / IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符，在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误]）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
<h3 id="_13、传了-syn-为什么还要传-ack" tabindex="-1"><a class="header-anchor" href="#_13、传了-syn-为什么还要传-ack" aria-hidden="true">#</a> 13、传了 SYN，为什么还要传 ACK？</h3>
<p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p>
<h3 id="_14、详细说下-tcp-四次挥手的过程" tabindex="-1"><a class="header-anchor" href="#_14、详细说下-tcp-四次挥手的过程" aria-hidden="true">#</a> 14、详细说下 TCP 四次挥手的过程？</h3>
<p>据传输结束后，通信的双方都可以释放连接。现在 A 和 B 都处于 ESTABLISHED 状态。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217174451472.png" alt="image-20211217174451472"></p>
<p>第一次挥手：A 的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭 TCP 连接。A 把连接释放报文段首部的终止控制位 FIN 置 1，其序号 seq = u（等于前面已传送过的数据的最后一个字节的序号加 1），这时 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。请注意：TCP 规定，FIN 报文段即使不携带数据，也将消耗掉一个序号。</p>
<p>第二次挥手：B 收到连接释放报文段后立即发出确认，确认号是 ack = u + 1，而这个报文段自己的序号是 v（等于 B 前面已经传送过的数据的最后一个字节的序号加1），然后 B 就进入 CLOSE-WAIT（关闭等待）状态。TCP 服务端进程这时应通知高层应用进程，因而从 A 到 B 这个方向的连接就释放了，这时的 TCP 连接处于半关闭（half-close）状态，即 A 已经没有数据要发送了，但 B 若发送数据，A 仍要接收。也就是说，从 B 到 A 这个方向的连接并未关闭，这个状态可能会持续一段时间。A 收到来自 B 的确认后，就进入 FIN-WAIT-2(终止等待2)状态，等待 B 发出的连接释放报文段。</p>
<p>第三次挥手：若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。这时 B 发出的连接释放报文段必须使 FIN = 1。假定 B 的序号为 w（在半关闭状态，B 可能又发送了一些数据）。B 还必须重复上次已发送过的确认号 ack = u + 1。这时 B 就进入 LAST-ACK(最后确认)状态，等待 A 的确认。</p>
<p>第四次挥手：A 在收到 B 的连接释放报文后，必须对此发出确认。在确认报文段中把 ACK 置 1，确认号 ack = w + 1，而自己的序号 seq = u + 1（前面发送的 FIN 报文段要消耗一个序号）。然后进入 TIME-WAIT(时间等待) 状态。请注意，现在 TCP 连接还没有释放掉。必须经过时间等待计时器设置的时间 2MSL（MSL：最长报文段寿命）后，A 才能进入到 CLOSED 状态，然后撤销传输控制块，结束这次 TCP 连接。当然如果 B 一收到 A 的确认就进入 CLOSED 状态，然后撤销传输控制块。所以在释放连接时，B 结束 TCP 连接的时间要早于 A。</p>
<h3 id="_15、为什么-time-wait-状态必须等待-2msl-的时间呢" tabindex="-1"><a class="header-anchor" href="#_15、为什么-time-wait-状态必须等待-2msl-的时间呢" aria-hidden="true">#</a> 15、为什么 TIME-WAIT 状态必须等待 2MSL 的时间呢？</h3>
<ol>
<li>
<p>为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内（超时 + 1MSL 传输）收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN + ACK 报文段，因而也不会再发送一次确认报文段，这样，B 就无法按照正常步骤进入 CLOSED 状态。</p>
</li>
<li>
<p>防止已失效的连接请求报文段出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。</p>
</li>
</ol>
<h3 id="_16、为什么第二次跟第三次不能合并-第二次和第三次之间的等待是什么" tabindex="-1"><a class="header-anchor" href="#_16、为什么第二次跟第三次不能合并-第二次和第三次之间的等待是什么" aria-hidden="true">#</a> 16、为什么第二次跟第三次不能合并, 第二次和第三次之间的等待是什么?</h3>
<p>当服务器执行第二次挥手之后, 此时证明客户端不会再向服务端请求任何数据, 但是服务端可能还正在给客户端发送数据（可能是客户端上一次请求的资源还没有发送完毕），所以此时服务端会等待把之前未传输完的数据传输完毕之后再发送关闭请求。</p>
<h3 id="_17-三次握手过程中可以携带数据么" tabindex="-1"><a class="header-anchor" href="#_17-三次握手过程中可以携带数据么" aria-hidden="true">#</a> 17.三次握手过程中可以携带数据么？</h3>
<p>第三次握手的时候，可以携带。前两次握手不能携带数据。</p>
<p>如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。</p>
<p>第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。
————————————————</p>
<h3 id="_18-同时打开会怎样" tabindex="-1"><a class="header-anchor" href="#_18-同时打开会怎样" aria-hidden="true">#</a> 18.同时打开会怎样？</h3>
<p>如果双方同时发 SYN报文，状态变化会是怎样的呢？</p>
<p>这是一个可能会发生的情况。</p>
<p>状态变迁如下:</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/db8390602f096753aa946ec218d5d422.png" alt="db8390602f096753aa946ec218d5d422.png"></p>
<p>在发送方给接收方发SYN报文的同时，接收方也给发送方发SYN报文，两个人刚上了!</p>
<p>发完SYN，两者的状态都变为SYN-SENT。</p>
<p>在各自收到对方的SYN后，两者状态都变为SYN-REVD。</p>
<p>接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。</p>
<p>这就是同时打开情况下的状态变迁。
————————————————</p>
<h3 id="_19-tcp协议如何来保证传输的可靠性" tabindex="-1"><a class="header-anchor" href="#_19-tcp协议如何来保证传输的可靠性" aria-hidden="true">#</a> 19.TCP协议如何来保证传输的可靠性</h3>
<p>TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。
（1）对于可靠性，TCP通过以下方式进行保证：</p>
<p>​		数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时TCP发送数据端超时后会重发数据；
​		对失序数据包重排序：既然TCP报文段作为IP数据报来传输，而IP数据报的到达可能会失序，因此TCP报文段的到达也可能会失序。TCP将对失序数据进行重新排序，然后才交给应用层；
​		丢弃重复数据：对于重复数据，能够丢弃重复数据；
​		应答机制：当TCP收到发自TCP连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；
​		超时重发：当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；
​		流量控制：TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP使用的流量控制协议是可变大小的滑动窗口协议。
（2）滑动窗口
位于传输层的TCP协议是面向连接的，可靠的传输协议，拥有着确认机制。理论上，每发一个数据包都会收到其对应的确认包，然后才可以继续发送数据。
在三次握手阶段，双方互相将自己的最大可接收的数据量告诉对方，也就是自己的数据接收缓冲池的大小。这样对方可以根据已发送的数据量来计算是否可以接着发送。在处理过程中，当接收缓冲池的大小发生变化时，要给对方发送更新窗口大小的通知，利用滑动窗口机制有效提高通信效率。
（3）TCP与UDP的区别
TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议属于传输层协议，它们之间的区别包括：
TCP是面向连接的，UDP是无连接的；
TCP是可靠的，UDP是不可靠的；
TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；
TCP是面向字节流的，UDP是面向报文的；
TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信；
TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大；
————————————————
<img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217181305690.png" alt="image-20211217181305690"></p>
<p>（4）TCP的拥塞处理
计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：</p>
<ul>
<li><strong>慢启动</strong>：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</li>
<li><strong>拥塞避免</strong>：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</li>
</ul>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217181337240.png" alt="image-20211217181337240"></p>
<ul>
<li><strong>快重传</strong>：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
</ul>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217181403680.png" alt="image-20211217181403680"></p>
<ul>
<li>快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</li>
</ul>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217181434776.png" alt="image-20211217181434776"></p>
<h3 id="_17、保活计时器的作用" tabindex="-1"><a class="header-anchor" href="#_17、保活计时器的作用" aria-hidden="true">#</a> 17、保活计时器的作用？</h3>
<p>除时间等待计时器外，TCP 还有一个保活计时器（keepalive  timer）。设想这样的场景：客户已主动与服务器建立了 TCP 连接。但后来客户端的主机突然发生故障。显然，服务器以后就不能再收到客户端发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就需要使用保活计时器了。</p>
<p>服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两个小时。若两个小时都没有收到客户端的数据，服务端就发送一个探测报文段，以后则每隔  75 秒钟发送一次。若连续发送 10个 探测报文段后仍然无客户端的响应，服务端就认为客户端出了故障，接着就关闭这个连接。</p>
<h3 id="_18、tcp-协议是如何保证可靠传输的" tabindex="-1"><a class="header-anchor" href="#_18、tcp-协议是如何保证可靠传输的" aria-hidden="true">#</a> 18、TCP 协议是如何保证可靠传输的？</h3>
<p>TCP提供一种面向连接的、可靠的字节流服务。其中，面向连接意味着两个使用TCP的应用（通常是一个客户和一个服务器）在彼此交换数据之前必须先建立一个TCP连接。在一个TCP连接中，仅有两方进行彼此通信；而字节流服务意味着两个应用程序通过TCP链接交换8bit字节构成的字节流，TCP不在字节流中插入记录标识符。</p>
<p>对于可靠性，TCP通过以下方式进行保证：</p>
<ol>
<li>
<p>数据包校验：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不给出响应，这时 TCP 发送数据端超时后会重发数据；</p>
</li>
<li>
<p>对失序数据包重排序：既然 TCP 报文段作为 IP 数据报来传输，而 IP 数据报的到达可能会失序，因此 TCP 报文段的到达也可能会失序。TCP 将对失序数据进行重新排序，然后才交给应用层；</p>
</li>
<li>
<p>丢弃重复数据：对于重复数据，能够丢弃重复数据；</p>
</li>
<li>
<p>应答机制：当 TCP 收到发自 TCP 连接另一端的数据，它将发送一个确认。这个确认不是立即发送，通常将推迟几分之一秒；</p>
</li>
<li>
<p>超时重发：当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段；</p>
</li>
<li>
<p>流量控制：TCP 连接的每一方都有固定大小的缓冲空间。TCP 的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这就是流量控制。TCP 使用的流量控制协议是可变大小的滑动窗口协议。</p>
</li>
</ol>
<h3 id="_19、谈谈你对停止等待协议的理解" tabindex="-1"><a class="header-anchor" href="#_19、谈谈你对停止等待协议的理解" aria-hidden="true">#</a> 19、谈谈你对停止等待协议的理解？</h3>
<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组；在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。主要包括以下几种情况：无差错情况、出现差错情况（超时重传）、确认丢失和确认迟到、确认丢失和确认迟到。</p>
<h3 id="_20、谈谈你对-arq-协议的理解" tabindex="-1"><a class="header-anchor" href="#_20、谈谈你对-arq-协议的理解" aria-hidden="true">#</a> 20、谈谈你对 ARQ 协议的理解？</h3>
<p><strong>自动重传请求 ARQ 协议</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。</p>
<p><strong>连续 ARQ 协议</strong></p>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<h3 id="_21、谈谈你对滑动窗口的了解" tabindex="-1"><a class="header-anchor" href="#_21、谈谈你对滑动窗口的了解" aria-hidden="true">#</a> 21、谈谈你对滑动窗口的了解？</h3>
<p>TCP 利用滑动窗口实现流量控制的机制。滑动窗口（Sliding window）是一种流量控制技术。早期的网络通信中，通信双方不会考虑网络的拥挤情况直接发送数据。由于大家不知道网络拥塞状况，同时发送数据，导致中间节点阻塞掉包，谁也发不了数据，所以就有了滑动窗口机制来解决此问题。</p>
<p>TCP 中采用滑动窗口来进行传输控制，滑动窗口的大小意味着接收方还有多大的缓冲区可以用于接收数据。发送方可以通过滑动窗口的大小来确定应该发送多少字节的数据。当滑动窗口为 0 时，发送方一般不能再发送数据报，但有两种情况除外，一种情况是可以发送紧急数据，例如，允许用户终止在远端机上的运行进程。另一种情况是发送方可以发送一个 1 字节的数据报来通知接收方重新声明它希望接收的下一字节及发送方的滑动窗口大小。</p>
<h3 id="_22、谈下你对流量控制的理解" tabindex="-1"><a class="header-anchor" href="#_22、谈下你对流量控制的理解" aria-hidden="true">#</a> 22、谈下你对流量控制的理解？</h3>
<p>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="_23、谈下你对-tcp-拥塞控制的理解-使用了哪些算法" tabindex="-1"><a class="header-anchor" href="#_23、谈下你对-tcp-拥塞控制的理解-使用了哪些算法" aria-hidden="true">#</a> 23、谈下你对 TCP 拥塞控制的理解？使用了哪些算法？</h3>
<p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p>
<p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p>为了进行拥塞控制，TCP 发送方要维持一个拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即：慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如：主动队列管理 AQM），以减少网络拥塞的发生。</p>
<p>慢开始：</p>
<p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</p>
<p>拥塞避免：</p>
<p>拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1。</p>
<p>快重传与快恢复：</p>
<p>在 TCP/IP 中，快速重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。</p>
<p>没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。</p>
<p>有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和快恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p>
<h3 id="_23-2、tcp的拥塞处理" tabindex="-1"><a class="header-anchor" href="#_23-2、tcp的拥塞处理" aria-hidden="true">#</a> 23.2、TCP的拥塞处理</h3>
<p>计算机网络中的带宽、交换结点中的缓存及处理机等都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。拥塞控制就是 防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。注意，拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。拥塞控制的方法主要有以下四种：</p>
<p>1). 慢启动：不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小;</p>
<p>2). 拥塞避免：拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍，这样拥塞窗口按线性规律缓慢增长。</p>
<p>3). 快重传：快重传要求接收方在收到一个 失序的报文段 后就立即发出 重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
<p>4). 快恢复：快重传配合使用的还有快恢复算法，当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半，但是接下去并不执行慢开始算法：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。</p>
<h3 id="_24、什么是粘包" tabindex="-1"><a class="header-anchor" href="#_24、什么是粘包" aria-hidden="true">#</a> 24、什么是粘包？</h3>
<p>在进行 Java NIO 学习时，可能会发现：如果客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况。</p>
<ol>
<li>
<p>TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界；</p>
</li>
<li>
<p>从 TCP 的帧结构也可以看出，在 TCP 的首部没有表示数据长度的字段。</p>
</li>
</ol>
<p>基于上面两点，在使用 TCP 传输数据时，才有粘包或者拆包现象发生的可能。一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。</p>
<p>接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。拆包和粘包的问题导致接收端在处理的时候会非常困难，因为无法区分一个完整的数据包。</p>
<h3 id="_25、tcp-黏包是怎么产生的" tabindex="-1"><a class="header-anchor" href="#_25、tcp-黏包是怎么产生的" aria-hidden="true">#</a> 25、TCP 黏包是怎么产生的？</h3>
<p>发送方产生粘包</p>
<p>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 Nagle 算法，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</p>
<p>接收方产生粘包</p>
<p>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（C 语言用 recv、read 等函数）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）</p>
<h3 id="_26、怎么解决拆包和粘包" tabindex="-1"><a class="header-anchor" href="#_26、怎么解决拆包和粘包" aria-hidden="true">#</a> 26、怎么解决拆包和粘包？</h3>
<p>分包机制一般有两个通用的解决方法：</p>
<ol>
<li>
<p>特殊字符控制；</p>
</li>
<li>
<p>在包头首都添加数据包的长度。</p>
</li>
</ol>
<p>如果使用 netty 的话，就有专门的编码器和解码器解决拆包和粘包问题了。</p>
<p>tips：UDP 没有粘包问题，但是有丢包和乱序。不完整的包是不会有的，收到的都是完全正确的包。传送的数据单位协议是 UDP 报文或用户数据报，发送的时候既不合并，也不拆分。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211221135914360.png" alt="image-20211221135914360"></p>
<h3 id="_29、java中forward-和-redirect-的区别" tabindex="-1"><a class="header-anchor" href="#_29、java中forward-和-redirect-的区别" aria-hidden="true">#</a> 29、java中forward 和 redirect 的区别？</h3>
<p>Forward 和 Redirect 代表了两种请求转发方式：直接转发和间接转发。</p>
<p>直接转发方式（Forward）：客户端和浏览器只发出一次请求，Servlet、HTML、JSP 或其它信息资源，由第二个信息资源响应该请求，在请求对象 request 中，保存的对象对于每个信息资源是共享的。</p>
<p>间接转发方式（Redirect）：实际是两次 HTTP 请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个 URL 发出请求，从而达到转发的目的。</p>
<p>举个通俗的例子：</p>
<p>直接转发就相当于：“A 找 B 借钱，B 说没有，B 去找 C 借，借到借不到都会把消息传递给 A”；</p>
<p>间接转发就相当于：&quot;A 找 B 借钱，B 说没有，让 A 去找 C 借&quot;。</p>
<h3 id="_43、ip地址与物理地址" tabindex="-1"><a class="header-anchor" href="#_43、ip地址与物理地址" aria-hidden="true">#</a> 43、IP地址与物理地址</h3>
<p>物理地址是数据链路层和物理层使用的地址，IP地址是网络层和以上各层使用的地址，是一种逻辑地址，其中ARP协议用于IP地址与物理地址的对应。</p>
<h3 id="_46、客户端不断进行请求链接会怎样-ddos-distributed-denial-of-service-攻击" tabindex="-1"><a class="header-anchor" href="#_46、客户端不断进行请求链接会怎样-ddos-distributed-denial-of-service-攻击" aria-hidden="true">#</a> 46、客户端不断进行请求链接会怎样？DDos(Distributed Denial of Service)攻击？</h3>
<p>服务器端会为每个请求创建一个链接，并向其发送确认报文，然后等待客户端进行确认</p>
<p>1)、DDos 攻击</p>
<p>客户端向服务端发送请求链接数据包
服务端向客户端发送确认数据包
客户端不向服务端发送确认数据包，服务器一直等待来自客户端的确认
2)、DDos 预防 ( 没有彻底根治的办法，除非不使用TCP )</p>
<p>限制同时打开SYN半链接的数目
缩短SYN半链接的Time out 时间
关闭不必要的服务</p>
<p>分布式拒绝服务（DDoS）攻击是通过大规模互联网流量淹没目标服务器或其周边基础设施，以破坏目标服务器、服务或网络正常流量的恶意行为。</p>
<p>DDoS 攻击利用多台受损计算机系统作为攻击流量来源以达到攻击效果。利用的机器可以包括计算机，也可以包括其他联网资源（如 <a href="https://www.cloudflare.com/learning/ddos/glossary/internet-of-things-iot/" target="_blank" rel="noopener noreferrer">IoT 设备<ExternalLinkIcon/></a>）。</p>
<p>总体而言，DDoS 攻击好比高速公路发生交通堵塞，妨碍常规车辆抵达预定目的地。</p>
<h6 id="ddos-攻击的工作原理" tabindex="-1"><a class="header-anchor" href="#ddos-攻击的工作原理" aria-hidden="true">#</a> DDoS 攻击的工作原理</h6>
<p>DDoS 攻击是通过连接互联网的计算机网络进行的。</p>
<p>这些网络由计算机和其他设备（例如 IoT 设备）组成，它们感染了<a href="https://www.cloudflare.com/learning/ddos/glossary/malware/" target="_blank" rel="noopener noreferrer">恶意软件<ExternalLinkIcon/></a>，从而被攻击者远程控制。这些个体设备称为<a href="https://www.cloudflare.com/learning/bots/what-is-a-bot/" target="_blank" rel="noopener noreferrer">机器人<ExternalLinkIcon/></a>（或僵尸），一组机器人则称为<a href="https://www.cloudflare.com/learning/ddos/what-is-a-ddos-botnet/" target="_blank" rel="noopener noreferrer">僵尸网络<ExternalLinkIcon/></a>。</p>
<p>一旦建立了僵尸网络，攻击者就可通过向每个机器人发送远程指令来发动攻击。</p>
<p>当僵尸网络将受害者的服务器或网络作为目标时，每个机器人会将请求发送到目标的 <a href="https://www.cloudflare.com/learning/dns/glossary/what-is-my-ip-address/" target="_blank" rel="noopener noreferrer">IP 地址<ExternalLinkIcon/></a>，这可能导致服务器或网络不堪重负，从而造成对正常流量的<a href="https://www.cloudflare.com/learning/ddos/glossary/denial-of-service/" target="_blank" rel="noopener noreferrer">拒绝服务<ExternalLinkIcon/></a>。</p>
<p>由于每个机器人都是合法的互联网设备，因而可能很难区分攻击流量与正常流量。</p>
<h6 id="如何识别-ddos-攻击" tabindex="-1"><a class="header-anchor" href="#如何识别-ddos-攻击" aria-hidden="true">#</a> 如何识别 DDoS 攻击</h6>
<p>DDoS 攻击最明显的症状是网站或服务突然变慢或不可用。但是，造成类似性能问题的原因有多种（如合法流量激增），因此通常需要进一步调查。流量分析工具可以帮助您发现 DDoS 攻击的一些明显迹象：</p>
<ul>
<li>来自单个 IP 地址或 IP 范围的可疑流量</li>
<li>来自共享单个行为特征（例如设备类型、地理位置或 Web 浏览器版本）的用户的大量流量</li>
<li>对单个页面或端点的请求数量出现不明原因的激增</li>
<li>奇怪的流量模式，例如一天中非常规时间段的激增或看似不自然的模式（例如，每 10 分钟出现一次激增）</li>
</ul>
<p>DDoS 攻击还有其他更具体的迹象，具体取决于攻击的类型。</p>
<h6 id="常见的-ddos-攻击有哪几类" tabindex="-1"><a class="header-anchor" href="#常见的-ddos-攻击有哪几类" aria-hidden="true">#</a> 常见的 DDoS 攻击有哪几类？</h6>
<p>不同类型的 DDoS 攻击针对不同的网络连接组件。为了解不同的 DDoS 攻击如何运作，有必要知道网络连接是如何建立的。</p>
<p>互联网上的网络连接由许多不同的组件或“层”构成。就像打地基盖房子一样，模型中的每一步都有不同的用途。</p>
<p><a href="https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/" target="_blank" rel="noopener noreferrer">OSI 模型<ExternalLinkIcon/></a>（如下图所示）是一个概念框架，用于描述 7 个不同层级的网络连接。</p>
<p><img src="https://cloudflare.com/img/learning/ddos/what-is-a-ddos-attack/osi-model-7-layers.svg" alt="OSI 模型"></p>
<p>虽然几乎所有 DDoS 攻击都涉及用流量淹没目标设备或网络，但攻击可以分为三类。攻击者可能利用一种或多种不同的攻击手段，也可能根据目标采取的防范措施循环使用多种攻击手段。</p>
<h3 id="_49-整个网络体系图" tabindex="-1"><a class="header-anchor" href="#_49-整个网络体系图" aria-hidden="true">#</a> 49.整个网络体系图？</h3>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217180238844.png" alt="image-20211217180238844"></p>
<h3 id="_57-线程进程预防死锁的机制原理" tabindex="-1"><a class="header-anchor" href="#_57-线程进程预防死锁的机制原理" aria-hidden="true">#</a> 57.线程进程预防死锁的机制原理</h3>
<h3 id="_58-为什么现在的网络最后采用了tcp-ip参考模型而没用osi参考模型" tabindex="-1"><a class="header-anchor" href="#_58-为什么现在的网络最后采用了tcp-ip参考模型而没用osi参考模型" aria-hidden="true">#</a> 58.为什么现在的网络最后采用了TCP/IP参考模型而没用OSI参考模型？</h3>
<h3 id="_59-请说一下http请示的基本过程-ibm" tabindex="-1"><a class="header-anchor" href="#_59-请说一下http请示的基本过程-ibm" aria-hidden="true">#</a> 59.请说一下HTTP请示的基本过程（IBM）</h3>
<p>TCP/IP 建立连接的过程?(3-way shake)
答：在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。
　　第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；
　　第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<h3 id="_60-icmp是什么协议-处于哪一层" tabindex="-1"><a class="header-anchor" href="#_60-icmp是什么协议-处于哪一层" aria-hidden="true">#</a> 60.ICMP是什么协议,处于哪一层?</h3>
<p>答：Internet控制报文协议，处于网络层（IP层）</p>
<h3 id="_63、tcp协议中的数据包分片与重组功能有了解吗" tabindex="-1"><a class="header-anchor" href="#_63、tcp协议中的数据包分片与重组功能有了解吗" aria-hidden="true">#</a> 63、TCP协议中的数据包分片与重组功能有了解吗？</h3>
<p>当TCP传输的数据包比较大时，在发送方会进行分片，在接收方进行数据包的重组。
发送方：
将数据包分为多个TCP头部+数据包的组合，TCP头部中存着不同的数据序号；之后将多个组合交由IP模块，统一添加IP头部和MAC头部，IP头部的ID号设为统一的。
接收方：
IP模块具有分片重组的功能，如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包。分片的包会在IP头部的标志字段中进行标记，当收到分片的包时，IP模块会将其暂时存在内部的内存空间中，然后等待IP头部中具有相同ID的包全部到达，因为同一个包的所有分片都具有相同的ID。此外，IP头部还有一个分片偏移量的字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有的分片全部收到之后，就可以将它们还原成原始的包。
<img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217181818734.png" alt="image-20211217181818734"></p>
<h3 id="_64-谈下你对五层网络协议体系结构的理解" tabindex="-1"><a class="header-anchor" href="#_64-谈下你对五层网络协议体系结构的理解" aria-hidden="true">#</a> 64.<strong>谈下你对五层网络协议体系结构的理解？</strong></h3>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217181921254.png" alt=""></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217181932398.png" alt="image-20211217181932398"></p>
<h3 id="_65-osi-tcp-ip-五层协议的体系结构" tabindex="-1"><a class="header-anchor" href="#_65-osi-tcp-ip-五层协议的体系结构" aria-hidden="true">#</a> 65.OSI ， TCP/IP ，五层协议的体系结构</h3>
<p>OSI分层（7层） ：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>TCP/IP分层（4层） ：网络接口层、网际层、运输层、应用层。</p>
<p>五层协议（5层） ：物理层、数据链路层、网络层、运输层、应用层。</p>
<p>每一层的作用如下 ：</p>
<p>物理层：激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的物理媒体。
数据链路层 ：数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p>
<p>网络层 ：网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。</p>
<p>传输层 ：第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。</p>
<p>会话层 ：会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。</p>
<p>表示层 ：表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</p>
<p>应用层 ：为操作系统或网络应用程序提供访问网络服务的接口。</p>
<h3 id="_67-路由设备与相关层" tabindex="-1"><a class="header-anchor" href="#_67-路由设备与相关层" aria-hidden="true">#</a> 67.路由设备与相关层</h3>
<p>物理层 ：中继器（Repeater，也叫放大器），集线器。</p>
<p>数据链路层 ：网桥，交换机。</p>
<p>网络层 ：路由器。</p>
<p>网关 ：网络层以上的设备。</p>
<h3 id="_68-常见的路由选择协议-以及它们的区别" tabindex="-1"><a class="header-anchor" href="#_68-常见的路由选择协议-以及它们的区别" aria-hidden="true">#</a> 68.常见的路由选择协议，以及它们的区别</h3>
<p>常见的路由选择协议有：RIP协议、OSPF协议。</p>
<p>RIP协议 ：底层是贝尔曼福特算法，它选择路由的度量标准（metric)是跳数，最大跳数是15跳，如果大于15跳，它就会丢弃数据包。</p>
<p>OSPF协议 ：底层是迪杰斯特拉算法，是链路状态路由选择协议，它选择路由的度量标准是带宽，延迟。</p>
<h3 id="_69-tcp-的可靠性如何保证" tabindex="-1"><a class="header-anchor" href="#_69-tcp-的可靠性如何保证" aria-hidden="true">#</a> 69.TCP 的可靠性如何保证？</h3>
<p>TCP的可靠性是通过顺序编号和确认（ACK）来实现的。</p>
<h3 id="_71-特殊的ip地址" tabindex="-1"><a class="header-anchor" href="#_71-特殊的ip地址" aria-hidden="true">#</a> 71.特殊的IP地址</h3>
<p>（1）网络地址</p>
<p>IP地址由网络号（包括子网号）和主机号组成，网络地址的主机号为全0，网络地址代表着整个网络。</p>
<p>（2）广播地址</p>
<p>广播地址通常称为直接广播地址，是为了区分受限广播地址。</p>
<p>广播地址与网络地址的主机号正好相反，广播地址中，主机号为全1。当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。</p>
<p>（3）组播地址</p>
<p>D类地址就是组播地址。</p>
<p>先回忆下A，B，C，D类地址吧</p>
<p>A类地址以00开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；</p>
<p>B类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;</p>
<p>C类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。</p>
<p>D类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；</p>
<p>E类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。</p>
<p>Notice：只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。</p>
<p>（4）255.255.255.255</p>
<p>该IP地址指的是受限的广播地址。受限广播地址与一般广播地址（直接广播地址）的区别在于，受限广播地址之只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。例如：主机192.168.1.1/30上的直接广播数据包后，另外一个网段192.168.1.5/30也能收到该数据报；若发送受限广播数据报，则不能收到。</p>
<p>Notice：一般的广播地址（直接广播地址）能够通过某些路由器（当然不是所有的路由器），而受限的广播地址不能通过路由器。</p>
<p>（5）0.0.0.0</p>
<p>常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。</p>
<p>（6）回环地址</p>
<p>127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。</p>
<p>（7）A、B、C类私有地址</p>
<p>私有地址(private address)也叫专用地址，它们不会在全球使用，只具有本地意义。</p>
<p>A类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255</p>
<p>B类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255</p>
<p>C类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255</p>
<h3 id="_72-nat-协议、-dhcp-协议、-dns-协议的作用" tabindex="-1"><a class="header-anchor" href="#_72-nat-协议、-dhcp-协议、-dns-协议的作用" aria-hidden="true">#</a> 72.NAT 协议、 DHCP 协议、 DNS 协议的作用</h3>
<p>NAT协议 ：网络地址转换(NAT,Network AddressTranslation)属接入广域网(WAN)技术，</p>
<p>是一种将私有（保留）地址转化为合法IP地址的转换技术，它被广泛应用于各种类型Internet接入方式和各种类型的网络中。原因很简单，NAT不仅完美地解决了lP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。</p>
<p>DHCP协议 ：动态主机设置协议（Dynamic Host ConfigurationProtocol, DHCP）</p>
<p>是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<p>DNS协议 ：DNS 是域名系统 (Domain Name System) 的缩写，是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串
————————————————</p>
<h3 id="_3-websocket如何建立连接的-升级请求包含哪些内容" tabindex="-1"><a class="header-anchor" href="#_3-websocket如何建立连接的-升级请求包含哪些内容" aria-hidden="true">#</a> 3 websocket如何建立连接的，升级请求包含哪些内容</h3>
<h3 id="_10-rpc-http-www-360doc-com-content-20-0427-13-64728681-908688723-shtml" tabindex="-1"><a class="header-anchor" href="#_10-rpc-http-www-360doc-com-content-20-0427-13-64728681-908688723-shtml" aria-hidden="true">#</a> 10.RPC. http://www.360doc.com/content/20/0427/13/64728681_908688723.shtml</h3>
<h1 id="三-http协议面试题" tabindex="-1"><a class="header-anchor" href="#三-http协议面试题" aria-hidden="true">#</a> 三.http协议面试题</h1>
<h3 id="_1、你对-http-状态码有了解吗" tabindex="-1"><a class="header-anchor" href="#_1、你对-http-状态码有了解吗" aria-hidden="true">#</a> 1、你对 HTTP 状态码有了解吗？</h3>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217174602116.png" alt="image-20211217174602116"></p>
<p>1XX 信息</p>
<ol>
<li>100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li>
</ol>
<p>2XX 成功</p>
<ol>
<li>
<p>200 OK</p>
</li>
<li>
<p>204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</p>
</li>
<li>
<p>206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</p>
</li>
</ol>
<p>3XX 重定向</p>
<ol>
<li>
<p>301 Moved Permanently ：永久性重定向；</p>
</li>
<li>
<p>302 Found ：临时性重定向；</p>
</li>
<li>
<p>303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</p>
</li>
<li>
<p>304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</p>
</li>
<li>
<p>307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</p>
</li>
</ol>
<p>4XX 客户端错误</p>
<ol>
<li>
<p>400 Bad Request ：请求报文中存在语法错误。</p>
</li>
<li>
<p>401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</p>
</li>
<li>
<p>403 Forbidden ：请求被拒绝。</p>
</li>
<li>
<p>404 Not Found</p>
</li>
</ol>
<p>5XX 服务器错误</p>
<ol>
<li>
<p>500 Internal Server Error ：服务器正在执行请求时发生错误；</p>
</li>
<li>
<p>503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</p>
</li>
</ol>
<h3 id="_2、http-协议包括哪些请求" tabindex="-1"><a class="header-anchor" href="#_2、http-协议包括哪些请求" aria-hidden="true">#</a> 2、HTTP 协议包括哪些请求？</h3>
<p>GET：请求读取由URL所标志的信息。</p>
<p>POST：给服务器添加信息（如注释）。</p>
<p>PUT：在给定的URL下存储一个文档。</p>
<p>DELETE：删除给定的URL所标志的资源。</p>
<h3 id="_3、http-方法有哪些" tabindex="-1"><a class="header-anchor" href="#_3、http-方法有哪些" aria-hidden="true">#</a> 3、HTTP 方法有哪些？</h3>
<p>3客户端发送的 请求报文 第一行为请求行，包含了方法字段。</p>
<ol>
<li>GET：获取资源，当前网络中绝大部分使用的都是 GET；</li>
<li>HEAD：获取报文首部，和 GET 方法类似，但是不返回报文实体主体部分；</li>
<li>POST：传输实体主体</li>
<li>PUT：上传文件，由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</li>
<li>PATCH：对资源进行部分修改。PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</li>
<li>OPTIONS：查询指定的 URL 支持的方法；</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道。使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</li>
<li>TRACE：追踪路径。服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</li>
</ol>
<p>HTTP请求方法
在HTTP1.1规定里8种请求方法，都必须大写的形式存在：
(1)GET：获取资源，可以理解为读取或者下载数据；
(2)HEAD：获取资源的元信息；
(3)POST：向资源提交数据，相当于写入或上传数据；
(4)PUT：类似POST；
(5)DELETE：删除资源；
(6)CONNECT：建立特殊的连接隧道；
(7)OPTIONS：列出课对资源实行的方法；
(8)TRACE：追踪请求-响应的传输路径。</p>
<p>安全和幂等
安全：GET、HEAD（只读）
不安全：POST、PUT、DELETE（修改服务器资源和增删数据）
幂等：GET、HEAD、PUT
非幂等：POST</p>
<h3 id="_4、说下-get-和-post-的区别" tabindex="-1"><a class="header-anchor" href="#_4、说下-get-和-post-的区别" aria-hidden="true">#</a> 4、说下 GET 和 POST 的区别？</h3>
<p>GET 和 POST 本质都是 HTTP 请求，只不过对它们的作用做了界定和适配，并且让他们适应各自的场景。</p>
<p>本质区别：GET 只是一次 HTTP请求，POST 先发请求头再发请求体，实际上是两次请求。</p>
<ol>
<li>从功能上讲，GET 一般用来从服务器上获取资源，POST 一般用来更新服务器上的资源；</li>
<li>从 REST 服务角度上说，GET 是幂等的，即读取同一个资源，总是得到相同的数据，而 POST 不是幂等的，因为每次请求对资源的改变并不是相同的；进一步地，GET 不会改变服务器上的资源，而 POST 会对服务器资源进行改变；</li>
<li>从请求参数形式上看，GET 请求的数据会附在 URL 之后，即将请求数据放置在 HTTP 报文的 请求头 中，以 ? 分割 URL 和传输数据，参数之间以 &amp; 相连。特别地，如果数据是英文字母/数字，原样发送；否则，会将其编码为 application/x-www-form-urlencoded MIME 字符串(如果是空格，转换为+，如果是中文/其他字符，则直接把字符串用 BASE64 加密，得出如：%E4%BD%A0%E5%A5%BD，其中 ％XX 中的 XX 为该符号以 16 进制表示的 ASCII)；而 POST 请求会把提交的数据则放置在是 HTTP 请求报文的 请求体 中；</li>
<li>就安全性而言，POST 的安全性要比 GET 的安全性高，因为 GET 请求提交的数据将明文出现在 URL 上，而且 POST 请求参数则被包装到请求体中，相对更安全；</li>
<li>从请求的大小看，GET 请求的长度受限于浏览器或服务器对 URL 长度的限制，允许发送的数据量比较小，而 POST 请求则是没有大小限制的。</li>
</ol>
<p>服务端在接收到该数据后就可以遍历该字节流，一个字节一个字节的吃，当吃到3D这字节后，服务端就知道前面吃得字节表示一个key，再往后吃，如果遇到26，说明从刚才吃的3D到26子节之间的是上一个key的value，以此类推就可以解析出客户端传过来的参数。</p>
<p>现在考虑这样一个问题，如果我们的参数值中就包含=或&amp;这种特殊字符的时候该怎么办？比如，“name1=value1”，其中value1的值是“va&amp;lu=e1”字符串，那么实际在传输过程中就会变成这样“name1=va&amp;lu=e1”。这样，我们的本意是只有一个键值对，但是服务端却会解析成两个键值对，这样就产生了歧义。</p>
<p>那么，如何解决上述问题带来的歧义呢？解决的办法就是对参数进行URL编码：例如，我们对上述会产生歧义的字符进行URL编码后结果：“name1=va%26lu%3D”，这样服务端会把紧跟在“%”后的字节当成普通的字节，就是不会把它当成各个参数或键值对的分隔符。
————————————————</p>
<h3 id="_5、在浏览器中输入-url-地址到显示主页的过程" tabindex="-1"><a class="header-anchor" href="#_5、在浏览器中输入-url-地址到显示主页的过程" aria-hidden="true">#</a> 5、在浏览器中输入 URL 地址到显示主页的过程？</h3>
<ol>
<li>
<p>DNS 解析：浏览器查询 DNS，获取域名对应的 IP 地址：具体过程包括浏览器搜索自身的 DNS 缓存、搜索操作系统的 DNS 缓存、读取本地的 Host 文件和向本地 DNS 服务器进行查询等。对于向本地 DNS 服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地 DNS 服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个 IP 地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</p>
</li>
<li>
<p>TCP 连接：浏览器获得域名对应的 IP 地址以后，浏览器向服务器请求建立链接，发起三次握手；</p>
</li>
<li>
<p>发送 HTTP 请求：TCP 连接建立起来后，浏览器向服务器发送 HTTP 请求；</p>
</li>
<li>
<p>服务器处理请求并返回 HTTP 报文：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</p>
</li>
<li>
<p>浏览器解析渲染页面：浏览器解析并渲染视图，若遇到对 js 文件、css 文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</p>
</li>
<li>
<p>连接结束。</p>
</li>
</ol>
<h3 id="_6、dns-的解析过程" tabindex="-1"><a class="header-anchor" href="#_6、dns-的解析过程" aria-hidden="true">#</a> 6、DNS 的解析过程？</h3>
<ol>
<li>主机向本地域名服务器的查询一般都是采用递归查询。所谓递归查询就是：如果主机所询问的本地域名服务器不知道被查询的域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。因此，递归查询返回的查询结果或者是所要查询的 IP 地址，或者是报错，表示无法查询到所需的 IP 地址。</li>
<li>本地域名服务器向根域名服务器的查询的迭代查询。迭代查询的特点：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地服务器进行后续的查询。根域名服务器通常是把自己知道的顶级域名服务器的 IP 地址告诉本地域名服务器，让本地域名服务器再向顶级域名服务器查询。顶级域名服务器在收到本地域名服务器的查询请求后，要么给出所要查询的 IP 地址，要么告诉本地服务器下一步应当向哪一个权限域名服务器进行查询。最后，本地域名服务器得到了所要解析的 IP 地址或报错，然后把这个结果返回给发起查询的主机。</li>
</ol>
<p>下面来详细解释DNS域名解析的过程：</p>
<p>网络客户端就是我们平常使用的电脑，打开浏览器，输入一个域名。比如输入www.163.com，这时，你使用的电脑会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p>
<p>查询www.163.com的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</p>
<p>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。</p>
<p>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p>
<p>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<h3 id="_7、谈谈你对域名缓存的了解" tabindex="-1"><a class="header-anchor" href="#_7、谈谈你对域名缓存的了解" aria-hidden="true">#</a> 7、谈谈你对域名缓存的了解？</h3>
<p>为了提高 DNS 查询效率，并减轻服务器的负荷和减少因特网上的 DNS 查询报文数量，在域名服务器中广泛使用了高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录。</p>
<p>由于名字到地址的绑定并不经常改变，为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超过合理时间的项（例如：每个项目两天）。当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新到授权管理该项的域名服务器绑定信息。当权限服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的正确性。</p>
<p>不仅在本地域名服务器中需要高速缓存，在主机中也需要。许多主机在启动时从本地服务器下载名字和地址的全部数据库，维护存放自己最近使用的域名的高速缓存，并且只在从缓存中找不到名字时才使用域名服务器。维护本地域名服务器数据库的主机应当定期地检查域名服务器以获取新的映射信息，而且主机必须从缓存中删除无效的项。由于域名改动并不频繁，大多数网点不需花精力就能维护数据库的一致性。</p>
<h3 id="_8、谈下你对-http-长连接和短连接的理解-分别应用于哪些场景" tabindex="-1"><a class="header-anchor" href="#_8、谈下你对-http-长连接和短连接的理解-分别应用于哪些场景" aria-hidden="true">#</a> 8、谈下你对 HTTP 长连接和短连接的理解？分别应用于哪些场景？</h3>
<p>在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。</p>
<p>而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p>
<p>Connection:keep-alive
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p>
<p>Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<h3 id="_9、谈下-http-1-0-和-1-1、1-2-的主要变化" tabindex="-1"><a class="header-anchor" href="#_9、谈下-http-1-0-和-1-1、1-2-的主要变化" aria-hidden="true">#</a> 9、谈下 HTTP 1.0 和 1.1、1.2 的主要变化？</h3>
<p>HTTP1.1 的主要变化：</p>
<ol>
<li>
<p>HTTP1.0 经过多年发展，在 1.1 提出了改进。首先是提出了长连接，HTTP 可以在一次 TCP 连接中不断发送请求。</p>
</li>
<li>
<p>然后 HTTP1.1 支持只发送 header 而不发送 body。原因是先用 header 判断能否成功，再发数据，节约带宽，事实上，post 请求默认就是这样做的。</p>
</li>
<li>
<p>HTTP1.1 的 host 字段。由于虚拟主机可以支持多个域名，所以一般将域名解析后得到 host。</p>
</li>
</ol>
<p>HTTP2.0 的主要变化：</p>
<ol>
<li>HTTP2.0 支持多路复用，同一个连接可以并发处理多个请求，方法是把 HTTP数据包拆为多个帧，并发有序的发送，根据序号在另一端进行重组，而不需要一个个 HTTP请求顺序到达；</li>
<li>HTTP2.0 支持服务端推送，就是服务端在 HTTP 请求到达后，除了返回数据之外，还推送了额外的内容给客户端；</li>
<li>HTTP2.0 压缩了请求头，同时基本单位是二进制帧流，这样的数据占用空间更少；</li>
<li>HTTP2.0 适用于 HTTPS 场景，因为其在 HTTP和 TCP 中间加了一层 SSL 层。</li>
</ol>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>二，如何理解http协议是没有状态的
(1) http协议是无状态的，指的是http协议对于事务处理没有记忆功能，客户端向服务端请求完数据之后，服务端不知道客户端是什么状态。

三，什么是长连接？短连接？
http的长连接和短连接，本质上是tcp层的长连接和短连接
(1) http 1.0 默认使用短连接，就是，客户端和服务端每进行一次http操作，就建立一次连接，任务结束就中断连接。如果请求的html中有网络js和图片，则需要新建连接去取。
client发起请求--建立连接--server响应请求---发送消息--关闭连接
建立连接--数据传输--关闭连接

(2) http 1.1 默认使用长连接，在使用的http协议，在响应头会加上 Connection:keep-alive，当一个网页打开完成之后，连接不会马上关闭，再次访问这个服务时，
会继续使用这个长连接，而是在一段时间后关闭，这个时间可以再浏览器设置。
建立连接--数据传输......保持连接......数据传输--关闭连接

四，TPC短连接
当网络通信使用tcp协议时，在真正的读写操作前，需要完成3次握手，来建立连接。当读写完成时，需要四次握手来释放连接，每个连接的建立和释放都是需要资源和时间的，所以长连接比短连接
更节省资源，效率更高（RPC比http高效的原因）

五，RPC比HTTP请求快的原因
(1)http使用http协议，rpc使用tcp协议，比http少了应用层，表示层，会话层，这3层
(2)rpc使用长连接，当网络通信使用tcp协议时，在真正的读写操作前，需要完成3次握手，来建立连接。当读写完成时，需要四次握手来释放连接，每个连接的建立和释放都是需要资源和时间的，所以长连接比短连接
更节省资源，效率更高

第一层：物理层
第二层：数据链路层 802.2、802.3ATM、HDLC、FRAME RELAY 
第三层：网络层 IP、IPX、ARP、APPLETALK、ICMP 
第四层：传输层 TCP、UDP、SPX 
第五层：会话层 RPC、SQL、NFS 、X WINDOWS、ASP
第六层：表示层 ASCLL、PICT、TIFF、JPEG、 MIDI、MPEG 
第七层：应用层 HTTP,FTP,SNMP等


六，长连接和短连接的优点和缺点
（1）长连接，可以省去较多的tpc建立和关闭操作，减少资源的浪费，节约时间。长连接多用于操作频繁，点对点的通讯，而且连接数不能太多。数据库的连接就是使用长连接，如果用短连接频繁通讯会造成socke错误
，而且频繁的Socket创建和销毁也是对资源的消耗比较大。

（2）短连接，短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段，web网站一般使用短连接，因为长连接对服务端来说会消耗一定资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的，对资源消耗过大

七， tcp的keep-alive和http人Keep-alive
（1） Tcp的keep-alive是检查当前tcp是否存活，表现就是当一个连接在一段时间没有数据传输是，一方会发一个心跳包，果对方有回包则表明当前连接有效，继续监控。
这个“一段时间”可以设置。
WinHttp库的设置：
WINHTTP_OPTION_WEB_SOCKET_KEEPALIVE_INTERVAL
Sets the interval, in milliseconds, to send a keep-alive packet over the connection. The default interval is 30000 (30 seconds). The minimum interval is 15000 (15 seconds). Using WinHttpSetOption to set a value lower than 15000 will return with ERROR_INVALID_PARAMETER

（2） http的Keep-alive是让一个tcp连接活久点。在浏览器设置
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_10、https-的工作过程" tabindex="-1"><a class="header-anchor" href="#_10、https-的工作过程" aria-hidden="true">#</a> 10、HTTPS 的工作过程？</h3>
<ol>
<li>
<p>客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了；</p>
</li>
<li>
<p>服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构；</p>
</li>
<li>
<p>客户端收到网站的证书之后要做下面的事情：</p>
</li>
</ol>
<p>3.1 验证证书的合法性；</p>
<p>3.2 果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密；</p>
<p>3.3 用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器。</p>
<ol start="4">
<li>服务器接收到客户端传送来的信息，要做下面的事情：</li>
</ol>
<p>4.1 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致；</p>
<p>4.2 使用密钥加密消息；</p>
<ol start="5">
<li>如果计算法 hash 值一致，握手成功。</li>
</ol>
<h3 id="_11、http-和-https-的区别" tabindex="-1"><a class="header-anchor" href="#_11、http-和-https-的区别" aria-hidden="true">#</a> 11、HTTP 和 HTTPS 的区别？</h3>
<ol>
<li>开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</li>
<li>资源消耗：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；</li>
<li>端口不同：HTTP 和 HTTPS 使用的是完全不同的连接方式，用的端口也不一样，前者是  80，后者是 443；</li>
<li>安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li>
</ol>
<h4 id="什么是-https" tabindex="-1"><a class="header-anchor" href="#什么是-https" aria-hidden="true">#</a> 什么是 HTTPS?</h4>
<p>HTTPS (基于安全套接字层的超文本传输协议 或者是 HTTP over SSL) 是一个 Netscape 开发的 Web 协议。</p>
<p>你也可以说：HTTPS = HTTP + SSL</p>
<p>HTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。</p>
<h4 id="为什么需要-https" tabindex="-1"><a class="header-anchor" href="#为什么需要-https" aria-hidden="true">#</a> 为什么需要 HTTPS ？</h4>
<p>超文本传输协议 (HTTP) 是一个用来通过互联网传输和接收信息的协议。HTTP 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输。当你访问 Web 页面的时候你就是在使用 HTTP 协议，但 HTTP 是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输。在很多情况下，客户和服务器之间传输的是敏感歇息，需要防止未经授权的访问。为了满足这个要求，网景公司(Netscape)推出了<a href="http://www.nowamagic.net/librarys/veda/tag/https" target="_blank" rel="noopener noreferrer">HTTPS<ExternalLinkIcon/></a>，也就是基于安全套接字层的 HTTP 协议。</p>
<h4 id="http-和-https-的相同点" tabindex="-1"><a class="header-anchor" href="#http-和-https-的相同点" aria-hidden="true">#</a> HTTP 和 HTTPS 的相同点</h4>
<p>大多数情况下，HTTP 和 HTTPS 是相同的，因为都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。而 HTTPS 和 HTTP 唯一不同的只是一个协议头(https)的说明，其他都是一样的。</p>
<h4 id="http-和-https-的不同之处" tabindex="-1"><a class="header-anchor" href="#http-和-https-的不同之处" aria-hidden="true">#</a> HTTP 和 HTTPS 的不同之处</h4>
<ol>
<li>HTTP 的 URL 以 http:// 开头，而 HTTPS 的 URL 以 https:// 开头</li>
<li>HTTP 是不安全的，而 HTTPS 是安全的</li>
<li>HTTP 标准端口是 80 ，而 HTTPS 的标准端口是 443</li>
<li>在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层</li>
<li>HTTP 无需加密，而 HTTPS 对传输的数据进行加密</li>
<li>HTTP 无需证书，而 HTTPS 需要认证证书</li>
</ol>
<h4 id="https-如何工作" tabindex="-1"><a class="header-anchor" href="#https-如何工作" aria-hidden="true">#</a> HTTPS 如何工作?</h4>
<p>使用 HTTPS 连接时，服务器要求有公钥和签名的证书。</p>
<p>当使用 https 连接，服务器响应初始连接，并提供它所支持的加密方法。作为回应，客户端选择一个连接方法，并且客户端和服务器端交换证书验证彼此身份。完成之后，在确保使用相同密钥的情况下传输加密信息，然后关闭连接。为了提供 https 连接支持，服务器必须有一个公钥证书，该证书包含经过证书机构认证的密钥信息，大部分证书都是通过第三方机构授权的，以保证证书是安全的。</p>
<p>换句话说，HTTPS 跟 HTTP 一样，只不过增加了 <a href="http://www.nowamagic.net/librarys/veda/tag/SSL" target="_blank" rel="noopener noreferrer">SSL<ExternalLinkIcon/></a>。</p>
<p>HTTP 包含如下动作：</p>
<ol>
<li>浏览器打开一个 TCP 连接</li>
<li>浏览器发送 HTTP 请求到服务器端</li>
<li>服务器发送 HTTP 回应信息到浏览器</li>
<li>TCP 连接关闭</li>
</ol>
<p>SSL 包含如下动作：</p>
<ol>
<li>验证服务器端</li>
<li>允许客户端和服务器端选择加密算法和密码，确保双方都支持</li>
<li>验证客户端(可选)</li>
<li>使用公钥加密技术来生成共享加密数据</li>
<li>创建一个加密的 SSL 连接</li>
<li>基于该 SSL 连接传递 HTTP 请求</li>
</ol>
<h4 id="什么时候该使用-https" tabindex="-1"><a class="header-anchor" href="#什么时候该使用-https" aria-hidden="true">#</a> 什么时候该使用 HTTPS?</h4>
<p>银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS，例如：</p>
<ul>
<li>PayPal: https://www.paypal.com</li>
<li>Google AdSense: https://www.google.com/adsense/</li>
</ul>
<p>如果某个网站要求你填写信用卡信息，首先你要检查该网页是否使用 https 加密连接，如果没有，那么请不要输入任何敏感信息如信用卡号。</p>
<h4 id="浏览器集成" tabindex="-1"><a class="header-anchor" href="#浏览器集成" aria-hidden="true">#</a> 浏览器集成</h4>
<p>多数浏览器在收到一个无效证书的时候都会显示警告信息，而一些老的浏览器会弹出对话框让用户选择是否继续浏览。新的浏览器一般在整个窗口显示横幅的警告信息，同时在地址栏上显示该网站的安全信息。如果网站中包含加密和非加密的混合内容，多数浏览器会提示警告信息。</p>
<p>=======================================================</p>
<p>在URL前加https://前缀表明是用SSL加密的。你的电脑与服务器之间收发的信息传输将更加安全。 Web服务器启用SSL需要获得一个服务器证书并将该证书与要使用SSL的服务器绑定。 http和https使用的是完全不同的连接方式,用的端口也不一样,前者是80,后者是443。</p>
<p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议
要比http协议安全</p>
<p>HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议
它是一个安全通信通道，它基于HTTP开发，用于在客户计算机和服务器之间交换信息。它使用安全套接字层(SSL)进行信息交换，简单来说它是HTTP的安全版。
它是由Netscape开发并内置于其浏览器中，用于对数据进行压缩和解压操作，并返回网络上传送回的结果。HTTPS实际上应用了Netscape的安全全套接字层（SSL）作为HTTP应用层的子层。（HTTPS使用端口443，而不是象HTTP那样使用端口80来和TCP/IP进行通信。）SSL使用40 位关键字作为RC4流加密<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener noreferrer">算法<ExternalLinkIcon/></a>，这对于商业信息的加密是合适的。HTTPS和SSL支持使用X.509数字认证，如果需要的话用户可以确认发送者是谁。
HTTPS和HTTP的区别：
https协议需要到ca申请证书，一般免费证书很少，需要交费。
http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议
http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。
http的连接很简单,是无状态的
HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全
HTTPS解决的问题：
1 . 信任主机的问题. 采用https 的server 必须从CA 申请一个用于证明服务器用途类型的证书. 改证书只有用于对应的server 的时候,客户度才信任次主机. 所以目前所有的银行系统网站,关键部分应用都是https 的. 客户通过信任该证书,从而信任了该主机. 其实这样做效率很低,但是银行更侧重安全. 这一点对我们没有任何意义,我们的server ,采用的证书不管自己issue 还是从公众的地方issue, 客户端都是自己人,所以我们也就肯定信任该server.
2 . 通讯过程中的数据的泄密和被窜改
\1. 一般意义上的https, 就是 server 有一个证书.
a) 主要目的是保证server 就是他声称的server. 这个跟第一点一样.
b) 服务端和客户端之间的所有通讯,都是加密的.
i. 具体讲,是客户端产生一个对称的密钥,通过server 的证书来交换密钥. 一般意义上的握手过程.
ii. 加下来所有的信息往来就都是加密的. 第三方即使截获,也没有任何意义.因为他没有密钥. 当然窜改也就没有什么意义了.
\2. 少许对客户端有要求的情况下,会要求客户端也必须有一个证书.
a) 这里客户端证书,其实就类似表示个人信息的时候,除了用户名/密码, 还有一个CA 认证过的身份. 应为个人证书一般来说上别人无法模拟的,所有这样能够更深的确认自己的身份.
b) 目前少数个人银行的专业版是这种做法,具体证书可能是拿U盘作为一个备份的载体.
HTTPS 一定是繁琐的.
a) 本来简单的http协议,一个get一个response. 由于https 要还密钥和确认加密算法的需要.单握手就需要6/7 个往返.
i. 任何应用中,过多的round trip 肯定影响性能.
b) 接下来才是具体的http协议,每一次响应或者请求, 都要求客户端和服务端对会话的内容做加密/解密.
i. 尽管对称加密/解密效率比较高,可是仍然要消耗过多的CPU,为此有专门的SSL 芯片. 如果CPU 信能比较低的话,肯定会降低性能,从而不能serve 更多的请求.
ii. 加密后数据量的影响. 所以，才会出现那么多的安全认证提示</p>
<h3 id="_12、https-的优缺点" tabindex="-1"><a class="header-anchor" href="#_12、https-的优缺点" aria-hidden="true">#</a> 12、HTTPS 的优缺点？</h3>
<p>优点：</p>
<ol>
<li>
<p>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器；</p>
</li>
<li>
<p>HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性；</p>
</li>
<li>
<p>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>
<p>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电；</p>
</li>
<li>
<p>HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响；</p>
</li>
<li>
<p>SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用；</p>
</li>
<li>
<p>SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗；</p>
</li>
<li>
<p>HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。</p>
</li>
</ol>
<h3 id="_13、什么是数字签名" tabindex="-1"><a class="header-anchor" href="#_13、什么是数字签名" aria-hidden="true">#</a> 13、什么是数字签名？</h3>
<p>为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。</p>
<h3 id="_14、什么是数字证书" tabindex="-1"><a class="header-anchor" href="#_14、什么是数字证书" aria-hidden="true">#</a> 14、什么是数字证书？</h3>
<p>对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。</p>
<h3 id="_15、什么是对称加密和非对称加密" tabindex="-1"><a class="header-anchor" href="#_15、什么是对称加密和非对称加密" aria-hidden="true">#</a> 15、什么是对称加密和非对称加密？</h3>
<p>对称密钥加密是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。</p>
<p>非对称加密指使用一对非对称密钥，即：公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p>
<p>由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。但是和对称加密比起来，它非常的慢，所以我们还是要用对称加密来传送消息，但对称加密所使用的密钥我们可以通过非对称加密的方式发送出去。</p>
<h3 id="_16、http协议理解" tabindex="-1"><a class="header-anchor" href="#_16、http协议理解" aria-hidden="true">#</a> 16、http协议理解</h3>
<p><strong>HTTP协议的特点</strong></p>
<p><strong>1.HTTP协议是无状态的</strong></p>
<p>就是说每次HTTP请求都是独立的，任何两个请求之间没有什么必然的联系。但是在实际应用当中并不是完全这样的，引入了Cookie和Session机制来关联请求。</p>
<p><strong>2.多次HTTP请求</strong></p>
<p>在客户端请求网页时多数情况下并不是一次请求就能成功的，服务端首先是响应HTML页面，然后浏览器收到响应之后发现HTML页面还引用了其他的资源，例如，CSS，JS文件，图片等等，还会自动发送HTTP请求这些需要的资源。现在的HTTP版本支持管道机制，可以同时请求和响应多个请求，大大提高了效率。</p>
<p><strong>3.基于TCP协议</strong></p>
<p>HTTP协议目的是规定客户端和服务端数据传输的格式和数据交互行为，并不负责数据传输的细节。底层是基于TCP实现的。现在使用的版本当中是默认持久连接的，也就是多次HTTP请求使用一个TCP连接。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211223143218458.png" alt="image-20211223143218458"></p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>GET /wxisme HTTP/1.1  
Host: www.cnblogs.com 
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.0; zh-CN; rv:1.8.1) Gecko/20061010 Firefox/2.0  
Accept: text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5  
Accept-Language: en-us,zh-cn;q=0.7,zh;q=0.3  
Accept-Encoding: gzip,deflate  
Accept-Charset: gb2312,utf-8;q=0.7,*;q=0.7  
Keep-Alive: 300  
Proxy-Connection: keep-alive  
Cookie: ASP.NET_SessionId=ey5drq45lsomio55hoydzc45
Cache-Control: max-age=0
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说请求报文就是由请求行、请求头、内容实体组成的，注意，每一行的末尾都有回车和换行，在内容实体和请求头之间另有一个空行。其中请求行指定的是请求方法、请求URL、协议版本；请求头是键值对的形式存在的，就是字段名：值；内容实体就是要传输的数据。稍后会对方法、请求头字段做详细的说明。</p>
<p><strong>2.响应报文</strong></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211223143302882.png" alt="image-20211223143302882"></p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>HTTP/1.1 200 OK
Date: Tue, 12 Jul 2016 21:36:12 GMT
Content-Length: 563
Content-Type: text/html

&lt;html>
    &lt;body>
    Hello http!
    &lt;/body>
&lt;/html>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>简单来说响应报文由状态行、响应首部字段（响应头）、响应实体组成，其中第一行是状态行，依次包含HTTP版本，状态码和状态短语组成；在一个回车换行之后是响应头，也是键值对的形式，字段名：值；然后会有一个空行也包含回车换行，之后是响应实体，就是要传输的数据。在上面的例子当中就是一个非常简单的HTML页面。对于响应状态码，首部字段键值对稍后会有更加详细的说明。</p>
<p><strong>四、HTTP请求方法</strong></p>
<p>请求方法是客户端用来告知服务器其动作意图的方法。就像下达命令一样。在HTTP1.1版本中支持GET、POST等近10种方法。需要注意的是方法名区分大小写，需要用大写字母。下面详细说明。</p>
<p><strong>1.GET：获取资源</strong></p>
<p>GET方法用来请求访问已被URI识别的资源。也就是指定了服务器处理请求之后响应的内容。</p>
<p><strong>2.POST：传输实体主体</strong></p>
<p>POST方法用来传输实体主体。POST与GET的区别之一就是目的不同，二者之间的区别会在文章的最后详细说明。虽然GET方法也可以传输，但是一般不用，因为GET的目的是获取，POST的目的是传输。</p>
<p><strong>3.PUT：传输文件</strong></p>
<p>PUT方法用来传输文件。类似FTP协议，文件内容包含在请求报文的实体中，然后请求保存到URL指定的服务器位置。</p>
<p><strong>4.HEAD：获得报文首部</strong></p>
<p>HEAD方法类似GET方法，但是不同的是HEAD方法不要求返回数据。用于确认URI的有效性及资源更新时间等。</p>
<p><strong>5.DELETE：删除文件</strong></p>
<p>DELETE方法用来删除文件，是与PUT相反的方法。DELETE是要求返回URL指定的资源。</p>
<p><strong>6.OPTIONS：询问支持的方法</strong></p>
<p>因为并不是所有的服务器都支持规定的方法，为了安全有些服务器可能会禁止掉一些方法例如DELETE、PUT等。那么OPTIONS就是用来询问服务器支持的方法。</p>
<p><strong>7.TRACE：追踪路径</strong></p>
<p>TRACE方法是让Web服务器将之前的请求通信环回给客户端的方法。这个方法并不常用。</p>
<p><strong>8.CONNECT：要求用隧道协议连接代理</strong></p>
<p>CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL/TLS协议对通信内容加密后传输。</p>
<p>汇总：</p>
<p>​        <img src="@source/docs/theme-reco/img/最高级多方面面试题/735119-20161222203657557-1281147259.png" alt="img"></p>
<p><strong>六、HTTP的首部字段</strong></p>
<p>HTTP首部字段是构成HTTP报文最重要的元素之一。在客户端与服务端之前进行信息传递的时候请求和响应都会使用首部字段，会传递一些重要的元信息。首部字段是以键值对的形式存在的。包含报文的主体大小、语言、认证信息等。HTTP首部字段包含4种类型：</p>
<p><strong>通用首部字段（General Header Fields）</strong></p>
<p>代表请求报文和响应报文都会使用的字段</p>
<p><strong>请求首部字段（Request Header Fields）</strong></p>
<p>是客户端向服务端发送请求时使用的首部字段。包含请求的附加内容、客户端信息、响应内容相关优先级等信息。</p>
<p><strong>响应首部字段（Response Header Fields）</strong></p>
<p>是服务端向客户端返回响应时使用的首部字段，包含响应的附加内容，可能也会要求客户端附加额外的内容信息。</p>
<p><strong>实体首部字段（Entity Header Fields）</strong></p>
<p>是针对请求报文和响应报文的实体部分使用的首部。包含资源内容更新时间等和实体有关的信息。</p>
<p>在HTTP/1.1种规定了47种首部字段（图表参考《图解HTTP》，感谢作者。）</p>
<p><strong>通用首部字段</strong></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/735119-20161223145334839-1996412478.png" alt="img"></p>
<p><strong>请求首部字段</strong></p>
<p><strong><img src="@source/docs/theme-reco/img/最高级多方面面试题/735119-20161223145540682-785036654.png" alt="img"></strong></p>
<p><strong>响应首部字段</strong></p>
<p><strong><img src="@source/docs/theme-reco/img/最高级多方面面试题/735119-20161223150131386-2024915441.png" alt="img"></strong></p>
<p><strong>实体首部字段</strong></p>
<p><strong><img src="@source/docs/theme-reco/img/最高级多方面面试题/735119-20161223150312932-2091828241.png" alt="img"></strong></p>
<p><strong>其他首部字段</strong></p>
<p><strong>Cookie、Set-Cookie、Content-Disposition、Connection、Keep-Alive、Proxy-Authenticate、Proxy-Authorization、Trailer、TE、Transfer-Encoding、Upgrade etc...</strong></p>
<p><strong>这么多的首部字段，估计如果不是很了解会被吓着，但是根本不用全部记住，其实字段的名字就说明了作用，看一眼就大概知道是干啥的了，只不过有些类似的字段要区分一下就好了。只要深刻理解了HTTP的设计思路就没有大问题了，熟悉常见的就可以了。用到的时候想了解细节再去查。</strong></p>
<p><strong>关于首部字段的细节请参考《图解HTTP》或者《HTTP权威指南》的首部字段部分。够再写一篇长博客的了~</strong></p>
<p><strong>以上就把HTTP协议的重点内容——报文格式、方法、状态码、首部字段介绍完了，可以说对HTTP协议有了一些了解。下面就工作中的常见问题（或者说面试中的）做一个总结。^_^</strong></p>
<p><strong>2.408 Request Timeout和504 Gateway Timeout的区别</strong></p>
<p>408是说请求超时，就是建立连接之后再约定的时间内客户端没有发送请求到客户端到服务端。本质上原因在于客户端或者网络拥塞。504是网关超时，是说代理服务器把客户端请求转发到应用服务器后再约定的时间内没有收到应用服务器的响应。本质上原因在于服务端的响应过慢，也有可能是网络问题。</p>
<h3 id="_17-http-code-码含义-比如204-304-404" tabindex="-1"><a class="header-anchor" href="#_17-http-code-码含义-比如204-304-404" aria-hidden="true">#</a> 17.http code 码含义 比如204, 304, 404</h3>
<h3 id="_18-http1-0与http1-1的区别-http与https的区别" tabindex="-1"><a class="header-anchor" href="#_18-http1-0与http1-1的区别-http与https的区别" aria-hidden="true">#</a> 18.http1.0与http1.1的区别, http与https的区别.</h3>
<h3 id="_19-描述http请求的三次握手" tabindex="-1"><a class="header-anchor" href="#_19-描述http请求的三次握手" aria-hidden="true">#</a> 19.描述http请求的三次握手.</h3>
<h1 id="四-mysql面试" tabindex="-1"><a class="header-anchor" href="#四-mysql面试" aria-hidden="true">#</a> 四.mysql面试</h1>
<h3 id="_1、谈谈你在写sql语句需要注意有哪些点" tabindex="-1"><a class="header-anchor" href="#_1、谈谈你在写sql语句需要注意有哪些点" aria-hidden="true">#</a> 1、谈谈你在写sql语句需要注意有哪些点？</h3>
<p>答：</p>
<p>select * 问题，客户端需要什么，就给什么，不要给多余的字段，这种情况可能还会导致本来可以走覆盖索引的语句不能走覆盖索引。</p>
<p>不要在查询语句字段上做函数运算，这样会让索引失效。</p>
<p>一定要避免mysql自动类型转换，比如 where ‘9’ =9。</p>
<p>能不设置允许 null 的字段尽量不要设置，因为 null 会导致 mysql 多一层判断。</p>
<p>使用 like 的时候如果是通配符 % 在最前面的话也会走的全表扫描。</p>
<h3 id="_2、你刚才一直在提索引-把你知道的关于索引的一些技巧说下" tabindex="-1"><a class="header-anchor" href="#_2、你刚才一直在提索引-把你知道的关于索引的一些技巧说下" aria-hidden="true">#</a> 2、你刚才一直在提索引，把你知道的关于索引的一些技巧说下</h3>
<p>答：</p>
<p>要在区分度高的字段上建立索引，否则索引意义不大。</p>
<p>字符串建立索引要注意大小，索引长度过长，占用的空间也就越大，适当的可以截取进行索引，缺点是不能使用到覆盖索引，具体根据业务合理安排。</p>
<p>建立联合索引要知道最左前缀原则，举个例子( name, email, phone ),最终能走这个联合索引的一定只会是 （ name ）,（ name, email )，( name, email, phone )，其他只能走全表，需要根据业务合理设置联合索引的顺序。</p>
<h3 id="_3-索引底层结构介绍-二叉树-红黑树-rb-tree-b-tree-b-tree之间的区别" tabindex="-1"><a class="header-anchor" href="#_3-索引底层结构介绍-二叉树-红黑树-rb-tree-b-tree-b-tree之间的区别" aria-hidden="true">#</a> 3.索引底层结构介绍（二叉树，红黑树（RB tree）B+tree  B-tree之间的区别）</h3>
<h4 id="_1-索引" tabindex="-1"><a class="header-anchor" href="#_1-索引" aria-hidden="true">#</a> 1.索引</h4>
<p>1.1 索引是什么？
索引是帮助MySQL高效获取数据的排好序的数据结构 ，即本质上是一种数据结构。</p>
<p>1.2 索引的优劣
创建索引的好处</p>
<p>①通过创建索引,可以在查询的过程中,提高系统的性能</p>
<p>②通过创建唯一性索引,可以保证数据库表中每一行数据的唯一性</p>
<p>创建索引的坏处</p>
<p>①创建索引和维护索引要耗费时间,而且时间随着数据量的增加而增大</p>
<p>②索引需要占用物理空间,如果要建立聚簇索引,所需要的空间会更大</p>
<p>③在对表中的数据进行增加删除和修改时需要耗费较多的时间,因为索引也要动态地维护</p>
<h4 id="_2-索引的底层实现" tabindex="-1"><a class="header-anchor" href="#_2-索引的底层实现" aria-hidden="true">#</a> 2.索引的底层实现</h4>
<p>首先介绍几种数据节构，二叉树、红黑树、Hash表、B-Tree、B+Tree</p>
<p>B+Tree索引是B+Tree在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。</p>
<p>B+Tree中的B代表平衡（balance），而不是二叉（binary），因为B+Tree是从最早的平衡二叉树演化而来的。</p>
<p>要想说明B+Tree，必须先了解二叉查找树、平衡二叉树（红黑树）和平衡多路查找树（B-Tree），B+树即由这些树逐步优化而来。</p>
<h4 id="_2-1-二叉树" tabindex="-1"><a class="header-anchor" href="#_2-1-二叉树" aria-hidden="true">#</a> 2.1 二叉树</h4>
<p>二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217101121659.png" alt="image-20211217101121659"></p>
<p>对该二叉树的节点进行查找发现深度为1的节点的查找次数为1，深度为2的查找次数为2，深度为n的节点的查找次数为n，因此其平均查找次数为 (1+2+2+3+3+3) / 6 = 2.3次</p>
<p>二叉查找树可以任意地构造，同样是0,1,4,6,7,8这六个数字，也可以按照下图的方式来构造：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217101130736.png" alt="image-20211217101130736"></p>
<p>但是这棵二叉树的查询效率就很低了。因此若想二叉树的查询效率尽可能高，需要这棵二叉树是平衡的，从而引出新的定义——平衡二叉树。</p>
<h4 id="_2-2-红黑树索引" tabindex="-1"><a class="header-anchor" href="#_2-2-红黑树索引" aria-hidden="true">#</a> 2.2 红黑树索引</h4>
<p>红黑树是一种自平衡二叉查找树，是一种数据结构，典型的用途是实现关联数组，存储有序的数据，它基本都是存储在内存中才会使用的数据结构。
<img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217101140685.png" alt="image-20211217101140685">
<img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217101149970.png" alt="image-20211217101149970"></p>
<p>红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。</p>
<h5 id="红黑树查找、插入、删除分析" tabindex="-1"><a class="header-anchor" href="#红黑树查找、插入、删除分析" aria-hidden="true">#</a> 红黑树查找、插入、删除分析</h5>
<p>BST：二叉查找树(Binary Search Tree)</p>
<p>AVL：AVL树是最先发明的自平衡二叉查找树</p>
<p>(1) 查找代价：由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。</p>
<p>(2) 插入代价：RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。</p>
<p>(3) 删除代价：RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>RBT 效率总结 : 

查找 
	效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，但也远远好于BST

插入和删除
	这两种操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。
	因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，

删除
	最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，
	但是实际上，这种操作由于简单所需要的代价很小。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="rbt-avl和bst的区别" tabindex="-1"><a class="header-anchor" href="#rbt-avl和bst的区别" aria-hidden="true">#</a> RBT,AVL和BST的区别</h5>
<p>排序二叉树有<strong>不平衡</strong>的问题，可能左子树很长但是右子树很短，造成<strong>查询时性能不佳</strong>（logn退化成n），</p>
<p>​    自平衡的二叉树能保证层数平均，从而查询效率高，但是维护又很麻烦，每次插入和删除有很大的可能要大幅调整树结构。</p>
<p>​    <strong>红黑树</strong>就是介于完全不平衡和完全平衡之间的一种<strong>二叉树</strong>，通过每个节点有红黑两种颜色、从<strong>节点</strong>到<strong>任意叶子节点会经过相同数量的黑色节点等一系列规则</strong>，实现了【树的层数最大也只会有两倍的差距】，这样既能提<strong>高插入和删除</strong>的效率，又能让树<strong>相对平衡</strong>从而有<strong>还不错的查询效率</strong>。从整体上讲，红黑树就是一种<strong>中庸之道的二叉树</strong></p>
<h5 id="红黑树索引" tabindex="-1"><a class="header-anchor" href="#红黑树索引" aria-hidden="true">#</a> 红黑树索引</h5>
<p>​	磁盘读取数据介绍
我们要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。因为I/O读写较为缓慢，而I/O读写又与树的深度有关，所以树的深度越深越影响性能，因此选择较好的树结构减少树的高度，就变成衡量索引数据结构优良的重要标准。</p>
<p>在大规模数据存储的时候，红黑树往往出现由于树的深度过大而造成磁盘IO读写过于频繁（磁盘读写较为缓慢），进而导致效率低下的情况。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217101349576.png" alt="image-20211217101349576"></p>
<h4 id="_2-3-b-tree" tabindex="-1"><a class="header-anchor" href="#_2-3-b-tree" aria-hidden="true">#</a> 2.3 B-Tree</h4>
<p>B-Tree是为磁盘等外存储设备设计的一种平衡查找树。因此在讲B-Tree之前先了解下磁盘的相关知识。</p>
<p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p>
<p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K，在MySQL中可通过如下命令查看页的大小：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>mysql> show variables like 'innodb_page_size';
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>​		而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到内存时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
​		B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p>
<p>B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217103401940.png" alt="image-20211217103401940"></p>
<p>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>模拟查找关键字29的过程：
根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】
比较关键字29在区间（17,35），找到磁盘块1的指针P2。
根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】
比较关键字29在区间（26,30），找到磁盘块3的指针P2。
根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】
在磁盘块8中的关键字列表中找到关键字29。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​			分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。</p>
<p>​			弊端：无法解决范围查找的问题，每个索引带数据，影响查询效率。</p>
<h4 id="_2-4-b-tree-b-tree变种" tabindex="-1"><a class="header-anchor" href="#_2-4-b-tree-b-tree变种" aria-hidden="true">#</a> 2.4 B+Tree（B-Tree变种）</h4>
<p>B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。</p>
<p>从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。</p>
<p>B+Tree相对于B-Tree有几点不同：
<img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217104705078.png" alt="image-20211217104705078"></p>
<p>将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217105419213.png" alt="image-20211217105419213"></p>
<p>通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</p>
<p>下面做一个推算：</p>
<p>InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。
也就是说一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录。</p>
<p>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2到4层。mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</p>
<p>数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据。辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。</p>
<h4 id="建立索引的规则" tabindex="-1"><a class="header-anchor" href="#建立索引的规则" aria-hidden="true">#</a> 建立索引的规则？</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>数据库建立索引常用的规则如下：
1、表的主键、外键必须有索引；
2、数据量超过300的表应该有索引；
3、经常与其他表进行连接的表，在连接字段上应该建立索引；
4、经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；
5、索引应该建在选择性高的字段上；
6、索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
7、复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
	A、正确选择复合索引中的主列字段，一般是选择性较好的字段；
	B、复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？
		如果是，则可以建立复合索引；否则考虑单字段索引；
	C、如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
	E、如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；
8、频繁进行数据操作的表，不要建立太多的索引；
9、删除无用的索引，避免对执行计划造成负面影响
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="mysql的两种存储搜索引擎" tabindex="-1"><a class="header-anchor" href="#mysql的两种存储搜索引擎" aria-hidden="true">#</a> MySQL的两种存储搜索引擎</h4>
<p><strong>1）MyISAM存储搜索引擎</strong>：索引文件和数据文件是分离的（非聚集）</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217111512756.png" alt="image-20211217111512756"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217111601573.png" alt="image-20211217111601573"></p>
<p>采用MyISAM引擎会创建<strong>test_myisam</strong>表会生成三个文件
MYI 文件存储索引
frm 存储表结构
MYD 存储表数据</p>
<p><strong>2）InnoDB索引实现(聚集)</strong>：表数据文件本身就是按B + Tree组织的一个索引结构文件</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217111738570.png" alt="image-20211217111738570"></p>
<p>frm 存储表结构
ibd 索引+数据</p>
<p>聚集索引（节点包含了完整的数据记录，即索引和数据存储在一个文件中）</p>
<h4 id="为什么innodb表必须有主键-并且推荐使用整型的自增主键" tabindex="-1"><a class="header-anchor" href="#为什么innodb表必须有主键-并且推荐使用整型的自增主键" aria-hidden="true">#</a> 为什么InnoDB表必须有主键，并且推荐使用整型的自增主键?</h4>
<p>1）InnoDB搜索引擎是按照B+Tree来搜索管理数据，索引必须要有一个，，如果建表时没有创建索引，数据库会默认创建一个隐藏列来充当索引
2）因为B+Tree底层节点包含多个索引，且有序排列，采用整型便于比较大小，自增是为了扩展底层索引时少引起B+Tree进行较大结构的改动（树的分裂）</p>
<h4 id="一些问题" tabindex="-1"><a class="header-anchor" href="#一些问题" aria-hidden="true">#</a> 一些问题</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>索引的分类
    聚集索引
    辅助索引
    联合索引
    覆盖索引
哈希索引
    哈希算法
    自适应哈希索引
全文索引
    倒排索引
    全文检索索引缓存
    全文索引的一些限制
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211221221500129.png" alt="image-20211221221500129"></p>
<ol>
<li>InnoDB使用的是聚簇索引，将<strong>主键组织到一棵B+树</strong>中，而<strong>行数据就储存在叶子节点</strong>上，若使用&quot;where id = 14&quot;这样的条件查找主键，则<strong>按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据</strong>。</li>
<li>若<strong>对Name列进行条件搜索，则需要两个步骤</strong>：<strong>第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键</strong>。第二步<strong>使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据</strong>。（<strong>重点在于通过其他键需要建立辅助索引</strong>）</li>
</ol>
<p>MyISM使用的是非聚簇索引，<strong>非聚簇索引的两棵B+树看上去没什么不同</strong>，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于<strong>索引树是独立的，通过辅助键检索无需访问主键的索引树</strong>。</p>
<h6 id="_1-索引是怎么支持千万级别的快速搜索" tabindex="-1"><a class="header-anchor" href="#_1-索引是怎么支持千万级别的快速搜索" aria-hidden="true">#</a> 1.）索引是怎么支持千万级别的快速搜索？</h6>
<ul>
<li>底层采用了B+Tree的数据结构。</li>
</ul>
<h6 id="_2-索引具体采用的哪种数据结构呢" tabindex="-1"><a class="header-anchor" href="#_2-索引具体采用的哪种数据结构呢" aria-hidden="true">#</a> 2）索引具体采用的哪种数据结构呢？</h6>
<ul>
<li>常见的MySQL主要有两种结构：Hash索引和B+ Tree索引InnoDB引擎，默认的是B+树。</li>
</ul>
<h6 id="_3-既然innodb使用的b-tree的索引模型-那么为什么采用b-树-这和hash索引比较起来有什么优缺点" tabindex="-1"><a class="header-anchor" href="#_3-既然innodb使用的b-tree的索引模型-那么为什么采用b-树-这和hash索引比较起来有什么优缺点" aria-hidden="true">#</a> 3）既然InnoDB使用的B+ Tree的索引模型，那么为什么采用B+ 树？这和Hash索引比较起来有什么优缺点？</h6>
<ul>
<li>
<p>因为Hash索引底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何顺序关系的，所以，对于区间查询是无法直接通过索引查询的，就需要全表扫描。所以，哈希索引只适用于等值查询的场景。</p>
</li>
<li>
<p>哈希索引适合等值查询，但是无法进行范围查询 哈希索引没办法利用索引完成排序 哈希索引不支持多列联合索引的最左匹配规则 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题</p>
</li>
<li>
<p>B+ Tree是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p>
</li>
</ul>
<h6 id="_4-b-tree的叶子节点都可以存哪些东西" tabindex="-1"><a class="header-anchor" href="#_4-b-tree的叶子节点都可以存哪些东西" aria-hidden="true">#</a> 4）B+ Tree的叶子节点都可以存哪些东西？</h6>
<ul>
<li>InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值。</li>
</ul>
<h6 id="_5-这两者有什么区别" tabindex="-1"><a class="header-anchor" href="#_5-这两者有什么区别" aria-hidden="true">#</a> 5）这两者有什么区别？</h6>
<ul>
<li>在 InnoDB 里，索引B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。</li>
<li>索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。</li>
</ul>
<h6 id="_6-聚簇索引和非聚簇索引-在查询数据的时候有区别吗" tabindex="-1"><a class="header-anchor" href="#_6-聚簇索引和非聚簇索引-在查询数据的时候有区别吗" aria-hidden="true">#</a> 6）聚簇索引和非聚簇索引，在查询数据的时候有区别吗？</h6>
<ul>
<li>聚簇索引查询会更快，聚簇索引的叶子节点直接就是我们要查询的整行数据了。而非簇索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询（回表）。</li>
</ul>
<h6 id="_7-在创建索引的时候都会考虑哪些因素呢" tabindex="-1"><a class="header-anchor" href="#_7-在创建索引的时候都会考虑哪些因素呢" aria-hidden="true">#</a> 7）在创建索引的时候都会考虑哪些因素呢？</h6>
<ul>
<li>数据量超过300的表应该有索引；</li>
<li>经常与其他表进行连接的表，在连接字段上应该建立索引；</li>
<li>经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；</li>
<li>经常出现数据变动的表，不宜建立索引；</li>
</ul>
<h6 id="_8-创建联合索引的时候-需要做联合索引多个字段之间顺序你们是如何选择的呢" tabindex="-1"><a class="header-anchor" href="#_8-创建联合索引的时候-需要做联合索引多个字段之间顺序你们是如何选择的呢" aria-hidden="true">#</a> 8）创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？</h6>
<p>​		把识别度最高的字段放到最前面
​			原因：最左匹配原则
​			在创建多列索引时，我们根据业务需求，where子句中使用最频繁的一列放在最左边
​			因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。
​			所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。</p>
<h3 id="_4-字节、位、bit、byte、kb、b、字符之间有什么关系" tabindex="-1"><a class="header-anchor" href="#_4-字节、位、bit、byte、kb、b、字符之间有什么关系" aria-hidden="true">#</a> 4.字节、位、bit、byte、KB、B、字符之间有什么关系？</h3>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>1. bit就是位，也叫比特位，是计算机表示数据最小的单位
2. byte就是字节
3.1byte=8bit
4.1byte就是1B
5.一个字符=2字节
6.1KB=1024B
1.字节就是Byte，也是B
2.位就是bit也是b
3.转换关系如下：
	1)1KB=1024B
	2) 1B= 8b
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_5-二叉查找树-红黑树-avl树-b-b-树-b-tree-伸展树——优缺点及比较" tabindex="-1"><a class="header-anchor" href="#_5-二叉查找树-红黑树-avl树-b-b-树-b-tree-伸展树——优缺点及比较" aria-hidden="true">#</a> 5.二叉查找树，红黑树，AVL树，B~/B+树(B-tree)，伸展树——优缺点及比较</h3>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>二叉查找树(Binary Search Tree)
很显然，二叉查找树的发现完全是因为静态查找结构在动态插入，删除结点所表现出来的无能为力(需要付出极大的代价)。

BST 的操作代价分析：

    (1) 查找代价： 任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。
         当树中每个结点左右子树高度大致相同时，树高为logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)数量级上。
         当先后插入的关键字有序时，BST退化成单支树结构。此时树高n。平均查找长度为(n+1)/2，查找的平均时间复杂度在O(N)数量级上。
    (2) 插入代价： 新结点插入到树的叶子上，完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。
    (3) 删除代价： 当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的…的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN)。

    BST效率总结 :  查找最好时间复杂度O(logN)，最坏时间复杂度O(N)。
    插入删除操作算法简单，时间复杂度与查找差不多
AVL树
二叉查找树在最差情况下竟然和顺序查找效率相当，这是无法仍受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。

既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。

AVL树得名于它的发明者 G.M. Adelson-Velsky 和 E.M. Landis，他们在 1962 年的论文 “An algorithm for the organization of information” 中发表了它。
AVL树是最早的自平衡二叉树，相比于后来出现的（自）平衡二叉树（红黑树，treap，splay树）而言，它现在应用较少，但研究AVL树对于了解后面出现的常用（自）平衡二叉树具有重要意义。
在AVL树中任何节点的两个儿子子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O(log n)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

引入AVL树的目的是为了提高二叉树的搜索的效率,减少树的平均搜索长度.为此,就必须每向二叉树插入一个结点时调整树的结构,使得二叉树搜索保持平衡,从而可能降低树的高度,减少的平均树的搜索长度. 

AVL树的定义: 
一棵AVL树满足以下的条件: 
1>它的左子树和右子树都是AVL树 
2>左子树和右子树的高度差不能超过1 
从条件1可能看出是个递归定义,如GNU一样. 

性质: 
1>一棵n个结点的AVL树的其高度保持在0(log2(n)),不会超过3/2log2(n+1) 
2>一棵n个结点的AVL树的平均搜索长度保持在0(log2(n)). 
3>一棵n个结点的AVL树删除一个结点做平衡化旋转所需要的时间为0(log2(n)). 

从1这点来看红黑树是牺牲了严格的高度平衡的优越条件为 代价。

AVL 的操作代价分析：

    (1) 查找代价： AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。

 

    (2) 插入代价： AVL必须要保证严格平衡(|bf|&lt;=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。

 

    (3) 删除代价：AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)

 

    AVL 效率总结 :  查找的时间复杂度维持在O(logN)，不会出现最差情况

                            AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右。

                            AVL树在执行删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)。



红黑树(Red-Black Tree ) 
二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。但是这样做是否值得呢？

 

能不能找一种折中策略，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率呢？ 答案就是：红黑树。


        红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。

红黑树能够以O(log2 n) 的时间复杂度进行搜索、插入、删除操作。此外，由于它的设计，任何不平衡都会在三次旋转之内解决。当然，还有一些更好的，但实现起来更复杂的数据结构，能够做到一步旋转之内达到平衡。但红黑树能够给我们一个比较“便宜”的解决方案。红黑树的算法时间复杂度和AVL相同，但统计性能比AVL树更高。

        当然，红黑树并不适应所有应用树的领域。如果数据基本上是静态的，那么让他们待在他们能够插入，并且不影响平衡的地方会具有更好的性能。如果数据完全是静态的，例如，做一个哈希表，性能可能会更好一些。

在实际的系统中，例如，需要使用动态规则的防火墙系统，使用红黑树而不是散列表被实践证明具有更好的伸缩性。

典型的用途是实现关联数组

RBT 的操作代价分析：

     (1) 查找代价：由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。

 

    (2) 插入代价：RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。

 

    (3) 删除代价：RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。

 

    RBT 效率总结 : 查找 效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，但也远远好于BST。

                           插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。


B~树/B+树 (B-Tree ) 
对于在内存中的查找结构而言，红黑树的效率已经非常好了(实际上很多实际应用还对RBT进行了优化)。但是如果是数据量非常大的查找呢？将这些数据全部放入内存组织成RBT结构显然是不实际的。实际上，像OS中的文件目录存储，数据库中的文件索引结构的存储…. 都不可能在内存中建立查找结构。必须在磁盘中建立好这个结构。那么在这个背景下，RBT还是一种好的选择吗？

 

     在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。大家都知道，频繁的磁盘IO操作，效率是很低下的(机械运动比电子运动要慢不知道多少)。显而易见，所有的二叉树的查找结构在磁盘中都是低效的。因此，B树很好的解决了这一个问题。

 

    B-Tree的操作代价分析：

    (1) 查找代价： B-Tree作为一个平衡多路查找树(m-叉)。B树的查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。

 

    (2)插入代价： B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。

 

    (3)删除代价：B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次
读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写
访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）

 

   B-Tree效率总结： 由于考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)。


伸展树
伸展树使用“自调整”的数据结构。时间复杂度比较低低，各种基本操作的平摊时间复杂度为0(log2(n))。

与平衡结构或有明确限制的数据结构相比，自调整的数据结构有以下几个优点：

1、从平摊角度来说，它们忽略常量因子，因此绝对不会差于有明确限制的数据结构。而且由于它们可以根据具体使用情况进行调整，所以在 使用模式不均匀的情况下更加有效； 
2、由于无需存储平衡信息或者其它限制信息，所以所需的存储空间更小； 

3、它们的查找和更新算法概念和操作都很简单，易于实现。 

当然，自调整结构也有其潜在的缺点： 

1、它们需要更多的局部调整，尤其是在查找期间。而那些有明确限制的数据结构仅需要在更新期间进行调整，查找期间则不用； 

2、一系列查找操作中的某一个可能会耗时较长，这在实时应用程序中可能是一个不足之处。


平衡二叉树AVL VS 红黑树  [AVL  PK  RBT]
 

      AVL 和RBT 都是二叉查找树的优化。其性能要远远好于二叉查找树。他们之间都有自己的优势，其应用上也有不同。

 

      结构对比： AVL的结构高度平衡，RBT的结构基本平衡。平衡度AVL > RBT.

 

      查找对比： AVL 查找时间复杂度最好，最坏情况都是O(logN)。

                      RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。

 

      插入删除对比：  1. AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。

                             2. 如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但是由于操作简单，所以在实践中这种变色仍然是非常快速的。

                             3. 当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。

                             4. AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。

 

        总体评价：大量数据实践证明，RBT的总体统计性能要好于平衡二叉树。

 

 


B~树 VS B+树  [ B~Tree  PK  B+Tree ]
 

      B+树是B~树的一种变体，在磁盘查找结构中，B+树更适合文件系统的磁盘存储结构。

 

      结构对比： B~树是平衡多路查找树，所有结点中都包含了待查关键字的有效信息(比如文件磁盘指针)。每个结点若有n个关键字，则有n+1个指向其他结点的指针。

                     B+树严格意义上说已经不是树，它的叶子结点之间也有指针链接。B+树的非终结点中并不含有关键字的信息，需要查找的关键字的全部信息都包含在叶子结点上。非终结点中只作为叶子结点关键字的索引而存在。

 

      查找对比：1. 在相同数量的待查数据下，B+树查找过程中需要调用的磁盘IO操作要少于普通B~树。由于B树所在的磁盘存储背景下，因此B+树的查找性能要好于B~树。

                     2. B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树就不一定了，可能查找到某一个非终结点就结束了。

 

      插入删除对比：  B+树与B~树在插入删除操作中的效率是差不多的。

 

      总体评价：在应用背景下，特别是文件结构存储中。B+树的应用要更多，其效率也要比B~树好。


其它比较
AVL trees are actually easier to implement than RB trees because there are fewer cases. And AVL trees require O(1) rotations on an insertion, whereas red-black trees require O(lg n). 
In practice, the speed of AVL trees versus red-black trees will depend on the data that you’re inserting. If your data is well distributed, so that an unbalanced binary tree would generally be acceptable (i.e. roughly in random order), but you want to handle bad cases anyway, then red-black trees will be faster because they do less unnecessary rebalancing of already acceptable data.On the other hand, if a pathological insertion order (e.g. increasing order of key) is common, then AVL trees will be faster, because the stricter balancing rule will reduce the tree’s height. 
Splay trees might be even faster than either RB or AVL trees,depending on your data access distribution. And if you can use a hash instead of a tree, then that’ll be fastest of all. 

试着翻译一下：
由于AVL树种类较少（应该是AVL树在编程时需要处理的情况较少？），所以比红黑树实际上更容易实现。而且AVL树在旋转插入所需要的复杂度为0(1)，而红黑树则需要的复杂度为0(log2(n))。
实际上插入AVL树和红黑树的速度取决于你所插入的数据。

如果你的数据分布较好，则比较宜于采用AVL树(例如随机产生系列数)(应该是适宜于采用一般搜索二叉树unbalanced binary tree）；

但是如果你想处理比较杂乱的情况（什么叫杂乱的情况？bad cases？），则红黑树是比较快的，因为红黑树对已经处理好的数据重新平衡减少了不必要的操作。

另外一方面，如果是一种非寻常的插入系列，比较常见(比如,插入密钥系列)，则AVL树比较快，因为它的严格的平衡规则将会减少树的高度。
Splay树可能比红黑树和AVL树还要快，这也取决于你所访问的数据分布。

如果你用哈希表来代替一棵树，则在以上所有中，它将是最快的。


红黑树是一个更高效的检索二叉树，因此常常用来实现关联数组。典型地，JDK 提供的集合类 TreeMap 本身就是一个红黑树的实现。
IBM DevelopWorks 上一篇文章讲解非常好，供参考。
TreeMap 和 TreeSet 是 Java Collection Framework 的两个重要成员，其中 TreeMap 是 Map 接口的常用实现类，而 TreeSet 是 Set 接口的常用实现类。虽然 HashMap 和 HashSet 实现的接口规范不同，但 TreeSet 底层是通过 TreeMap 来实现的，因此二者的实现方式完全一样。而 TreeMap 的实现就是红黑树算法。
 
对于 TreeMap 而言，由于它底层采用一棵“红黑树”来保存集合中的 Entry，这意味这 TreeMap 添加元素、取出元素的性能都比 HashMap 低：当 TreeMap 添加元素时，需要通过循环找到新增 Entry 的插入位置，因此比较耗性能；当从 TreeMap 中取出元素时，需要通过循环才能找到合适的 Entry，也比较耗性能。
 
但 TreeMap、TreeSet 比 HashMap、HashSet 的优势在于：TreeMap 中的所有 Entry 总是按 key 根据指定排序规则保持有序状态，TreeSet 中所有元素总是根据指定排序规则保持有序状态。
————————————————
版权声明：本文为CSDN博主「Chan_Keh」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lwgechen/article/details/77685055
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_6、索引底层是什么数据结构" tabindex="-1"><a class="header-anchor" href="#_6、索引底层是什么数据结构" aria-hidden="true">#</a> 6、索引底层是什么数据结构？</h3>
<p>答：B+树。</p>
<h3 id="_7、为什么用的是b-树-不能使用红黑树或者其他的" tabindex="-1"><a class="header-anchor" href="#_7、为什么用的是b-树-不能使用红黑树或者其他的" aria-hidden="true">#</a> 7、为什么用的是B+树，不能使用红黑树或者其他的？</h3>
<p>答：可以使用红黑树。但是这样的话可能会造成树的高度过高，意味着相同查询下，会进行更多的磁盘I/O，影响性能，而 B+ 树可以保持树的高度不至于过高。这道题答得不是很好，不仅仅是这样，欢迎补充。</p>
<p>B-tree是每个节点都带了数据data，这样节点能存放的Key就有限了，B+tree是只在叶子结点存放data数据，这样可以非叶子节点就可以放很多key，三层树高度就可以存放将近10亿条记录。因为mysql的int或者Bigint占字节为4/8个字节，然后innodb一个页的大小是16kB，然后指针一个是4/8字节，这样一个页就可以存放1K个key，三层高度就是10的三次方，可以放10亿条数据。一个结点就是一个页。</p>
<h3 id="_8、你知道索引下推吗" tabindex="-1"><a class="header-anchor" href="#_8、你知道索引下推吗" aria-hidden="true">#</a> 8、你知道索引下推吗？</h3>
<p>本质上是对普通索引需要回表的一种优化，也就是引擎层在对索引指针遍历的过程中，先做一些优先的判断，过滤掉不符合条件的，可以减少磁盘IO。</p>
<p>什么是索引下推？</p>
<p>索引下推（index condition pushdown ）简称ICP，在Mysql5.6的版本上推出，用于优化查询。</p>
<p>在不使用ICP的情况下，在使用非主键索引（又叫普通索引或者二级索引）进行查询时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，服务器然后判断数据是否符合条件 。</p>
<p>在使用ICP的情况下，如果存在某些被索引的列的判断条件时，MySQL服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合MySQL服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给MySQL服务器 。</p>
<p>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。</p>
<p>在开始之前先先准备一张用户表(user)，其中主要几个字段有：id、name、age、address。建立联合索引（name，age）。</p>
<p>假设有一个需求，要求匹配姓名第一个为陈的所有用户，sql语句如下：</p>
<p>SELECT * from user where  name like '陈%'
根据 &quot;最佳左前缀&quot; 的原则，这里使用了联合索引（name，age）进行了查询，性能要比全表扫描肯定要高。</p>
<p>问题来了，如果有其他的条件呢？假设又有一个需求，要求匹配姓名第一个字为陈，年龄为20岁的用户，此时的sql语句如下：</p>
<p>SELECT * from user where  name like '陈%' and age=20
这条sql语句应该如何执行呢？下面对Mysql5.6之前版本和之后版本进行分析。</p>
<ol>
<li>Mysql5.6之前的版本</li>
</ol>
<p>5.6之前的版本是没有索引下推这个优化的，因此执行的过程如下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/format,png" alt="img"></p>
<p>会忽略age这个字段，直接通过name进行查询，在(name,age)这课树上查找到了两个结果，id分别为2,1，然后拿着取到的id值一次次的回表查询，因此这个过程需要回表两次。</p>
<ol start="2">
<li>Mysql5.6及之后版本</li>
</ol>
<p>5.6版本添加了索引下推这个优化，执行的过程如下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/format1,png" alt="img"></p>
<p>InnoDB并没有忽略age这个字段，而是在索引内部就判断了age是否等于20，对于不等于20的记录直接跳过，因此在(name,age)这棵索引树中只匹配到了一个记录，此时拿着这个id去主键索引树中回表查询全部数据，这个过程只需要回表一次。</p>
<ol start="3">
<li>实践</li>
</ol>
<p>当然上述的分析只是原理上的，我们可以实战分析一下，因此陈某装了Mysql5.6版本的Mysql，解析了上述的语句，如下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/format22,png" alt="img"></p>
<p>根据explain解析结果可以看出Extra的值为Using index condition，表示已经使用了索引下推。</p>
<p>using index 和using where只要使用了索引我们基本都能经常看到，而using index condition则是在mysql5.6后新加的新特性，我们先来看看mysql文档对using index condition的描述</p>
<p>简单来说，mysql开启了ICP的话，可以减少存储引擎访问基表的次数</p>
<p>下面来简单的介绍一下这三者的区别</p>
<p>using index ：使用覆盖索引的时候就会出现</p>
<p>using where：在查找使用索引的情况下，需要回表去查询所需的数据</p>
<p>using index condition：查找使用了索引，但是需要回表查询数据</p>
<p>using index &amp; using where：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p>
<p>以上四点就能看出它们之前的区别，或许有部分人都存在疑惑 using index &amp; using where 和using index condition那个比较好，从上面的的解释中就能看出是前者比较好，毕竟不需要回表查询数据，效率上应该比较快的</p>
<p>总结</p>
<p>索引下推在非主键索引上的优化，可以有效减少回表的次数，大大提升了查询的效率。</p>
<p>关闭索引下推可以使用如下命令，配置文件的修改不再讲述了，毕竟这么优秀的功能干嘛关闭呢：</p>
<p>set optimizer_switch='index_condition_pushdown=off';
————————————————</p>
<h3 id="_9、假设现在有人操作数据库-不小心执行错了语句-误删除了很多数据-这时候能恢复吗-咋么恢复。" tabindex="-1"><a class="header-anchor" href="#_9、假设现在有人操作数据库-不小心执行错了语句-误删除了很多数据-这时候能恢复吗-咋么恢复。" aria-hidden="true">#</a> 9、假设现在有人操作数据库，不小心执行错了语句，误删除了很多数据，这时候能恢复吗？咋么恢复。</h3>
<p>答：首先，一定要开启 bin-log ，如果没有开启的话，可能就恢复不了。要看具体的文件系统是否能恢复。开启了 bin-log ，类型设置要设置成 row 或者 mixed ，不能设置 statement 。然后，如果是误删行的话，就可以把里面对应的删除事件换成插入事件，在备用库上执行。如果是误删表的话，可以先获取最近的一次全量备份，放到备库，然后拿出 bin-log ， 除了不执行删除的事件，其他事件依次重放。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222093232757.png" alt="image-20211222093232757"></p>
<h3 id="_10-为什么不能设置成-statement" tabindex="-1"><a class="header-anchor" href="#_10-为什么不能设置成-statement" aria-hidden="true">#</a> 10.为什么不能设置成 statement ？</h3>
<p>答：设置成 statement ，实际 bin-log 存储的是 sql 语句（ 非具体删除的主键id ），这样如果是主从架构的话，主和从可能因为选择的索引不一样而导致主从不一致。</p>
<h3 id="_11-你刚才说到主从-那你说说主从运行的机制吧" tabindex="-1"><a class="header-anchor" href="#_11-你刚才说到主从-那你说说主从运行的机制吧" aria-hidden="true">#</a> 11.你刚才说到主从，那你说说主从运行的机制吧</h3>
<p>答：首先主库还是要开启 bin-log ， 从库先设置要连接的主库 change master…… 然后执行 start slave，这时候从库会创建两个线程，一个 io_thread ，主要负责连接主数据库。一个sql_thread 主要是负责执行中转日志语句。首先，主库接收到从库的同步请求，根据传递的 bin-log 文件名和开始同步的位置，发送二进制文件给从库，从库 io_thread 负责把接收到的数据放入到中转日志，然后 sql_thread 负责从中转日志读取解析执行，执行完成，更新同步的位置标志。</p>
<h3 id="_12-你知道主从延迟吗-有些时候延迟的时间还会很长。遇到这种情况咋么办" tabindex="-1"><a class="header-anchor" href="#_12-你知道主从延迟吗-有些时候延迟的时间还会很长。遇到这种情况咋么办" aria-hidden="true">#</a> 12.你知道主从延迟吗？有些时候延迟的时间还会很长。遇到这种情况咋么办？</h3>
<p>答：这种问题，注意了。划重点。问你出现问题，寻找解决方案的时候，一定要对症下药，也就是说这个问题你可以这样考虑，什么情况下导致的主从延迟。</p>
<p>如果主库和从库服务器配置不一样，从库的差点，那么就可能导致延迟时间加长。这时候，换成相同的服务器配置服务器即可。</p>
<p>从库压力太大了。一般主从了，从库基本用来查询，比如可能运营或者开发者自己都在从库上进行一系列的 sql 操作。那简单呗。多配几个从库，分摊压力，一主多从。</p>
<p>大事务。比如 delete 这种语句 不 limit 限制一下，如果数据量过大，导致主库运行时都花费了长时间，再同步到从库，这个时间间隔过长。</p>
<h3 id="_13-数据表锁机制你知道哪几种-彼此区别是什么-在实际项目中怎么应用的" tabindex="-1"><a class="header-anchor" href="#_13-数据表锁机制你知道哪几种-彼此区别是什么-在实际项目中怎么应用的" aria-hidden="true">#</a> 13.数据表锁机制你知道哪几种？彼此区别是什么？在实际项目中怎么应用的？</h3>
<p>MySQL中的锁机制,按力度分为行级锁,页级锁,表级锁，其中按用法还分为共享锁和排他锁.</p>
<h6 id="行级锁" tabindex="-1"><a class="header-anchor" href="#行级锁" aria-hidden="true">#</a> 行级锁</h6>
<p>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。</p>
<p>行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁.</p>
<p><strong>特点：</strong></p>
<p>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
<p>用法：</p>
<p>共享锁(s 锁 读锁)</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/forma333t,png" alt="我能想到的MySQL各种锁机制都在这了，你知道几种？"></p>
<p>排他锁(x 锁 写锁 )</p>
<p>用法：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/format22222,png" alt="我能想到的MySQL各种锁机制都在这了，你知道几种？"></p>
<h6 id="表级锁" tabindex="-1"><a class="header-anchor" href="#表级锁" aria-hidden="true">#</a> 表级锁</h6>
<p>表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。</p>
<p>最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为共享锁和排他锁.</p>
<p>特点</p>
<p>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>
<p>用法</p>
<p>共享锁(s 锁 读锁)</p>
<p>用法：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/forma22t,png" alt="我能想到的MySQL各种锁机制都在这了，你知道几种？"></p>
<p>排他锁(x 锁 写锁 )</p>
<p>用法：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/for1mat,png" alt="我能想到的MySQL各种锁机制都在这了，你知道几种？"></p>
<h6 id="页级锁" tabindex="-1"><a class="header-anchor" href="#页级锁" aria-hidden="true">#</a> <strong>页级锁</strong></h6>
<p>页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。</p>
<p>表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁</p>
<p><strong>特点</strong></p>
<p>开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发度一般。</p>
<h6 id="乐观锁和悲观锁的思想" tabindex="-1"><a class="header-anchor" href="#乐观锁和悲观锁的思想" aria-hidden="true">#</a> <strong>乐观锁和悲观锁的思想</strong></h6>
<p>在数据库的锁机制中介绍过，数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。</p>
<p>乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>
<p>无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。</p>
<p>其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。</p>
<p>针对于不同的业务场景，应该选用不同的并发控制方式。所以，不要把乐观并发控制和悲观并发控制狭义的理解为DBMS中的概念，更不要把他们和数据中提供的锁机制（行锁、表锁、排他锁、共享锁）混为一谈。其实，在DBMS中，悲观锁正是利用数据库本身提供的锁机制来实现的。</p>
<h6 id="悲观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁" aria-hidden="true">#</a> <strong>悲观锁</strong></h6>
<p>在关系数据库管理系统里，悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。</p>
<p>如果一个事务执行的操作都进行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。</p>
<p>悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用所保护数据的成本要低于回滚事务的成本的环境中。</p>
<p>悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)</p>
<p>因此，在整个数据处理过程中，将数据处于锁定状态。</p>
<p>悲观锁的实现，往往依靠数据库提供的锁机制 （也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）</p>
<p><strong>在数据库中，悲观锁的流程如下：</strong></p>
<p>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）</p>
<p>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。</p>
<p>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</p>
<p>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</p>
<h6 id="mysql-innodb中使用悲观锁" tabindex="-1"><a class="header-anchor" href="#mysql-innodb中使用悲观锁" aria-hidden="true">#</a> <strong>MySQL InnoDB中使用悲观锁</strong></h6>
<p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式</p>
<p>也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/format14,png" alt="我能想到的MySQL各种锁机制都在这了，你知道几种？"></p>
<p><strong>优点与不足</strong></p>
<p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。</p>
<p>但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；</p>
<p>另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；</p>
<p>还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数</p>
<h6 id="乐观锁" tabindex="-1"><a class="header-anchor" href="#乐观锁" aria-hidden="true">#</a> <strong>乐观锁</strong></h6>
<p>在关系数据库管理系统里，乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。</p>
<p>它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。</p>
<p>在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>
<p>乐观事务控制最早是由孔祥重（H.T.Kung）教授提出。</p>
<p>乐观说（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突</p>
<p>所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测</p>
<p>如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p>
<p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p>
<p>数据版本,为数据增加的一个版本标识。当读取数据时，将版本标识的值一同读出，数据每更新一次，同时对版本标识进行更新。</p>
<p>当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的版本标识进行比对，如果数据库表当前版本号与第一次取出来的版本标识值相等，则予以更新，否则认为是过期数据。</p>
<p>实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。</p>
<p>乐观锁使用CAS（Compare And Swep）操作保证数据一致性</p>
<h6 id="使用版本号实现乐观锁" tabindex="-1"><a class="header-anchor" href="#使用版本号实现乐观锁" aria-hidden="true">#</a> <strong>使用版本号实现乐观锁</strong></h6>
<p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<p>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p>
<p>但如果直接简单这么做，还是有可能会遇到不可预期的结果，例如两个事务都读取了数据库的某一行，经过修改以后写回数据库，这时就遇到了问题。</p>
<h6 id="mysql常用存储引擎的锁机制" tabindex="-1"><a class="header-anchor" href="#mysql常用存储引擎的锁机制" aria-hidden="true">#</a> <strong>MySQL常用存储引擎的锁机制</strong></h6>
<p>MyISAM和MEMORY采用表级锁(table-level locking)</p>
<p>BDB采用页面锁(page-level locking)或表级锁，默认为页面锁</p>
<p>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</p>
<h6 id="innodb中的行锁与表锁" tabindex="-1"><a class="header-anchor" href="#innodb中的行锁与表锁" aria-hidden="true">#</a> Innodb中的行锁与表锁</h6>
<p>InnoDB行锁是通过给索引上的索引项加锁来实现的，这一点MySQL与Oracle不同，后者是通过在数据块中对相应数据行加锁来实现的。</p>
<p>InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！</p>
<p>在实际应用中，要特别注意InnoDB行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。</p>
<p>在不通过索引条件查询的时候,InnoDB 确实使用的是表锁,而不是行锁。
由于 MySQL 的行锁是针对索引加的锁,不是针对记录加的锁,所以虽然是访问不同行的记录,但是如果是使用相同的索引键,是会出现锁冲突的。应用设计的时候要注意这一点。
当表有多个索引的时候,不同的事务可以使用不同的索引锁定不同的行,另外,不论 是使用主键索引、唯一索引或普通索引,InnoDB 都会使用行锁来对数据加锁。
即便在条件中使用了索引字段,但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的,如果 MySQL 认为全表扫效率更高,比如对一些很小的表,它就不会使用索引,这种情况下 InnoDB 将使用表锁,而不是行锁。因此,在分析锁冲突时, 别忘了检查 SQL 的执行计划,以确认是否真正使用了索引。</p>
<h6 id="行级锁与死锁" tabindex="-1"><a class="header-anchor" href="#行级锁与死锁" aria-hidden="true">#</a> <strong>行级锁与死锁</strong></h6>
<p>MyISAM中是不会产生死锁的，因为MyISAM总是一次性获得所需的全部锁，要么全部满足，要么全部等待。</p>
<p>而在InnoDB中，锁是逐步获得的，就造成了死锁的可能。</p>
<p>在MySQL中，行级锁并不是直接锁记录，而是锁索引。</p>
<p>索引分为主键索引和非主键索引两种，如果一条sql语句操作了主键索引，MySQL就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL会先锁定该非主键索引，再锁定相关的主键索引。</p>
<p>在UPDATE、DELETE操作时，MySQL不仅锁定WHERE条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的next-key locking。</p>
<p>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。</p>
<p>发生死锁后，InnoDB一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p>
<h6 id="避免死锁-这里只介绍常见的三种" tabindex="-1"><a class="header-anchor" href="#避免死锁-这里只介绍常见的三种" aria-hidden="true">#</a> 避免死锁，这里只介绍常见的三种：</h6>
<p>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会
在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率
对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过升级锁定来减少死锁产生的概率
————————————————
版权声明：本文为CSDN博主「Java全能架构师」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_48182198/article/details/108055088</p>
<h3 id="_14-谈谈悲观锁与乐观锁的区别与联系" tabindex="-1"><a class="header-anchor" href="#_14-谈谈悲观锁与乐观锁的区别与联系" aria-hidden="true">#</a> 14.谈谈悲观锁与乐观锁的区别与联系？</h3>
<p>答：
悲观锁：顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。
传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>乐观锁： 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。</p>
<p>悲观锁和乐观锁的区别：</p>
<p>​          两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适。</p>
<h3 id="_14-2-请说说-mysql-的锁机制" tabindex="-1"><a class="header-anchor" href="#_14-2-请说说-mysql-的锁机制" aria-hidden="true">#</a> 14.2.请说说 MySQL 的锁机制？</h3>
<p>表锁是日常开发中的常见问题，因此也是面试当中最常见的考察点，当多个查询同一时刻进行数据修改时，就会产生并发控制的问题。MySQL 的共享锁和排他锁，就是读锁和写锁。</p>
<p>共享锁：不堵塞，多个用户可以同时读一个资源，互不干扰。
排他锁：一个写锁会阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用户读取正在写入的资源。
? 锁的粒度？</p>
<p>表锁：系统开销最小，会锁定整张表，MyIsam 使用表锁。
行锁：最大程度的支持并发处理，但是也带来了最大的锁开销，InnoDB 使用行锁。
? 什么是悲观锁？什么是乐观锁？</p>
<p>1）悲观锁</p>
<p>它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。</p>
<p>在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p>
<p>2）乐观锁</p>
<p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p>
<p>而乐观锁机制在一定程度上解决了这个问题。乐观锁，大多是基于数据版本（ Version ）记录机制实现。何谓数据版本？即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p>
<p>什么是死锁？</p>
<p>多数情况下，可以认为如果一个资源被锁定，它总会在以后某个时间被释放。而死锁发生在当多个进程访问同一数据库时，其中每个进程拥有的锁都是其他进程所需的，由此造成每个进程都无法继续下去。简单的说，进程 A 等待进程 B 释放他的资源，B 又等待 A 释放他的资源，这样就互相等待就形成死锁。</p>
<p>虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件：</p>
<p>互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合 {P0，P1，P2，•••，Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源，……，Pn 正在等待已被 P0 占用的资源。
下列方法有助于最大限度地降低死锁：</p>
<p>设置获得锁的超时时间。</p>
<p>通过超时，至少保证最差最差最差情况下，可以有退出的口子。</p>
<p>按同一顺序访问对象。</p>
<p>这个是最重要的方式。</p>
<p>避免事务中的用户交互。</p>
<p>保持事务简短并在一个批处理中。</p>
<p>使用低隔离级别。</p>
<p>使用绑定连接。</p>
<h3 id="_15-浅谈innodb的next-key-locking策略" tabindex="-1"><a class="header-anchor" href="#_15-浅谈innodb的next-key-locking策略" aria-hidden="true">#</a> 15.浅谈InnoDB的next-key locking策略</h3>
<p>InnoDB 存储引擎默认隔离级别为可重复读（Repeatable Read），该隔离级别下加行锁采用的是next-key locking 策略。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/SouthEast1" alt="img"></p>
<p>InnoDB支持行锁（锁定字段含有索引的情况下，否则走表锁），但锁定方式并非简单的锁定指定行上的索引，而是分为3种锁定算法：
1）记录锁（Record Locks）：锁定指定行的索引项
2）Gap Locks：锁定某一个范围内的索引，但不包括记录本身
3）间隙锁定（Next-Key Locks）：锁定一个范围内的索引，并且锁定记录本身   Next-Key Locks = Record Locks + Gap Locks
A next-key lock is a combination of a record lock on the index record and a gap lock on the gap before the index record</p>
<p>InnoDB在默认配置下（隔离级别：可重复读；innodb_locks_unsafe_for_binlog=OFF：采用gap locking），对于索引的查询采用 next-key locks。这样做避免了幻读现象的产生。
By default, InnoDB operates in REPEATABLE READ transaction isolation level and with the innodb_locks_unsafe_for_binlog system variable disabled. In this case, InnoDB uses next-key locks for searches and index scans, which prevents phantom rows
特别的，
1、当锁定的索引项含有唯一属性的时候，Next-Key Lock 会进行优化，将其降级为Record Lock，即仅锁住索引本身，不是范围。
2、当唯一索引是由多个列组成，而query仅查询多个列中的其中一个，则依然使用 Next-key lock。
3、通过主键或者唯一索引来锁定不存在的值，则依然使用 Next-key lock。。</p>
<p>强制关闭Gap Lock，仅使用记录锁从而避免阻塞（有幻读的风险）：配置参数 innodb_locks_unsafe_for_binlog = 1 或者隔离级别设为 READ COMMITTED
By default, the value of innodb_locks_unsafe_for_binlog is 0 (disabled), which means that gap locking is enabled: InnoDB uses next-key locks for searches and index scans. To enable the variable, set it to 1. This causes gap locking to be disabled: InnoDB uses only index-record locks for searches and index scans.
The effects of enabling innodb_locks_unsafe_for_binlog are the same as setting the transaction isolation level toREAD COMMITTED</p>
<p>（1）采用next-key locks的InnoDB无法插入除了锁定行外的其他行的测试案例：</p>
<p>http://www.cnblogs.com/zhoujinyi/p/3435982.html
（2）何登成 --- MySQL加锁处理分析</p>
<p>http://hedengcheng.com/?p=771
（3）《深入浅出MySQL数据库开发优化与管理维护》开发篇
（4）https://dev.mysql.com/doc/refman/5.5/en/innodb-locking.html
（5）https://dev.mysql.com/doc/refman/5.5/en/innodb-consistent-read.html
————————————————
版权声明：本文为CSDN博主「leonpenn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/leonpenn/article/details/72832010</p>
<h3 id="_16-对mysql数据库缓存和非缓存有过了解吗-怎么应用的" tabindex="-1"><a class="header-anchor" href="#_16-对mysql数据库缓存和非缓存有过了解吗-怎么应用的" aria-hidden="true">#</a> 16.对mysql数据库缓存和非缓存有过了解吗？怎么应用的？</h3>
<p><strong>MySQL数据库的缓存：</strong></p>
<p>每进行一次select查询，会在SQL层的查询缓存模块的cache中分配一个key，value为查询的结果，当再次查询时，会去匹配这个key，如果有的话则直接返回value，就不需要经过命令解析器和存储引擎层了，所以速度更快。但是，当执行了增、删、改操作之后，该cache缓存就会被清空。</p>
<p>需要注意的是，SQL语句的大小写很重要，大小写会被识别为不同的语句。例如：</p>
<p>select * from table</p>
<p>SELECT * FROM TABLE</p>
<p>以上两句SQL语句会被识别为两条SQL，并不会使用缓存。</p>
<p>先，SHOW VARIABLES LIKE 'query_cache%'，查询缓存开启情况，ON为开启（此处是MySQL5.5，默认为开启）</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/969363-20210205220858584-1641720978.png" alt="img"></p>
<p>再通过，SHOW STATUS LIKE '%qcache%'，查询缓存效果</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/969363-20210205222138444-637311485.png" alt="img"></p>
<p>Qcache_hits：数值越大表明查询缓冲使用的非常频繁。</p>
<p>Qcache_free_memory：缓存空闲空间，如果值很小，则表明空间不够了。</p>
<p>Qcache_not_cached：没有进入查询缓存的select个数。</p>
<h3 id="_17-mysql的缓冲查询和非缓冲查询" tabindex="-1"><a class="header-anchor" href="#_17-mysql的缓冲查询和非缓冲查询" aria-hidden="true">#</a> 17.mysql的缓冲查询和非缓冲查询</h3>
<p>最近在开发一个PHP程序时遇到了下面的错误：</p>
<blockquote>
<p>PHP Fatal error: Allowed memory size of 268 435 456 bytes exhausted</p>
</blockquote>
<p>错误信息显示允许的最大内存已经耗尽。遇到这样的错误起初让我很诧异，但转眼一想，也不奇怪，因为我正在开发的这个程序是要用一个<code v-pre>foreach</code>循环语句在一个有4万条记录的表里全表搜索具有特定特征的数据，也就是说，一次要把4万条数据取出，然后逐条检查每天数据。可想而知，4万条数据全部加载到内存中，内存不爆才怪。</p>
<p>毕竟编程这么多年，我隐约记得PHP里提供有非一次全部加载数据的API，是像处理流媒体那样，随用随取随丢、数据并不会积累在内存的查询方法。经过简单的搜索，果然在官方网站上找到的正确的用法。</p>
<p>这个问题在PHP的官方网站上叫<a href="http://php.net/manual/zh/mysqlinfo.concepts.buffering.php" target="_blank" rel="noopener noreferrer">缓冲查询和非缓冲查询(Buffered and Unbuffered queries)<ExternalLinkIcon/></a>。PHP的查询缺省模式是缓冲模式。也就是说，查询数据结果会一次全部提取到内存里供PHP程序处理。这样给了PHP程序额外的功能，比如说，计算行数，将指针指向某一行等。更重要的是程序可以对数据集反复进行二次查询和过滤等操作。但这种缓冲查询模式的缺陷就是消耗内存，也就是用空间换速度。</p>
<p>相对的，另外一种PHP查询模式是非缓冲查询，数据库服务器会一条一条的返回数据，而不是一次全部返回，这样的结果就是PHP程序消耗较少的内存，但却增加了数据库服务器的压力，因为数据库会一直等待PHP来取数据，一直到数据全部取完。</p>
<p>很显然，缓冲查询模式适用于小数据量查询，而非缓冲查询适应于大数据量查询。</p>
<p>对于PHP的缓冲模式查询大家都知道，下面列举的例子是如何执行非缓冲查询API。</p>
<h4 id="非缓冲查询方法一-mysqli" tabindex="-1"><a class="header-anchor" href="#非缓冲查询方法一-mysqli" aria-hidden="true">#</a> 非缓冲查询方法一: mysqli</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
$mysqli  = new mysqli("localhost", "my_user", "my_password", "world");
$uresult = $mysqli->query("SELECT Name FROM City", MYSQLI_USE_RESULT);

if ($uresult) {
   while ($row = $uresult->fetch_assoc()) {
       echo $row['Name'] . PHP_EOL;
   }
}
$uresult->close();
?>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="非缓冲查询方法二-pdo-mysql" tabindex="-1"><a class="header-anchor" href="#非缓冲查询方法二-pdo-mysql" aria-hidden="true">#</a> 非缓冲查询方法二: pdo_mysql</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
$pdo = new PDO("mysql:host=localhost;dbname=world", 'my_user', 'my_pass');
$pdo->setAttribute(PDO::MYSQL_ATTR_USE_BUFFERED_QUERY, false);

$uresult = $pdo->query("SELECT Name FROM City");
if ($uresult) {
   while ($row = $uresult->fetch(PDO::FETCH_ASSOC)) {
       echo $row['Name'] . PHP_EOL;
   }
}
?>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="非缓冲查询方法三-mysql" tabindex="-1"><a class="header-anchor" href="#非缓冲查询方法三-mysql" aria-hidden="true">#</a> 非缓冲查询方法三: mysql</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
$conn = mysql_connect("localhost", "my_user", "my_pass");
$db   = mysql_select_db("world");

$uresult = mysql_unbuffered_query("SELECT Name FROM City");
if ($uresult) {
   while ($row = mysql_fetch_assoc($uresult)) {
       echo $row['Name'] . PHP_EOL;
   }
}
?>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>注：引之 http://www.webhek.com/php-buffered-and-unbuffered-queries</p>
<p>手册资料 http://php.net/manual/zh/mysqlinfo.concepts.buffering.php</p>
<h3 id="_18-mysql把一个大表拆分多个表后-如何解决跨表查询效率问题" tabindex="-1"><a class="header-anchor" href="#_18-mysql把一个大表拆分多个表后-如何解决跨表查询效率问题" aria-hidden="true">#</a> 18.mysql把一个大表拆分多个表后，如何解决跨表查询效率问题？</h3>
<p>大表分表后每个表的结构相同，可以用sql的union</p>
<p>比如a,b表结构相同可以通过union来联接</p>
<p>select * from a
union all
select * from b
where
。。。。</p>
<p>其实你还可以建一张主表将你要连表查询的字段放在其中，做好索引；你还记录下用户经常查询的条件，把查出的数据缓存，以便用户经常调用。</p>
<p>大表分表后每个表的结构相同，可以用sql的union。比如a,b表结构相同可以通过union来联接</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>select * from a
union all
select * from b
where ...
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、Union和Union All到底有什么区别</p>
<p>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；</p>
<p>Union All：对两个结果集进行并集操作，包括重复行，不进行排序；</p>
<p>比如一家公司在中美均有雇员，我们使用Union这个命令想查出中美所有雇员，是不行的。假如我们有两个名字相同的雇员，他们当中就只会有一个人被列出来了。UNION 命令只会选取不同的值。而Union All则可以查出全部的值。</p>
<p>详细了解：https://www.w3school.com.cn/sql/sql_union.asp</p>
<p>2、大表拆分后的查询效率问题</p>
<p>假如一个超级大的用户表按照数据拆分成10个表后，某个用户登录的时候是不是要从10个表里面去查询这个用户的用户名和密码是否正确。这样就存在效率问题。</p>
<p>一种方案就是拆表的时候，按照一定规则来拆表，查询的时候按照这个规则来查，通过规则就能知道到底该去哪个表查，如果胡乱拆表，那一个表和10个表有什么区别。</p>
<p>3、大表拆分</p>
<p>表的拆分分为横向拆分（记录的拆分）和纵向拆分（字段的拆分）。拆分表的目的：提高查询速度。</p>
<p>（1）横向拆分</p>
<p>我们从一个案例去解释，情景是这样的：某某博客，有50W的博客量，有2w的用户，发现随着用户和博客数的增加，查询速度日渐下降，现在要对博客表blog与用户表user进行优化。</p>
<p>表结构如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>create table blog(
        bid
        title
        content
        pubtime
        uid
    ) 50万
create table user(
        uid
        username
        password
        nick
        ......
    )  2万
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>首先我们要决定根据哪个字段对记录进行拆分，查询决定了拆分，在这里我们根据uid字段对两个表进行拆分是比较合理的。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>博客表根据uid去拆分：
    1-5000------blog_1
    5001-10000-----blog_2
    10001-15000----blog_3
    15001-20000----blog_4
人员表根据uid 等分：
    1-5000------user_1
    5001-10000-----user_2
    10001-15000----user_3
    15001-20000----user_4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>比如查询某人的博客：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>// 根据uid确认表名：
     $num=ceil(12345/5000)；
     select uid,bid,title,pubtime from blog_$num where uid=12345；
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（2）纵向拆分：把活跃字段（常用）、惰性字段（不常用）分开。</p>
<p>案例：比如人员表，活跃字段像用户名、密码、昵称等，惰性字段像手机号、邮箱、性别等不经常使用和修改的字段。</p>
<p>一张完整的用户表可以拆分为两张表，如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>create table user(
    uid int key auto_increment,
    username char(20),
    password char(32) not null, 
    nick char(10)
);
create table user_ext(
    uid
    regtime
    name
    email
    qq
    phone
    sex    
)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_19-我们都知道可以通过索引对数据库查询进行优化-mysql支持哪些索引-不同索引之间的性能对比如何-索引越多越好吗" tabindex="-1"><a class="header-anchor" href="#_19-我们都知道可以通过索引对数据库查询进行优化-mysql支持哪些索引-不同索引之间的性能对比如何-索引越多越好吗" aria-hidden="true">#</a> 19.我们都知道可以通过索引对数据库查询进行优化，MySQL支持哪些索引，不同索引之间的性能对比如何？索引越多越好吗？</h3>
<p>MySQL 索引是为了帮助快速查询数据的数据结构，我们平常对数据库的操作大部分是读多写少，合理设置索引，可以有效提高查询效率，但索引需要额外处理和存储，因此在写入的时候性能要比不使用索引差。</p>
<p>MySQL 索引属于存储引擎级别的概念，我们比较熟悉的存储引擎是 MyISAM 和 InnoDB，后者支持事务、外键和行级锁，所以我们日常使用 InnoDB 更多。两者支持的索引和对索引的处理也不尽相同。</p>
<p>我们日常常见的索引有以下四个：主键索引（PRIMARY）、唯一索引（UNIQUE）、普通索引（INDEX）和全文索引（FULLTEXT）。我们可以在指定字段上设置索引，也可以组合几个字段设置索引。从查询性能上说，一般它们的优先级是这样的：主键索引&gt;唯一索引&gt;普通索引&gt;全文索引。</p>
<p>在 MyISAM 中，索引和数据是分离的，所以允许数据表没有主键，而 InnoDB 中索引和数据是一体的，表数据本身就是主索引，并且按照主键聚集，所以必须包含主键，此外 InnoDB 不再支持 FULLTEXT 全文索引，因为全文索引通常用于实现全文搜索，如果不支持分词的话这个查询很鸡肋，我们现在一般借助搜索引擎来实现类似搜索功能。</p>
<h3 id="_20-请简单介绍下数据库事务的定义及其作用-有哪些特性-以及在php或者你所使用的框架中如何实现-数据库事务能保证并发操作的原子性问题吗" tabindex="-1"><a class="header-anchor" href="#_20-请简单介绍下数据库事务的定义及其作用-有哪些特性-以及在php或者你所使用的框架中如何实现-数据库事务能保证并发操作的原子性问题吗" aria-hidden="true">#</a> 20.请简单介绍下数据库事务的定义及其作用，有哪些特性，以及在PHP或者你所使用的框架中如何实现，数据库事务能保证并发操作的原子性问题吗？</h3>
<p>一般地，我们看到事务，脑袋蹦出的可能很直接“要么都成功，要么都失败”。
实际上，数据库事务指的是满足 ACID 特性（原子性、一致性、隔离性、持久性）的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。一个数据库事务通常是包含对数据库进行读或写的一个操作序列，目的在于保证操作序列的完整性。</p>
<p>在并发环境下，数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读 （non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，于是就有了“隔离级别”的概念。
Laravel 使用事务的基本实现原理应该是通过 savepoint。</p>
<h6 id="重点-原子性不能完全保障一致性。所以数据库事务不能保证并发操作的原子性问题。" tabindex="-1"><a class="header-anchor" href="#重点-原子性不能完全保障一致性。所以数据库事务不能保证并发操作的原子性问题。" aria-hidden="true">#</a> 重点：原子性不能完全保障一致性。所以数据库事务不能保证并发操作的原子性问题。</h6>
<h6 id="原子性、一致性的实现机制是什么" tabindex="-1"><a class="header-anchor" href="#原子性、一致性的实现机制是什么" aria-hidden="true">#</a> 原子性、一致性的实现机制是什么</h6>
<p>这个问题的有趣之处，不在于问题本身（“原子性、一致性的实现机制是什么”），而在于回答者的分歧反映出来的另外一个问题：原子性和一致性之间的关系是什么？</p>
<p>我特别关注了@我练功发自真心 的答案，他正确地指出了，为了保证事务操作的原子性，必须实现基于日志的REDO/UNDO机制。但这个答案仍然是不完整的，因为原子性并不能够完全保证一致性。</p>
<p>按照我个人的理解，在事务处理的ACID属性中，一致性是最基本的属性，其它的三个属性都为了保证一致性而存在的。</p>
<p>首先回顾一下一致性的定义。所谓一致性，指的是数据处于一种有意义的状态，这种状态是语义上的而不是语法上的。最常见的例子是转帐。例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。</p>
<p>在数据库实现的场景中，一致性可以分为数据库外部的一致性和数据库内部的一致性。前者由外部应用的编码来保证，即某个应用在执行转帐的数据库操作时，必须在同一个事务内部调用对帐户A和帐户B的操作。如果在这个层次出现错误，这不是数据库本身能够解决的，也不属于我们需要讨论的范围。后者由数据库来保证，即在同一个事务内部的一组操作必须全部执行成功（或者全部失败）。这就是事务处理的原子性。</p>
<p>为了实现原子性，需要通过日志：将所有对数据的更新操作都写入日志，如果一个事务中的一部分操作已经成功，但以后的操作，由于断电/系统崩溃/其它的软硬件错误而无法继续，则通过回溯日志，将已经执行成功的操作撤销，从而达到“全部操作失败”的目的。最常见的场景是，数据库系统崩溃后重启，此时数据库处于不一致的状态，必须先执行一个crash recovery的过程：读取日志进行REDO（重演将所有已经执行成功但尚未写入到磁盘的操作，保证持久性），再对所有到崩溃时尚未成功提交的事务进行UNDO（撤销所有执行了一部分但尚未提交的操作，保证原子性）。crash recovery结束后，数据库恢复到一致性状态，可以继续被使用。</p>
<p>日志的管理和重演是数据库实现中最复杂的部分之一。如果涉及到并行处理和分布式系统（日志的复制和重演是数据库高可用性的基础），会比上述场景还要复杂得多。</p>
<p>但是，原子性并不能完全保证一致性。在多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。例如，事务1需要将100元转入帐号A：先读取帐号A的值，然后在这个值上加上100。但是，在这两个操作之间，另一个事务2修改了帐号A的值，为它增加了100元。那么最后的结果应该是A增加了200元。但事实上， 事务1最终完成后，帐号A只增加了100元，因为事务2的修改结果被事务1覆盖掉了。</p>
<p>为了保证并发情况下的一致性，引入了隔离性，即保证每一个事务能够看到的数据总是一致的，就好象其它并发事务并不存在一样。用术语来说，就是多个事务并发执行后的状态，和它们串行执行后的状态是等价的。怎样实现隔离性，已经有很多人回答过了，原则上无非是两种类型的锁：</p>
<p>一种是悲观锁，即当前事务将所有涉及操作的对象加锁，操作完成后释放给其它对象使用。为了尽可能提高性能，发明了各种粒度（数据库级/表级/行级……）/各种性质（共享锁/排他锁/共享意向锁/排他意向锁/共享排他意向锁……）的锁。为了解决死锁问题，又发明了两阶段锁协议/死锁检测等一系列的技术。</p>
<p>一种是乐观锁，即不同的事务可以同时看到同一对象（一般是数据行）的不同历史版本。如果有两个事务同时修改了同一数据行，那么在较晚的事务提交时进行冲突检测。实现也有两种，一种是通过日志UNDO的方式来获取数据行的历史版本，一种是简单地在内存中保存同一数据行的多个历史版本，通过时间戳来区分。</p>
<p>锁也是数据库实现中最复杂的部分之一。同样，如果涉及到分布式系统（分布式锁和两阶段提交是分布式事务的基础），会比上述场景还要复杂得多。</p>
<p>@我练功发自真心 提到，其他回答者说的其实是操作系统对atomic的理解，即并发控制。我不能完全同意这一点。数据库有自己的并发控制和锁问题，虽然在原理上和操作系统中的概念非常类似，但是并不是同一个层次上的东西。数据库中的锁，在粒度/类型/实现方式上和操作系统中的锁都完全不同。操作系统中的锁，在数据库实现中称为latch（一般译为闩）。其他回答者回答的其实是“在并行事务处理的情况下怎样保证数据的一致性”。</p>
<p>最后回到原来的问题（“原子性、一致性的实现机制是什么”）。我手头有本Database System Concepts（4ed，有点老了），在第15章的开头简明地介绍了ACID的概念及其关系。如果你想从概念上了解其实现，把这本书的相关章节读完应该能大概明白。如果你想从实践上了解其实现，可以找innodb这样的开源引擎的源代码来读。不过，即使是一个非常粗糙的开源实现（不考虑太复杂的并行处理，不考虑分布式系统，不考虑针对操作系统和硬件的优化之类），要基本搞明白恐怕也不是一两年的事。
————————————————
版权声明：本文为CSDN博主「suerge_storm」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/suerge_storm/article/details/90484944</p>
<h3 id="_21-什么是数据库主从分离-为什么要做主从分离-主从分离要怎么设计-主从之间的数据同步是怎么做的-针对主从分离网络延迟导致的数据不一致-你会怎么处理" tabindex="-1"><a class="header-anchor" href="#_21-什么是数据库主从分离-为什么要做主从分离-主从分离要怎么设计-主从之间的数据同步是怎么做的-针对主从分离网络延迟导致的数据不一致-你会怎么处理" aria-hidden="true">#</a> 21.什么是数据库主从分离？为什么要做主从分离？主从分离要怎么设计，主从之间的数据同步是怎么做的？针对主从分离网络延迟导致的数据不一致，你会怎么处理？</h3>
<h6 id="读写分离的定义" tabindex="-1"><a class="header-anchor" href="#读写分离的定义" aria-hidden="true">#</a> 读写分离的定义：</h6>
<p>读写分离通常指的是让主库进行事务性查询（插入、更新、删除）操作，而让从库进行 SELECT 查询操作，通俗来说，就是主库写、从库读。</p>
<h6 id="读写分离的意义" tabindex="-1"><a class="header-anchor" href="#读写分离的意义" aria-hidden="true">#</a> 读写分离的意义：</h6>
<p>对大部分 web 应用而言，都是读多写少，我们设计一主多从，可以提高系统的并发处理能力；
增加冗余备份，一处写入（主），多处同步（从），可以提高系统的可用性；
读写分离，让主库专注于写，让读库专注于读，区分优化读库和写库，从而提升数据库性能。</p>
<h6 id="读写分离的实现" tabindex="-1"><a class="header-anchor" href="#读写分离的实现" aria-hidden="true">#</a> 读写分离的实现：</h6>
<p>通过读写分离的定义，我们知道，所谓读写分离，就是写入操作都在主库完成，查询操作都在从库完成。</p>
<p>所以在代码层级，我们需要将查询和写入操作区分开，通过不同的数据库连接实现，对于简单的读写分离，通过配置文件完成即可，对于多个主库/从库，从配置数组中随机选取一个建立连接即可，对于更复杂的数据库集群，可以通过数据库中间件来建立连接。</p>
<p>在数据库级别，我们要实现主库记录通过同步机制实时同步到从库，以便随时可以从从库查询到最新记录，关于这一块可以通过配置主库和从库通过 binlog 日志实现数据同步复制。</p>
<h6 id="数据延迟" tabindex="-1"><a class="header-anchor" href="#数据延迟" aria-hidden="true">#</a> 数据延迟</h6>
<p>binlog 同步机制简单方便，但是由于需要从库通过网络请求去主库拉取数据，对于高并发场景，可能会由于系统负载、网络延迟问题导致从库和主库短期内的数据不一致（毫秒级或者秒级），针对这种情况，对于简单的中小型系统，可以在写入操作完成后强制查询操作使用主库连接来解决，比如 Laravel 的数据库 sticky 配置项底层实现就是这么干的，此外我们还可以借助缓存层来解决这种不一致性，然后主从同步之后触发缓存更新。</p>
<p>需要注意的是，在分布式系统中，绝对的数据一致性是无法保证的，我们必须在 CAP 中找到一个平衡。</p>
<h3 id="_22-对于大型应用系统-数据库-sql-优化、读写分离、添加缓存之后-往往还是满足不了系统的并发处理要求-这个时候往往就要进行垂直拆分和水平拆分-以进一步提高数据库负载能力-说说你对数据库水平拆分和垂直拆分的理解-以及面对这样的数据库系统改造-从代码层面和数据库层面我们要注意哪些问题-如果需要你去做这样的系统改造-你会怎么设计" tabindex="-1"><a class="header-anchor" href="#_22-对于大型应用系统-数据库-sql-优化、读写分离、添加缓存之后-往往还是满足不了系统的并发处理要求-这个时候往往就要进行垂直拆分和水平拆分-以进一步提高数据库负载能力-说说你对数据库水平拆分和垂直拆分的理解-以及面对这样的数据库系统改造-从代码层面和数据库层面我们要注意哪些问题-如果需要你去做这样的系统改造-你会怎么设计" aria-hidden="true">#</a> 22.对于大型应用系统，数据库 SQL 优化、读写分离、添加缓存之后，往往还是满足不了系统的并发处理要求，这个时候往往就要进行垂直拆分和水平拆分，以进一步提高数据库负载能力，说说你对数据库水平拆分和垂直拆分的理解，以及面对这样的数据库系统改造，从代码层面和数据库层面我们要注意哪些问题，如果需要你去做这样的系统改造，你会怎么设计？</h3>
<p>数据库的垂直拆分和水平拆分</p>
<p>所谓垂直拆分指的是按照业务类型对原来存放在一个数据库中的表进行分类，然后 按照分类将数据库拆分成多个子库，比如用户库、商品库、交易库等。</p>
<p>随着业务增长，垂直分库还是会遇到单体瓶颈，比如库存表，每次交易、下单、秒杀都会涉及到频繁修改库存表，当业务到达一定级别，可能导致库存表单体性能瓶颈，这个时候，我们就需要对其进行水平拆分。</p>
<p>相对于垂直拆分把不同表拆分到不同数据库，水平拆分指的是把同一张表进行拆分，这个「水平」可以理解为按照表的数据行进行切分，把一张表拆分成多个表，如果是水平分表，则拆分后的表可以存放到同一个库，如果是水平分库分表，还要把拆分后的表放到不同数据库。</p>
<p>垂直拆分和水平拆分需要注意的问题</p>
<p>垂直拆分和水平拆分都是为了提高数据库负载和并发处理能力，但是引入它们也增加了系统的复杂度，垂直拆分还要好一些，尤其是水平拆分，如何拆分，拆分后如何查询，都是比较棘手的问题。</p>
<p>它们引入的主要共同问题包括：</p>
<p>分布式事务一致性如何解决
跨库 join 查询如何处理
分库分表后数据的扩展和维护难度增加
对于水平拆分，还有一些更加棘手的问题：</p>
<p>主键 ID 唯一性在分布式数据表中如何保证
数据拆分到不同表中聚合查询如何做
垂直拆分遇到瓶颈还可以考虑水平拆分，水平拆分再度遇到瓶颈如何对数据进行扩容？
这些问题都是我们需要在拆分前考虑好对应解决方案的。这些问题处理起来都不简单，所以数据库拆分一定要慎重，而不是一拍脑门下决定，它应该放到 SQL 语句优化、表结构优化（索引、分表）、引入缓存系统、读写分离之后，并且再细分的话，把水平拆分放到垂直拆分之后，因为它最复杂。</p>
<p><strong>垂直拆分和水平拆分的实现</strong></p>
<p>万不得已，必须要做垂直拆分和水平拆分的话，我们接下来看看如何做。</p>
<p>垂直拆分相对简单，需要先对系统业务进行分类，一般系统模块很好划分，比如用 户、商品、交易、售后等，然后把相关表都拆分到对应子系统中，一般来说，垂直拆分可以伴随着服务拆分（微服务、服务化）改造同步进行，这样每一个服务子系统访问对应的子库即可，这样也有利于权责划分，商品系统没有访问用户系统数据库的权限，只能通过用户服务提供的接口对数据进行访问和修改。在代码层面我们需要做好数据库事务和跨库 join 代码的改造。</p>
<p>水平拆分相对复杂，需要先规划好切分维度，比如范围、时间、取模、哈希等，然后一般规划拆分后单表数据在1000万以内，比如我们对一个预计容量在1亿的表进行水平拆分，按照对主键 ID 取模的维度分表，可以通过 ID % 10 去指定表查询数据，对于唯一主键不能再通过数据库自增的 ID 来解决，可以借助 UUID 之类的解决方案，对于聚合查询和分页查询，也要做限制，比如用户只能看多少页数据，或者必须按照切分维度进行查询，一定要排除全表扫描的可能，分库的话设计到数据库事务和跨库 join 的代码也要调整，比如我之前的公司不再使用数据库事务并在代码中杜绝使用 join 查询。</p>
<p>在具体实践中，可以借助数据库中间件来做分库分表，比如 Cobar 等，但是一定建立在你对分库分表底层的东西非常熟悉，否则一旦出现问题，那是灾难性的。</p>
<h3 id="_23-假设我们有一个商城订单表-用来保存用户订单信息-现在这张表数据容量达到亿级-影响到交易并发量-需要进行拆分-你会从哪些维度对它进行拆分-并列举出你选择方案的优缺点。" tabindex="-1"><a class="header-anchor" href="#_23-假设我们有一个商城订单表-用来保存用户订单信息-现在这张表数据容量达到亿级-影响到交易并发量-需要进行拆分-你会从哪些维度对它进行拆分-并列举出你选择方案的优缺点。" aria-hidden="true">#</a> 23.假设我们有一个商城订单表，用来保存用户订单信息，现在这张表数据容量达到亿级，影响到交易并发量，需要进行拆分，你会从哪些维度对它进行拆分，并列举出你选择方案的优缺点。</h3>
<h3 id="_24-常见的关系型数据库管理系统产品有" tabindex="-1"><a class="header-anchor" href="#_24-常见的关系型数据库管理系统产品有" aria-hidden="true">#</a> 24.常见的关系型数据库管理系统产品有？</h3>
<p>答：Oracle、SQL Server、MySQL、Sybase、DB2、Access等。</p>
<h3 id="_25-什么是锁" tabindex="-1"><a class="header-anchor" href="#_25-什么是锁" aria-hidden="true">#</a> 25.什么是锁？</h3>
<p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。</p>
<p>加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据对象有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。
基本锁类型：锁包括行级锁和表级锁</p>
<h3 id="_26-什么叫视图-游标是什么" tabindex="-1"><a class="header-anchor" href="#_26-什么叫视图-游标是什么" aria-hidden="true">#</a> 26.什么叫视图？游标是什么？</h3>
<p>视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，视图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。</p>
<p>游标：是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p>
<h3 id="_27-什么是存储过程-用什么来调用" tabindex="-1"><a class="header-anchor" href="#_27-什么是存储过程-用什么来调用" aria-hidden="true">#</a> 27.什么是存储过程？用什么来调用？</h3>
<p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。可以用一个命令对象来调用存储过程。</p>
<h3 id="_28-索引的作用-和它的优点缺点是什么" tabindex="-1"><a class="header-anchor" href="#_28-索引的作用-和它的优点缺点是什么" aria-hidden="true">#</a> 28.索引的作用？和它的优点缺点是什么？</h3>
<p>索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。它很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。索引可以是唯一的，创建索引允许指定单个列或者是多个列。</p>
<p>缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。</p>
<h3 id="_45-1-什么是索引" tabindex="-1"><a class="header-anchor" href="#_45-1-什么是索引" aria-hidden="true">#</a> 45.1.什么是索引？</h3>
<p>? 索引有什么好处？</p>
<p>提高数据的检索速度，降低数据库IO成本：使用索引的意义就是通过缩小表中需要查询的记录的数目从而加快搜索的速度。
降低数据排序的成本，降低CPU消耗：索引之所以查的快，是因为先将数据排好序，若该字段正好需要排序，则正好降低了排序的成本。
? 索引有什么坏处？</p>
<p>占用存储空间：索引实际上也是一张表，记录了主键与索引字段，一般以索引文件的形式存储在磁盘上。
降低更新表的速度：表的数据发生了变化，对应的索引也需要一起变更，从而减低的更新速度。否则索引指向的物理数据可能不对，这也是索引失效的原因之一。
? 索引的使用场景？</p>
<p>1、对非常小的表，大部分情况下全表扫描效率更高。</p>
<p>2、对中大型表，索引非常有效。</p>
<p>3、特大型的表，建立和使用索引的代价随着增长，可以使用分区技术来解决。</p>
<p>实际场景下，MySQL 分区表很少使用，原因可以看看 《互联网公司为啥不使用 MySQL 分区表？》 文章。</p>
<p>对于特大型的表，更常用的是“分库分表”，目前解决方案有 Sharding Sphere、MyCAT 等等。</p>
<p>? 索引的类型？</p>
<p>索引，都是实现在存储引擎层的。主要有六种类型：</p>
<p>1、普通索引：最基本的索引，没有任何约束。</p>
<p>2、唯一索引：与普通索引类似，但具有唯一性约束。</p>
<p>3、主键索引：特殊的唯一索引，不允许有空值。</p>
<p>4、复合索引：将多个列组合在一起创建索引，可以覆盖多个列。</p>
<p>5、外键索引：只有InnoDB类型的表才可以使用外键索引，保证数据的一致性、完整性和实现级联操作。</p>
<p>6、全文索引：MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎。</p>
<p>常用的全文索引引擎的解决方案有 Elasticsearch、Solr 等等。最为常用的是 Elasticsearch 。
————————————————</p>
<h3 id="_45-2什么是索引" tabindex="-1"><a class="header-anchor" href="#_45-2什么是索引" aria-hidden="true">#</a> 45.2<strong>什么是索引</strong></h3>
<p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息。</p>
<h5 id="索引类型" tabindex="-1"><a class="header-anchor" href="#索引类型" aria-hidden="true">#</a> <strong>索引类型</strong></h5>
<p>1.FULLTEXT 全文索引
全文索引，仅MyISAM引擎支持。其可以在CREATE TABLE ，ALTER TABLE ，CREATE INDEX 使用，不过目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。</p>
<p>2.HASH 哈希索引
HASH索引的唯一性及类似键值对的形式十分适合作为索引，HASH索引可以一次定位，不需要像树形索引那样逐层参照，因此具有极高的效率。但是这种高效是有条件的。即只在“=”和“in”条件下高效，对于范围查询，排序及组合索引仍然效率不高。</p>
<p>3.BTREE 树形索引
BTREE所以是一种将索引按一定算法，存入一个树形的数据结构中（二叉树），每次查询都是从树的入口root开始，一次遍历node，获取leaf。这是MySQL中默认也是最常用的索引类型。</p>
<p>4.RTREE
RTREE在MySQL中很少使用，仅支持geometry数据类型，支持该存储引擎只有MyISAM、BDb、InnoDb、NDb、Archive几种。相对于BTREE，RTREE的优势在于范围查找。</p>
<h5 id="索引种类" tabindex="-1"><a class="header-anchor" href="#索引种类" aria-hidden="true">#</a> <strong>索引种类</strong></h5>
<p>普通索引：仅加速查询
唯一索引：加速查询+列值唯一（可以有null）
主键索引：加速查询+列值唯一（不可以有null）+表中只有一个
组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
全文索引：对文本内容进行分词，进行搜索
外键索引：与主键索引形成联系，保证数据的完整性。</p>
<h5 id="从物理角度来讲" tabindex="-1"><a class="header-anchor" href="#从物理角度来讲" aria-hidden="true">#</a> <strong>从物理角度来讲</strong></h5>
<ol>
<li>聚集索引</li>
<li>非聚集索引</li>
</ol>
<h5 id="索引使用的注意事项" tabindex="-1"><a class="header-anchor" href="#索引使用的注意事项" aria-hidden="true">#</a> <strong>索引使用的注意事项</strong></h5>
<p>1.符合索引遵循前缀原则
2.like查询%不能再前，否则索引失效。如有需要，使用全文索引
3.column is null可以使用索引
4.如果MySQL估计使用索引比全表扫描慢，则放弃使用索引
5.如果or前的条件中列有索引，后面的没有，索引不会生效。
6.列类型是字符串，查询时，一定要给值加引号，否则索引失效。
7.确定order by 和 group by 中只有一个表的列，这样才能使用索引</p>
<p>mysql的order by语句，如果在where条件中没有合适的索引选择时，将会选择order by col中的索引作为条件，但是如果是多个order by组合，将会导致放弃使用索引。</p>
<p>order by m,n 不要轻易写这种语句，一般的order by前面的m才是order by的重点，后面的n为配角，如果没有必要，尽量去掉。</p>
<h3 id="_32-主键、外键和索引的区别" tabindex="-1"><a class="header-anchor" href="#_32-主键、外键和索引的区别" aria-hidden="true">#</a> 32.主键、外键和索引的区别？</h3>
<p>主键、外键和索引的区别</p>
<p>定义：
主键–唯一标识一条记录，不能有重复的，不允许为空
外键–表的外键是另一表的主键, 外键可以有重复的, 可以是空值
索引–该字段没有重复值，但可以有一个空值</p>
<p>作用：
主键–用来保证数据完整性
外键–用来和其他表建立联系用的
索引–是提高查询排序的速度</p>
<p>个数：
主键–主键只能有一个
外键–一个表可以有多个外键
索引–一个表可以有多个唯一索引</p>
<h3 id="_29-如何通俗地理解三个范式" tabindex="-1"><a class="header-anchor" href="#_29-如何通俗地理解三个范式" aria-hidden="true">#</a> 29.如何通俗地理解三个范式？</h3>
<p>第一范式：1NF是对属性的原子性约束，要求属性具有原子性，不可再分解；</p>
<p>第二范式：2NF是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性;</p>
<p>第三范式：3NF是对字段冗余性的约束，即任何字段不能由其他字段派生出来，它要求字段没有冗余。。</p>
<h3 id="_30-什么是基本表-什么是视图" tabindex="-1"><a class="header-anchor" href="#_30-什么是基本表-什么是视图" aria-hidden="true">#</a> 30.什么是基本表？什么是视图？</h3>
<p>基本表是本身独立存在的表，在 SQL 中一个关系就对应一个表。</p>
<p>视图是从一个或几个基本表导出的表。视图本身不独立存储在数据库中，是一个虚表</p>
<p>试述视图的优点？
(1) 视图能够简化用户的操作</p>
<p>(2) 视图使用户能以多种角度看待同一数据；</p>
<p>(3) 视图为数据库提供了一定程度的逻辑独立性；</p>
<p>(4) 视图能够对机密数据提供安全保护。</p>
<h3 id="_31-null是什么意思" tabindex="-1"><a class="header-anchor" href="#_31-null是什么意思" aria-hidden="true">#</a> 31.NULL是什么意思</h3>
<p>NULL这个值表示UNKNOWN(未知):它不表示“”(空字符串)。</p>
<p>对NULL这个值的任何比较都会生产一个NULL值。</p>
<p>您不能把任何值与一个 NULL值进行比较，并在逻辑上希望获得一个答案。</p>
<p>使用IS NULL来进行NULL判断</p>
<h3 id="_33-说说对sql语句优化有哪些方法-选择几条" tabindex="-1"><a class="header-anchor" href="#_33-说说对sql语句优化有哪些方法-选择几条" aria-hidden="true">#</a> 33.说说对SQL语句优化有哪些方法？（选择几条）</h3>
<p>（1）Where子句中：where表之间的连接必须写在其他Where条件之前，那些可以过滤掉最大数量记录的条件必须写在Where子句的末尾.HAVING最后。</p>
<p>（2）用EXISTS替代IN、用NOT EXISTS替代NOT IN。</p>
<p>使用IN的SQL：select u.* from user u where u.id in (select uu.id from user uu where uu.name like '%a%');</p>
<p>使用exists改进后：select u.* from user u where exists (select uu.id from user uu where uu.name like '%a%' and uu.id=u.id);</p>
<p>（3） 避免在索引列上使用计算</p>
<p>（4）避免在索引列上使用IS NULL和IS NOT NULL</p>
<p>（5）对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
<p>（6）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描</p>
<p>（7）应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描</p>
<h3 id="_34-sql语句中-相关子查询-与-非相关子查询-有什么区别" tabindex="-1"><a class="header-anchor" href="#_34-sql语句中-相关子查询-与-非相关子查询-有什么区别" aria-hidden="true">#</a> 34.SQL语句中‘相关子查询’与‘非相关子查询’有什么区别？</h3>
<p>（1）非相关子查询是独立于外部查询的子查询，子查询总共执行一次，执行完毕后将值传递给外部查询。</p>
<p>（2）相关子查询的执行依赖于外部查询的数据，外部查询执行一行，子查询就执行一次。</p>
<p>因此非相关子查询比相关子查询效率高</p>
<p><strong>非相关子查询：</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>select t1.ename, t1.job, t1.sal from emp t1  where t1.sal>(select avg(t2.sal)  from emp t2);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>相关子查询：</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>select t1.ename,t1.job,t1.sal 
from emp t1  
where t1.sal > (  
  select avg(t2.sal) 
  from emp t2  
  where t2.deptno=t1.deptno  --依赖于外部查询结果  
);  
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相关子查询的执行依赖于外部查询。多数情况下是子查询的WHERE子句中引用了外部查询的表，执行过程：</p>
<ol>
<li>从外层查询中取出一个元组，将元组相关列的值传给内层查询（元组：就是表中的一条数据）</li>
<li>执行内层查询，得到子查询操作的值</li>
<li>外查询根据子查询返回的结果或结果集得到满足条件的行。</li>
</ol>
<h3 id="_35-mysql-的存储引擎-myisam和innodb的区别" tabindex="-1"><a class="header-anchor" href="#_35-mysql-的存储引擎-myisam和innodb的区别" aria-hidden="true">#</a> 35.Mysql 的存储引擎,myisam和innodb的区别</h3>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>a. MyISAM类型不支持事务处理等高级处理，而InnoDB类型支持.
b. MyISAM类型的表强调的是性能，其执行数度比InnoDB类型更快.
c. InnoDB不支持FULLTEXT类型的索引.
d. InnoDB 中不保存表的具体行数，也就是说，
执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，
但是MyISAM只要简单的读出保存好的行数即可.
e. 对于AUTO_INCREMENT类型的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中，可以和其他字段一起建立联合索引。
f. DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的删除。
g. LOAD TABLE FROM MASTER操作对InnoDB是不起作用的，解决方法是首先把InnoDB表改成MyISAM表，导入数据后再改成InnoDB表，
但是对于使用的额外的InnoDB特性(例如外键)的表不适用.
h. MyISAM支持表锁，InnoDB支持行锁。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="innodb-myisam的区别" tabindex="-1"><a class="header-anchor" href="#innodb-myisam的区别" aria-hidden="true">#</a> InnoDB，MyISAM的区别</h5>
<p>MyISAM：</p>
<p>不支持事务；</p>
<p>数据存储在磁盘，可被压缩，存储空间较小；</p>
<p>只支持表级锁；</p>
<p>支持(FULLTEXT类型的)全文索引。</p>
<p>保存有表的总行数，如果select count(*) from table，会直接取出该值；</p>
<p>如果执行大量的SELECT，MyISAM是更好的选择；</p>
<p>不支持外键；</p>
<p>InnoDB：</p>
<p>支持事务；</p>
<p>存储在共享空间，需要更多的内存和存储；</p>
<p>具有事务、回滚和崩溃修复能力；</p>
<p>只支持行级锁；</p>
<p>不支持(FULLTEXT类型的)全文索引，但是innodb可以使用sphinx插件支持全文索引，并且效果更好；</p>
<p>支持外键；</p>
<p>如果你的数据执行大量的INSERT或UPDATE，出于性能方面的考虑，应该使用InnoDB表。</p>
<h5 id="myisam和innodb两者的应用场景" tabindex="-1"><a class="header-anchor" href="#myisam和innodb两者的应用场景" aria-hidden="true">#</a> <strong>MyISAM和InnoDB两者的应用场景：</strong></h5>
<ol>
<li>
<p>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。
如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。</p>
</li>
<li>
<p>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。
如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。</p>
</li>
</ol>
<h3 id="_36-安全对一套程序来说至关重要-请说说在开发中应该注意哪些安全机制" tabindex="-1"><a class="header-anchor" href="#_36-安全对一套程序来说至关重要-请说说在开发中应该注意哪些安全机制" aria-hidden="true">#</a> 36.安全对一套程序来说至关重要，请说说在开发中应该注意哪些安全机制？</h3>
<p>（1）使用验证码防止注册机灌水。</p>
<p>（2）使用预处理，绑定参数，参数过滤转义 防止sql注入</p>
<p>（3）使用token防止远程提交，使用token验证登录状态。</p>
<h3 id="_37-在程序的开发中-如何提高程序的运行效率" tabindex="-1"><a class="header-anchor" href="#_37-在程序的开发中-如何提高程序的运行效率" aria-hidden="true">#</a> 37.在程序的开发中，如何提高程序的运行效率？</h3>
<p>（1）优化SQL语句，查询语句中尽量不使用select *，用哪个字段查哪个字段；少用子查询可用表连接代替；少用模糊查询。</p>
<p>（2）数据表中创建索引。</p>
<p>（3）对程序中经常用到的数据生成缓存（比如使用redis缓存数据，比如使用ob进行动态页面静态化等等）。</p>
<p>php页面静态化的原理，用最少的代码解释页面静态化</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>//开启缓存
Ob_start();

//获取html模板
$tmp_html = file_get_contents(‘template.tpl’);
//将模板里的文件替换掉
$php_content = str_replace(“{”, “&lt;?php echo ”, $tmp_html);
$php_content = str_replace(“)”, “?>”, $tmp_html);

//将新内容输出到php文件
file_put_contents($phpfilename, $php_content);

//包含该文件时，将会输出,这是里面没有&lt;?php ?>等php的相关字符,但因开启了ob_start所以会输出到缓存中
Include “$phpfilename”;
//从缓存中获取该页面的内容，此时的内容没有&lt;?php ?>等php的相关字符，完全转为html了
$html_content = ob_get_contents();
//将内容输出到html文件
file_put_contents($htmlfilename, $html_content);

//关闭缓存
ob_clean();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h5 id="利用php的ob函数实现生成静态化页面" tabindex="-1"><a class="header-anchor" href="#利用php的ob函数实现生成静态化页面" aria-hidden="true">#</a> 利用PHP的ob函数实现生成静态化页面</h5>
<p>之前用过一些开源的CMS管理系统，当时就很好奇后台中的生成HTML静态文件是怎么实现的。今天和同事讨论了下，没想到同事之前做过这类的生成静态页面的功能，果断向他请教了下。</p>
<p>经他讲解后，才知道其实生成静态HTML页面很简单。PHP提供了专门的函数来实现。</p>
<p>以下整理出方法（实现生成html这应该只是其中一种方法）：</p>
<h5 id="通过php的ob缓存来实现" tabindex="-1"><a class="header-anchor" href="#通过php的ob缓存来实现" aria-hidden="true">#</a> 通过php的ob缓存来实现</h5>
<p>提高速度
1，通过php的ob缓存来实现
使用php的ob缓存实现页面静态化
修改php.ini配置文件
output_buffering=Off
1，缓存：smarty缓存， ThinkPHP框架的缓存，PHP的ob缓存
（1）ob---缓存，先将输出的数据呢，缓冲到一块空间
然后显示的时候再显示这块空间的缓存的数据
1，ob_start() 先将输出的数据优先放入到 ob缓存中
2，ob_clean() 清空缓存，但是没有关闭
3，ob_end_clean() 清空缓存，同时也关闭缓存
4，ob_flush() 将ob缓存的数据，输出到程序缓存
5，ob_end_flush() 将ob缓存的数据输出到程序缓存并且关闭ob缓存
（1）程序缓存
就是如果没有开启ob缓存，先将数据缓存到程序中，等echo都完了，再统一的输出
浏览器也有缓存：
浏览器先攒着数据，等达到一定的数量之后（ie 500多MB）的时候才输出</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
    header('Content-type:text/html; charset=utf-8');
    /**
        ob_start():是打开缓冲区的，就是要把您需要生成的静态文件的内容缓存在这里；
        ob_get_contents():是读出缓冲区里的内容，下面有代码为例；
        ob_end_clean():这个比较重要，只有使用了这个函数后，缓冲区里的内容才会读取出来

    */
    if(file_exists('./index.html')) //静态index.html文件是否存在
    {
        $time = time(); //文件修改时间和现在时间相差的话，直接导向html文件,否则重新生成htm

        if($time-filemtime('./index.html') &lt; 60)
        {
            header('Location:./index.html');
        }
    }

    //开始处加入ob_start();
    ob_start(); //开启php的ob缓存，这些数据放到ob缓存中,没有开启ob缓存，然后放到程序缓存中

    //动态部分内容
?>
    &lt;html>
        &lt;head>
            &lt;meta charset="utf-8" />
            &lt;title>Hello&lt;/title>
            &lt;style>
                body{ background:black;color:white;font-size:20px;}
            &lt;/style>
        &lt;/head>
        &lt;body>
            &lt;p align="center">PHP生成HTML文件....&lt;/p>
        &lt;/body>
    &lt;/html>
&lt;?php
    //在结尾加入ob_end_clean(),并把本页输出到一个变量中
    $htmlStr = ob_get_contents(); //获得缓存中的数据
    ob_end_clean();

    //写入文件
    $fp = fopen('./index.html', 'w');
    fwrite($fp, $htmlStr) or die('写文件错误');

    echo "生成HTML完成!";
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>（4）对mysql做主从复制，读写分离。（提高mysq执行效率和查询速度）</p>
<p>（5）使用nginx做负载均衡。（将访问压力平均分配到多态服务器）</p>
<h3 id="_38-mysql数据库作发布系统的存储-一天五万条以上的增量-预计运维三年-怎么优化" tabindex="-1"><a class="header-anchor" href="#_38-mysql数据库作发布系统的存储-一天五万条以上的增量-预计运维三年-怎么优化" aria-hidden="true">#</a> 38.MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？</h3>
<p>a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。
c. mysql库主从读写分离。
d. 找规律分表，减少单表中的数据量提高查询速度。
e。添加缓存机制，比如memcached，apc等。
f. 不经常改动的页面，生成静态页面。
g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.</p>
<h3 id="_39-如何处理-mysql-死锁" tabindex="-1"><a class="header-anchor" href="#_39-如何处理-mysql-死锁" aria-hidden="true">#</a> 39.如何处理 MySQL 死锁？</h3>
<h4 id="一、什么是死锁" tabindex="-1"><a class="header-anchor" href="#一、什么是死锁" aria-hidden="true">#</a> 一、什么是死锁</h4>
<p>官方定义如下：两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁。</p>
<p>这个就好比你有一个人质，对方有一个人质，你们俩去谈判说换人。你让对面放人，对面让你放人。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/713751-20190414015018303-1880886128.png" alt="死锁的形成"></p>
<h4 id="二、为什么会形成死锁" tabindex="-1"><a class="header-anchor" href="#二、为什么会形成死锁" aria-hidden="true">#</a> 二、为什么会形成死锁</h4>
<p>看到这里，也许你会有这样的疑问，事务和谈判不一样，为什么事务不能使用完锁之后立马释放呢？居然还要操作完了之后一直持有锁？这就涉及到 MySQL 的并发控制了。</p>
<p>MySQL的并发控制有两种方式，一个是 MVCC，一个是两阶段锁协议。那么为什么要并发控制呢？是因为多个用户同时操作 MySQL 的时候，为了提高并发性能并且要求如同多个用户的请求过来之后如同串行执行的一样（<code v-pre>可串行化调度</code>）。具体的并发控制这里不再展开。咱们继续深入讨论两阶段锁协议。</p>
<h4 id="两阶段锁协议-2pl" tabindex="-1"><a class="header-anchor" href="#两阶段锁协议-2pl" aria-hidden="true">#</a> 两阶段锁协议（2PL）</h4>
<p>官方定义：</p>
<blockquote>
<p>两阶段锁协议是指所有事务必须分两个阶段对数据加锁和解锁，在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁；在释放一个封锁之后，事务不再申请和获得任何其他封锁。</p>
</blockquote>
<p>对应到 MySQL 上分为两个阶段：</p>
<ol>
<li>扩展阶段（事务开始后，commit 之前）：获取锁</li>
<li>收缩阶段（commit 之后）：释放锁</li>
</ol>
<p>就是说呢，只有遵循两段锁协议，才能实现 <code v-pre>可串行化调度</code>。</p>
<p>但是两阶段锁协议不要求事务必须一次将所有需要使用的数据加锁，并且在加锁阶段没有顺序要求，所以这种并发控制方式会形成死锁。</p>
<h4 id="三、mysql-如何处理死锁" tabindex="-1"><a class="header-anchor" href="#三、mysql-如何处理死锁" aria-hidden="true">#</a> 三、MySQL 如何处理死锁？</h4>
<p>MySQL有两种死锁处理方式：</p>
<ol>
<li>等待，直到超时（innodb_lock_wait_timeout=50s）。</li>
<li>发起死锁检测，主动回滚一条事务，让其他事务继续执行（innodb_deadlock_detect=on）。</li>
</ol>
<p>由于性能原因，一般都是使用死锁检测来进行处理死锁。</p>
<h4 id="死锁检测" tabindex="-1"><a class="header-anchor" href="#死锁检测" aria-hidden="true">#</a> 死锁检测</h4>
<p>死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。</p>
<h4 id="回滚" tabindex="-1"><a class="header-anchor" href="#回滚" aria-hidden="true">#</a> 回滚</h4>
<p>检测到死锁之后，选择插入更新或者删除的行数最少的事务回滚，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。</p>
<h4 id="四、如何避免发生死锁" tabindex="-1"><a class="header-anchor" href="#四、如何避免发生死锁" aria-hidden="true">#</a> 四、如何避免发生死锁</h4>
<h4 id="收集死锁信息" tabindex="-1"><a class="header-anchor" href="#收集死锁信息" aria-hidden="true">#</a> 收集死锁信息：</h4>
<ol>
<li>利用命令 <code v-pre>SHOW ENGINE INNODB STATUS</code>查看死锁原因。</li>
<li>调试阶段开启 innodb_print_all_deadlocks，收集所有死锁日志。</li>
</ol>
<h4 id="减少死锁" tabindex="-1"><a class="header-anchor" href="#减少死锁" aria-hidden="true">#</a> 减少死锁：</h4>
<ol>
<li>使用事务，不使用 <code v-pre>lock tables</code> 。</li>
<li>保证没有长事务。</li>
<li>操作完之后立即提交事务，特别是在交互式命令行中。</li>
<li>如果在用 <code v-pre>(SELECT ... FOR UPDATE or SELECT ... LOCK IN SHARE MODE)</code>，尝试降低隔离级别。</li>
<li>修改多个表或者多个行的时候，<code v-pre>将修改的顺序保持一致</code>。</li>
<li>创建索引，可以使创建的锁更少。</li>
<li>最好不要用 <code v-pre>(SELECT ... FOR UPDATE or SELECT ... LOCK IN SHARE MODE)</code>。</li>
<li>如果上述都无法解决问题，那么尝试使用 <code v-pre>lock tables t1, t2, t3</code> 锁多张表</li>
</ol>
<h3 id="_40-mysql-事务-for-update-mysql事务-select-for-update-及数据的一致性处理" tabindex="-1"><a class="header-anchor" href="#_40-mysql-事务-for-update-mysql事务-select-for-update-及数据的一致性处理" aria-hidden="true">#</a> 40.mysql 事务 for update_mysql事务，select for update，及数据的一致性处理</h3>
<p>在MySQL的InnoDB中，预设的Tansaction isolation level 为REPEATABLE READ(可重读)</p>
<p>在SELECT 的读取锁定主要分为两种方式：</p>
<p>SELECT ... LOCK IN SHARE MODE</p>
<p>SELECT ... FOR UPDATE</p>
<p>这两种方式在事务(Transaction) 进行当中SELECT 到同一个数据表时，都必须等待其它事务数据被提交(Commit)后才会执行。</p>
<p>而主要的不同在于LOCK IN SHARE MODE 在有一方事务要Update 同一个表单时很容易造成死锁。</p>
<p>简单的说，如果SELECT 后面若要UPDATE 同一个表单，最好使用SELECT ... UPDATE。</p>
<p>举个例子:</p>
<p>假设商品表单products 内有一个存放商品数量的quantity ，在订单成立之前必须先确定quantity 商品数量是否足够(quantity&gt;0) ，然后才把数量更新为1。代码如下:</p>
<p>SELECT quantity FROM products WHERE id=3; UPDATE products SET quantity = 1 WHERE id=3;</p>
<p>为什么不安全呢?</p>
<p>少量的状况下或许不会有问题，但是大量的数据存取「铁定」会出问题。如果我们需要在quantity&gt;0 的情况下才能扣库存，假设程序在第一行SELECT 读到的quantity 是2 ，看起来数字没有错，但</p>
<p>是当MySQL 正准备要UPDATE 的时候，可能已经有人把库存扣成0 了，但是程序却浑然不知，将错就错的UPDATE 下去了。因此必须透过的事务机制来确保读取及提交的数据都是正确的。</p>
<p>于是我们在MySQL 就可以这样测试，代码如下:</p>
<p>SET AUTOCOMMIT=0; BEGIN WORK; SELECT quantity FROM products WHERE id=3 FOR UPDATE;</p>
<p>此时products 数据中id=3 的数据被锁住(注3)，其它事务必须等待此次事务 提交后才能执行</p>
<p>SELECT * FROM products WHERE id=3 FOR UPDATE 如此可以确保quantity 在别的事务读到的数字是正确的。</p>
<p>UPDATE products SET quantity = '1' WHERE id=3 ; COMMIT WORK;</p>
<p>提交(Commit)写入数据库，products 解锁。</p>
<p>注1: BEGIN/COMMIT 为事务的起始及结束点，可使用二个以上的MySQL Command 视窗来交互观察锁定的状况。</p>
<p>注2: 在事务进行当中，只有SELECT ... FOR UPDATE 或LOCK IN SHARE MODE 同一笔数据时会等待其它事务结束后才执行，一般SELECT ... 则不受此影响。</p>
<p>注3: 由于InnoDB 预设为Row-level Lock，数据列的锁定可参考这篇。</p>
<p>注4: InnoDB 表单尽量不要使用LOCK TABLES 指令，若情非得已要使用，请先看官方对于InnoDB 使用LOCK TABLES 的说明，以免造成系统经常发生死锁。</p>
<p>MySQL SELECT ... FOR UPDATE 的Row Lock 与Table Lock</p>
<p>上面介绍过SELECT ... FOR UPDATE 的用法，不过锁定(Lock)的数据是判别就得要注意一下了。由于InnoDB 预设是Row-Level Lock，所以只有「明确」的指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p>
<p>举个例子:</p>
<p>假设有个表单products ，里面有id 跟name 二个栏位，id 是主键。</p>
<p>例1: (明确指定主键，并且有此数据，row lock)</p>
<p>SELECT * FROM products WHERE id='3' FOR UPDATE;</p>
<p>例2: (明确指定主键，若查无此数据，无lock)</p>
<p>SELECT * FROM products WHERE id='-1' FOR UPDATE;</p>
<p>例2: (无主键，table lock)</p>
<p>SELECT * FROM products WHERE name='Mouse' FOR UPDATE;</p>
<p>例3: (主键不明确，table lock)</p>
<p>SELECT * FROM products WHERE id&lt;&gt;'3' FOR UPDATE;</p>
<p>例4: (主键不明确，table lock)</p>
<p>SELECT * FROM products WHERE id LIKE '3' FOR UPDATE;</p>
<p>乐观所和悲观锁策略</p>
<p>悲观锁：在读取数据时锁住那几行，其他对这几行的更新需要等到悲观锁结束时才能继续 。</p>
<p>乐观所：读取数据时不锁，更新时检查是否数据已经被更新过，如果是则取消当前更新，一般在悲观锁的等待时间过长而不能接受时我们才会选择乐观锁。
————————————————
版权声明：本文为CSDN博主「weixin_39630126」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_39630126/article/details/113595188</p>
<h3 id="_41-mysql高并发下保持一致性-高并发下数据库和缓存一致性的保证" tabindex="-1"><a class="header-anchor" href="#_41-mysql高并发下保持一致性-高并发下数据库和缓存一致性的保证" aria-hidden="true">#</a> 41.mysql高并发下保持一致性_高并发下数据库和缓存一致性的保证</h3>
<p>对于缓存的使用，从理论上来说，既然想要使用缓存就肯定存在数据在极短时间内的不一致性，如果追求极强一致性，例如下单商品的价格之类是不可以采用获取缓存的方式，所以在缓存的架构中更多是寻找一种最终一致性的解决方案，对应不同的应用场景也需要寻找不同的解决方案。</p>
<p>大致网上会有几种简单的方案：</p>
<p>1.先更新缓存，后更新数据库</p>
<p>2.先更新数据库，后更新缓存</p>
<p>3.先删除缓存，后更新数据库</p>
<p>4.先更新数据库，后删除缓存</p>
<p>5.先删除缓存，后更新数据库，再删除缓存</p>
<p>1.先更新缓存，后更新数据库</p>
<p>这种策略纯属凑数，应该没人会这么使用</p>
<p>2.先更新数据库，后更新缓存</p>
<p>这种策略存在最大的问题是多线程导致出现的脏数据</p>
<p>T1线程先更新了数据库 —&gt; T2线程再更新数据库 -&gt; T2线程更新了缓存 -&gt; T1线程更新了缓存</p>
<p>此时DB中的数据是T2线程更新的数据，但缓存中确实T1线程更新的缓存，出现了数据库和缓存的不一致</p>
<p>另外还存在一种问题就是，如果写的几率比读的几率大，那每次写的线程，还需要额外承担输入缓存的业务，从性能上来看得不偿失。</p>
<p>3.先删除缓存，后更新数据库</p>
<p>也是在多线程中可能导致脏数据</p>
<p>T1写线程删除缓存 -&gt; T2读线程获取不到缓存 -&gt; T2读线程重新从DB构建缓存 -&gt; T1更新DB</p>
<p>此时DB中的数据是T1写线程更新的数据，而缓存中的数据是T2读线程在T1提交之前构建的数据，出现数据库和缓存不一致性</p>
<p>解决这个问题可以让T1写进程，再更新DB后，再删除一次缓存，这个其实是双删策略，其实就是第5条</p>
<p>4.先更新数据库，后删除缓存</p>
<p>此策略是让读线程从缓存中获取，如果缓存不存在或失效，从db获取，然后再写回去缓存。</p>
<p>T1写线程直接更新DB，然后删除掉缓存，如果现在有三个线程 T1写 T2写 T3读</p>
<p>T1写写成更新DB -&gt; T1删除缓存 -&gt; T3读线程获取不到缓存，读取DB获取数据 -&gt; T2写线程更新DB -&gt; T2删除缓存 -&gt; T3把获取到的数据写回缓存</p>
<p>此时DB的数据是T2更新的数据，而缓存确实T3在T2更新DB前从DB获取的数据，出现数据库和缓存不一致，不过这是一种理论的存在，这种理论在于T3很快获取DB数据，而又很慢的会写缓存，这种理论却是是存在的，不过可以说几率确实比前面2种小的多得多</p>
<p>如果非得解决有几种解决的思路</p>
<p>T2写线程更新完DB，可以稍等下去删除缓存，不过这是不可靠的</p>
<p>减少缓存有效期，用缓存失效来达到最终一致性，(在考虑到极低的概率出现不一致性的问题，其实这是最低成本也是最方便的解决方案，当然根据业务而定)</p>
<p>此处还存在另一个问题，网上有人提出，就是第一步操作成功，第二部操作失败，这个其实是分布式中的分布式事务常常出现的问题，也是根据业务而定</p>
<p>删除缓存可以通过 1。线程自身判断，重复尝试 2.把删除失败交付给队列，让另外一个队列机制去尽最大努力尝试 3.抛出异常流，实施报警，让人为介入。</p>
<p>另外还有一种是阿里的canal，是直接订阅mysql的binlog到相对的缓存或者nosql中去，并没有使用过。
————————————————
版权声明：本文为CSDN博主「令狐诗楠」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_35970195/article/details/113304148</p>
<h3 id="_42-高并发情况下如何保证数据的一致性" tabindex="-1"><a class="header-anchor" href="#_42-高并发情况下如何保证数据的一致性" aria-hidden="true">#</a> 42.高并发情况下如何保证数据的一致性</h3>
<p>1.业务层面乐观锁CAS，使用版本号解决ABA问题，实际使用中使用时间戳，更新的时候把查出来的时间戳带上，如果更新失败可以自旋，获取最近值和时间戳，直到更新成功。</p>
<p>2.DB层面开启一个事务，然后select一行for update给这一行加上排它锁，再去更新行，然后提交，其他事务就会阻塞在select for update。</p>
<p>3.分布式锁适合竞争不激烈的情况保证一致性，因为性能比较差，按CAP理论来讲应该是保证了CP放弃了A，zk或者redis保证一致性P，只有拿到锁的线程才能执行，保证一致性C</p>
<p>另一种回答：</p>
<p>1.通过悲观锁实现 for update</p>
<p>2.通过乐观锁实现，加字段</p>
<p>3.针对秒杀系统，可以采取将并发请求串行化。放在一个队列中，处理对数据库的写操作</p>
<p>4.通过redis实现，读和写都操作redis。写redis数据时，同时产生一条业务相关联的日志数据。单独开个任务或者消息队列来对日志数据进行读取，获取里面的对数据库的操作。然后进行写数据库。</p>
<p>5.因为redis支持事务，所有写操作可以通过lua脚本来支持对数据库的操作。</p>
<p>6.写update语句时，还可以这样写。update produce p set p.num=$SumNum-$num where p.num=$sumNum and $sumNum-$num&gt;0;</p>
<p>更新某个库存值时，首先获取当前库存量。更新时传入查询到的数量。减出此次要操作的数量。加上两个限制条件：</p>
<p>1.查询到的数量和数据库里面的库存数量一致</p>
<p>2.此次操作后，库存数量大于0。</p>
<p>第四条：使用乐观锁，虽然可以做到一致性。但是在高并发情况下，会产生大量的失败请求。会产生大量的数据库Io操作。为了减少io，可以将其放在redis中，进行操作。然后产生业务日志，根据业务日志对数据库进行更新。</p>
<p>另：redis支持事务，支持set，一般只用来做缓存。这里备注下，都忘了有这些功能了。</p>
<h3 id="_43-mysql如何保证一致性" tabindex="-1"><a class="header-anchor" href="#_43-mysql如何保证一致性" aria-hidden="true">#</a> 43.Mysql如何保证一致性？</h3>
<h5 id="_1-关于事务和一致性的理解" tabindex="-1"><a class="header-anchor" href="#_1-关于事务和一致性的理解" aria-hidden="true">#</a> 1.关于事务和一致性的理解</h5>
<p>事务的产生,其实是为了当应用程序访问数据库的时候,事务能够简化我们的编程模型,不需要我们去考虑各种各样的潜在错误和并发问题.可以想一下当我们使用事务时,要么提交,要么回滚,我们不会去考虑网络异常了,服务器宕机了,同时更改一个数据怎么办对吧?因此事务本质上是为了应用层服务的.而不是伴随着数据库系统天生就有的。</p>
<p>ACID里的AID都是数据库的特征,也就是依赖数据库的具体实现.而唯独这个C,实际上它依赖于应用层,也就是依赖于开发者.这里的一致性是指系统从一个正确的状态,迁移到另一个正确的状态.什么叫正确的状态呢?就是当前的状态满足预定的约束就叫做正确的状态.而事务具备ACID里C的特性是说通过事务的AID来保证我们的一致性.</p>
<p>一致性就是:应用系统从一个正确的状态到另一个正确的状态.而ACID就是说事务能够通过AID来保证这个C的过程.C是目的,AID都是手段</p>
<p>事务的四个属性：ACID
1.原子性(Automic)：一个动作要么做完，要么不做。</p>
<p>2.一致性(Consistency)：保证数据处于一致性的状态，我理解就是保证数据有意义的。</p>
<p>3.隔离性(Isolation)：多个事务并行的结果，应该和多个事务串行的结果一致。</p>
<p>4.持久性(Duration)：一个事务一旦成功提交，对数据改变是永久性的。</p>
<p>这个四个属性中，最重要的是一致性，也就是说其他的三个属性都是为了保证一致性而存在。</p>
<h5 id="_2-那么-aid是如何保证的呢" tabindex="-1"><a class="header-anchor" href="#_2-那么-aid是如何保证的呢" aria-hidden="true">#</a> 2.那么，AID是如何保证的呢</h5>
<p>在使用Mysql的时候，有两种常用的存储引擎：MyISAM和InnoDB</p>
<p>InnoDB的性能不如MyISAM高，因为InnoDB提供事务支持以及外部键等高级数据库功能</p>
<p>事务有什么用？</p>
<p>银行转账，A转给B账户100元，需要保证A账户减少100元的同时B账户增加100元，如果A账户减少100元之后，系统crash，B账户并未增加100元，这样是没有数据保证一致性的。所以，如果两个动作是同一个事务，那么此时A操作需要回滚，保证数据一致性。
如何回滚？
原子性如何保证？</p>
<p>这个就需要说到Mysql的log，Mysql有许多种类的log，例如：二进制日志(binlog)，错误日志，慢查询日志等等。这里需要引入的是undo log。这是Mysql的Write-Ahead-Logging机制。</p>
<h5 id="_3-undo-log如何工作的" tabindex="-1"><a class="header-anchor" href="#_3-undo-log如何工作的" aria-hidden="true">#</a> 3.undo log如何工作的？</h5>
<p>例如：数据库中A=1，现在需要update A=3</p>
<p>那么整个步骤如下：</p>
<p>1.事务开始</p>
<p>2.记录A=1到undo log</p>
<p>3.修改A=3</p>
<p>4.将undo log写入磁盘</p>
<p>5.将A=3数据写入磁盘</p>
<p>6.事务提交</p>
<p>这个就是undo log工作流程，也就是在数据库断电或者crash的时候，在进行恢复的时候，把undo log里面的数据写回到数据库，这样就让数据回滚了。这样实现了事务的原子性，同时保证了数据的一致性。</p>
<p>但是，这样每个操作都会进行磁盘IO的写入，频繁的磁盘IO对性能是很大的降低。</p>
<p>引入redo log实现持久性，这个时候就在考虑如果只需要将日志写入磁盘，将数据缓存在内存中，一定时间后再进行更新。</p>
<p>例如：数据库中A=1,B=2,需要update A=3,B=4</p>
<p>1.事务开始</p>
<p>2.记录A=1到undo log</p>
<p>3.修改A=3</p>
<p>4.记录A=3到redo log</p>
<p>5.记录B=2到undo log</p>
<p>6.修改B=4</p>
<p>7.记录B=4到redo log</p>
<p>8.将redo log顺序写入磁盘</p>
<p>9.事务提交</p>
<p>整个过程中，数据修改都是在内存中，极大提升磁盘IO速度，而且将redo log提前写入磁盘。</p>
<p>如果整个事务执行的过程系统崩溃或者断电了，在系统重启的时候，恢复机制会将redo log中已提交的事务重做，保证事务的持久性；而undo log中未提交的事务进行回滚，保证事务的原子性。</p>
<p>Mysql通过预写式日志，保证了原子性和持久性。那么在多个事务并行的情况下，是否还能保证数据的一致性？如果A事务能够访问B事务正在提交的数据，然后B事务又做出了回滚，这样是不是就让数据乱套了。所以事务并行的情况下，这样是不够的。</p>
<p>隔离性：引入锁机制来保证。那么是什么情况下不锁，什么情况下锁呢？还有读写分离需要实现吗？这就需要去说说四种级别的隔离性。</p>
<p>1.未提交读：A事务可以读取B事务正在修改的数据，但是会出现B事务如果回滚，这样数据前后不一致，会造成脏读的现象。</p>
<p>2.已提交读：A事务只能读取B事务已提交的数据。B事务修改数据，A事务进行读取，数据未改，当B事务提交数据后，A事务读取数据不一致。这是幻读现象，因为同一个事务，我读取两次相同的数据返回的是不同的，这样并未保证一致性。</p>
<p>3.可重复读：利用MVCC并发版本控制，B事务修改数据，A事务进行读取，数据未改，当B事务提交后，A事务读取数据，这个时候会返回A数据之前读的版本。</p>
<p>4.序列化：简单粗暴，读锁和写锁都是排它锁，不管读操作还是写操作都是会对数据上锁。这样粗暴造成性能下降很多。</p>
<p>大多数数据库默认使用已提交读的隔离级别，Mysql中InnoDB默认使用可重复读的隔离级别。</p>
<p>总结</p>
<p>Mysql的InnoDB保证事务性，最重要是保证数据的一致性。</p>
<p>通过预写式日志，undo log保证原子性，redo log保证持久性，设置隔离级别，保证并发事务进行的时候，保证数据一致性。
————————————————
版权声明：本文为CSDN博主「爱笑的k11」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/max1231ff/article/details/103838150</p>
<h3 id="_44-mysql-必须掌握的三大日志-binglog、redo-log以及undo-log" tabindex="-1"><a class="header-anchor" href="#_44-mysql-必须掌握的三大日志-binglog、redo-log以及undo-log" aria-hidden="true">#</a> 44.MySQL 必须掌握的三大日志-binglog、redo log以及undo log</h3>
<p>MySQL服务器的<a href="https://so.csdn.net/so/search?q=%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84&amp;spm=1001.2101.3001.7020" target="_blank" rel="noopener noreferrer">体系结构<ExternalLinkIcon/></a></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/10d8aab8c9f3b874790b0fa654e9a982.png" alt="img"></p>
<p><strong>一条更新语句执行的顺序</strong></p>
<p>update T set c=c+1 where ID=2;</p>
<p>a. 执行器先找引擎取 ID=2 这一行。ID 是主键，引擎直接用树搜索找到这一行。如果 ID=2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</p>
<p>b. 执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</p>
<p>c. 引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</p>
<p>d. 执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</p>
<p>e. <strong>执行器调用引擎的提交事务接口</strong>，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</p>
<h5 id="_1-binlog" tabindex="-1"><a class="header-anchor" href="#_1-binlog" aria-hidden="true">#</a> 1.binlog</h5>
<p>binlog属于MySQL Server层面，称为归档日志，以二进制形式记录语句的原始逻辑，binlog是没有crash-safe能力</p>
<p><code v-pre>binlog</code> 用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。<code v-pre>binlog</code> 是 <code v-pre>mysql</code>的逻辑日志，并且由 <code v-pre>Server</code> 层进行记录，使用任何存储引擎的 <code v-pre>mysql</code> 数据库都会记录 <code v-pre>binlog</code> 日志。</p>
<ul>
<li><strong>逻辑日志</strong>：可以简单理解为记录的就是sql语句 。</li>
<li><strong>物理日志</strong>：<code v-pre>mysql</code> 数据最终是保存在数据页中的，物理日志记录的就是数据页变更 。</li>
</ul>
<p><code v-pre>binlog</code> 是通过追加的方式进行写入的，可以通过<code v-pre>max_binlog_size</code> 参数设置每个 <code v-pre>binlog</code>文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p>
<h5 id="binlog-使用场景" tabindex="-1"><a class="header-anchor" href="#binlog-使用场景" aria-hidden="true">#</a> binlog 使用场景</h5>
<p>在实际应用中， <code v-pre>binlog</code> 的主要使用场景有两个，分别是 <strong>主从复制</strong> 和 <strong>数据恢复</strong> 。</p>
<ol>
<li><strong>主从复制</strong> ：在 <code v-pre>Master</code> 端开启 <code v-pre>binlog</code> ，然后将 <code v-pre>binlog</code>发送到各个 <code v-pre>Slave</code> 端， <code v-pre>Slave</code> 端重放 <code v-pre>binlog</code> 从而达到主从数据一致。</li>
<li><strong>数据恢复</strong> ：通过使用 <code v-pre>mysqlbinlog</code> 工具来恢复数据。</li>
</ol>
<h5 id="binlog-刷盘时机" tabindex="-1"><a class="header-anchor" href="#binlog-刷盘时机" aria-hidden="true">#</a> binlog 刷盘时机</h5>
<p>对于 <code v-pre>InnoDB</code> 存储引擎而言，只有在事务提交时才会记录<code v-pre>biglog</code> ，此时记录还在内存中，那么 <code v-pre>biglog</code>是什么时候刷到磁盘中的呢？</p>
<p><code v-pre>mysql</code> 通过 <code v-pre>sync_binlog</code> 参数控制 <code v-pre>biglog</code> 的刷盘时机，取值范围是 <code v-pre>0-N</code>：</p>
<ul>
<li>0：不去强制要求，由系统自行判断何时写入磁盘；</li>
<li>1：每次 <code v-pre>commit</code> 的时候都要将 <code v-pre>binlog</code> 写入磁盘；</li>
<li>N：每N个事务，才会将 <code v-pre>binlog</code> 写入磁盘。</li>
</ul>
<p>从上面可以看出， <code v-pre>sync_binlog</code> 最安全的是设置是 <code v-pre>1</code> ，这也是<code v-pre>MySQL 5.7.7</code>之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p>
<h5 id="binlog-日志格式" tabindex="-1"><a class="header-anchor" href="#binlog-日志格式" aria-hidden="true">#</a> binlog 日志格式</h5>
<p><code v-pre>binlog</code> 日志有三种格式，分别为 <code v-pre>STATMENT</code> 、 <code v-pre>ROW</code> 和 <code v-pre>MIXED</code>。</p>
<blockquote>
<p>在 <code v-pre>MySQL 5.7.7</code> 之前，默认的格式是 <code v-pre>STATEMENT</code> ， <code v-pre>MySQL 5.7.7</code> 之后，默认值是 <code v-pre>ROW</code>。日志格式通过 <code v-pre>binlog-format</code> 指定。</p>
</blockquote>
<ul>
<li>
<p><code v-pre>STATMENT</code>：基于<code v-pre>SQL</code> 语句的复制( <code v-pre>statement-based replication, SBR</code> )，每一条会修改数据的sql语句会记录到<code v-pre>binlog</code> 中 。</p>
<p>**优点：**不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO , 从而提高了性能；
**缺点：**在某些情况下会导致主从数据不一致，比如执行sysdate() 、 slepp() 等 。</p>
</li>
<li>
<p><code v-pre>ROW</code>：基于行的复制(<code v-pre>row-based replication, RBR</code> )，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了 。</p>
<p>**优点：**不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题 ；
<strong>缺点</strong>：会产生大量的日志，尤其是<code v-pre>alter table</code> 的时候会让日志暴涨</p>
</li>
<li>
<p><code v-pre>MIXED</code>：基于<code v-pre>STATMENT</code> 和 <code v-pre>ROW</code> 两种模式的混合复制(<code v-pre>mixed-based replication, MBR</code> )，一般的复制使用<code v-pre>STATEMENT</code> 模式保存 <code v-pre>binlog</code> ，对于 <code v-pre>STATEMENT</code> 模式无法复制的操作使用 <code v-pre>ROW</code> 模式保存 <code v-pre>binlog</code></p>
</li>
</ul>
<h5 id="_2-redo-log" tabindex="-1"><a class="header-anchor" href="#_2-redo-log" aria-hidden="true">#</a> 2.redo log</h5>
<h5 id="_2-1为什么需要redo-log" tabindex="-1"><a class="header-anchor" href="#_2-1为什么需要redo-log" aria-hidden="true">#</a> 2.1为什么需要redo log</h5>
<p>我们都知道，事务的四大特性里面有一个是 <strong>持久性</strong> ，具体来说就是<strong>只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong> 。</p>
<p>那么 <code v-pre>mysql</code>是如何保证一致性的呢？</p>
<p>最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：</p>
<ol>
<li>因为 <code v-pre>Innodb</code> 是以 <code v-pre>页</code> 为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li>
<li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！</li>
</ol>
<p>因此 <code v-pre>mysql</code> 设计了 <code v-pre>redo log</code> ， <strong>具体来说就是只记录事务对数据页做了哪些修改</strong>，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。</p>
<h5 id="_2-2-redo-log-基本概念" tabindex="-1"><a class="header-anchor" href="#_2-2-redo-log-基本概念" aria-hidden="true">#</a> 2.2 redo log 基本概念</h5>
<p>每次对记录的修改写入缓冲池的时候，先讲记录写入redo log buffer（记录着哪一页修改了什么数据），后续在特定时刻将多个操作刷盘到redo log file中(放在磁盘)，这种先写日志，再写磁盘的技术就是MySQL里的WAL(Write-Ahead Logging)技术。</p>
<p>在操作系统中，用户空间下的缓冲区是无法直接写入磁盘的，中间必须经过操作系统内核空间(kernal space)缓冲区，然后通过系统调用fsync()刷到redo log file中。</p>
<p>MySQL支持三种将redo log buffer写入redo log file的时机，可以通过 innodb_flush_log_at_trx_commit 参数配置，相关含义如下：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/8e7071c87c17b8822f2f15283d18e59d.png" alt="img"></p>
<p>可以发现写入redo log file也是磁盘IO，但它是顺序IO，比从缓冲池将数据页随机IO到磁盘快很多。 <img src="@source/docs/theme-reco/img/最高级多方面面试题/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NzUxMzIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5 id="_2-3-redo-log-记录形式" tabindex="-1"><a class="header-anchor" href="#_2-3-redo-log-记录形式" aria-hidden="true">#</a> 2.3 redo log 记录形式</h5>
<p>在更新一条语句时，InnoDB会把更新记录写到redo log中，然后更新内存，然后在空闲的时候或是按照设定的更新策略将redo log中的内容更新到磁盘。<strong>redo log日志大小是固定的</strong>，即记录满了后就从头循环写。Checkpoint 以前表示已经更新到磁盘的文件，write pos表示当前写的位置，如果两个指针相遇了，表示redo log已经满了，需要同步到磁盘中。</p>
<p>前面说过， <code v-pre>redo log</code> 实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此 <code v-pre>redo log</code>实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。如下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/7a829994a06ef5b2bc983f102af3338d.png" alt="img"></p>
<p>同时我们很容易得知， 在innodb中，既有<code v-pre>redo log</code> 需要刷盘，还有 <code v-pre>数据页</code> 也需要刷盘， <code v-pre>redo log</code>存在的意义主要就是降低对 <code v-pre>数据页</code> 刷盘的要求 ** 。</p>
<p>在上图中， <code v-pre>write pos</code> 表示 <code v-pre>redo log</code> 当前记录的 <code v-pre>LSN</code> (逻辑序列号)位置， <code v-pre>check point</code> 表示 <strong>数据页更改记录</strong> 刷盘后对应 <code v-pre>redo log</code> 所处的 <code v-pre>LSN</code>(逻辑序列号)位置。</p>
<p><code v-pre>write pos</code> 到 <code v-pre>check point</code> 之间的部分是 <code v-pre>redo log</code> 空着的部分，用于记录新的记录；<code v-pre>check point</code> 到 <code v-pre>write pos</code> 之间是 <code v-pre>redo log</code> 待落盘的数据页更改记录。当 <code v-pre>write pos</code>追上<code v-pre>check point</code> 时，会先推动 <code v-pre>check point</code> 向前移动，空出位置再记录新的日志。</p>
<p>启动 <code v-pre>innodb</code> 的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为 <code v-pre>redo log</code>记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 <code v-pre>binlog</code> )要快很多。</p>
<p>重启<code v-pre>innodb</code> 时，首先会检查磁盘中数据页的 <code v-pre>LSN</code> ，如果数据页的<code v-pre>LSN</code> 小于日志中的 <code v-pre>LSN</code> ，则会从 <code v-pre>checkpoint</code> 开始恢复。</p>
<p>还有一种情况，在宕机前正处于<code v-pre>checkpoint</code> 的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 <code v-pre>LSN</code> 大于日志中的 <code v-pre>LSN</code>，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p>
<h5 id="_2-4-redo-log和binlog区别" tabindex="-1"><a class="header-anchor" href="#_2-4-redo-log和binlog区别" aria-hidden="true">#</a> 2.4 redo log和binlog区别</h5>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/d09fe897c781444b94a6903be02e79c2.png" alt="img"></p>
<p>由 <code v-pre>binlog</code> 和 <code v-pre>redo log</code> 的区别可知：<code v-pre>binlog</code> 日志只用于归档，只依靠 <code v-pre>binlog</code> 是没有 <code v-pre>crash-safe</code> 能力的。</p>
<p>但只有 <code v-pre>redo log</code> 也不行，因为 <code v-pre>redo log</code> 是 <code v-pre>InnoDB</code>特有的，且日志上的记录落盘后会被覆盖掉。因此需要 <code v-pre>binlog</code>和 <code v-pre>redo log</code>二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p>
<h5 id="_3-undo-log" tabindex="-1"><a class="header-anchor" href="#_3-undo-log" aria-hidden="true">#</a> 3. undo log</h5>
<p>数据库事务四大特性中有一个是 <strong>原子性</strong> ，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。</p>
<p>实际上， <strong>原子性</strong> 底层就是通过 <code v-pre>undo log</code> 实现的。<code v-pre>undo log</code>主要记录了数据的逻辑变化，比如一条 <code v-pre>INSERT</code> 语句，对应一条<code v-pre>DELETE</code> 的 <code v-pre>undo log</code> ，对于每个 <code v-pre>UPDATE</code> 语句，对应一条相反的 <code v-pre>UPDATE</code> 的 <code v-pre>undo log</code> ，这样在发生错误时，就能回滚到事务之前的数据状态。</p>
<p>同时， <code v-pre>undo log</code> 也是 <code v-pre>MVCC</code>(多版本并发控制)实现的关键。</p>
<p>每条数据修改(insert、update或delete)操作都伴随一条undo log的生成,并且回滚日志必须先于数据持久化到磁盘上</p>
<h3 id="_45-mysql-事务的四大特性" tabindex="-1"><a class="header-anchor" href="#_45-mysql-事务的四大特性" aria-hidden="true">#</a> 45.MySQL 事务的四大特性</h3>
<p>一般来说，事务是必须满足4个条件（ACID）：</p>
<p>1.原子性（Atomicity，或称不可分割性）
2.一致性（Consistency）
3.隔离性（Isolation，又称独立性）
4.持久性（Durability）。</p>
<p>原子性：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>
<p>一致性：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
<p>隔离性：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
事务隔离级别，分为：
1.读未提交（Read uncommitted）
2.读提交（read committed）
3.可重复读（repeatable read）
4.串行化（Serializable）。</p>
<p>持久性：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</p>
<h3 id="_46-mysql-事务隔离级别" tabindex="-1"><a class="header-anchor" href="#_46-mysql-事务隔离级别" aria-hidden="true">#</a> 46.MySQL 事务隔离级别</h3>
<p>一、读未提交（RU）</p>
<p>MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。任何事务对数据的修改都会第一时间暴露给其他事务，即使事务还没有提交。</p>
<p>二、读提交（RC）</p>
<blockquote>
<p>既然读未提交没办法解决脏数据问题，那么就有了读提交。读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。那脏数据问题就迎刃而解了。</p>
</blockquote>
<p>三、可重复读（RR）</p>
<p>可重复是对比不可重复而言的，不可重复读是指同一事务不同时刻读到的数据值可能不一致。而可重复读是指事务不会读到其他事务对已有数据的修改，即使其他事务已提交；也就是说，事务开始时读到的已有数据是什么，在事务提交前的任意时刻，这些数据的值都是一样的。但是对于其他事务新插入的数据是可以读到的，这就引发了幻读的问题。</p>
<p>四、串行化</p>
<blockquote>
<p>串行化是 4 种事务隔离级别中隔离效果最好的，解决了脏读、可重复读、幻读的问题，但是效果最差，它将事务的执行变为顺序执行，与其他三个隔离级别相比，它就是相当于单线程，后一个事务的执行必须等待前一个事务结束才能执行。</p>
</blockquote>
<p>隔离级别说明与更换级别：https://blog.csdn.net/qq_39408664/article/details/119004699</p>
<p>读取未提交(脏读问题)与读取已提交(不可重复读问题)：https://blog.csdn.net/qq_39408664/article/details/119025393</p>
<p>可重复读(幻读问题)与串行化说明：https://blog.csdn.net/qq_39408664/article/details/119037440
————————————————</p>
<h3 id="_47-如何分析sql-explain有哪些常用字段" tabindex="-1"><a class="header-anchor" href="#_47-如何分析sql-explain有哪些常用字段" aria-hidden="true">#</a> 47.如何分析sql？explain有哪些常用字段？</h3>
<p>使用explain关键字可以模拟优化器执行SQL语句，分析查询语句或是结构的性能瓶颈</p>
<p>字段解释：</p>
<ol>
<li>
<p>id：表的读取顺序，id相同，读取顺序从上到下，id不同，值越大则优先级越高。</p>
</li>
<li>
<p>select_type：查询类型；simple表示简单查询，不包含子查询或联合查询。</p>
</li>
<li>
<p>table：表示这一行的数据是关于哪张表的。</p>
</li>
<li>
<p>type：表示的是表的连接类型。</p>
</li>
<li>
<p>possible_keys：列支出mysql能使用哪个索引在该表中找到行。</p>
</li>
<li>
<p>key：表示查询实际应用到的索引。</p>
</li>
<li>
<p>key_len：表示mysql选择的索引字段按字节计算的长度。</p>
</li>
<li>
<p>ref：表示使用哪个列或常数与索引一起来查询记录。</p>
</li>
<li>
<p>rows：显示mysql表中进行查询时必须检查的行数。</p>
<p>10.filtered：表示返回结果的行数占需读取行数的百分比，列的值越大越好。</p>
<p>11.Extra：显示mysql在处理查询时的详细信息 或者理解为 额外的信息说明。</p>
</li>
</ol>
<h3 id="_48-mysql随机获取一条或者多条数据" tabindex="-1"><a class="header-anchor" href="#_48-mysql随机获取一条或者多条数据" aria-hidden="true">#</a> 48.mysql随机获取一条或者多条数据</h3>
<p>语句一：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>select * from users order by rand() LIMIT 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>MYSQL手册里面针对RAND()的提示大概意思就是，在 ORDER BY从句里面不能使用RAND()函数，因为这样会导致数据列被多次扫描，导致效率相当相当的低，效率不行，切忌使用。</p>
<p>语句二：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>SELECT * FROM users AS t1 JOIN (SELECT ROUND(RAND() * ((SELECT MAX(userId) FROM `users`)-(SELECT MIN(userId) FROM users))+(SELECT MIN(userId) FROM users)) AS userId) AS t2 WHERE t1.userId >= t2.userId ORDER BY t1.userId LIMIT 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执 行该sql语句，用时0.031s，效率非常好。当把”LIMIT 1“改为了”LIMIT 100“ 随机取一百条记录，用时0.048s。可是就在此时问题出现了，发现结果好像不是随机的。为了验证结果，又执行了N次，的确不是随机的。问题出现 在”ORDER BY t1.userId“这里，按userId排序了。随机取一条记录还是不错的选择，多条就不行了啊。</p>
<p>语句三</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>SELECT * FROM users WHERE userId >= ((SELECT MAX(userId) FROM users)-(SELECT MIN(userId) FROM users)) * RAND() + (SELECT MIN(userId) FROM users) LIMIT 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>执行该sql语句，用时0.039s，效率也是非常好。接着把”LIMIT 1“改为了”LIMIT 10000“，用时0.063s。经过多次验证，得出的结果都是随机的。
结论：语句一效率不行，切忌使用。随机获得一条记录，语句二是相当不错的选择，采用JOIN的语法比直接在WHERE中使用函数效率还是要高一些的。语句三也不错，随机获得多条记录的首选。</p>
<h3 id="_49-innodb下创建表-表中不创建主键索引-创建一般索引后-查询逻辑是怎样。" tabindex="-1"><a class="header-anchor" href="#_49-innodb下创建表-表中不创建主键索引-创建一般索引后-查询逻辑是怎样。" aria-hidden="true">#</a> 49.Innodb下创建表，表中不创建主键索引，创建一般索引后，查询逻辑是怎样。</h3>
<h3 id="_50-mysql-性能调优" tabindex="-1"><a class="header-anchor" href="#_50-mysql-性能调优" aria-hidden="true">#</a> 50.mysql 性能调优</h3>
<p>数据库性能的影响因素很多，包括：</p>
<p>影响因素	说明	解决方案
SQL 查询速度	存在慢查询 SQL	
大表和大事务	MySQL 单表行数超过千万行或单表数据超过10GB就会影响性能。	
数据库存储引擎		
数据库参数配置	配置不当会直接影响性能。	
服务器硬件		
网卡流量		
磁盘 IO		使用更快的磁盘设备，比如 RAID 卡、SSD、Fusion-IO 等；检查是否存在其他大量消耗磁盘性能的计划任务，如果存在，则调整计划任务，做好磁盘维护。
注意：MySQL 5.7 是单线程的服务，并不支持多 cpu 并发运算，意味着每条 sql 只能用到 1 个 cpu。</p>
<p>如何定位并优化慢查询 SQL？具体场景具体分析，大致思路如下：</p>
<p>根据慢查询日志定位慢查询 SQL；
使用 explain 等工具分析 SQL；
修改 SQL 或者尽量让 SQL 走索引。
SQL 查询优化，索引优化，库表结构优化需要齐头并进。本篇主要记录了一些 SQL 调优的经验。</p>
<p>在进行库表结构设计时，我们要考虑到以后的查询要如何的使用这些表，同样，编写 SQL 语句的时候也要考虑到如何使用到目前已经存在的索引，或是如何增加新的索引才能提高查询的性能。</p>
<p>想要对存在性能问题的查询进行优化，需要能够找到这些查询，下面先看下如何获取有性能问题的 SQL。</p>
<p>1.SQL调优
获取有性能问题的 SQL 的两种方法：</p>
<p>通过慢查日志获取存在性能问题的 SQL；
实时获取存在性能问题的 SQL；
1.根据慢查询日志定位慢查询 SQL
MySQL 慢查询日志是一种性能开销比较低的解决方案，主要性能开销在磁盘 IO 和存储日志所需要的磁盘空间。对于磁盘 IO 来说，由于写日志是顺序存储，开销基本上忽略不计，所以主要需要关注的还是磁盘空间。</p>
<p>MySQL 提供了以下参数用于控制慢查询日志：</p>
<p>slow_query_log：是否启动慢查询日志，默认不启动，on 启动；
slow_query_log_file：指定慢查询日志的存储路径及文件，默认保存在 MySQL 的数据目录中；
long_query_time：指定记录慢查询日志 SQL 执行时间的阈值，单位秒，默认10，对于一个繁忙的系统，改为0.001比较合适；
log_queries_not_using_indexes：是否记录未使用索引的 SQL；
1
2
3
4
开启慢查询日志有两种方式，第一种是通过配置 /etc/my.cnf 文件开启，是永久性的，第二种是通过设置全局变量开启，MySQL 重启后会失效。</p>
<p>设置全局变量的 SQL 如下：</p>
<p>set global slow_query_log = on;
set global long_query_time = 1;
1
2
和二进制日志不同，慢查询日志会记录所有符合条件的 SQL，包括查询语句、数据修改语句、已经回滚的 SQL。</p>
<p>慢查询日志中记录的内容：</p>
<p>Query_time: 0.000220             //执行时间，可以精确到毫秒，220毫秒</p>
<p>Lock_time: 0.000120              //所使用锁的时间，可以精确到毫秒</p>
<p>Rows_sent: 1                     //返回的数据行数</p>
<p>Rows_examined: 1                 //扫描的数据行数</p>
<p>SET timestamp=1538323200;          //执行sql的时间戳
SELECT c FROM test1 WHERE id =100;    //sql</p>
<p>通常情况下，在一个繁忙的系统中，短时间内就可以产生几个 G 的慢查询日志，人工检查几乎是不可能的，为了快速分析慢查询日志，必须借助相关的工具。</p>
<p>常用的慢查询日志工具：</p>
<p>1、mysqldumpslow：一个常用的，MySQL 官方提供的慢查询日志分析工具，随着 MySQL 服务器的安装而被安装。可以汇总除查询条件外其他完全相同的 SQL，并将分析结果按照参数中所指定的顺序输出。</p>
<p>2、pt-query-digest：用于分析 MySQL 慢查询的一个工具。</p>
<p>2.实时获取性能问题SQL
为了更加及时的发现当前的性能问题，我们还可以通过实时的方法来获取有性能问题的 SQL。最方便的一种方法就是利用 MySQL information_schema 数据库下的 PROCESSLIST 表来实现实时的发现性能问题 SQL。例如下面这条 SQL 表示查询出当前服务器中执行时间超过 1 秒的 SQL：</p>
<p>SELECT id,user,host,db,command,time,state,info FROM information_schema.PROCESSLIST WHERE TIME&gt;=1
1
然后我们可以通过脚本周期性的来执行这条 SQL，实时的发现哪些 SQL 执行的是比较慢的。</p>
<p>2.使用explain分析SQL
explain 可以帮助我们分析 select 语句，让我们知道查询效率低下的原因。这个关键字一般放在 select 语句的前面，用于描述 MySQL 如何执行查询操作以及 MySQL 成功返回结果集需要执行的行数，执行会输出一些 explain 的字段。例如：</p>
<p>EXPLAIN SELECT name FROM person_info_large order by name desc;
1
需要注意的是，执行 explain 并不会真正的执行 SQL，而是对 SQL 做了一些分析，速度非常快。</p>
<p>explain 关键字段：</p>
<p>id：表示了 MySQL 的执行顺序，id 越大越先执行；
type：表示 MySQL 找到数据行的方式；
key：实际使用的索引；
Extra：额外信息。</p>
<p>type 字段的返回值，性能从最优到最差：</p>
<p>system -&gt; const -&gt; eq_ref -&gt; ref -&gt; fulltext -&gt; ref_or_null -&gt; index_merge -&gt; unique_subquery -&gt; index_subquery -&gt; range -&gt; index -&gt; all</p>
<p>index 和 all 表示本次查询走的是全表扫描。如果 type 值是这两个，表明 SQL 是需要优化的。</p>
<p>Extra 中出现了以下两种意味着 MySQL 根本不能使用索引，效率会受到重大影响，应尽可能对此进行优化：</p>
<p>Extra 项	说明
Using filesort	表示 MySQL 会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容。可能在内存或者磁盘上进行排序。MySQL 中无法利用索引完成的排序操作称为 “文件排序”。
Using temporary	表示 MySQL 在对查询结果排序时使用的临时表，常见于排序 order by 和分组查询 group by。
3.修改 SQL或者尽量让SQL走索引
例如为上面 SQL 中的 name 加索引：</p>
<p>ALTER TABLE person_info_large add index idx_name(name);
1
MySQL的查询优化器</p>
<p>2.SQL的解析预处理及生成执行计划
找到了那些查询存在性能问题的 SQL，那么下面我们就看下，为什么这些 SQL 会存在性能问题？</p>
<p>为了搞清楚这个问题，我们先来看下 MySQL 服务器处理一条 SQL 请求所需要经历的步骤都有哪些：</p>
<p>客户端通过 MySQL 的接口发送 SQL 请求给服务器，这一步通常不会影响查询性能；
MySQL 服务器检查是否可以在查询缓存中命中该 SQL，如果命中，则立即返回存储在缓存中的结果，否则进入下一阶段；
MySQL 服务器进行 SQL 解析，预处理，再由 SQL 优化器生成对应的执行计划；
根据执行计划，调用存储引擎 API 来查询数据；
将结果返回给客户端。
这就是 MySQL 服务器处理查询请求的整个过程。在第二到第五步，都有可能对查询的响应速度造成影响，下面来分别看下这些过程可能对查询的响应速度有影响的因素都有些什么：</p>
<p>在解析查询语句前，如果查询缓存是打开的，那么 MySQL 优先检查这个查询是否命中查询缓存中的数据，这个检查是通过一个对大小写敏感的 Hash 查找实现的。由于 Hash 查找只能进行全值匹配，所以请求的查询和缓存中的查询就算只有一个字节的不同，那么也不会匹配到缓存中的结果，这种情况下，查询就会进入到下一阶段处理。如果正好命中查询缓存，在返回查询结果之前，MySQL 就会检查用户权限，也是无需解析 SQL 语句的，因为在查询缓存中，已经存放了当前查询所需要访问的表的信息，如果权限没有问题，MySQL 会跳过所有的其他阶段，直接从缓存中拿到结果，并返回给客户端，这种情况下查询是不会被解析的，也不会生成查询计划，不会被执行。</p>
<p>可以发现，从查询缓存中直接返回结果并不容易。</p>
<p>查询缓存对 SQL 性能的影响：</p>
<p>如果查询缓存，一旦数据更新，都要对缓存中数据进行刷新，影响性能；
每次在查询缓存中检查 SQL 是否被命中，都要对缓存加锁，影响性能；
对于一个读写频繁的系统来说，查询缓存很可能会降低查询处理的效率。所以在这种情况下建议大家不要使用查询缓存。</p>
<p>对查询缓存影响的一些系统参数：</p>
<p>query_cache_type: 设置查询缓存是否可用，可以设置为ON、OFF、DEMAND，DEMAND表示只有在查询语句中使用 SQL_CACHE 和 SQL_NO_CACHE 来控制是否需要缓存。
query_cache_size: 设置查询缓存的内存大小，必须是1024字节的整数倍。
query_cache_limit: 设置查询缓存可用存储的最大值，如果知道很大不会被缓存，可以在查询上加上 SQL_NO_CACHE 提高效率。
query_cache_wlock_invalidate: 设置数据表被锁后是否返回缓存中的数据，默认关闭。
query_cache_min_res_unit: 设置查询缓存分配的内存块最小单位。</p>
<p>对于一个读写频繁的系统来说，可以把 query_cache_type 设置为 OFF，并且把 query_cache_size 设置为 0。</p>
<p>当查询缓存未启用或者未命中则会进入下一阶段，也就是需要将一个 SQL 转换成一个执行计划，MySQL 再依据这个执行计划和存储引擎进行交互，这个阶段包括了多个子过程：解析 SQL，预处理，优化 SQL 执行计划。在这个过程中，出现任何错误，比如语法错误等，都有可能中止查询的过程。</p>
<p>在语法解析阶段，主要是通过关键字对 MySQL 语句进行解析，并生成一棵对应的 “解析树”。这一阶段，MySQL 解析器将使用 MySQL 语法规则验证和解析查询，包括检查语法是否使用了正确的关键字、关键字的顺序是否正确等。</p>
<p>预处理阶段则是根据 MySQL 规则进一步检查解析树是否合法，比如检查查询中所涉及的表和数据列是否存在、检查名字或别名是否存在歧义等。</p>
<p>如果语法检查全部都通过了，查询优化器就可以生成查询计划了。</p>
<p>会造成 MySQL 生成错误的执行计划的原因：</p>
<p>统计信息不准确；
执行计划中的成本估算不等同于实际的执行计划的成本；
MySQL 查询优化器所认为的最优可能与你所认为的最优不一样；
MySQL 从不考虑其他并发的查询，这可能会影响当前查询的速度；
MySQL 有时候也会基于一些固定的规则来生成执行计划；
MySQL 不会考虑不受其控制的成本，例如存储过程、用户自定义的函数等。
MySQL 的查询优化器可以优化的 SQL 类型：</p>
<p>重新定义表的关联顺序，优化器会根据统计信息来决定表的关联顺序；
将外连接转化为内连接，比如 where 条件和库表结构都可能让一个外连接等价于内连接；
使用等价变换规则，比如 (5=5 and a&gt;5) 将被改写为 a&gt;5；
利用索引和列是否为空来优化 count()、min() 和 max() 等聚合函数；
将一个表达式转换为常数表达式；
使用等价变换规则，比如覆盖索引，当 MySQL 查询优化器发现索引中的列包含所有查询中所需要的信息的时候，MySQL 就能使用索引返回需要的数据；
子查询优化，比如把子查询转换为关联查询，减少表的查询次数；
提前终止查询；
对 in() 条件进行优化。
以上这些就是 MySQL 查询优化器可以自动对查询所做的一些优化。经过查询优化器改写后的 SQL，查询优化器会对其生成一个 SQL 执行计划，然后 MySQL 服务器就可以根据执行计划调用存储引擎的 API，通过存储引擎获取数据了。</p>
<p>3.确定查询处理各个阶段的耗时
SQL 查询优化的主要目的就是减少查询所消耗的时间，加快查询的响应速度。下面来介绍如何度量查询处理各个阶段所消耗的时间。</p>
<p>对于一个存在性能问题的 SQL 来说，必须知道在查询的哪一阶段消耗的时间最多，然后才能有针对性的进行优化。度量查询处理各个阶段所消耗的时间，常用的方法有两种：</p>
<p>使用 profile；
使用 performance_schema；
4.特定SQL的查询优化
前面介绍的方法，已经可以获取一个存在性能问题的 SQL 和获取一个 SQL 在执行的各个阶段所消耗的时间了。得到这些信息后，我们就可以针对性的对 SQL 进行优化了，下面举几个对特定 SQL 优化的案例：</p>
<p>1.大表的更新和删除
对于大表的数据修改最好要分批处理，比如我们要在一个 1000 万行记录的表中删除/更新 100 万行记录，那么我们最好分多个批次进行删除/更新，一次只删除/更新 5000 行记录，避免长时间的阻塞，并且为了减少对主从复制带来的压力，每次删除/修改数据后需要暂停几秒。这里提供一个可以完成这样工作的 MySQL 存储过程的实例：</p>
<p>DELIMITER $$
USE 'db_name'$$
DROP PROCEDURE IF EXISTS 'p_delete_rows'$$
CREATE DEFINER='mysql'@'127.0.0.1' PROCEDURE 'p_delete_rows'()
BEGIN
DECLARE v_rows INT;
SET v_rows = 1;
WHERE v_rows &gt; 0
DO
DELETE FROM table_name WHERE id &gt;= 9000 AND id &lt;= 290000 LIMIT 5000;
SELECT ROW_COUNT() INTO v_rows;
SELECT SLEEP(5);
END WHERE;
END$$
DELIMITER;</p>
<p>大家可以根据自己的情况来修改这个存储过程，或者使用自己熟悉的开发语言实现这个处理过程，使用这个存储过程只需要修改 DELETE FROM table_name WHERE id &gt;= 9000 AND id &lt;= 290000 LIMIT 5000; 部分的内容即可。</p>
<p>2.如何修改大表的表结构
对于 InnoDB 存储引擎来说，对表中的列的字段类型进行修改或者改变字段的宽度时还是会锁表，同时也无法解决主从数据库延迟的问题。</p>
<p>解决方案：</p>
<p>在主服务器上建立新表，新表的结构就是修改之后的结构，再把老表的数据导入到新表中，并且在老表上建立一系列的触发器，把老表数据的修改同步更新到新表中，当老表和新表的数据同步后，再对老表加一个排它锁，然后重新命名新表为老表的名字，最好删除重命名的老表，这样就完成了大表表结构修改的工作。这样处理的好处是可以尽量减少主从延迟，以及在重命名之前不需要加任何的锁，只需要在重命名的时候加一个短暂的锁，这对应用通常是无影响的，缺点就是操作比较复杂。好在有工具可以帮我们实行这个过程，这个工具同样是 percona 公司 MySQL 工具集中的一个，叫做 pt-online-schema-change：</p>
<p>pt-online-schema-change <br>
--alter=&quot;MODIFY c VARCHAR(150) NOT NULL DEFAULT ''&quot; <br>
--user=root --password=password D=db_name,t=table_name <br>
--charset=utf8 --execute
1
2
3
4
这个命令就是把 db_name 数据库下的 table_name 表中 c 列的宽度改为 VARCHAR(150)。</p>
<p>3.如何优化not in和&lt;&gt;查询
MySQL 查询优化器可以自动的把一些子查询优化为关联查询，但是对于存在not in和&lt;&gt;这样的子查询语句来说，就无法进行自动优化了，这就造成了会循环多次来查找子表来确认是否满足过滤条件，如果子查询恰好是一个很大的表的话，这样做的效率会非常低，所以我们在进行 SQL 开发时，最好把这类查询自行改写成关联查询。</p>
<p>改写前：</p>
<p>SELECT id,name,email
FROM customer
WHERE id
NOT IN(SELECT id FROM payment)
1
2
3
4
优化改写后：</p>
<p>SELECT a.id,a.name,a.email
FROM customer a
LEFT JOIN payment b ON a.id=b.id
WHERE b.id IS NULL
1
2
3
4
使用 LEFT JOIN 关联替代了 NOT IN 过滤，这样避免了对 payment 表进行多次查询，这是一种非常常用的对 NOT IN 的优化方式。</p>
<p>4.使用汇总表优化查询
最常见的就是商品的评论数，如果我们在用户访问页面时，实时的访问商品的评论数，通常来说，查询的 SQL 会类似于下面这个样子：</p>
<p>SELECT COUNT(*) FROM product_comment WHERE product_id = 10001;
1
这个 SQL 就是统计出所有 product_id = 10001 的评论，假设评论表中有上亿条记录，那么这个 SQL 执行起来是非常的慢的，如果有大量的并发访问，则会对数据库带来很大的压力。对于这么情况，我们通常使用汇总表的方式进行优化。所谓的汇总表就是提前把要统计的数据进行汇总并记录到表中已备后续的查询使用。针对这个查询，我们可以使用下面的方式进行优化：</p>
<p>CREATE TABLE product_comment_cnt(product_id INT, cnt INT);   //建立汇总表</p>
<p>//查询评论数
SELECT SUM(cnt) FROM(
SELECT cnt FROM product_comment_cnt WHERE product_id = 10001
UNION ALL
SELECT COUNT(*) FROM product_comment WHERE product_id = 10001
AND timestr &gt; DATE(NOW())
);</p>
<p>————————————————
版权声明：本文为CSDN博主「一叶知秋V」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/smartbetter/article/details/93541792</p>
<h3 id="_51-一条sql语句在mysql中如何执行的" tabindex="-1"><a class="header-anchor" href="#_51-一条sql语句在mysql中如何执行的" aria-hidden="true">#</a> 51.一条SQL语句在MySQL中如何执行的？</h3>
<p>MySQL 的处理流程主要分为 4 个步骤：客户端与服务端通信、查询优化处理过程、查询执行引擎、返回结果给客户端。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/formfdfdfdfat,png" alt="img"></p>
<h3 id="_52-金额-字段在数据库中怎么设计-与之对应的javabean是什么类型-该类型的除法运算怎么用的" tabindex="-1"><a class="header-anchor" href="#_52-金额-字段在数据库中怎么设计-与之对应的javabean是什么类型-该类型的除法运算怎么用的" aria-hidden="true">#</a> 52.“金额”字段在数据库中怎么设计？与之对应的JavaBean是什么类型？该类型的除法运算怎么用的？</h3>
<p>【decimal；BigDecimal；a.divide(b, scale).doubleValue()】</p>
<h3 id="_53-mysql的主键和oracle主键都怎么进行自增的" tabindex="-1"><a class="header-anchor" href="#_53-mysql的主键和oracle主键都怎么进行自增的" aria-hidden="true">#</a> 53.mysql的主键和Oracle主键都怎么进行自增的？</h3>
<p>【auto_increment ；序列】</p>
<h3 id="_54-mysql分页方式-oracle分页方式" tabindex="-1"><a class="header-anchor" href="#_54-mysql分页方式-oracle分页方式" aria-hidden="true">#</a> 54.mysql分页方式，Oracle分页方式？</h3>
<p>【①.原生语句——limit，rownum；②.mysql有分页插件——可能会问你插件原理，慎答！】</p>
<h3 id="_55-mysql的分区类型及使用场景" tabindex="-1"><a class="header-anchor" href="#_55-mysql的分区类型及使用场景" aria-hidden="true">#</a> 55.mysql的分区类型及使用场景？</h3>
<p>【range，list，hash等】</p>
<h3 id="_56-oracle怎么解决死锁问题" tabindex="-1"><a class="header-anchor" href="#_56-oracle怎么解决死锁问题" aria-hidden="true">#</a> 56.Oracle怎么解决死锁问题?</h3>
<p>【造成的原因——sql一直处于执行状态，可能是多用户操作同一张表未提交事务而导致；解决思路——查询哪些对象存在死锁，杀死进程】
项目中让你设计数据库，说下设计思路。
场景：有订单模块，支付模块，库存模块，商场首页等模块组成的系统，你怎么设计数据库的表？具体有哪些表？【同第8题】</p>
<h3 id="_57-mysql索引底层结构-及特点" tabindex="-1"><a class="header-anchor" href="#_57-mysql索引底层结构-及特点" aria-hidden="true">#</a> 57.mysql索引底层结构，及特点？</h3>
<p>【分存储引擎，若InnoDB默认B+Tree，还有hash；B+Tree特点 —— 叶子结点冗余非叶子节点数据，且叶子结点从左往右相邻节点存在引用关系，适合范围和模糊查询，而hash是k-v结构，适合等值查询！】</p>
<h3 id="_58-mysql如何实现加锁的-及如何实现乐观锁" tabindex="-1"><a class="header-anchor" href="#_58-mysql如何实现加锁的-及如何实现乐观锁" aria-hidden="true">#</a> 58.mysql如何实现加锁的，及如何实现乐观锁？</h3>
<p>【这要了解mysql锁机制，MVCC，表锁和行锁等才能回答上来…】</p>
<h3 id="_59-mysql如何排查慢sql语句问题" tabindex="-1"><a class="header-anchor" href="#_59-mysql如何排查慢sql语句问题" aria-hidden="true">#</a> 59.mysql如何排查慢SQL语句问题？</h3>
<p>【mysql提供了慢日志查询，具体的也可以展开说…】</p>
<h5 id="一、导致sql执行慢的原因" tabindex="-1"><a class="header-anchor" href="#一、导致sql执行慢的原因" aria-hidden="true">#</a> <strong>一、导致SQL执行慢的原因</strong></h5>
<p>1、硬件问题。如网络速度慢，内存不足，I/O吞吐量小，磁盘空间满了等。</p>
<p>2、没有索引或者索引失效。（一般在互联网公司，DBA会在半夜把表锁了，重新建立一遍索引，因为当你删除某个数据的时候，索引的树结构就不完整了。所以互联网公司的数据做的是假删除，一是为了做数据分析,二是为了不破坏索引 ）</p>
<p>3、数据过多（分库分表）</p>
<p>4、服务器调优及各个参数设置（调整my.cnf）</p>
<h5 id="二、分析原因时-一定要找切入点" tabindex="-1"><a class="header-anchor" href="#二、分析原因时-一定要找切入点" aria-hidden="true">#</a> <strong>二、分析原因时，一定要找切入点</strong></h5>
<p>1、先观察，开启慢查询日志，设置相应的阈值（比如超过3秒就是慢SQL），在生产环境跑上个一天过后，看看哪些SQL比较慢。</p>
<p>2、Explain和慢SQL分析。比如SQL语句写的烂，索引没有或失效，关联查询太多（有时候是设计缺陷或者不得以的需求）等等。</p>
<p>3、Show Profile是比Explain更近一步的执行细节，可以查询到执行每一个SQL都干了什么事，这些事分别花了多少秒。</p>
<p>4、找DBA或者运维对MySQL进行服务器的参数调优。</p>
<p>解析：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>(1)explain出来的各种item的意义

id:每个被独立执行的操作的标志，表示对象被操作的顺序。一般来说， id 值大，先被执行；如果 id 值相同，则顺序从上到下。
select_type：查询中每个 select 子句的类型。
table:名字，被操作的对象名称，通常的表名(或者别名)，但是也有其他格式。
partitions:匹配的分区信息。
type:join 类型。
possible_keys：列出可能会用到的索引。
key:实际用到的索引。
key_len:用到的索引键的平均长度，单位为字节。
ref:表示本行被操作的对象的参照对象，可能是一个常量用 const 表示，也可能是其他表的
key 指向的对象，比如说驱动表的连接列。
rows:估计每次需要扫描的行数。
filtered:rows*filtered/100 表示该步骤最后得到的行数(估计值)。
extra:重要的补充信息。

(2)profile的意义以及使用场景

Profile 用来分析 sql 性能的消耗分布情况。当用 explain 无法解决慢 SQL 的时候，需要用profile 来对 sql 进行更细致的分析，找出 sql 所花的时间大部分消耗在哪个部分，确认 sql的性能瓶颈。

(3)explain 中的索引问题

Explain 结果中，一般来说，要看到尽量用 index(type 为 const、 ref 等， key 列有值)，避免使用全表扫描(type 显式为 ALL)。比如说有 where 条件且选择性不错的列，需要建立索引。
被驱动表的连接列，也需要建立索引。被驱动表的连接列也可能会跟 where 条件列一起建立联合索引。当有排序或者 group by 的需求时，也可以考虑建立索引来达到直接排序和汇总的需求。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_60-mysql-中-varchar-与-char-的区别-varchar-50-中的-50-代表的涵义" tabindex="-1"><a class="header-anchor" href="#_60-mysql-中-varchar-与-char-的区别-varchar-50-中的-50-代表的涵义" aria-hidden="true">#</a> 60.MySQL 中 varchar 与 char 的区别？varchar(50) 中的 50 代表的涵义？</h3>
<p>1、varchar 与 char 的区别，char 是一种固定长度的类型，varchar 则是一种可变长度的类型。
2、varchar(50) 中 50 的涵义最多存放 50 个字符。varchar(50) 和 (200) 存储 hello 所占空间一样，但后者在排序时会消耗更多内存，因为 ORDER BY col 采用 fixed_length 计算 col 长度(memory引擎也一样)。所以，实际场景下，选择合适的 varchar 长度还是有必要的。</p>
<h3 id="_61-金额-金钱-相关的数据-选择什么数据类型" tabindex="-1"><a class="header-anchor" href="#_61-金额-金钱-相关的数据-选择什么数据类型" aria-hidden="true">#</a> 61.<strong>金额(金钱)相关的数据，选择什么数据类型？</strong></h3>
<ul>
<li>方式一，使用 int 或者 bigint 类型。如果需要存储到分的维度，需要 *100 进行放大。</li>
<li>方式二，使用 decimal 类型，避免精度丢失。如果使用 Java 语言时，需要使用 BigDecimal 进行对应。</li>
</ul>
<h3 id="_62-一张表-里面有-id-自增主键-当-insert-了-17-条记录之后-删除了第-15-16-17-条记录-再把-mysql-重启-再-insert-一条记录-这条记录的-id-是-18-还是-15" tabindex="-1"><a class="header-anchor" href="#_62-一张表-里面有-id-自增主键-当-insert-了-17-条记录之后-删除了第-15-16-17-条记录-再把-mysql-重启-再-insert-一条记录-这条记录的-id-是-18-还是-15" aria-hidden="true">#</a> 62.一张表，里面有 ID 自增主键，当 insert 了 17 条记录之后，删除了第 15,16,17 条记录，再把 MySQL 重启，再 insert 一条记录，这条记录的 ID 是 18 还是 15？</h3>
<p>一般情况下，我们创建的表的类型是 InnoDB ，如果新增一条记录（不重启 MySQL 的情况下），这条记录的 ID 是18 ；但是如果重启 MySQL 的话，这条记录的 ID 是 15 。因为 InnoDB 表只把自增主键的最大 ID 记录到内存中，所以重启数据库或者对表 OPTIMIZE 操作，都会使最大 ID 丢失。
但是，如果我们使用表的类型是 MyISAM ，那么这条记录的 ID 就是 18 。因为 MyISAM 表会把自增主键的最大 ID 记录到数据文件里面，重启 MYSQL 后，自增主键的最大 ID 也不会丢失。
————————————————</p>
<h3 id="_63-表中有大字段-x-例如-text-类型-且字段-x-不会经常更新-以读为为主-请问您是选择拆成子表-还是继续放一起-写出您这样选择的理由" tabindex="-1"><a class="header-anchor" href="#_63-表中有大字段-x-例如-text-类型-且字段-x-不会经常更新-以读为为主-请问您是选择拆成子表-还是继续放一起-写出您这样选择的理由" aria-hidden="true">#</a> 63.表中有大字段 X(例如：text 类型)，且字段 X 不会经常更新，以读为为主，请问您是选择拆成子表，还是继续放一起?写出您这样选择的理由</h3>
<p>拆带来的问题：连接消耗 + 存储拆分空间。</p>
<p>如果能容忍拆分带来的空间问题，拆的话最好和经常要查询的表的主键在物理结构上放置在一起(分区) 顺序 IO ，减少连接消耗，最后这是一个文本列再加上一个全文索引来尽量抵消连接消耗。</p>
<p>不拆可能带来的问题：查询性能。</p>
<p>如果能容忍不拆分带来的查询性能损失的话，上面的方案在某个极致条件下肯定会出现问题，那么不拆就是最好的选择。</p>
<p>实际场景下，例如说商品表数据量比较大的情况下，会将商品描述单独存储到一个表中。即，使用拆的方案。
————————————————</p>
<h3 id="_64-mysql-默认的存储引擎是-innodb-并且也是最主流的选择。主要原因如下" tabindex="-1"><a class="header-anchor" href="#_64-mysql-默认的存储引擎是-innodb-并且也是最主流的选择。主要原因如下" aria-hidden="true">#</a> 64.MySQL 默认的存储引擎是 InnoDB ，并且也是最主流的选择。主要原因如下：</h3>
<p>【最重要】支持事务。
支持行级锁和表级锁，能支持更多的并发量。
查询不加锁，完全不影响查询。
支持崩溃后恢复。
在 MySQL5.1 以及之前的版本，默认的存储引擎是 MyISAM ，但是目前已经不再更新，且它有几个比较关键的缺点：</p>
<p>不支持事务。
使用表级锁，如果数据量大，一个插入操作锁定表后，其他请求都将阻塞。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218141159433.png" alt="image-20211218141159433"></p>
<h3 id="_65-请说说-innodb-的-4-大特性" tabindex="-1"><a class="header-anchor" href="#_65-请说说-innodb-的-4-大特性" aria-hidden="true">#</a> 65.<strong>请说说 InnoDB 的 4 大特性？</strong></h3>
<ul>
<li>插入缓冲(insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h3 id="_66-为什么-select-count-from-table-在-innodb-比-myisam-慢" tabindex="-1"><a class="header-anchor" href="#_66-为什么-select-count-from-table-在-innodb-比-myisam-慢" aria-hidden="true">#</a> 66.为什么 SELECT COUNT(*) FROM table 在 InnoDB 比 MyISAM 慢？</h3>
<p>对于 SELECT COUNT(*) FROM table 语句，在没有 WHERE 条件的情况下，InnoDB 比 MyISAM 可能会慢很多，尤其在大表的情况下。因为，InnoDB 是去实时统计结果，会全表扫描；而 MyISAM 内部维持了一个计数器，预存了结果，所以直接返回即可。
————————————————</p>
<h3 id="_67-各种不同-mysql-版本的-innodb-的改进" tabindex="-1"><a class="header-anchor" href="#_67-各种不同-mysql-版本的-innodb-的改进" aria-hidden="true">#</a> 67.各种不同 MySQL 版本的 Innodb 的改进？</h3>
<p>MySQL5.6 下 Innodb 引擎的主要改进：</p>
<p>online DDL
memcached NoSQL 接口
transportable tablespace（ alter table discard/import tablespace）
MySQL 正常关闭时，可以 dump 出 buffer pool 的（ space， page_no），重启时 reload，加快预热速度
索引和表的统计信息持久化到 mysql.innodb_table_stats 和 mysql.innodb_index_stats，可提供稳定的执行计划
Compressed row format 支持压缩表</p>
<p>MySQL5.7 下 Innodb 引擎的主要改进：</p>
<p>1、修改 varchar 字段长度有时可以使用</p>
<p>这里的“有时”，指的是也有些限制。可见 《MySQL 5.7 online ddl 的一些改进》 。</p>
<p>2、Buffer pool 支持在线改变大小</p>
<p>3、Buffer pool 支持导出部分比例</p>
<p>4、支持新建 innodb tablespace，并可以在其中创建多张表</p>
<p>5、磁盘临时表采用 innodb 存储，并且存储在 innodb temp tablespace 里面，以前是 MyISAM 存储</p>
<p>6、透明表空间压缩功能</p>
<h3 id="_68-mysql-索引的-创建-原则" tabindex="-1"><a class="header-anchor" href="#_68-mysql-索引的-创建-原则" aria-hidden="true">#</a> 68.MySQL 索引的“创建”原则？</h3>
<p>注意，是“创建”噢。</p>
<p>1、最适合索引的列是出现在 WHERE 子句中的列，或连接子句中的列，而不是出现在 SELECT 关键字后的列。</p>
<p>2、索引列的基数越大，索引效果越好。</p>
<p>具体为什么，可以看看如下两篇文章：</p>
<p>《MySQL 索引基数》 理解相对简单
《低基数索引为什么会对性能产生负面影响》 写的更原理，所以较为难懂。
3、根据情况创建复合索引，复合索引可以提高查询效率。</p>
<p>因为复合索引的基数会更大。</p>
<p>4、避免创建过多的索引，索引会额外占用磁盘空间，降低写操作效率。</p>
<p>5、主键尽可能选择较短的数据类型，可以有效减少索引的磁盘占用提高查询效率。</p>
<p>6、对字符串进行索引，应该定制一个前缀长度，可以节省大量的索引空间。
————————————————</p>
<h3 id="_69-mysql-索引的-使用-注意事项" tabindex="-1"><a class="header-anchor" href="#_69-mysql-索引的-使用-注意事项" aria-hidden="true">#</a> 69.MySQL 索引的“使用”注意事项？</h3>
<p>注意，是“使用”噢。</p>
<p>1、应尽量避免在 WHERE 子句中使用 != 或 &lt;&gt; 操作符，否则将引擎放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。</p>
<p>注意，column IS NULL 也是不可以使用索引的。</p>
<p>2、应尽量避免在 WHERE 子句中使用 OR 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：SELECT id FROM t WHERE num = 10 OR num = 20 。</p>
<p>3、应尽量避免在 WHERE 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
<p>4、应尽量避免在 WHERE 子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。</p>
<p>5、不要在 WHERE 子句中的 = 左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
<p>6、复合索引遵循前缀原则。</p>
<p>7、如果 MySQL 评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中添加强制索引。</p>
<p>8、列类型是字符串类型，查询时一定要给值加引号，否则索引失效。</p>
<p>9、LIKE 查询，% 不能在前，因为无法使用索引。如果需要模糊匹配，可以使用全文索引。
————————————————</p>
<h3 id="_70-聚簇索引的注意点有哪些" tabindex="-1"><a class="header-anchor" href="#_70-聚簇索引的注意点有哪些" aria-hidden="true">#</a> 70.聚簇索引的注意点有哪些？</h3>
<p>聚簇索引表最大限度地提高了 I/O 密集型应用的性能，但它也有以下几个限制：</p>
<p>1、插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于 InnoDB 表，我们一般都会定义一个自增的 ID 列为主键。</p>
<p>关于这一点，可能面试官会换一个问法。例如，为什么主键需要是自增 ID ，又或者为什么主键需要带有时间性关联。</p>
<p>2、更新主键的代价很高，因为将会导致被更新的行移动。因此，对于InnoDB 表，我们一般定义主键为不可更新。</p>
<p>MySQL 默认情况下，主键是允许更新的。对于 MongoDB ，其 主键是不允许更新的。</p>
<p>3、二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。</p>
<p>当然，有一种情况可以无需二次查找，基于非主键索引查询，但是查询字段只有主键 ID ，那么在二级索引中就可以查找到。</p>
<p>4、主键 ID 建议使用整型。因为，每个主键索引的 B+Tree 节点的键值可以存储更多主键 ID ，每个非主键索引的 B+Tree 节点的数据可以存储更多主键 ID 。</p>
<h3 id="_71-myisam-索引实现" tabindex="-1"><a class="header-anchor" href="#_71-myisam-索引实现" aria-hidden="true">#</a> 71.MyISAM 索引实现？</h3>
<p>MyISAM 索引的实现，和 InnoDB 索引的实现是一样使用 B+Tree ，差别在于 MyISAM 索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。</p>
<p>MyISAM 索引与 InnoDB 索引的区别？</p>
<p>InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。
InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。
MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。
InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</p>
<h3 id="_72-mysql-中-innodb-引擎的行锁是通过加在什么上完成-或称实现-的-为什么是这样子的" tabindex="-1"><a class="header-anchor" href="#_72-mysql-中-innodb-引擎的行锁是通过加在什么上完成-或称实现-的-为什么是这样子的" aria-hidden="true">#</a> 72.MySQL 中 InnoDB 引擎的行锁是通过加在什么上完成(或称实现)的？为什么是这样子的？？</h3>
<p>InnoDB 是基于索引来完成行锁。例如：SELECT * FROM tab_with_index WHERE id = 1 FOR UPDATE 。</p>
<p>FOR UPDATE 可以根据条件来完成行锁锁定，并且 id 是有索引键的列,如果 id 不是索引键那么 InnoDB 将完成表锁，并发将无从谈起。</p>
<h3 id="_73-【重要】mysql-查询执行顺序" tabindex="-1"><a class="header-anchor" href="#_73-【重要】mysql-查询执行顺序" aria-hidden="true">#</a> 73.【重要】MySQL 查询执行顺序？</h3>
<p>MySQL 查询执行的顺序是：</p>
<p>(1)     SELECT
(2)     DISTINCT &lt;select_list&gt;
(3)     FROM &lt;left_table&gt;
(4)     &lt;join_type&gt; JOIN &lt;right_table&gt;
(5)     ON &lt;join_condition&gt;
(6)     WHERE &lt;where_condition&gt;
(7)     GROUP BY &lt;group_by_list&gt;
(8)     HAVING &lt;having_condition&gt;
(9)     ORDER BY &lt;order_by_condition&gt;
(10)    LIMIT &lt;limit_number&gt;
————————————————</p>
<h3 id="_74-请简述项目中优化mysql语句执行效率的方法-从哪些方面入手-sql语句性能如何分析" tabindex="-1"><a class="header-anchor" href="#_74-请简述项目中优化mysql语句执行效率的方法-从哪些方面入手-sql语句性能如何分析" aria-hidden="true">#</a> 74.请简述项目中优化MySQL语句执行效率的方法，从哪些方面入手，SQL语句性能如何分析？</h3>
<p>分析查询速度</p>
<ul>
<li>记录慢查询日志
分析查询日志，使用<code v-pre>pt-query-digest</code>工具进行分析</li>
<li>使用<code v-pre>show profile</code>
set peofiling=1; # 服务器上执行的所有语句会检测消耗的时间、存到临时表中
<code v-pre>show profiles # 所有的SQL语句执行记录</code>
<code v-pre>show profile for query 临时表ID # 查执行ID的SQL语句</code></li>
</ul>
<div class="language-ruby line-numbers-mode" data-ext="rb"><pre v-pre class="language-ruby"><code>mysql<span class="token operator">></span> set profiling<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
Query <span class="token constant">OK</span><span class="token punctuation">,</span> <span class="token number">0</span> rows affected

mysql<span class="token operator">></span> select <span class="token operator">*</span> from user<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> name <span class="token operator">|</span> age <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> Jack <span class="token operator">|</span>  <span class="token number">23</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token number">1</span> row <span class="token keyword">in</span> set

mysql<span class="token operator">></span> show profiles<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> Query_ID <span class="token operator">|</span> Duration   <span class="token operator">|</span> Query                                                                                                                           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>  
<span class="token operator">|</span>       <span class="token number">1</span> <span class="token operator">|</span>   <span class="token number">8.675E-5</span> <span class="token operator">|</span> set profiling<span class="token operator">=</span><span class="token number">1</span>                                                                                                                 <span class="token operator">|</span>
<span class="token operator">|</span>       <span class="token number">2</span><span class="token operator">|</span>   <span class="token number">0.000197</span> <span class="token operator">|</span> select <span class="token operator">*</span> from user                                                                                                              <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token number">10</span> rows <span class="token keyword">in</span> set

mysql<span class="token operator">></span> show profile <span class="token keyword">for</span> query <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> Status               <span class="token operator">|</span> Duration <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> starting             <span class="token operator">|</span> <span class="token number">4.3E-5</span>   <span class="token operator">|</span>
<span class="token operator">|</span> checking permissions <span class="token operator">|</span> <span class="token number">7E-6</span>     <span class="token operator">|</span>
<span class="token operator">|</span> Opening tables       <span class="token operator">|</span> <span class="token number">1.8E-5</span>   <span class="token operator">|</span>
<span class="token operator">|</span> System lock          <span class="token operator">|</span> <span class="token number">1E-5</span>     <span class="token operator">|</span>
<span class="token operator">|</span> init                 <span class="token operator">|</span> <span class="token number">1.4E-5</span>   <span class="token operator">|</span>
<span class="token operator">|</span> optimizing           <span class="token operator">|</span> <span class="token number">4E-6</span>     <span class="token operator">|</span>
<span class="token operator">|</span> statistics           <span class="token operator">|</span> <span class="token number">3.1E-5</span>   <span class="token operator">|</span>
<span class="token operator">|</span> preparing            <span class="token operator">|</span> <span class="token number">1E-5</span>     <span class="token operator">|</span>
<span class="token operator">|</span> executing            <span class="token operator">|</span> <span class="token number">2E-6</span>     <span class="token operator">|</span>
<span class="token operator">|</span> Sending data         <span class="token operator">|</span> <span class="token number">1E-5</span>     <span class="token operator">|</span>
<span class="token operator">|</span> <span class="token keyword">end</span>                  <span class="token operator">|</span> <span class="token number">3E-6</span>     <span class="token operator">|</span>
<span class="token operator">|</span> query <span class="token keyword">end</span>            <span class="token operator">|</span> <span class="token number">2E-6</span>     <span class="token operator">|</span>
<span class="token operator">|</span> closing tables       <span class="token operator">|</span> <span class="token number">5E-6</span>     <span class="token operator">|</span>
<span class="token operator">|</span> freeing items        <span class="token operator">|</span> <span class="token number">3.5E-5</span>   <span class="token operator">|</span>
<span class="token operator">|</span> logging slow query   <span class="token operator">|</span> <span class="token number">3E-6</span>     <span class="token operator">|</span>
<span class="token operator">|</span> cleaning up          <span class="token operator">|</span> <span class="token number">2E-6</span>     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token number">16</span> rows <span class="token keyword">in</span> set
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>show status
<code v-pre>show status</code>会返回一些计数器，<code v-pre>show global status</code>查看服务器级别的所有计数。</li>
<li>show processlist
观察是否有大量的线程处于不正常的状态或特征。</li>
<li>explain
分析单条的SQL语句</li>
</ul>
<div class="language-ruby line-numbers-mode" data-ext="rb"><pre v-pre class="language-ruby"><code>mysql<span class="token operator">></span> explain select <span class="token operator">*</span> from user<span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> table <span class="token operator">|</span> type   <span class="token operator">|</span> possible_keys <span class="token operator">|</span> key  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> rows <span class="token operator">|</span> Extra <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token constant">SIMPLE</span>      <span class="token operator">|</span> user  <span class="token operator">|</span> system <span class="token operator">|</span> <span class="token constant">NULL</span>          <span class="token operator">|</span> <span class="token constant">NULL</span> <span class="token operator">|</span> <span class="token constant">NULL</span>    <span class="token operator">|</span> <span class="token constant">NULL</span> <span class="token operator">|</span>    <span class="token number">1</span> <span class="token operator">|</span>       <span class="token operator">|</span>
<span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">-</span><span class="token operator">+</span>
<span class="token number">1</span> row <span class="token keyword">in</span> set
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote>
<p>explain它有一个别名<code v-pre>desc</code>，所以使用<code v-pre>explain select * from user;</code>查询到的结果与上面的一样。</p>
</blockquote>
<h5 id="优化查询过程中的数据访问" tabindex="-1"><a class="header-anchor" href="#优化查询过程中的数据访问" aria-hidden="true">#</a> 优化查询过程中的数据访问</h5>
<ul>
<li>数据太多会导致查询性能下降。</li>
<li>确定应用程序是否在检索大量超过需要的数据，可能太多行或列。</li>
<li>确认MySQL服务器是否在分析大量不必要的数据行</li>
</ul>
<p><strong>避免使用以下SQL语句</strong></p>
<ul>
<li>查询不需要的记录，使用<code v-pre>limit</code>解决</li>
<li>多表管理返回全部列，需要制定列，如A.id、B.name等</li>
<li>总是取出全部列，<code v-pre>select *</code>会让优化器无法完成索引覆盖扫描优化</li>
<li>重复查询相同的数据，可以使用缓存，下次直接读取缓存</li>
</ul>
<p><strong>是否在扫描额外的记录</strong>
使用<code v-pre>explain</code>来进行分析，如果发现查询需要扫描大量的数据但是只返回少数的行，可以通过如下技巧去优化：</p>
<ul>
<li>使用索引覆盖扫描，把所有的列都放在索引中。</li>
<li>改变数据库和表的结构，修改数据表范式</li>
<li>重写SQL语句，让优化器可以以最优的方式执行查询</li>
</ul>
<h5 id="优化长难的查询语句" tabindex="-1"><a class="header-anchor" href="#优化长难的查询语句" aria-hidden="true">#</a> 优化长难的查询语句</h5>
<p>使用尽可能小的查询是好的，但有时将一个大的查询分解成多个小的查询是很有必要的。</p>
<ul>
<li><strong>切分查询</strong>
将一个大的查询分为多个小的相同的查询
一次性删除1000万的数据比一次删除1万，暂停一会儿在执行删除1万条数据要较少更多的服务器开销。</li>
<li><strong>分解关联查询</strong>
可以将一条关联语句分解成多个SQL语句执行
让缓存的效率更高
执行单个查询可以减少锁的竞争
在应用层做关联可以更容易对数据库进行拆分</li>
</ul>
<h5 id="优化特定类型的查询语句" tabindex="-1"><a class="header-anchor" href="#优化特定类型的查询语句" aria-hidden="true">#</a> 优化特定类型的查询语句</h5>
<h5 id="优化count-查询" tabindex="-1"><a class="header-anchor" href="#优化count-查询" aria-hidden="true">#</a> 优化<code v-pre>count()</code>查询</h5>
<ul>
<li><code v-pre>count(*)</code>占用的<code v-pre>*</code>会忽略所有的列，直接统计所有的列数，因此不要使用<code v-pre>count(列名)</code></li>
<li>MyISAM中<code v-pre>没有任何where条件的count(* )</code>查询速度非常快</li>
<li><code v-pre>有where条件</code>时，MyISAM的count统计不一定比其他表引擎快</li>
</ul>
<p>优化：</p>
<ul>
<li>可以使用<code v-pre>explain</code>查询近似值，用近似值代替<code v-pre>count(*)</code></li>
<li>增加汇总表</li>
<li>使用缓存</li>
</ul>
<h5 id="优化关联查询" tabindex="-1"><a class="header-anchor" href="#优化关联查询" aria-hidden="true">#</a> 优化关联查询</h5>
<ul>
<li>确定on或者using子句的列上有索引；</li>
<li>确保<code v-pre>group by</code>和<code v-pre>order by</code>中只有一个表中的列，这样MySQL才有可能使用索引；</li>
</ul>
<h5 id="优化子查询" tabindex="-1"><a class="header-anchor" href="#优化子查询" aria-hidden="true">#</a> 优化子查询</h5>
<p>尽量使用关联查询替代</p>
<h5 id="优化group-by和distinct" tabindex="-1"><a class="header-anchor" href="#优化group-by和distinct" aria-hidden="true">#</a> 优化<code v-pre>group by</code>和<code v-pre>distinct</code></h5>
<ul>
<li>使用<strong>索引</strong>来优化</li>
<li>关联查询中，使用<strong>标识列</strong>（主键列）进行分组的效率会更高</li>
<li>如果不需要<code v-pre>order by</code>，进行<code v-pre>group by</code>时使用<code v-pre>order by NULL</code>，MySQL不会进行文件排序</li>
<li><code v-pre>with rollup</code>超级剧和，可以挪到应用程序处理</li>
</ul>
<h5 id="优化limit子句" tabindex="-1"><a class="header-anchor" href="#优化limit子句" aria-hidden="true">#</a> 优化<code v-pre>limit</code>子句</h5>
<p><code v-pre>limit</code>偏移量大的时候，查询效率较低。</p>
<p>方案：</p>
<ul>
<li>记录上一次查询的最大ID，下次查询时直接根据ID来查询（还是使用limit查询，不过加一个where条件，id &gt; ID）</li>
</ul>
<h5 id="优化union" tabindex="-1"><a class="header-anchor" href="#优化union" aria-hidden="true">#</a> 优化<code v-pre>union</code></h5>
<p><code v-pre>union all</code> 的效率高于<code v-pre>union</code>。</p>
<h3 id="_75-mysql-数据库-cpu-飙升到-500-的话-怎么处理" tabindex="-1"><a class="header-anchor" href="#_75-mysql-数据库-cpu-飙升到-500-的话-怎么处理" aria-hidden="true">#</a> 75.MySQL 数据库 CPU 飙升到 500% 的话，怎么处理？</h3>
<p>当 CPU 飙升到 500% 时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>
<p>如果此时是 IO 压力比较大，可以使用 iostat 命令，定位是哪个进程占用了磁盘 IO 。</p>
<p>如果是 mysqld 造成的，使用 show processlist 命令，看看里面跑的 Session 情况，是不是有消耗资源的 SQL 在运行。找出消耗高的 SQL ，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。一般来说，肯定要 kill 掉这些线程(同时观察 CPU 使用率是否下降)，等进行相应的调整(比如说加索引、改 SQL 、改内存参数)之后，再重新跑这些 SQL。</p>
<p>也可以查看 MySQL 慢查询日志，看是否有慢 SQL 。</p>
<p>也有可能是每个 SQL 消耗资源并不多，但是突然之间，有大量的 Session 连进来导致 CPU 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等。
————————————————</p>
<h3 id="_76-在-mysql-服务器运行缓慢的情况下输入什么命令能缓解服务器压力" tabindex="-1"><a class="header-anchor" href="#_76-在-mysql-服务器运行缓慢的情况下输入什么命令能缓解服务器压力" aria-hidden="true">#</a> 76.在 MySQL 服务器运行缓慢的情况下输入什么命令能缓解服务器压力？</h3>
<p>1）检查系统的状态</p>
<p>通过操作系统的一些工具检查系统的状态，比如 CPU、内存、交换、磁盘的利用率，根据经验或与系统正常时的状态相比对，有时系统表面上看起来看空闲，这也可能不是一个正常的状态，因为 CPU 可能正等待IO的完成。除此之外，还应观注那些占用系统资源(CPU、内存)的进程。</p>
<p>使用 sar 来检查操作系统是否存在 IO 问题。
使用 vmstat 监控内存 CPU 资源。
磁盘 IO 问题，处理方式：做 raid10 提高性能 。
网络问题，telnet 一下 MySQL 对外开放的端口。如果不通的话，看看防火墙是否正确设置了。另外，看看 MySQ L是不是开启了 skip-networking 的选项，如果开启请关闭。</p>
<p>2）检查 MySQL 参数</p>
<p>max_connect_errors
connect_timeout
skip-name-resolve
slave-net-timeout=seconds
master-connect-retry</p>
<p>3）检查 MySQL 相关状态值</p>
<p>关注连接数
关注下系统锁情况
关注慢查询（slow query）日志</p>
<h3 id="_77-innodb-的事务与日志的实现方式" tabindex="-1"><a class="header-anchor" href="#_77-innodb-的事务与日志的实现方式" aria-hidden="true">#</a> 77.Innodb 的事务与日志的实现方式</h3>
<h5 id="有多少种日志" tabindex="-1"><a class="header-anchor" href="#有多少种日志" aria-hidden="true">#</a> 有多少种日志？</h5>
<p>redo 日志
undo 日志</p>
<h5 id="日志的存放形式" tabindex="-1"><a class="header-anchor" href="#日志的存放形式" aria-hidden="true">#</a> 日志的存放形式？</h5>
<p>redo：在页修改的时候，先写到 redo log buffer 里面， 然后写到 redo log 的文件系统缓存里面(fwrite)，然后再同步到磁盘文件（fsync）。
undo：在 MySQL5.5 之前，undo 只能存放在 ibdata* 文件里面， 5.6 之后，可以通过设置 innodb_undo_tablespaces 参数把 undo log 存放在 ibdata* 之外。</p>
<h5 id="事务是如何通过日志来实现的-说得越深入越好" tabindex="-1"><a class="header-anchor" href="#事务是如何通过日志来实现的-说得越深入越好" aria-hidden="true">#</a> 事务是如何通过日志来实现的，说得越深入越好</h5>
<p>基本流程如下：</p>
<p>因为事务在修改页时，要先记 undo ，在记 undo 之前要记 undo 的 redo， 然后修改数据页，再记数据页修改的 redo。 redo（里面包括 undo 的修改）一定要比数据页先持久化到磁盘。
当事务需要回滚时，因为有 undo，可以把数据页回滚到前镜像的状态。
崩溃恢复时，如果 redo log 中事务没有对应的 commit 记录，那么需要用 undo 把该事务的修改回滚到事务开始之前。如果有 commit 记录，就用 redo 前滚到该事务完成时并提交掉。</p>
<h3 id="_78-mysql-binlog-的几种日志录入格式以及区别" tabindex="-1"><a class="header-anchor" href="#_78-mysql-binlog-的几种日志录入格式以及区别" aria-hidden="true">#</a> 78.MySQL binlog 的几种日志录入格式以及区别</h3>
<h5 id="各种日志格式的涵义" tabindex="-1"><a class="header-anchor" href="#各种日志格式的涵义" aria-hidden="true">#</a> 各种日志格式的涵义</h5>
<p>binlog 有三种格式类型，分别如下：</p>
<p>1）Statement</p>
<p>每一条会修改数据的 SQL 都会记录在 binlog 中。</p>
<p>优点：不需要记录每一行的变化，减少了 binlog 日志量，节约了 IO，提高性能。(相比 row 能节约多少性能与日志量，这个取决于应用的 SQL 情况，正常同一条记录修改或者插入 row 格式所产生的日志量还小于 Statement 产生的日志量，但是考虑到如果带条件的 update 操作，以及整表删除，alter 表等操作，ROW 格式会产生大量日志，因此在考虑是否使用 ROW 格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的 IO 性能问题。)</p>
<p>缺点：由于记录的只是执行语句，为了这些语句能在 slave 上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息，以保证所有语句能在 slave 得到和在 master 端执行时候相同 的结果。另外 MySQL 的复制，像一些特定函数功能，slave 可与 master 上要保持一致会有很多相关问题(如 sleep() 函数，last_insert_id()，以及 user-defined functions(udf) 会出现问题)。</p>
<p>使用以下函数的语句也无法被复制：</p>
<ul>
<li>
<p>LOAD_FILE()</p>
</li>
<li>
<p>UUID()</p>
</li>
<li>
<p>USER()</p>
</li>
<li>
<p>FOUND_ROWS()</p>
</li>
</ul>
<p>SYSDATE() (除非启动时启用了 --sysdate-is-now 选项)</p>
<p>同时在 INSERT …SELECT 会产生比 RBR 更多的行级锁 。</p>
<p>2）Row</p>
<p>不记录 SQL 语句上下文相关信息，仅保存哪条记录被修改。</p>
<p>优点：binlog 中可以不记录执行的 SQL 语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以 rowlevel 的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或 function ，以及 trigger 的调用和触发无法被正确复制的问题。
缺点：所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条 Update 语句，修改多条记录，则 binlog 中每一条修改都会有记录，这样造成 binlog 日志量会很大，特别是当执行 alter table 之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。
3）Mixedlevel</p>
<p>是以上两种 level 的混合使用。</p>
<p>一般的语句修改使用 Statement 格式保存 binlog 。
如一些函数，statement 无法完成主从复制的操作，则采用 Row 格式保存 binlog 。
MySQL 会根据执行的每一条具体的 SQL 语句来区分对待记录的日志形式，也就是在 Statement 和 Row 之间选择 一种。</p>
<p>新版本的 MySQL 中对 row level 模式也被做了优化，并不是所有的修改都会以 row level 来记录。</p>
<p>像遇到表结构变更的时候就会以 Statement 模式来记录。
至于 Update 或者 Delete 等修改数据的语句，还是会记录所有行的变更，即使用 Row 模式。</p>
<h5 id="适用场景" tabindex="-1"><a class="header-anchor" href="#适用场景" aria-hidden="true">#</a> 适用场景？</h5>
<p>在一条 SQL 操作了多行数据时， Statement 更节省空间，Row 更占用空间。但是， Row 模式更可靠。</p>
<p>因为，互联网公司，使用 MySQL 的功能相对少，基本不使用存储过程、触发器、函数的功能，选择默认的语句模式，Statement Level（默认）即可。</p>
<h5 id="结合第一个问题-每一种日志格式在复制中的优劣" tabindex="-1"><a class="header-anchor" href="#结合第一个问题-每一种日志格式在复制中的优劣" aria-hidden="true">#</a> 结合第一个问题，每一种日志格式在复制中的优劣？</h5>
<p>Statement 可能占用空间会相对小一些，传送到 slave 的时间可能也短，但是没有 Row 模式的可靠。
Row 模式在操作多行数据时更占用空间，但是可靠。
所以，这是在占用空间和可靠之间的选择。</p>
<h5 id="如何在线正确清理-mysql-binlog" tabindex="-1"><a class="header-anchor" href="#如何在线正确清理-mysql-binlog" aria-hidden="true">#</a> 如何在线正确清理 MySQL binlog？</h5>
<p>MySQL 中的 binlog 日志记录了数据中的数据变动，便于对数据的基于时间点和基于位置的恢复。但日志文件的大小会越来越大，占用大量的磁盘空间，因此需要定时清理一部分日志信息。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218143112768.png" alt="image-20211218143112768"></p>
<h3 id="_79-mysql-主从复制的流程是怎么样的" tabindex="-1"><a class="header-anchor" href="#_79-mysql-主从复制的流程是怎么样的" aria-hidden="true">#</a> 79.MySQL 主从复制的流程是怎么样的？</h3>
<p>MySQL 的主从复制是基于如下 3 个线程的交互（多线程复制里面应该是 4 类线程）：</p>
<p>1、Master 上面的 binlog dump 线程，该线程负责将 master 的 binlog event 传到 slave 。
2、Slave 上面的 IO 线程，该线程负责接收 Master 传过来的 binlog，并写入 relay log 。
3、Slave 上面的 SQL 线程，该线程负责读取 relay log 并执行。
4、如果是多线程复制，无论是 5.6 库级别的假多线程还是 MariaDB 或者 5.7 的真正的多线程复制， SQL 线程只做 coordinator ，只负责把 relay log 中的 binlog 读出来然后交给 worker 线程， woker 线程负责具体 binlog event 的执行。</p>
<h5 id="mysql-如何保证复制过程中数据一致性" tabindex="-1"><a class="header-anchor" href="#mysql-如何保证复制过程中数据一致性" aria-hidden="true">#</a> MySQL 如何保证复制过程中数据一致性？</h5>
<p>1、在 MySQL5.5 以及之前， slave 的 SQL 线程执行的 relay log 的位置只能保存在文件（ relay-log.info）里面，并且该文件默认每执行 10000 次事务做一次同步到磁盘， 这意味着 slave 意外 crash 重启时， SQL 线程执行到的位置和数据库的数据是不一致的，将导致复制报错，如果不重搭复制，则有可能会导致数据不一致。
MySQL 5.6 引入参数 relay_log_info_repository，将该参数设置为 TABLE 时， MySQL 将 SQL 线程执行到的位置存到 mysql.slave_relay_log_info 表，这样更新该表的位置和 SQL 线程执行的用户事务绑定成一个事务，这样 slave 意外宕机后，slave 通过 innodb 的崩溃恢复可以把 SQL 线程执行到的位置和用户事务恢复到一致性的状态。
2、MySQL 5.6 引入 GTID 复制，每个 GTID 对应的事务在每个实例上面最多执行一次， 这极大地提高了复制的数据一致性。
3、MySQL 5.5 引入半同步复制， 用户安装半同步复制插件并且开启参数后，设置超时时间，可保证在超时时间内如果 binlog 不传到 slave 上面，那么用户提交事务时不会返回，直到超时后切成异步复制，但是如果切成异步之前用户线程提交时在 master 上面等待的时候，事务已经提交，该事务对 master 上面的其他 session 是可见的，如果这时 master 宕机，那么到 slave 上面该事务又不可见了，该问题直到 5.7 才解决。
4、MySQL 5.7 引入无损半同步复制，引入参 rpl_semi_sync_master_wait_point，该参数默认为 after_sync，指的是在切成半同步之前，事务不提交，而是接收到 slave 的 ACK 确认之后才提交该事务，从此，复制真正可以做到无损的了。
5、可以再说一下 5.7 的无损复制情况下， master 意外宕机，重启后发现有 binlog 没传到 slave 上面，这部分 binlog 怎么办？？？分 2 种情况讨论， 1 宕机时已经切成异步了， 2 是宕机时还没切成异步？？？ 这个怎么判断宕机时有没有切成异步呢？？？ 分别怎么处理？？？</p>
<h5 id="mysql-如何解决主从复制的延时性" tabindex="-1"><a class="header-anchor" href="#mysql-如何解决主从复制的延时性" aria-hidden="true">#</a> MySQL 如何解决主从复制的延时性？</h5>
<p>5.5 是单线程复制，5.6 是多库复制（对于单库或者单表的并发操作是没用的），5.7 是真正意义的多线程复制，它的原理是基于 group commit， 只要 master 上面的事务是 group commit 的，那 slave 上面也可以通过多个 worker线程去并发执行。 和 MairaDB10.0.0.5 引入多线程复制的原理基本一样。</p>
<h5 id="工作遇到的复制-bug-的解决方法" tabindex="-1"><a class="header-anchor" href="#工作遇到的复制-bug-的解决方法" aria-hidden="true">#</a> 工作遇到的复制 bug 的解决方法？</h5>
<p>5.6 的多库复制有时候自己会停止，我们写了一个脚本重新 start slave 。</p>
<h5 id="你是否做过主从一致性校验-如果有-怎么做的-如果没有-你打算怎么做" tabindex="-1"><a class="header-anchor" href="#你是否做过主从一致性校验-如果有-怎么做的-如果没有-你打算怎么做" aria-hidden="true">#</a> 你是否做过主从一致性校验，如果有，怎么做的，如果没有，你打算怎么做？</h5>
<p>主从一致性校验有多种工具 例如 checksum、mysqldiff、pt-table-checksum 等。</p>
<h3 id="_80-聊聊-mysql-备份方式-备份策略是怎么样的" tabindex="-1"><a class="header-anchor" href="#_80-聊聊-mysql-备份方式-备份策略是怎么样的" aria-hidden="true">#</a> 80.聊聊 MySQL 备份方式？备份策略是怎么样的？</h3>
<p>具体的，胖友可以看看 《MySQL 高级备份策略》 。主要有几个知识点：</p>
<p>数据的备份类型</p>
<p>【常用】完全备份</p>
<p>这是大多数人常用的方式，它可以备份整个数据库，包含用户表、系统表、索引、视图和存储过程等所有数据库对象。但它需要花费更多的时间和空间，所以，一般推荐一周做一次完全备份。</p>
<p>增量备份</p>
<p>它是只备份数据库一部分的另一种方法，它不使用事务日志，相反，它使用整个数据库的一种新映象。它比最初的完全备份小，因为它只包含自上次完全备份以来所改变的数据库。它的优点是存储和恢复速度快。推荐每天做一次差异备份。</p>
<p>【常用】事务日志备份</p>
<p>事务日志是一个单独的文件，它记录数据库的改变，备份的时候只需要复制自上次备份以来对数据库所做的改变，所以只需要很少的时间。为了使数据库具有鲁棒性，推荐每小时甚至更频繁的备份事务日志。</p>
<p>文件备份</p>
<p>数据库可以由硬盘上的许多文件构成。如果这个数据库非常大，并且一个晚上也不能将它备份完，那么可以使用文件备份每晚备份数据库的一部分。由于一般情况下数据库不会大到必须使用多个文件存储，所以这种备份不是很常用。</p>
<p>备份数据的类型</p>
<p>热备份
温备份
冷备份
备份工具</p>
<p>cp
mysqldump
xtrabackup
lvm2 快照
MySQL 几种备份方式？</p>
<p>MySQL 一般有 3 种备份方式。</p>
<p>1）逻辑备份</p>
<p>使用 MySQL 自带的 mysqldump 工具进行备份。备份成sql文件形式。</p>
<p>优点：最大好处是能够与正在运行的 MySQL 自动协同工作，在运行期间可以确保备份是当时的点，它会自动将对应操作的表锁定，不允许其他用户修改(只能访问)。可能会阻止修改操作。SQL 文件通用方便移植。
缺点：备份的速度比较慢。如果是数据量很多的时候，就很耗时间。如果数据库服务器处在提供给用户服务状态，在这段长时间操作过程中，意味着要锁定表(一般是读锁定，只能读不能写入数据)，那么服务就会影响的。
2）物理备份</p>
<p>艿艿：因为现在主流是 InnoDB ，所以基本不再考虑这种方式。</p>
<p>直接拷贝只适用于 MyISAM 类型的表。这种类型的表是与机器独立的。但实际情况是，你设计数据库的时候不可能全部使用 MyISAM 类型表。你也不可能因为 MyISAM 类型表与机器独立，方便移植，于是就选择这种表，这并不是选择它的理由。</p>
<p>缺点：你不能去操作正在运行的 MySQL 服务器(在拷贝的过程中有用户通过应用程序访问更新数据，这样就无法备份当时的数据)，可能无法移植到其他机器上去。
3）双机热备份。</p>
<p>当数据量太大的时候备份是一个很大的问题，MySQL 数据库提供了一种主从备份的机制，也就是双机热备。</p>
<p>优点：适合数据量大的时候。现在明白了，大的互联网公司对于 MySQL 数据备份，都是采用热机备份。搭建多台数据库服务器，进行主从复制。
数据库不能停机，请问如何备份? 如何进行全备份和增量备份?</p>
<p>可以使用逻辑备份和双机热备份。</p>
<p>完全备份：完整备份一般一段时间进行一次，且在网站访问量最小的时候，这样常借助批处理文件定时备份。主要是写一个批处理文件在里面写上处理程序的绝对路径然后把要处理的东西写在后面，即完全备份数据库。</p>
<p>增量备份：对 ddl 和 dml 语句进行二进制备份。且 5.0 无法增量备份，5.1 后可以。如果要实现增量备份需要在 my.ini 文件中配置备份路径即可，重启 MySQL 服务器，增量备份就启动了。</p>
<h5 id="你的备份工具的选择-备份计划是怎么样的" tabindex="-1"><a class="header-anchor" href="#你的备份工具的选择-备份计划是怎么样的" aria-hidden="true">#</a> 你的备份工具的选择？备份计划是怎么样的？</h5>
<p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump 更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p>
<p>100G 以上的库，可以考虑用 xtrabackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p>
<p>备份恢复时间是多长？</p>
<p>物理备份恢复快，逻辑备份恢复慢。</p>
<p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考：</p>
<p>20G 的 2 分钟（mysqldump）
80G 的 30分钟（mysqldump)
111G 的 30分钟（mysqldump)
288G 的 3 小时（xtrabackup)
3T 的 4 小时（xtrabackup)
逻辑导入时间一般是备份时间的 5 倍以上。</p>
<p>备份恢复失败如何处理？</p>
<p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p>
<h5 id="mysqldump-和-xtrabackup-实现原理" tabindex="-1"><a class="header-anchor" href="#mysqldump-和-xtrabackup-实现原理" aria-hidden="true">#</a> mysqldump 和 xtrabackup 实现原理？</h5>
<p>1）mysqldump</p>
<p>mysqldump 是最简单的逻辑备份方式。</p>
<p>在备份 MyISAM 表的时候，如果要得到一致的数据，就需要锁表，简单而粗暴。
在备份 InnoDB 表的时候，加上 –master-data=1 –single-transaction 选项，在事务开始时刻，记录下 binlog pos 点，然后利用 MVCC 来获取一致的数据，由于是一个长事务，在写入和更新量很大的数据库上，将产生非常多的 undo ，显著影响性能，所以要慎用。
优点：简单，可针对单表备份，在全量导出表结构的时候尤其有用。
缺点：简单粗暴，单线程，备份慢而且恢复慢，跨 IDC 有可能遇到时区问题
2）xtrabackup</p>
<p>xtrabackup 实际上是物理备份+逻辑备份的组合。</p>
<p>在备份 InnoDB 表的时候，它拷贝 ibd 文件，并一刻不停的监视 redo log 的变化，append 到自己的事务日志文件。在拷贝 ibd 文件过程中，ibd文件本身可能被写”花”，这都不是问题，因为在拷贝完成后的第一个 prepare 阶段，xtrabackup 采用类似于 Innodb 崩溃恢复的方法，把数据文件恢复到与日志文件一致的状态，并把未提交的事务回滚。
如果同时需要备份 MyISAM 表以及 InnoDB 表结构等文件，那么就需要用 flush tables with lock 来获得全局锁，开始拷贝这些不再变化的文件，同时获得 binlog 位置，拷贝结束后释放锁，也停止对 redo log 的监视。
如何从 mysqldump 产生的全库备份中只恢复某一个库、某一张表？</p>
<p>具体可见 《MySQL 全库备份中恢复某个库和某张表以及 mysqldump 参数 –ignore-table 介绍》 文章。</p>
<h3 id="_81-聊聊-mysql-集群" tabindex="-1"><a class="header-anchor" href="#_81-聊聊-mysql-集群" aria-hidden="true">#</a> 81.聊聊 MySQL 集群?</h3>
<p>对于简历中写有熟悉 MySQL 高可用方案？</p>
<p>我一般先问他现在管理的数据库架构是什么，如果他只说出了主从，而没有说任何 HA 的方案，那么我就可以判断出他没有实际的 HA 经验。</p>
<p>不过这时候也不能就是断定他不懂 MySQL 高可用，也许是没有实际机会去使用，那么我就要问 MMM 以及 MHA 以及 MM + keepalived 等的原理、实现方式以及它们之间的优势和不足了，一般这种情况下，能说出这个的基本没有。</p>
<p>MMM 那东西好像不靠谱，据说不稳定，但是有人在用的，和 mysql-router 比较像，都是指定可写的机器和只读机器。
MHA 的话一句话说不完，可以搜索下相关博客</p>
<h3 id="_82-聊聊-mysql-监控" tabindex="-1"><a class="header-anchor" href="#_82-聊聊-mysql-监控" aria-hidden="true">#</a> 82.聊聊 MySQL 监控？</h3>
<h3 id="_83-你是如何监控你们的数据库的" tabindex="-1"><a class="header-anchor" href="#_83-你是如何监控你们的数据库的" aria-hidden="true">#</a> 83.你是如何监控你们的数据库的？</h3>
<p>监控的工具有很多，例如 Zabbix ，Lepus ，我这里用的是 Lepus 。</p>
<p>对一个大表做在线 DDL ，怎么进行实施的才能尽可能降低影响？
使用 pt-online-schema-change ，具体可以看看 《MySQL 大表在线 DML 神器–pt-online-schema-change》 文章。</p>
<h3 id="_84-drop-delete与truncate的区别" tabindex="-1"><a class="header-anchor" href="#_84-drop-delete与truncate的区别" aria-hidden="true">#</a> 84.drop,delete与truncate的区别</h3>
<p>drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始 delete删除表中数据，可以加where字句。</p>
<p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p>
<p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p>
<p>（3） 一般而言，drop &gt; truncate &gt; delete</p>
<p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p>
<p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p>
<p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程/函数将被保留，但其状态会变为：invalid。</p>
<p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p>
<p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚</p>
<p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p>
<p>（10） Truncate table 表名 速度快,而且效率高,因为:
truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p>
<p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p>
<p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p>
<h3 id="_85-mysql有哪几种索引" tabindex="-1"><a class="header-anchor" href="#_85-mysql有哪几种索引" aria-hidden="true">#</a> 85.mysql有哪几种索引</h3>
<h5 id="从数据结构角度" tabindex="-1"><a class="header-anchor" href="#从数据结构角度" aria-hidden="true">#</a> 从数据结构角度</h5>
<p>1、B+树索引(O(log(n)))：关于B+树索引，可以参考 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener noreferrer">MySQL索引背后的数据结构及算法原理<ExternalLinkIcon/></a></p>
<p>2、hash索引：
a 仅仅能满足&quot;=&quot;,&quot;IN&quot;和&quot;&lt;=&gt;&quot;查询，不能使用范围查询
b 其检索效率非常高，索引的检索可以一次定位，不像B-Tree 索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问，所以 Hash 索引的查询效率要远高于 B-Tree 索引
c 只有Memory存储引擎显示支持hash索引</p>
<p>3、FULLTEXT索引（现在MyISAM和InnoDB引擎都支持了）</p>
<p>4、R-Tree索引（用于对GIS数据类型创建SPATIAL索引）</p>
<h5 id="从物理存储角度" tabindex="-1"><a class="header-anchor" href="#从物理存储角度" aria-hidden="true">#</a> 从物理存储角度</h5>
<p>1、聚集索引（clustered index）</p>
<p>2、非聚集索引（non-clustered index）</p>
<h5 id="从逻辑角度" tabindex="-1"><a class="header-anchor" href="#从逻辑角度" aria-hidden="true">#</a> 从逻辑角度</h5>
<p>1、主键索引：主键索引是一种特殊的唯一索引，不允许有空值</p>
<p>2、普通索引或者单列索引</p>
<p>3、多列索引（复合索引）：复合索引指多个字段上创建的索引，只有在查询条件中使用了创建索引时的第一个字段，索引才会被使用。使用复合索引时遵循最左前缀集合</p>
<p>4、唯一索引或者非唯一索引</p>
<p>5、空间索引：空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MYISAM的表中创建</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>CREATE TABLE table_name[col_name data type]
[unique|fulltext|spatial][index|key][index_name](col_name[length])[asc|desc]
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>1、unique|fulltext|spatial为可选参数，分别表示唯一索引、全文索引和空间索引；</p>
<p>2、index和key为同义词，两者作用相同，用来指定创建索引</p>
<p>3、col_name为需要创建索引的字段列，该列必须从数据表中该定义的多个列中选择；</p>
<p>4、index_name指定索引的名称，为可选参数，如果不指定，MYSQL默认col_name为索引值；</p>
<p>5、length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；</p>
<p>6、asc或desc指定升序或降序的索引值存储</p>
<h3 id="_86-innodb的读写参数优化" tabindex="-1"><a class="header-anchor" href="#_86-innodb的读写参数优化" aria-hidden="true">#</a> 86.innodb的读写参数优化</h3>
<p><strong>1、读取参数</strong>
global buffer 以及 local buffer：
Global buffer：
Innodb_buffer_pool_size
innodb_log_buffer_size
innodb_additional_mem_pool_size</p>
<p>local buffer(下面的都是 server 层的 session 变量，不是 innodb 的)：
Read_buffer_size
Join_buffer_size
Sort_buffer_size
Key_buffer_size
Binlog_cache_size</p>
<p><strong>2、写入参数</strong>
innodb_flush_log_at_trx_commit
innodb_buffer_pool_size
insert_buffer_size
innodb_double_write
innodb_write_io_thread
innodb_flush_method</p>
<p><strong>3、与IO相关的参数</strong>
innodb_write_io_threads = 8
innodb_read_io_threads = 8
innodb_thread_concurrency = 0
Sync_binlog
Innodb_flush_log_at_trx_commit
Innodb_lru_scan_depth
Innodb_io_capacity
Innodb_io_capacity_max
innodb_log_buffer_size
innodb_max_dirty_pages_pct</p>
<p><strong>4、缓存参数以及缓存的适用场景</strong>
query cache/query_cache_type
并不是所有表都适合使用query cache。造成query cache失效的原因主要是相应的table发生了变更
第一个：读操作多的话看看比例，简单来说，如果是用户清单表，或者说是数据比例比较固定，比如说商品列表，是可以打开的，前提是这些库比较集中，数据库中的实务比较小。
第二个：我们“行骗”的时候，比如说我们竞标的时候压测，把query cache打开，还是能收到qps激增的效果，当然前提示前端的连接池什么的都配置一样。大部分情况下如果写入的居多，访问量并不多，那么就不要打开，例如社交网站的，10%的人产生内容，其余的90%都在消费，打开还是效果很好的，但是你如果是qq消息，或者聊天，那就很要命。
第三个：小网站或者没有高并发的无所谓，高并发下，会看到 很多 qcache 锁 等待，所以一般高并发下，不建议打开query cache</p>
<h3 id="_87-数据库优化的思路" tabindex="-1"><a class="header-anchor" href="#_87-数据库优化的思路" aria-hidden="true">#</a> 87.数据库优化的思路</h3>
<h5 id="_1-sql语句优化" tabindex="-1"><a class="header-anchor" href="#_1-sql语句优化" aria-hidden="true">#</a> 1.SQL语句优化</h5>
<p>1）应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。
2）应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：
select id from t where num is null
<strong>可以在num上设置默认值0，确保表中num列没有null值</strong>，然后这样查询：
select id from t where num=0
3）很多时候用 exists 代替 in 是一个好的选择
4）用Where子句替换HAVING 子句 因为HAVING 只会在检索出所有记录之后才对结果集进行过滤</p>
<h5 id="_2-索引优化" tabindex="-1"><a class="header-anchor" href="#_2-索引优化" aria-hidden="true">#</a> 2.索引优化</h5>
<p>看上文索引</p>
<h5 id="_3-数据库结构优化" tabindex="-1"><a class="header-anchor" href="#_3-数据库结构优化" aria-hidden="true">#</a> 3.数据库结构优化</h5>
<p>1）范式优化： 比如消除冗余（节省空间。。）</p>
<p>2）反范式优化：比如适当加冗余等（减少join）</p>
<p>3）拆分表： 分区将数据在物理上分隔开，不同分区的数据可以制定保存在处于不同磁盘上的数据文件里。这样，当对这个表进行查询时，只需要在表分区中进行扫描，而不必进行全表扫描，明显缩短了查询时间，另外处于不同磁盘的分区也将对这个表的数据传输分散在不同的磁盘I/O，一个精心设置的分区可以将数据传输对磁盘I/O竞争均匀地分散开。对数据量大的时时表可采取此方法。可按月自动建表分区。
4）拆分其实又分垂直拆分和水平拆分：</p>
<p>案例： 简单购物系统暂设涉及如下表： 1.产品表（数据量10w，稳定） 2.订单表（数据量200w，且有增长趋势） 3.用户表 （数据量100w，且有增长趋势） 以<a href="http://www.2cto.com/database/MySQL/" target="_blank" rel="noopener noreferrer">mysql<ExternalLinkIcon/></a>为例讲述下水平拆分和垂直拆分，mysql能容忍的数量级在百万静态数据可以到千万</p>
<p>**垂直拆分：**解决问题：表与表之间的io竞争 不解决问题：单表中数据量增长出现的压力 方案： 把产品表和用户表放到一个server上 订单表单独放到一个server上</p>
<p><strong>水平拆分：</strong> 解决问题：单表中数据量增长出现的压力 不解决问题：表与表之间的io争夺
方案： 用户表通过性别拆分为男用户表和女用户表 订单表通过已完成和完成中拆分为已完成订单和未完成订单 产品表 未完成订单放一个server上 已完成订单表盒男用户表放一个server上 女用户表放一个server上(女的爱购物 哈哈)</p>
<h5 id="_4-服务器硬件优化" tabindex="-1"><a class="header-anchor" href="#_4-服务器硬件优化" aria-hidden="true">#</a> 4.服务器硬件优化</h5>
<h3 id="_88-视图的作用-视图可以更改么" tabindex="-1"><a class="header-anchor" href="#_88-视图的作用-视图可以更改么" aria-hidden="true">#</a> 88.视图的作用，视图可以更改么？</h3>
<p>视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。
视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。
创建视图：create view XXX as XXXXXXXXXXXXXX;
对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。</p>
<h3 id="_89-存储过程与触发器的区别" tabindex="-1"><a class="header-anchor" href="#_89-存储过程与触发器的区别" aria-hidden="true">#</a> 89.存储过程与触发器的区别</h3>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，从而确保对数据的处理必须符合这些SQL语句所定义的规则。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_90-如何在最快时间之内重启500台db" tabindex="-1"><a class="header-anchor" href="#_90-如何在最快时间之内重启500台db" aria-hidden="true">#</a> 90.如何在最快时间之内重启500台db</h3>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>可以使用批量 ssh 工具 pssh 来对需要重启的机器执行重启命令。 也可以使用 salt（前提是客户端有安装 salt）或者 ansible（ ansible 只需要 ssh 免登通了就行）等多线程工具同时操作多台服务器
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="_91-从innodb的索引结构分析-为什么索引的key长度不能太长" tabindex="-1"><a class="header-anchor" href="#_91-从innodb的索引结构分析-为什么索引的key长度不能太长" aria-hidden="true">#</a> 91.从innodb的索引结构分析，为什么索引的key长度不能太长?</h3>
<p>key太长会导致一个页当中能够存放的key的数目变少，间接导致索引树的页数目变多，索引层次增加，从而影响整体查询变更的效率。</p>
<h3 id="_92-主键索引和非主键索引有什么区别" tabindex="-1"><a class="header-anchor" href="#_92-主键索引和非主键索引有什么区别" aria-hidden="true">#</a> <strong>92.主键索引和非主键索引有什么区别？</strong></h3>
<p>如果查询语句是 select * from table where ID = 100,即主键查询的方式，则只需要搜索 ID 这棵 B+树。</p>
<p>如果查询语句是 select * from table where k = 1，即非主键的查询方式，则先搜索k索引树，得到ID=100,再到ID索引树搜索一次，这个过程也被称为回表。</p>
<h3 id="_93-为什么建议使用主键自增的索引" tabindex="-1"><a class="header-anchor" href="#_93-为什么建议使用主键自增的索引" aria-hidden="true">#</a> <strong>93.为什么建议使用主键自增的索引？</strong></h3>
<p>对于这颗主键索引的树</p>
<p><img src="https://pic3.zhimg.com/80/v2-4aa4b73c3f9d7eeb2f7c002cadf9b202_720w.jpg" alt="img"></p>
<p>如果我们插入 ID = 650 的一行数据，那么直接在最右边插入就可以了</p>
<p><img src="https://pic2.zhimg.com/80/v2-bca7e5e179fb4e9bfc5f8743ef6b1b45_720w.jpg" alt="img"></p>
<p>但是如果插入的是 ID = 350 的一行数据，由于 B+ 树是有序的，那么需要将下面的叶子节点进行移动，腾出位置来插入 ID = 350 的数据，这样就会比较消耗时间，如果刚好 R4 所在的数据页已经满了，需要进行页分裂操作，这样会更加糟糕。</p>
<p>但是，如果我们的主键是自增的，每次插入的 ID 都会比前面的大，那么我们每次只需要在后面插入就行， 不需要移动位置、分裂等操作，这样可以提高性能。也就是为什么建议使用主键自增的索引。</p>
<h3 id="_94-主键和唯一索引的区别" tabindex="-1"><a class="header-anchor" href="#_94-主键和唯一索引的区别" aria-hidden="true">#</a> <strong>94.主键和唯一索引的区别？</strong></h3>
<p>1&gt;主键一<strong>定会创建一个唯一索引，但是有唯一索引的列不一定是主键；</strong></p>
<p>2&gt;主键不允许为空值，唯一索引列允许空值；</p>
<p>3&gt;一个表只能有一个主键，但是可以有多个唯一索引；</p>
<p>4&gt;主键可以被<strong>其他表引用为外键，唯一索引列不可以；</strong></p>
<p>5&gt;主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本</p>
<h3 id="_95-如何让-like-abc-走索引查询" tabindex="-1"><a class="header-anchor" href="#_95-如何让-like-abc-走索引查询" aria-hidden="true">#</a> 95.如何让 like %abc 走索引查询</h3>
<p>我们知道如果要让 like 查询要走索引，查询字符不能以通配符（%）开始，如果要让 like %abc 也走索引，可以使用 REVERSE() 函数来创建一个函数索引，查询脚本</p>
<p>如下：</p>
<p>select * from t where reverse(f) like reverse(’%abc’);</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224112928759.png" alt="image-20211224112928759"></p>
<h3 id="_96-联合索引的作用是什么" tabindex="-1"><a class="header-anchor" href="#_96-联合索引的作用是什么" aria-hidden="true">#</a> 96.联合索引的作用是什么？</h3>
<p>1&gt;用于多字段查询，比如，建了一个 key(a,b,c) 的联合索引，那么实际等于建了 key(a)、key(a,b)、key(a,b,c) 等三个索引，我们知道，每多一个索引，就会多一些写操作和占用磁盘空间的开销，尤其是对大数据量的表来说，这可以减少一部分不必要的开销；</p>
<p>2&gt;覆盖索引，比如，对于联合索引 key(a,b,c) 来说，如果使用 SQL：select a,b,c from table where a=1 and b = 1 ，就可以直接通过遍历索引取得数据，而无需回表查询，这就减少了随机的 IO 操作，减少随机的 IO 操作，可以有效的提升数据库查询的性能，是非常重要的数据库优化手段之一；</p>
<p>3&gt;索引列越多，通过索引筛选出的数据越少。</p>
<h3 id="_97-唯一索引和普通索引哪个性能更好" tabindex="-1"><a class="header-anchor" href="#_97-唯一索引和普通索引哪个性能更好" aria-hidden="true">#</a> 97.唯一索引和普通索引哪个性能更好？</h3>
<p>· 对于查询操作来说：普通索引和唯一索引的性能相近，都是从索引树中进行查询；</p>
<p>· 对于更新操作来说：唯一索引要比普通索引执行的慢，因为唯一索引需要先将数据读取到内存中，再在内存中进行数据的唯一效验，所以执行起来要比普通索引更慢。</p>
<h3 id="_98-以下-or-查询有什么问题吗-该如何优化" tabindex="-1"><a class="header-anchor" href="#_98-以下-or-查询有什么问题吗-该如何优化" aria-hidden="true">#</a> 98.以下 or 查询有什么问题吗？该如何优化？</h3>
<p>· select * from t where num=10 or num=20;</p>
<p>· 答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p>
<p>select * from t where num=10 union select * from t where num=20;</p>
<h3 id="_99-主键和候选键有什么区别" tabindex="-1"><a class="header-anchor" href="#_99-主键和候选键有什么区别" aria-hidden="true">#</a> 99.主键和候选键有什么区别？</h3>
<p>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。 注定义中的“属性集”，超键可以是一个很大的集合，只要他能确定是哪一行就行，因此’id’,‘user’,‘pwd’,‘section’,'name’都可以是超键的集。</p>
<p>候选键：不含有多余属性的超键，比如在上面的超键中，'id’自己就可以独自确定是哪一行，所以他自己可以是一个候选键，除去它以外的另外四个也可以是候选键，但是这五个放在一起因为有了多余的列，他们就不是候选键。（另外四个可以是候选键的原因是每一列都有可能有重复的内容）</p>
<p>主键：在所有的候选键里面找一个作为主键供使用，也就是说可以是id，也可以是另外四个的合体，也有可能是其他的选择，只要能保证选择的集合能唯一确定即可。</p>
<p>总结来说，候选键是超键的子集，主键是候选键的子集。</p>
<h3 id="_100-mysql-性能优化的21个最佳实践" tabindex="-1"><a class="header-anchor" href="#_100-mysql-性能优化的21个最佳实践" aria-hidden="true">#</a> 100.MySQL 性能优化的21个最佳实践</h3>
<p>1、为查询缓存优化你的查询</p>
<p>2、EXPLAIN 你的 SELECT 查询</p>
<p>3、当只要一行数据时使用 LIMIT 1</p>
<p>4、为搜索字段建索引</p>
<p>5、在 Join 表的时候使用相当类型的例，并将其索引</p>
<p>6、千万不要 ORDER BY RAND()</p>
<p>7、避免 SELECT *</p>
<p>8、永远为每张表设置一个 ID</p>
<p>9、使用 ENUM 而不是 VARCHAR</p>
<p>10、从 PROCEDURE ANALYSE() 取得建议</p>
<p>11、尽可能的使用 NOT NULL</p>
<p>12、Prepared Statements</p>
<p>13、无缓冲的查询</p>
<p>14、把 IP 地址存成 UNSIGNED INT</p>
<p>15、固定长度的表会更快</p>
<p>16、垂直分割</p>
<p>17、拆分大的 DELETE 或 INSERT 语句</p>
<p>18、越小的列会越快</p>
<p>19、选择正确的存储引擎</p>
<p>20、使用一个对象关系映射器(Object Relational Mapper)</p>
<p>21、小心“永久链接”</p>
<h3 id="_101-mysql-性能调优与架构设计" tabindex="-1"><a class="header-anchor" href="#_101-mysql-性能调优与架构设计" aria-hidden="true">#</a> 101.MySQL 性能调优与架构设计</h3>
<h5 id="基础篇" tabindex="-1"><a class="header-anchor" href="#基础篇" aria-hidden="true">#</a> 基础篇：</h5>
<p>1、MySQL基本介绍</p>
<p>2、MySQL架构组成</p>
<p>3、MySQL存储引擎简介</p>
<p>4、MySQL安全管理</p>
<p>5、MySQL备份与恢复</p>
<h5 id="性能优化篇" tabindex="-1"><a class="header-anchor" href="#性能优化篇" aria-hidden="true">#</a> 性能优化篇：</h5>
<p>1、影响MySQLServer性能的相关因素</p>
<p>2、MySQL数据库锁定机制</p>
<p>3、MySQL数据库Query的优化</p>
<p>4、MySQL数据库Schema设计的性能优化</p>
<p>5、MySQLServer性能优化</p>
<p>6、常用存储引擎优化</p>
<h5 id="架构设计篇" tabindex="-1"><a class="header-anchor" href="#架构设计篇" aria-hidden="true">#</a> 架构设计篇：</h5>
<p>1、MySQL可扩展设计的基本原则</p>
<p>2、可扩展性设计之MySQLReplication</p>
<p>3、可扩展性设计之数据切分</p>
<p>4、可扩展性设计之Cache与Search的…</p>
<p>5、MySQLCluster</p>
<p>6、高可用设计之思路及方案</p>
<p>7、高可用设计之MySQL监控</p>
<h3 id="_102-聚镞索引-数据存储在哪里" tabindex="-1"><a class="header-anchor" href="#_102-聚镞索引-数据存储在哪里" aria-hidden="true">#</a> 102.聚镞索引 数据存储在哪里 ？</h3>
<p><strong>一、聚族索引的构造</strong></p>
<p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但InnoDB的聚族索引实际上在同一个结构中保存了B-Tree索引和数据行。当表有聚族索引时，它的数据行存放在索引的叶子页中。术语“聚族”表示数据行和相邻的键值紧凑的存储在一起。因为无法同时把数据行放在两个不同的地方，所以一个表只能有一个聚族索引。</p>
<p>因为是存储引擎负责实现索引，因此不是所有的存储引擎都支持聚族索引。这里我们主要关注InnoDB，但是这里讨论的原理对于任何支持聚族索引的存储引擎都是适用的。</p>
<p>下面展示了聚族索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据，但是节点页只包含了索引列。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/d5b1d5b1-8a63-3c7b-ba39-58f8d1c27ba4.png" alt="img">
在InnoDB中通过主键聚集数据，这也就是说上图中“被索引的列”就是主键列。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚族索引。InnoDB只聚集在同一个页面中的记录。包含相邻键的页面可能会相距甚远。</p>
<p>聚族主键可能对性能有帮助，但也可能导致严重的性能问题。所以需要仔细的考虑聚族索引，尤其是将表的引擎从InnoDB改成其他引擎的时候。</p>
<p><strong>二、聚族索引的优点</strong></p>
<ul>
<li>可以把相关数据保存在一起。例如实现电子邮件时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚族索引，则每封邮件都可能导致一次磁盘I/O；</li>
<li>数据访问更快。聚族索引将索引和数据保存在同一个B-Tree中，因此从聚族索引中获取数据通常比在非聚族索引中查找更快。</li>
<li>使用覆盖索引扫描的查询可以直接使用节点中的主键值。</li>
</ul>
<p><strong>三、聚族索引的缺点</strong></p>
<ul>
<li>
<p>聚簇数据最大限度的提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有那么优势了；</p>
</li>
<li>
<p>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。</p>
</li>
<li>
<p>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</p>
</li>
<li>
<p>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次分裂操作。页分裂会导致表占用更多的磁盘空间。</p>
</li>
<li>
<p>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</p>
</li>
<li>
<p>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</p>
</li>
<li>
<p>二级索引访问需要两次索引查找，而不是一次。</p>
<p>**备注：**有关二级索引需要两次索引查找的问题？答案在于二级索引中保存的“行指针”的实质。要记住，二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。这意味着通过二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B-Tree查找而不是一次。对于InnoDB，自适应哈希索引能够减少这样的重复工作。</p>
</li>
</ul>
<p><strong>四、InnoDB和MyISAM的数据分布对比</strong></p>
<p>聚簇索引和非聚簇索引的数据分布有区别，以及对应的主键索引和二级索引的数据分布也有区别。</p>
<p><strong>1、MyISAM的主键索引和二级索引</strong></p>
<p>MyISAM的数据分布非常简单，MyISAM按照数据插入的顺序存储在磁盘上。在行的旁边显示了行号，从0开始递增。因为行是定长的，所以MyISAM可以从表的开头跳过所需的字节找到需要的行。这种分布方式很容易创建索引。并且，MyISAM中主键索引和其他索引在结构上没有什么不同。主键索引就是一个名为primary的唯一非空索引。如下图：</p>
<p>1、MyISAM数据行分布</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/5735d0c0-bd06-3015-bf21-4fb35f7a53c7.png" alt="img">
2、MyISAM的主键分布</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/a093e22c-7ca1-3c17-8c7d-a93af428f093.png" alt="img">
3、MyISAM上的其他索引分布</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/806f6c3c-7f37-3441-80d7-2969c37fae07.png" alt="img"></p>
<p><strong>2、InnoDB的主键索引和二级索引</strong></p>
<p>InnoDB的数据分布，因为InnoDB支持聚簇索引，索引使用非常不同的方式存储这样的数据，如下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/15134c60-f1ab-3ca1-ade5-b9d3b2ebe408.png" alt="img">
仔细查看，会注意到该图显示了整个表，而不是只有索引。因为在InnoDB中，聚簇索引“就是”表，所以不像MyISAM那样需要独立的行存储。聚簇索引的每个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。如果主键是一个列前缀索引，InnoDB也会包含完整的主键列和剩下的其他列。</p>
<p>还有一点和MyISAM的不同是，InnoDB的二级索引和聚簇索引很不相同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”。这样的策略减少了当出现航移动或者数据页分裂时二级索引的维护工作。使用主键值当作指针会让二级索引占用更多的空间，换来的好处是，InnoDB在移动行时无需更新二级索引中的这个“指针”。下图就是InnoDB的二级索引：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/505c4a79-cf4a-3a60-abe5-ce5d8ba1459f.png" alt="img">
<strong>3、MyISAM和InnoDB的对比</strong></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/7c3350a7-168a-3c31-acfd-4848774168dc.png" alt="img">
<strong>五、在InnoDB表中按主键顺序插入行</strong></p>
<p>如果正在使用InnoDB表并且没有什么数据需要聚集，那么可以定义一个代理键作为主键，这种主键的数据应该和应用无关，最简单的方法是使用auto_increment自增列。这样可以保证数据行是按照顺序写入，对于根据主键做关联操作的性能也会更好。</p>
<p>最好避免随机的聚簇索引，特别对于I/O密集型的应用。例如，从性能的角度考虑，使用UUID作为聚簇索引会很糟糕：它使得聚簇索引的插入变得完全随机，这是最坏的情况，使得数据没有任何聚集特性。通过测试，向UUID主键插入行不仅花费的时间更长，而且索引占用的空间也更大。这一方面是由于主键字段更长，另一方面毫无疑问是由于页分裂和碎片导致的。</p>
<p>这是由于当主键的值是顺序的，则InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB默认的最大填充因子是页大小的15/16，留出的部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这样顺序的方式加载，主键页就会近似于被顺序的记录填满，这也是所期望的结果。</p>
<p>而当采用UUID的聚簇索引的表插入数据，因为新行的主键值不一定比之前的插入值大，所以InnoDB无法简单的总是把新行插入到索引的最后，而是需要为新的行寻找合适的位置----通常是已有数据的中间位置----并且分配空间。这会增加很多额外的工作，并导致数据分布不够优化。下面是总结的一些缺点：</p>
<ul>
<li>写入目标页可能已经刷到磁盘上并从缓存中移除，或者是还没有被加载到缓存中，InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机I/O；</li>
<li>因为写入是乱序的，InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。</li>
<li>由于频繁的页分裂，页会变得稀疏并被不规则的填充，所以最终数据会有碎片。</li>
<li>把这些随机值载入到聚簇索引以后，需要做一次optimize table来重建表并优化页的填充。</li>
</ul>
<p>注意：顺序主键也有缺点：对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是auto_increment锁机制；如果遇到这个问题，则可能需要考虑重新设计表或者应用，或者更改innodb_autonc_lock_mode配置。</p>
<h3 id="_103-普通索引和主键索引的关系" tabindex="-1"><a class="header-anchor" href="#_103-普通索引和主键索引的关系" aria-hidden="true">#</a> 103.普通索引和主键索引的关系</h3>
<p>主键索引的叶子结点存放了整行记录，普通索引的叶子结点存放了主键ID，查询的时候需要做一次回表查询
一定要回表查询么？
不一定，当查询的字段刚好是索引的字段或者索引的一部分，就可以不用回表，这也是索引覆盖的原理</p>
<h3 id="_104-如何查看sql语句是否使用了索引" tabindex="-1"><a class="header-anchor" href="#_104-如何查看sql语句是否使用了索引" aria-hidden="true">#</a> 104.如何查看sql语句是否使用了索引？</h3>
<p>此方法，个人认为对于mysql索引优化很有用处，可以作为其中一个判断依据，去判断sql语句是否合理。
答：使用explain 关键字
例如： select * from bu_course_lesson =&gt; explain select * from bu_course_lesson 通过查看结果的type值可以看出，如果type是all那么就没有使用索引</p>
<h3 id="_105-date-datetime和timestamp数据类型有什么区别" tabindex="-1"><a class="header-anchor" href="#_105-date-datetime和timestamp数据类型有什么区别" aria-hidden="true">#</a> 105.date,datetime和timestamp数据类型有什么区别</h3>
<p>一个完整的日期格式如下：YYYY-MM-DD HH:MM:SS[.fraction]，它可分为两部分：date部分和time部分，其中，date部分对应格式中的“YYYY-MM-DD”，time部分对应格式中的“HH:MM:SS[.fraction]”。对于date字段来说，它只支持date部分，如果插入了time部分的内容，它会丢弃掉该部分的内容，并提示一个warning。</p>
<p><strong>timestamp和datetime的相同点：</strong></p>
<p>（1） 两者都可用来表示YYYY-MM-DD HH:MM:SS[.fraction]类型的日期。</p>
<p><strong>timestamp和datetime的不同点：</strong></p>
<p>（1）两者的存储方式不一样</p>
<p>对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，将其又转化为客户端当前时区进行返回。</p>
<p>而对于DATETIME，不做任何改变，基本上是原样输入和输出。</p>
<p>（2）两者所能存储的时间范围不一样</p>
<p>timestamp所能存储的时间范围为：'1970-01-01 00:00:01.000000' 到 '2038-01-19 03:14:07.999999'。</p>
<p>datetime所能存储的时间范围为：'1000-01-01 00:00:00.000000' 到 '9999-12-31 23:59:59.999999'。</p>
<h3 id="_106-select-和-select-字段在性能上没有什么差别" tabindex="-1"><a class="header-anchor" href="#_106-select-和-select-字段在性能上没有什么差别" aria-hidden="true">#</a> 106.select * 和 select 字段在性能上没有什么差别</h3>
<h6 id="_2、网络io问题" tabindex="-1"><a class="header-anchor" href="#_2、网络io问题" aria-hidden="true">#</a> 2、网络IO问题</h6>
<p>select * 会查出所有的字段，有些是不需要的，当应用程序和服务器不在同一个局域网时，字段过多会影响网络传输的性能</p>
<h6 id="_3、索引问题" tabindex="-1"><a class="header-anchor" href="#_3、索引问题" aria-hidden="true">#</a> 3、索引问题</h6>
<p>select col1 from table;
select * from table;
在col1字段有索引的情况下，mysql是可以不用读data，直接使用index里面的值就返回结果的。
但是一旦用了select *，就会有其他列需要读取，这时在读完index以后还需要去读data才会返回结果。这样就造成了额外的性能开销</p>
<h3 id="_107-mysql-主从同步延迟如何解决" tabindex="-1"><a class="header-anchor" href="#_107-mysql-主从同步延迟如何解决" aria-hidden="true">#</a> 107.mysql 主从同步延迟如何解决</h3>
<ol start="2">
<li>
<h6 id="mysql数据库主从同步延迟是怎么产生的。" tabindex="-1"><a class="header-anchor" href="#mysql数据库主从同步延迟是怎么产生的。" aria-hidden="true">#</a> MySQL数据库主从同步延迟是怎么产生的。</h6>
</li>
</ol>
<p>答：当主库的TPS并发较高时，产生的DDL数量超过slave一个sql线程所能承受的范围，那么延时就产生了，当然还有就是可能与slave的大型query语句产生了锁等待。</p>
<ol start="3">
<li>
<h6 id="mysql数据库主从同步延迟解决方案" tabindex="-1"><a class="header-anchor" href="#mysql数据库主从同步延迟解决方案" aria-hidden="true">#</a> MySQL数据库主从同步延迟解决方案</h6>
</li>
</ol>
<p>答：最简单的减少slave同步延时的方案就是在架构上做优化，尽量让主库的DDL快速执行。还有就是主库是写，对数据安全性较高，比如 sync_binlog=1，innodb_flush_log_at_trx_commit = 1 之类的设置，而slave则不需要这么高的数据安全，完全可以讲sync_binlog设置为0或者关闭binlog，innodb_flushlog也 可以设置为0来提高sql的执行效率。另外就是使用比主库更好的硬件设备作为slave</p>
<h3 id="_108-php可以和sql-server-oracle等数据库连接吗" tabindex="-1"><a class="header-anchor" href="#_108-php可以和sql-server-oracle等数据库连接吗" aria-hidden="true">#</a> 108.PHP可以和sql server/oracle等数据库连接吗?</h3>
<h3 id="_109-sql注入漏洞产生的原因-如何防止" tabindex="-1"><a class="header-anchor" href="#_109-sql注入漏洞产生的原因-如何防止" aria-hidden="true">#</a> 109.SQL注入漏洞产生的原因 ? 如何防止?</h3>
<h3 id="_110-取得查询结果集总数的函数是" tabindex="-1"><a class="header-anchor" href="#_110-取得查询结果集总数的函数是" aria-hidden="true">#</a> 110.取得查询结果集总数的函数是?</h3>
<h3 id="_111-优化mysql数据库的方法" tabindex="-1"><a class="header-anchor" href="#_111-优化mysql数据库的方法" aria-hidden="true">#</a> 111.优化MYSQL数据库的方法？</h3>
<h3 id="_112-web应用中-数据库的读取频率远高于写入频率-如何优化mysql而应对此种情景" tabindex="-1"><a class="header-anchor" href="#_112-web应用中-数据库的读取频率远高于写入频率-如何优化mysql而应对此种情景" aria-hidden="true">#</a> 112.web应用中,数据库的读取频率远高于写入频率, 如何优化MySQL而应对此种情景 ?</h3>
<h3 id="_113-使用php写出完整的mysql代码-其中包括-连接数据库-判断错误-关闭数据库" tabindex="-1"><a class="header-anchor" href="#_113-使用php写出完整的mysql代码-其中包括-连接数据库-判断错误-关闭数据库" aria-hidden="true">#</a> 113.使用php写出完整的mysql代码，其中包括（连接数据库，判断错误，关闭数据库）</h3>
<h3 id="_114-mysql-fetch-row-和mysql-fetch-array之间有什么区别" tabindex="-1"><a class="header-anchor" href="#_114-mysql-fetch-row-和mysql-fetch-array之间有什么区别" aria-hidden="true">#</a> 114.mysql_fetch_row() 和mysql_fetch_array之间有什么区别?</h3>
<h3 id="_115-命令的题" tabindex="-1"><a class="header-anchor" href="#_115-命令的题" aria-hidden="true">#</a> 115.命令的题：</h3>
<h5 id="desc-user-这个命令的作用" tabindex="-1"><a class="header-anchor" href="#desc-user-这个命令的作用" aria-hidden="true">#</a> desc user; 这个命令的作用？</h5>
<h5 id="explain-select-from-user-这个命令的作用" tabindex="-1"><a class="header-anchor" href="#explain-select-from-user-这个命令的作用" aria-hidden="true">#</a> explain select * from user; 这个命令的作用？</h5>
<h5 id="show-processlist-这个命令的作用" tabindex="-1"><a class="header-anchor" href="#show-processlist-这个命令的作用" aria-hidden="true">#</a> show processlist; 这个命令的作用？</h5>
<h5 id="show-variables-这个命令的作用" tabindex="-1"><a class="header-anchor" href="#show-variables-这个命令的作用" aria-hidden="true">#</a> SHOW VARIABLES; 这个命令的作用？</h5>
<h5 id="show-variables-like-conn-这个命令的作用" tabindex="-1"><a class="header-anchor" href="#show-variables-like-conn-这个命令的作用" aria-hidden="true">#</a> SHOW VARIABLES like '%conn%'; 这个命令的作用？</h5>
<h5 id="left-join-写一个sql语句" tabindex="-1"><a class="header-anchor" href="#left-join-写一个sql语句" aria-hidden="true">#</a> LEFT JOIN 写一个SQL语句？</h5>
<h5 id="in-not-ni-exist-not-exist的作用和区别" tabindex="-1"><a class="header-anchor" href="#in-not-ni-exist-not-exist的作用和区别" aria-hidden="true">#</a> in, not ni, exist, not exist的作用和区别？</h5>
<h3 id="_116-怎么找到数据库的配置文件路径" tabindex="-1"><a class="header-anchor" href="#_116-怎么找到数据库的配置文件路径" aria-hidden="true">#</a> 116.怎么找到数据库的配置文件路径？</h3>
<h3 id="_117-mysql字段类型有很多种-如int-bigint-char-varchar-text等等-请描述每种字段占用的字节数和最大范围" tabindex="-1"><a class="header-anchor" href="#_117-mysql字段类型有很多种-如int-bigint-char-varchar-text等等-请描述每种字段占用的字节数和最大范围" aria-hidden="true">#</a> 117.MySQL字段类型有很多种，如int ,bigint , char, varchar, text等等, 请描述每种字段占用的字节数和最大范围</h3>
<p>int:4个字节</p>
<p>bigint  8个字节</p>
<p>char  255字符</p>
<p>varchar  65535字符</p>
<p>注意：平台环境为32位字长计算机,Mysql 5.0+, 数字型字段使用unsigned属性</p>
<h3 id="_118-有两张数据表-表user-id-name-记录了用户的id和昵称-表article-id-title-content-time-记录了用户发表的文章标题、内容和时间-写一个sql语句打印出每个用户的昵称及其发表的文章总数。" tabindex="-1"><a class="header-anchor" href="#_118-有两张数据表-表user-id-name-记录了用户的id和昵称-表article-id-title-content-time-记录了用户发表的文章标题、内容和时间-写一个sql语句打印出每个用户的昵称及其发表的文章总数。" aria-hidden="true">#</a> 118.有两张数据表，表user(id, name)记录了用户的ID和昵称，表article(id, title, content, time)记录了用户发表的文章标题、内容和时间，写一个SQL语句打印出每个用户的昵称及其发表的文章总数。</h3>
<h3 id="_119-有a-id-sex-par-c1-c2-b-id-age-c1-c2-两张表-其中a-id与b-id关联-现在要求写一条sql语句-将b中age-50的记录的c1、c2更新到a表中统一记录中的c1、c2字段中。" tabindex="-1"><a class="header-anchor" href="#_119-有a-id-sex-par-c1-c2-b-id-age-c1-c2-两张表-其中a-id与b-id关联-现在要求写一条sql语句-将b中age-50的记录的c1、c2更新到a表中统一记录中的c1、c2字段中。" aria-hidden="true">#</a> 119.有A(id,sex,par,c1,c2),B(id,age,c1,c2)两张表，其中A.id与B.id关联，现在要求写一条SQL语句，将B中age&gt;50的记录的c1、c2更新到A表中统一记录中的c1、c2字段中。</h3>
<h3 id="_120-指出以下代码片段中的sql注入漏洞以及解决方法-magic-quotes-gpc-off" tabindex="-1"><a class="header-anchor" href="#_120-指出以下代码片段中的sql注入漏洞以及解决方法-magic-quotes-gpc-off" aria-hidden="true">#</a> 120.指出以下代码片段中的SQL注入漏洞以及解决方法(magic_quotes_gpc = off)</h3>
<p>mysql_query(&quot;select id,title from content where catid='{$_GET[catid]}' and title like '%$_GET[keywords]%'&quot;, $link);</p>
<h3 id="_121-使用php写一段简单查询-查出所有姓名为-张三-的内容并打印出来" tabindex="-1"><a class="header-anchor" href="#_121-使用php写一段简单查询-查出所有姓名为-张三-的内容并打印出来" aria-hidden="true">#</a> 121.使用php写一段简单查询，查出所有姓名为“张三”的内容并打印出来</h3>
<p>表名User</p>
<p>Name 	Tel 		 	Content 		Date</p>
<p>张三 13333663366 	大专毕业 2006-10-11</p>
<p>张三 13612312331 	本科毕业 2006-10-15</p>
<p>张四 021-55665566 	中专毕业 2006-10-15</p>
<h3 id="_122-对于一条sql查询-下面那种情况下不会用到索引" tabindex="-1"><a class="header-anchor" href="#_122-对于一条sql查询-下面那种情况下不会用到索引" aria-hidden="true">#</a> 122.对于一条SQL查询，下面那种情况下不会用到索引？（）</h3>
<p>where shou=’’</p>
<p>where shou&gt;’a’</p>
<p>where shou=null</p>
<p>where shou is not null</p>
<h3 id="_123-怎样在php中书写代码防止一个数据库表格中同一条记录被多人同时操作-怎样通过数据库的方法防止一个数据库表格中同一条记录被多人同时操作" tabindex="-1"><a class="header-anchor" href="#_123-怎样在php中书写代码防止一个数据库表格中同一条记录被多人同时操作-怎样通过数据库的方法防止一个数据库表格中同一条记录被多人同时操作" aria-hidden="true">#</a> 123.怎样在php中书写代码防止一个数据库表格中同一条记录被多人同时操作，怎样通过数据库的方法防止一个数据库表格中同一条记录被多人同时操作?</h3>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>文件锁分为两种方式：

【一】.阻塞模式：(如果其他进程已经加锁文件,当前进程会一直等其他进程解锁文件后继续执行)

&lt;?php
//连接数据库
$con=mysqli_connect("192.168.2.186","root","root","test");
//查询商品数量是否大于0,大于0才能下单,并减少库存
$fp = fopen("lock.txt", "r");
//加锁
if(flock($fp,LOCK_EX))
{
	$res=mysqli_fetch_assoc(mysqli_query($con,'SELECT total FROM shop WHERE id=1 LIMIT 1'));
	if($res['total']>0){mysqli_query($con,'UPDATE shop SET total=total-1  WHERE id=1');}
	//执行完成解锁
	flock($fp,LOCK_UN);
}
//关闭文件
fclose($fp);
unset($res);
mysqli_close($con);
?>
这种情况若是其他进程已经加锁文件，那么所有进程都会等他执行完并解锁文件后才会执行
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_124-列出mysql几种数据库引挚-请说出他们各自的优缺点。" tabindex="-1"><a class="header-anchor" href="#_124-列出mysql几种数据库引挚-请说出他们各自的优缺点。" aria-hidden="true">#</a> 124.列出mysql几种数据库引挚，请说出他们各自的优缺点。</h3>
<h5 id="隔离级别" tabindex="-1"><a class="header-anchor" href="#隔离级别" aria-hidden="true">#</a> 隔离级别</h5>
<ol>
<li>
<ol>
<li>
<p>隔离性详细说一下</p>
</li>
<li>
<ol>
<li>
<p>读未提交、读已提交、可重复读、串行化</p>
</li>
<li>
<ol>
<li>读未提交：<strong>READ-UNCOMMITTED(读未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>
<li>读已提交：<strong>READ-COMMITTED(读已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>
<li>可重复度：<strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>
<li>串行化：<strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>出现啥问题</p>
</li>
<li>
<ol>
<li>
<p>脏读、幻读、不可重复读</p>
</li>
<li>
<ol>
<li>脏读：脏读(Dirty Reads)：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</li>
<li>幻读：幻读（Phantom Reads)：幻读与不可重复读类似。它发生在一个事务A读取了几行数据，接着另一个并发事务B插入了一些数据时。在随后的查询中，事务A就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</li>
<li>不可重复读：不可重复读（Non-Repeatable Reads)：事务 A 多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="锁机制" tabindex="-1"><a class="header-anchor" href="#锁机制" aria-hidden="true">#</a> 锁机制</h5>
<ol>
<li>
<ol>
<li>
<p><strong>对数据操作的类型分类：</strong></p>
</li>
<li>
<ol>
<li><strong>读锁</strong>（共享锁）：针对同一份数据，多个读操作可以同时进行，不会互相影响</li>
<li><strong>写锁</strong>（排他锁）：当前写操作没有完成前，它会阻断其他写锁和读锁</li>
</ol>
</li>
<li></li>
<li>
<p><strong>数据操作的粒度分类：</strong></p>
</li>
<li>
<ol>
<li><strong>表级锁</strong>：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低（MyISAM 和 MEMORY 存储引擎采用的是表级锁）；</li>
<li><strong>行级锁</strong>：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高（InnoDB 存储引擎既支持行级锁也支持表级锁，但默认情况下是采用行级锁）；</li>
<li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li>
</ol>
</li>
<li></li>
<li></li>
<li>
<p>InnoDB 实现了以下两种类型的<strong>行锁</strong></p>
</li>
<li>
<ol>
<li>共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。</li>
<li>排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。</li>
</ol>
</li>
<li>
<p>死锁：</p>
</li>
<li>
<ol>
<li>为了在单个InnoDB表上执行多个并发写入操作时避免死锁，可以在事务开始时通过为预期要修改的每个元祖（行）使用SELECT ... FOR UPDATE语句来获取必要的锁，即使这些行的更改语句是在之后才执行的。</li>
<li>在事务中，如果要更新记录，应该直接申请足够级别的锁，即排他锁，而不应先申请共享锁、更新时再申请排他锁，因为这时候当用户再申请排他锁时，其他事务可能又已经获得了相同记录的共享锁，从而造成锁冲突，甚至死锁</li>
<li>如果事务需要修改或锁定多个表，则应在每个事务中以相同的顺序使用加锁语句。 在应用中，如果不同的程序会并发存取多个表，应尽量约定以相同的顺序来访问表，这样可以大大降低产生死锁的机会</li>
<li>通过SELECT ... LOCK IN SHARE MODE获取行的读锁后，如果当前事务再需要对该记录进行更新操作，则很有可能造成死锁。</li>
<li>改变事务隔离级别</li>
<li>如果出现死锁，可以用 show engine innodb status;命令来确定最后一个死锁产生的原因。返回结果中包括死锁相关事务的详细信息，如引发死锁的 SQL 语句，事务已经获得的锁，正在等待什么锁，以及被回滚的事务等。据此可以分析死锁产生的原因和改进措施。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="_125-分布式事务" tabindex="-1"><a class="header-anchor" href="#_125-分布式事务" aria-hidden="true">#</a> 125.分布式事务</h3>
<ol start="6">
<li>
<ol>
<li>
<p>模型中分三块：应用程序（AP）、资源管理器（RM）、事务管理器（TM）</p>
</li>
<li>
<ol>
<li>应用程序：定义了事务的边界，指定需要做哪些事务；</li>
<li>资源管理器：提供了访问事务的方法，通常一个数据库就是一个资源管理器；</li>
<li>事务管理器：协调参与了全局事务中的各个事务。</li>
</ol>
</li>
<li>
<p>分布式事务采用两段式提交（two-phase commit）的方式</p>
</li>
<li>
<ol>
<li>第一阶段所有的事务节点开始准备，告诉事务管理器ready。</li>
<li>第二阶段事务管理器告诉每个节点是commit还是rollback。如果有一个节点失败，就需要全局的节点全部rollback，以此保障事务的原子性。</li>
</ol>
</li>
</ol>
</li>
<li>
<p>Mvcc</p>
</li>
<li>
<ol>
<li>MySQL的大多数事务型存储引擎实现都不是简单的行级锁。基于提升并发性考虑，一般都同时实现了多版本并发控制（MVCC），包括Oracle、PostgreSQL。只是实现机制各不相同。</li>
</ol>
</li>
<li>
<p>业务需求对MySQL的影响(合适合度)</p>
</li>
<li>
<ul>
<li>
<p>存储定位对MySQL的影响</p>
</li>
<li>
<p>不适合放进MySQL的数据</p>
</li>
<li>
<ul>
<li>二进制多媒体数据</li>
<li>流水队列数据</li>
<li>超大文本数据</li>
</ul>
</li>
<li>
<p>需要放进缓存的数据</p>
</li>
<li>
<ul>
<li>系统各种配置及规则数据</li>
<li>活跃用户的基本信息数据</li>
<li>活跃用户的个性化定制信息数据</li>
<li>准实时的统计信息数据</li>
<li>其他一些访问频繁但变更较少的数据</li>
</ul>
</li>
<li>
<p>Schema设计对系统的性能影响</p>
</li>
<li>
<p>尽量减少对数据库访问的请求</p>
</li>
<li>
<p>尽量减少无用数据的查询请求</p>
</li>
<li>
<p>硬件环境对系统性能的影响</p>
</li>
</ul>
</li>
</ol>
<h3 id="_126-索引优化" tabindex="-1"><a class="header-anchor" href="#_126-索引优化" aria-hidden="true">#</a> 126.索引优化：</h3>
<p>​	全值匹配我最爱</p>
<ol start="2">
<li>最佳左前缀法则，比如建立了一个联合索引(a,b,c)，那么其实我们可利用的索引就有(a), (a,b), (a,b,c)</li>
<li>不在索引列上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</li>
<li>存储引擎不能使用索引中范围条件右边的列</li>
<li>尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致))，减少select</li>
<li>is null ,is not null 也无法使用索引</li>
<li>like &quot;xxxx%&quot; 是可以用到索引的，like &quot;%xxxx&quot; 则不行(like &quot;%xxx%&quot; 同理)。like以通配符开头('%abc...')索引失效会变成全表扫描的操作，</li>
<li>字符串不加单引号索引失效</li>
<li>少用or，用它来连接时会索引失效</li>
<li>&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN 可用到索引，&lt;&gt;，not in ，!= 则不行，会导致全表扫描</li>
</ol>
<h3 id="_127-分区类型" tabindex="-1"><a class="header-anchor" href="#_127-分区类型" aria-hidden="true">#</a> 127.分区类型</h3>
<p>​	<strong>RANGE分区</strong>：基于属于一个给定连续区间的列值，把多行分配给分区。mysql将会根据指定的拆分策略，,把数据放在不同的表文件上。相当于在文件上,被拆成了小块.但是,对外给客户的感觉还是一张表，透明的。</p>
<p>按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，比如交易表啊，销售表啊等，可以根据年月来存放数据。可能会产生热点问题，大量的流量都打在最新的数据上了。</p>
<p>range 来分，好处在于说，扩容的时候很简单。</p>
<ol start="2">
<li>
<p><strong>LIST分区</strong>：类似于按RANGE分区，每个分区必须明确定义。它们的主要区别在于，LIST分区中每个分区的定义和选择是基于某列的值从属于一个值列表集中的一个值，而RANGE分区是从属于一个连续区间值的集合。</p>
</li>
<li>
<p><strong>HASH分区</strong>：基于用户定义的表达式的返回值来进行选择的分区，该表达式使用将要插入到表中的这些行的列值进行计算。这个函数可以包含MySQL 中有效的、产生非负整数值的任何表达式。</p>
<p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表</p>
</li>
<li>
<p><strong>KEY分区</strong>：类似于按HASH分区，区别在于KEY分区只支持计算一列或多列，且MySQL服务器提供其自身的哈希函数。必须有一列或多列包含整数值。</p>
</li>
</ol>
<h3 id="_128-分表" tabindex="-1"><a class="header-anchor" href="#_128-分表" aria-hidden="true">#</a> 128.分表</h3>
<ol>
<li>
<ol>
<li>
<p><strong>垂直拆分</strong></p>
<p>垂直分表，通常是按照业务功能的使用频次，把主要的、热门的字段放在一起做为主要表。然后把不常用的，按照各自的业务属性进行聚集，拆分到不同的次要表中；主要表和次要表的关系一般都是一对一的。</p>
</li>
<li>
<p><strong>水平拆分(数据分片)</strong></p>
<p>单表的容量不超过500W，否则建议水平拆分。是把一个表复制成同样表结构的不同表，然后把数据按照一定的规则划分，分别存储到这些表中，从而保证单表的容量不会太大，提升性能；当然这些结构一样的表，可以放在一个或多个数据库中。</p>
<p>水平分割的几种方法：</p>
</li>
<li>
<ul>
<li>使用MD5哈希，做法是对UID进行md5加密，然后取前几位（我们这里取前两位），然后就可以将不同的UID哈希到不同的用户表（user_xx）中了。</li>
<li>还可根据时间放入不同的表，比如：article_201601，article_201602。</li>
<li>按热度拆分，高点击率的词条生成各自的一张表，低热度的词条都放在一张大表里，待低热度的词条达到一定的贴数后，再把低热度的表单独拆分成一张表。</li>
<li>根据ID的值放入对应的表，第一个表user_0000，第二个100万的用户数据放在第二 个表user_0001中，随用户增加，直接添加用户表就行了。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h1 id="五-算法" tabindex="-1"><a class="header-anchor" href="#五-算法" aria-hidden="true">#</a> 五.算法：</h1>
<h2 id="三-php常用算法" tabindex="-1"><a class="header-anchor" href="#三-php常用算法" aria-hidden="true">#</a> 三.php常用算法：</h2>
<h3 id="_1-冒泡排序法-、选择排序法-、插入排序-、快速排序算法" tabindex="-1"><a class="header-anchor" href="#_1-冒泡排序法-、选择排序法-、插入排序-、快速排序算法" aria-hidden="true">#</a> 1.冒泡排序法 、选择排序法 、插入排序 、快速排序算法</h3>
<p>一、冒泡排序法</p>
<p>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，依次比较两个元素，如果他们的顺序错误就把他们交换过来。</p>
<p>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越来越小的元素会经由交换慢慢&quot;浮&quot;到数列的顶端。</p>
<p>步骤：</p>
<p>①：比较相邻的元素。如果第一个比第二个大，就交换他们两个</p>
<p>②：对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</p>
<p>③：针对所有的元素重复以上的步骤，除了最有一个</p>
<p>④：持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</p>
<p>具体代码：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>$arr=array(1,43,54,62,21,66,32,78,36,76,39);

print_r(bubbleSort($arr));

function bubbleSort($arr){

    $len = count($arr);

    //该层循环控制 需要冒泡的轮数

    for ($i=1; $i&lt;$len; $i++) {

        //该层循环用来控制每轮 冒出一个数 需要比较的次数

        for ($k=0; $k&lt;$len-$i; $k++) {

            if($arr[$k] > $arr[$k+1]) {

                $tmp = $arr[$k+1]; // 声明一个临时变量

                $arr[$k+1] = $arr[$k];

                $arr[$k] = $tmp;

            }

        }

    }

    return $arr;

}


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>二、选择排序法</strong></p>
<p>选择排序是一种简单直观的排序算法。它的工作原理如下：首先是在末排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从 剩余未排序元素中继续寻找最小元素。然后放到排序序列末尾。以此类推，直到所有元素均排序完成。</p>
<p><strong>具体代码：</strong></p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>$arr=array(1,43,54,62,21,66,32,78,36,76,39);
print_r(select_sort($arr));
//实现思路 双重循环完成，外层控制轮数，当前的最小值。内层 控制的比较次数
 function select_sort($arr) {
    //$i 当前最小值的位置， 需要参与比较的元素
    for($i=0, $len=count($arr); $i&lt;$len-1; $i++) {
        //先假设最小的值的位置
        $p = $i;
        //$j 当前都需要和哪些元素比较，$i 后边的。
        for($j=$i+1; $j&lt;$len; $j++) {
            //$arr[$p] 是 当前已知的最小值
            if($arr[$p] > $arr[$j]) {
                //比较，发现更小的,记录下最小值的位置；并且在下次比较时，应该采用已知的最小值进行比较。
                $p = $j;
            }
        }
        //已经确定了当前的最小值的位置，保存到$p中。
        //如果发现 最小值的位置与当前假设的位置$i不同，则位置互换即可
        if($p != $i) {
            $tmp = $arr[$p];
            $arr[$p] = $arr[$i];
            $arr[$i] = $tmp;
        }
    }
    //返回最终结果
    return $arr;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>三、插入排序</p>
<p>插入排序的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在一排序序列中从后向前扫描，找到相应的位置并插入。</p>
<p>插入排序在实现上，通常采用in-place排序（既只需用到O（1）的额外空间的排序），因而在从后面向前扫描过程中，需要反复把已排完元素逐步向后挪位，为最新元素提供插入空间。</p>
<p>步骤：</p>
<p>①从第一个元素开始，该元素可以认为已经被排序</p>
<p>②取出下一个元素，在已经排序的元素序列中从后向前扫描</p>
<p>③如果该元素（已排序）大于新元素，将该元素移到下一个位置</p>
<p>④重复步骤③，直到找打已排序的元素小于或者等于新元素的位置</p>
<p>⑤将新元素插入到该位置中</p>
<p>⑥重复步骤②</p>
<p>具体代码：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>$arr=array(1,43,54,62,21,66,32,78,36,76,39);

print_r(insert_sort($arr));

function insert_sort($arr){

    $len=count($arr);

    for($i=1; $i&lt;$len; $i++) {

        //获得当前需要比较的元素值。
        $tmp = $arr[$i];

        //内层循环控制 比较 并 插入
        for($j=$i-1; $j>=0; $j--) {

            //$arr[$i];//需要插入的元素; $arr[$j];//需要比较的元素
            if($tmp &lt; $arr[$j]) {

                //发现插入的元素要小，交换位置
                //将后边的元素与前面的元素互换
                $arr[$j+1] = $arr[$j];

                //将前面的数设置为 当前需要交换的数
                $arr[$j] = $tmp;

            } else {

                //如果碰到不需要移动的元素
                //由于是已经排序好是数组，则前面的就不需要再次比较了。

                break;

            }

        }

    }

    //将这个元素 插入到已经排序好的序列内。
    //返回

    return $arr;

}


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>四、快速排序算法</p>
<p>快速排序是由东尼·霍尔发展的一种排序算法。在平均状况下 ，排序n个项目要O（n log n）次比较。</p>
<p>在最坏状况下则需要O（n2）次比较，但这种状况并不常见。事实上，快速排序通常明显比其他O（n log n）算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地实现出来，且大部分真实世界的数据，可以决定设计的选择，减少所需时间的二次方之可能性。</p>
<p>步骤：</p>
<p>①从数列中挑出一个元素，称为‘基准’</p>
<p>②重复排序数列，所有元素比基准值小的摆放到基准前面，所有元素比基准大的摆放到基准后面（相同的数可以到任意一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</p>
<p>③递归地把小于基准值元素的子数列和大于基准值元素的子数列排序</p>
<p>具体代码：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>$arr=array(1,43,54,62,21,66,32,78,36,76,39);

print_r(quick_sort($arr));

function quick_sort($arr){

     //判断参数是否是一个数组
     if(!is_array($arr)) return false;

     //递归出口:数组长度为1，直接返回数组
     $length = count($arr);

     if($length&lt;=1) return $arr;

     //数组元素有多个,则定义两个空数组
     $left = $right = array();

    //使用for循环进行遍历，把第一个元素当做比较的对象
    for($i=1; $i&lt;$length; $i++){

        //判断当前元素的大小
        if($arr[$i]&lt;$arr[0]){

            $left[]=$arr[$i];

        }else{

            $right[]=$arr[$i];

        }

    }

    //递归调用
    $left=quick_sort($left);

    $right=quick_sort($right);

    //将所有的结果合并
    return array_merge($left,array($arr[0]),$right);

}


</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-手写算法-暂未复习" tabindex="-1"><a class="header-anchor" href="#_2-手写算法-暂未复习" aria-hidden="true">#</a> 2.手写算法（暂未复习）</h3>
<h4 id="_1-给定一个已排序的数组和一个指定值-返回指定值在数组中的下标位置-如果不存在-返回把给定值插入到数组之后的下标位置。注意时间复杂度。" tabindex="-1"><a class="header-anchor" href="#_1-给定一个已排序的数组和一个指定值-返回指定值在数组中的下标位置-如果不存在-返回把给定值插入到数组之后的下标位置。注意时间复杂度。" aria-hidden="true">#</a> <strong>（1）给定一个已排序的数组和一个指定值，返回指定值在数组中的下标位置，如果不存在，返回把给定值插入到数组之后的下标位置。注意时间复杂度。</strong></h4>
<p>比如给定有序数组 [1,3,5,6] 给定值5.那么返回下标2.</p>
<p>给定有序数组[1,3,5,6] 给定值 7，返回下标4.</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>function searchInsert($nums, $target) {
    if (!count($nums))  return 0;
    $l=0;
    $r = count($nums)-1;
    while ($l &lt;= $r){
        $middle = $l + (($r - $l) >> 1);
        if ($nums[$middle] == $target) return $middle;
        if ($nums[$middle] &lt; $target){
            $l = $middle+1;
        }else{
            $r = $middle-1;
        }    
    }
    return $l;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>典型的可以使用二分，时间复杂度 O(log2n)。空间复杂度O(1)。</p>
<h4 id="_2-快速排序" tabindex="-1"><a class="header-anchor" href="#_2-快速排序" aria-hidden="true">#</a> （2）快速排序</h4>
<p>基本思想：</p>
<pre><code>在数组中挑出一个元素（多为第一个）作为标尺，扫描一遍数组将比标尺小的元素排在标尺之前，将所有比标尺大的元素排在标尺之后，通过递归将各子序列分别划分为更小的序列直到所有的序列顺序一致。

  &lt;?php
  //快速排序
  function quick_sort($arr) 
  {
  	//先判断是否需要继续进行
    $length = count($arr);
  if($length &lt;= 1) 
  {
  	return $arr;
  }
  $base_num = $arr[0];//选择一个标尺 选择第一个元素
 
  //初始化两个数组
  $left_array = array();//小于标尺的
  $right_array = array();//大于标尺的
  for($i=1; $i&lt;$length; $i++) 
  {      //遍历 除了标尺外的所有元素，按照大小关系放入两个数组内
    if($base_num &gt; $arr[$i]) 
    {
      //放入左边数组
      $left_array[] = $arr[$i];
    } 
    else
    {
      //放入右边
      $right_array[] = $arr[$i];
    }
  }
  //再分别对 左边 和 右边的数组进行相同的排序处理方式
  //递归调用这个函数,并记录结果
  $left_array = quick_sort($left_array);
  $right_array = quick_sort($right_array);
  //合并左边 标尺 右边
  return array_merge($left_array, array($base_num), $right_array);
}
 
$arr = array(3,1,2);
var_dump(quick_sort($arr));
?&gt;
</code></pre>
<h4 id="_3-二分查找" tabindex="-1"><a class="header-anchor" href="#_3-二分查找" aria-hidden="true">#</a> （3）二分查找</h4>
<p>基本思想：</p>
<pre><code>假设数据是按升序排序的，对于给定值x，从序列的中间位置开始比较，如果当前位置值等于x，则查找成功；若x小于当前位置值，则在数列的前半段中查找；若x大于当前位置值则在数列的后半段中继续查找，直到找到为止。（数据量大的时候使用）
</code></pre>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
  //二分查找
  function bin_search($arr,$low,$high,$k)
  {
    if($low &lt;= $high)
    {
      $mid = intval(($low + $high)/2);
      if($arr[$mid] == $k)
      {
        return $mid;
      }
      else if($k &lt; $arr[$mid])
      {
        return bin_search($arr,$low,$mid-1,$k);
      }
      else
      {
        return bin_search($arr,$mid+1,$high,$k);
      }
    }
    return -1;
  }
 
  $arr = array(1,2,3,4,5,6,7,8,9,10);
 
  print(bin_search($arr,0,9,3));
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-顺序查找" tabindex="-1"><a class="header-anchor" href="#_4-顺序查找" aria-hidden="true">#</a> （4）顺序查找</h4>
<p>基本思想：</p>
<p>从数组的第一个元素开始一个一个向下查找，如果有和目标一致的元素，查找成功；如果到最后一个元素仍没有目标元素，则查找失败。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
  //顺序查找
  function seq_search($arr,$n,$k)
  {
    $array[$n] = $k;
    for($i = 0;$i &lt; $n; $i++)
    {
      if($arr[$i] == $k)
      {
        break;
      }
    }
 
    if($i &lt; $n)
    {
      return $i;
    }
    else
    {
      return -1;
    }
  }
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5-遍历文件夹" tabindex="-1"><a class="header-anchor" href="#_5-遍历文件夹" aria-hidden="true">#</a> （5）遍历文件夹</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php  
  function my_scandir($dir)
  {
    $files = array();
    if($handle = opendir($dir))
    {
      while (($file = readdir($handle))!== false) 
      {
        if($file != '..' &amp;&amp; $file != '.')
        {
          if(is_dir($dir."/".$file))
          {
            $files[$file]=my_scandir($dir."/".$file);
          }
          else
          {
            $files[] = $file;
          }
        }
      }
 
      closedir($handle);
      return $files;
    }
  }
 
  var_dump(my_scandir('../'));
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_6-使对象可以像数组一样进行foreach循环-要求属性必须是私有。-iterator模式的php5实现-写一类实现iterator接口-腾讯" tabindex="-1"><a class="header-anchor" href="#_6-使对象可以像数组一样进行foreach循环-要求属性必须是私有。-iterator模式的php5实现-写一类实现iterator接口-腾讯" aria-hidden="true">#</a> （6）使对象可以像数组一样进行foreach循环，要求属性必须是私有。(Iterator模式的PHP5实现，写一类实现Iterator接口)（腾讯）</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
    class Test implements Iterator{
    private $item = array('id'=>1,'name'=>'php');

    public function rewind(){
        reset($this->item);
    }

    public function current(){
        return current($this->item);
    }

    public function key(){
        return key($this->item);
    }

    public function next(){
        return next($this->item);
    }

    public function valid(){
        return($this->current()!==false);
    }
}
    //测试
    $t=new Test;
    foreach($t as $k=>$v){
        echo$k,'--->',$v,'&lt;br/>';
    }
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_7-写出一种排序算法-要写出代码-并说出优化它的方法。-新浪" tabindex="-1"><a class="header-anchor" href="#_7-写出一种排序算法-要写出代码-并说出优化它的方法。-新浪" aria-hidden="true">#</a> （7）写出一种排序算法（要写出代码），并说出优化它的方法。（新浪）</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
    //快速排序
    function partition(&amp;$arr,$low,$high){
        $pivotkey = $arr[$low];
        while($low&lt;$high){
            while($low &lt; $high &amp;&amp; $arr[$high] >= $pivotkey){
                $high--;
            }
            $temp = $arr[$low];
            $arr[$low] = $arr[$high];
            $arr[$high] = $temp;
            while($low &lt; $high &amp;&amp; $arr[$low] &lt;= $pivotkey){
                $low++;
            }
            $temp=$arr[$low];
            $arr[$low]=$arr[$high];
            $arr[$high]=$temp;
        }
        return$low;
    }


function quick_sort(&amp;$arr,$low,$high){
    if($low &lt; $high){
        $pivot = partition($arr,$low,$high);
        quick_sort($arr,$low,$pivot-1);
        quick_sort($arr,$pivot+1,$high);
    }
}
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_8-关于猴子的面试题" tabindex="-1"><a class="header-anchor" href="#_8-关于猴子的面试题" aria-hidden="true">#</a> （8）关于猴子的面试题</h4>
<p>一群猴子排成一圈，按1，2，...，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去...，如此不停的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n,输出最后那个大王的编号。（新浪）（小米）</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
    // 方案一，使用php来模拟这个过程
    function king($n,$m){
        $mokey = range(1, $n);
        $i = 0;

        while (count($mokey) >1) {
            $i += 1;
            $head = array_shift($mokey);//一个个出列最前面的猴子
            if ($i % $m !=0) {
                #如果不是m的倍数，则把猴子返回尾部，否则就抛掉，也就是出列
                array_push($mokey,$head);
            }

            // 剩下的最后一个就是大王了
            return $mokey[0];
        }
    }
    // 测试
    echo king(10,7);

    // 方案二，使用数学方法解决
    function josephus($n,$m){
        $r = 0;
        for ($i=2; $i &lt;= $m ; $i++) {
            $r = ($r + $m) % $i;
        }

        return $r+1;
    }
    // 测试
    print_r(josephus(10,7));
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_9-二维数组排序算法函数-能够具有通用性-可以调用php内置函数。" tabindex="-1"><a class="header-anchor" href="#_9-二维数组排序算法函数-能够具有通用性-可以调用php内置函数。" aria-hidden="true">#</a> （9）二维数组排序算法函数，能够具有通用性，可以调用php内置函数。</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
//二维数组排序，$arr是数据，$keys是排序的健值，$order是排序规则，1是降序，0是升序
function array_sort($arr,$keys,$order=0){
    if(!is_array($arr)){
        return false;
    }
    $keysvalue=array();
    foreach($arr as $key => $val){
        $keysvalue[$key] = $val[$keys];
    }
    if($order == 0){
        asort($keysvalue);
    }else{
        arsort($keysvalue);
    }
    reset($keysvalue);
    foreach($keysvalue as $key => $vals){
        $keysort[$key] = $key;
    }
    $new_array=array();
    foreach($keysort as $key=> $val){
        $new_array[$key]=$arr[$val];
    }
    return$new_array;
}
    //测试
    $person=array(
        array('id'=>2,'name'=>'zhangsan','age'=>23),
        array('id'=>5,'name'=>'lisi','age'=>28),
        array('id'=>3,'name'=>'apple','age'=>17)
    );
    $result = array_sort($person,'name',1);
    print_r($result);
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_10-顺序查找和二分查找-也叫做折半查找-算法-顺序查找必须考虑效率-对象可以是一个有序数组-小米" tabindex="-1"><a class="header-anchor" href="#_10-顺序查找和二分查找-也叫做折半查找-算法-顺序查找必须考虑效率-对象可以是一个有序数组-小米" aria-hidden="true">#</a> （10）顺序查找和二分查找（也叫做折半查找）算法，顺序查找必须考虑效率，对象可以是一个有序数组（小米）</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
    /**
     * 顺序查找
     * @param  array $arr 数组
     * @param   $k   要查找的元素
     * @return   mixed  成功返回数组下标，失败返回-1
     */
    function seq_sch($arr,$k){
        for ($i=0,$n = count($arr); $i &lt; $n; $i++) {
            if ($arr[$i] == $k) {
                break;
            }
        }
        if($i &lt; $n){
            return $i;
        }else{
            return -1;
        }
    }

    /**
     * 二分查找，要求数组已经排好顺序
     * @param  array $array 数组
     * @param  int $low   数组起始元素下标
     * @param  int $high  数组末尾元素下标
     * @param   $k     要查找的元素
     * @return mixed        成功时返回数组下标，失败返回-1
     */
    function bin_sch($array,$low,$high,$k){
        if ($low &lt;= $high) {
            $mid = intval(($low + $high) / 2);
            if ($array[$mid] == $k) {
                return $mid;
            } elseif ($k &lt; $array[$mid]) {
                return bin_sch($array,$low,$mid - 1,$k);
            } else{
                return bin_sch($array,$mid + 1,$high,$k);
            }
        }
        return -1;
    }

    // 测试：顺序查找
    $arr1 = array(9,15,34,76,25,5,47,55);
    echo seq_sch($arr1,47);//结果为6

    echo "&lt;br />";

    // 测试：二分查找
    $arr2 = array(5,9,15,25,34,47,55,76);
    echo bin_sch($arr2,0,7,47);//结果为5
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_11-洗牌算法" tabindex="-1"><a class="header-anchor" href="#_11-洗牌算法" aria-hidden="true">#</a> （11）洗牌算法</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
    $card_num = 54;//牌数
    function wash_card($card_num){
        $cards = $tmp = array();
        for($i = 0;$i &lt; $card_num;$i++){
            $tmp[$i] = $i;
        }

        for($i = 0;$i &lt; $card_num;$i++){
            $index = rand(0,$card_num-$i-1);
            $cards[$i] = $tmp[$index];
            unset($tmp[$index]);
            $tmp = array_values($tmp);
        }
        return $cards;
    }
    // 测试：
    print_r(wash_card($card_num));
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_12-php奇异算法" tabindex="-1"><a class="header-anchor" href="#_12-php奇异算法" aria-hidden="true">#</a> （12）.PHP奇异算法</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
function test(){
 $a=1;
 $b=&amp;$a;
 echo (++$a)+(++$a);
}
test();

PHP7以下的版本返回的是 6，PHP7版本返回5 ，还真的算奇异，个人底层算法差，认为是PHP7以下版本的BUG
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_13-字符集合-输入一个字符串-求出该字符串包含的字符集合-并按顺序排序-英文" tabindex="-1"><a class="header-anchor" href="#_13-字符集合-输入一个字符串-求出该字符串包含的字符集合-并按顺序排序-英文" aria-hidden="true">#</a> （13）字符集合：输入一个字符串，求出该字符串包含的字符集合，并按顺序排序（英文）</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>function set($str){
    //转化为数组
    $arr = str_split($str);
    //去除重复
    $arr = array_flip(array_flip($arr));
    //排序
    sort($arr);
    //返回字符串
    return implode('', $arr);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_14-有个人想上一个n级的台阶-每次只能迈1级或者迈2级台阶-问-这个人有多少种方法可以把台阶走完-例如-总共3级台阶-可以先迈1级再迈2级-或者先迈2级再迈1级-或者迈3次1级总共3中方式" tabindex="-1"><a class="header-anchor" href="#_14-有个人想上一个n级的台阶-每次只能迈1级或者迈2级台阶-问-这个人有多少种方法可以把台阶走完-例如-总共3级台阶-可以先迈1级再迈2级-或者先迈2级再迈1级-或者迈3次1级总共3中方式" aria-hidden="true">#</a> （14）.有个人想上一个n级的台阶，每次只能迈1级或者迈2级台阶，问：这个人有多少种方法可以把台阶走完？例如：总共3级台阶，可以先迈1级再迈2级，或者先迈2级再迈1级，或者迈3次1级总共3中方式</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>function jieti($num){    //实际上是斐波那契数列
        return $num&lt;2?1:jieti($num-1)+jieti($num-2);
    }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_15-随机输入一个数字能查询到对应的数据区间" tabindex="-1"><a class="header-anchor" href="#_15-随机输入一个数字能查询到对应的数据区间" aria-hidden="true">#</a> （15）随机输入一个数字能查询到对应的数据区间</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>//把区间换成数组写法，用二分法查找区间
function binsearch($x,$a){  
        $c=count($a);  
        $lower=0;  
        $high=$c-1;  
        while($lower&lt;=$high){  
            $middle=intval(($lower+$high)/2);  
            if($a[$middle]>=$x){  
                $high=$middle-1;
            }elseif($a[$middle]&lt;=$x ){  
                $lower=$middle+1;
            }   
        }
        return '在区间'.$a[$high].'到'.$a[$lower];  
}
 
$array  = ['1','50','100','150','200','250','300'];
$a = '120';
echo binsearch($a,$array);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_16-从0-1-2-3-4-5-6-7-8-9-这十个数字中任意选出三个不同的数字-三个数字中不含0和5-的概率是-小米" tabindex="-1"><a class="header-anchor" href="#_16-从0-1-2-3-4-5-6-7-8-9-这十个数字中任意选出三个不同的数字-三个数字中不含0和5-的概率是-小米" aria-hidden="true">#</a> （16）从0,1,2,3,4,5,6,7,8,9，这十个数字中任意选出三个不同的数字，“三个数字中不含0和5”的概率是（小米）</h4>
<p>​		7/15</p>
<h4 id="_17-用二分法查找一个长度为10的排好序的线性表-查找不成功时最多需要比较次数是-小米" tabindex="-1"><a class="header-anchor" href="#_17-用二分法查找一个长度为10的排好序的线性表-查找不成功时最多需要比较次数是-小米" aria-hidden="true">#</a> （17）用二分法查找一个长度为10的排好序的线性表，查找不成功时最多需要比较次数是（小米）</h4>
<p>​		4</p>
<h4 id="_18-一个三角形三个顶点有3只老鼠-一声枪响-3只老鼠开始沿三角形的边匀速运动-请问他们相遇的概率是-小米" tabindex="-1"><a class="header-anchor" href="#_18-一个三角形三个顶点有3只老鼠-一声枪响-3只老鼠开始沿三角形的边匀速运动-请问他们相遇的概率是-小米" aria-hidden="true">#</a> （18）一个三角形三个顶点有3只老鼠，一声枪响，3只老鼠开始沿三角形的边匀速运动，请问他们相遇的概率是（小米）</h4>
<p>75%，每只老鼠都有顺时针、逆时钟两种运动方向，3只老鼠共有8种运动情况，只有当3只老鼠都为顺时针或者逆时钟，它们才不会相遇，剩余的6中情况都会相遇，故相遇的概率为6/8=75%。</p>
<h4 id="_19-描述顺序查找和二分查找-也叫做折半查找-算法-顺序查找必须考虑效率-对象可以是一个有序数组-小米" tabindex="-1"><a class="header-anchor" href="#_19-描述顺序查找和二分查找-也叫做折半查找-算法-顺序查找必须考虑效率-对象可以是一个有序数组-小米" aria-hidden="true">#</a> （19）描述顺序查找和二分查找（也叫做折半查找）算法，顺序查找必须考虑效率，对象可以是一个有序数组（小米）</h4>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
    /**
     * 顺序查找
     * @param  array $arr 数组
     * @param   $k   要查找的元素
     * @return   mixed  成功返回数组下标，失败返回-1
     */
    function seq_sch($arr,$k){
        for ($i=0,$n = count($arr); $i &lt; $n; $i++) {
            if ($arr[$i] == $k) {
                break;
            }
        }
        if($i &lt; $n){
            return $i;
        }else{
            return -1;
        }
    }

    /**
     * 二分查找，要求数组已经排好顺序
     * @param  array $array 数组
     * @param  int $low   数组起始元素下标
     * @param  int $high  数组末尾元素下标
     * @param   $k     要查找的元素
     * @return mixed        成功时返回数组下标，失败返回-1
     */
    function bin_sch($array,$low,$high,$k){
        if ($low &lt;= $high) {
            $mid = intval(($low + $high) / 2);
            if ($array[$mid] == $k) {
                return $mid;
            } elseif ($k &lt; $array[$mid]) {
                return bin_sch($array,$low,$mid - 1,$k);
            } else{
                return bin_sch($array,$mid + 1,$high,$k);
            }
        }
        return -1;
    }

    // 测试：顺序查找
    $arr1 = array(9,15,34,76,25,5,47,55);
    echo seq_sch($arr1,47);//结果为6

    echo "&lt;br />";

    // 测试：二分查找
    $arr2 = array(5,9,15,25,34,47,55,76);
    echo bin_sch($arr2,0,7,47);//结果为5
?>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_20-如何快速寻找一个数组里最小的1000个数" tabindex="-1"><a class="header-anchor" href="#_20-如何快速寻找一个数组里最小的1000个数" aria-hidden="true">#</a> （20）如何快速寻找一个数组里最小的1000个数#</h4>
<p>思路：假设最前面的1000个数为最小的，算出这1000个数中最大的数，然后和第1001个数比较，如果这最大的数比这第1001个数小的话跳过，如果要比这第1001个数大则将两个数交换位置，并算出新的1000个数里面的最大数，再和下一个数比较，以此类推。
代码如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>//寻找最小的k个数
//题目描述
//输入n个整数，输出其中最小的k个。
/**
 * 获取最小的k个数
 * @param  array $arr 
 * @param  int $k   [description]
 * @return array
 */
function get_min_array($arr， $k)
{
    $n = count($arr);

    $min_array = array();

    for ($i = 0; $i &lt; $n; $i++) {
        if ($i &lt; $k) {
            $min_array[$i] = $arr[$i];
        } else {
            if ($i == $k) {
                $max_pos = get_max_pos($min_array);
                $max = $min_array[$max_pos];
            }

            if ($arr[$i] &lt; $max) {
                $min_array[$max_pos] = $arr[$i];

                $max_pos = get_max_pos($min_array);
                $max = $min_array[$max_pos];
            }
        }
    }

    return $min_array;
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h1 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a> </h1>
<h4 id="_1-基本排序算法要会写-时间复杂度要会推算-主要是冒泡排序-快速排序-选择排序" tabindex="-1"><a class="header-anchor" href="#_1-基本排序算法要会写-时间复杂度要会推算-主要是冒泡排序-快速排序-选择排序" aria-hidden="true">#</a> 1.基本排序算法要会写,时间复杂度要会推算, 主要是冒泡排序, 快速排序, 选择排序.</h4>
<h4 id="_2-查找算法-要会写二分查找法-实际场景要会应用" tabindex="-1"><a class="header-anchor" href="#_2-查找算法-要会写二分查找法-实际场景要会应用" aria-hidden="true">#</a> 2.查找算法,要会写二分查找法, 实际场景要会应用.</h4>
<h4 id="_3-猴子选大王" tabindex="-1"><a class="header-anchor" href="#_3-猴子选大王" aria-hidden="true">#</a> 3.猴子选大王</h4>
<h4 id="_4-斗地主项目设计" tabindex="-1"><a class="header-anchor" href="#_4-斗地主项目设计" aria-hidden="true">#</a> 4.斗地主项目设计</h4>
<h4 id="_5-实现随机函数" tabindex="-1"><a class="header-anchor" href="#_5-实现随机函数" aria-hidden="true">#</a> 5.实现随机函数</h4>
<p>rand()</p>
<p>rand(1,100)</p>
<p>mt_rand()</p>
<p>mt_rand(20,100);</p>
<h4 id="_6-字符串中元素各种变形查找" tabindex="-1"><a class="header-anchor" href="#_6-字符串中元素各种变形查找" aria-hidden="true">#</a> 6.字符串中元素各种变形查找</h4>
<h4 id="_7-123456-六个数放到三角形三个顶点及中点上-使每条边上的数字和相等" tabindex="-1"><a class="header-anchor" href="#_7-123456-六个数放到三角形三个顶点及中点上-使每条边上的数字和相等" aria-hidden="true">#</a> 7.123456 六个数放到三角形三个顶点及中点上,使每条边上的数字和相等</h4>
<h4 id="_8-一个超大文件里面存放关键-统计每个关键的个数-问如何实现" tabindex="-1"><a class="header-anchor" href="#_8-一个超大文件里面存放关键-统计每个关键的个数-问如何实现" aria-hidden="true">#</a> 8.一个超大文件里面存放关键,统计每个关键的个数, 问如何实现</h4>
<h4 id="_9-一个10g的文件-里面存放关键字-但内存只有10m-问如何实现统计-出现关键字次数最高的前100个" tabindex="-1"><a class="header-anchor" href="#_9-一个10g的文件-里面存放关键字-但内存只有10m-问如何实现统计-出现关键字次数最高的前100个" aria-hidden="true">#</a> 9.一个10G的文件,里面存放关键字, 但内存只有10M, 问如何实现统计, 出现关键字次数最高的前100个</h4>
<h4 id="_10-实现单链表与双链表" tabindex="-1"><a class="header-anchor" href="#_10-实现单链表与双链表" aria-hidden="true">#</a> 10.实现单链表与双链表</h4>
<h4 id="_11-实现有权重的随机算法" tabindex="-1"><a class="header-anchor" href="#_11-实现有权重的随机算法" aria-hidden="true">#</a> 11.实现有权重的随机算法</h4>
<h4 id="_2、矩阵的规律遍历-写出遍历的代码" tabindex="-1"><a class="header-anchor" href="#_2、矩阵的规律遍历-写出遍历的代码" aria-hidden="true">#</a> 2、矩阵的规律遍历，写出遍历的代码</h4>
<h4 id="_2、coding-一个数组-0-n-1-已经排好序-打印出满足-a-i-a-j-c-的所有i和j-说出时间复杂度-暂无答案" tabindex="-1"><a class="header-anchor" href="#_2、coding-一个数组-0-n-1-已经排好序-打印出满足-a-i-a-j-c-的所有i和j-说出时间复杂度-暂无答案" aria-hidden="true">#</a> 2、coding：一个数组 0 - n-1，已经排好序，打印出满足 a[i]+a[j] = c 的所有i和j，说出时间复杂度（暂无答案）</h4>
<p>常用算法（五种排序、二分查找、树广度深度遍历、猴子选大王、汉诺塔、斐波那契数列）</p>
<h2 id="八-小算法题" tabindex="-1"><a class="header-anchor" href="#八-小算法题" aria-hidden="true">#</a> 八.小算法题</h2>
<p>【程序1】
题目：古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一
对兔子，假如兔子都不死，问每个月的兔子总数为多少？
1.程序分析： 兔子的规律为数列1,1,2,3,5,8,13,21....</p>
<p>【程序2】
题目：判断101-200之间有多少个素数，并输出所有素数。
1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，
则表明此数不是素数，反之是素数。</p>
<p>做了【程序3】
题目：打印出所有的&quot;水仙花数&quot;，所谓&quot;水仙花数&quot;是指一个三位数，其各位数字立方和等于该数本身。例如：
153是一个&quot;水仙花数&quot;，因为153=1的三次方＋5的三次方＋3的三次方。
1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。</p>
<p>【程序4】
题目：将一个正整数分解质因数。例如：输入90,打印出90=2<em>3</em>3*5。
程序分析：对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：
(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。
(2)如果n&lt;&gt;k，但n能被k整除，则应打印出k的值，并用n除以k的商,作为新的正整数你n,重复执行第一步。
(3)如果n不能被k整除，则用k+1作为k的值,重复执行第一步。</p>
<p>【程序5】
题目：利用条件运算符的嵌套来完成此题：学习成绩&gt;=90分的同学用A表示，60-89分之间的用B表示，60分以下
的用C表示。
1.程序分析：(a&gt;b)?a:b这是条件运算符的基本例子。</p>
<p>【程序6】
题目：输入两个正整数m和n，求其最大公约数和最小公倍数。
1.程序分析：利用辗除法。</p>
<p>【程序7】
题目：输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。
1.程序分析：利用while语句,条件为输入的字符不为'\n'.</p>
<p>做了【程序8】
题目：求s=a+aa+aaa+aaaa+aa...a的值，其中a是一个数字。例如2+22+222+2222+22222(此时共有5个数相加)，
几个数相加有键盘控制。
1.程序分析：关键是计算出每一项的值。</p>
<p>【程序9】
题目：一个数如果恰好等于它的因子之和，这个数就称为&quot;完数&quot;。例如6=1＋2＋3.编程 找出1000以内的所有完
数。</p>
<p>【程序10】
题目：一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在 第10次落地时，共经过多
少米？第10次反弹多高？</p>
<p>【程序11】
题目：有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？
1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去 掉不满足条件的排列。</p>
<p>【程序12】
题目：企业发放的奖金根据利润提成。利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万
元时，低于10万元的部分按10%提成，高于10万元的部分，可可提成7.5%；20万到40万之间时，高于20万元的部
分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可
提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润I，求应发放奖金总数？
1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。</p>
<p>【程序13】
题目：一个整数，它加上100后是一个完全平方数，再加上168又是一个完全平方数，请问该数是多少？
1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上268后再开方，如果开方后的结果满足
如下条件，即是结果。请看具体分析：</p>
<p>【程序14】
题目：输入某年某月某日，判断这一天是这一年的第几天？
1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本年的第几天，特殊情况，闰年且
输入月份大于3时需考虑多加一天。</p>
<p>【程序15】
题目：输入三个整数x,y,z，请把这三个数由小到大输出。
1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt;y则将x与y的值进行交换，然后再用x
与z进行比较，如果x&gt;z则将x与z的值进行交换，这样能使x最小。</p>
<p>【程序16】
题目：输出9*9口诀。
1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。</p>
<p>【程序17】
题目：猴子吃桃问题：猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个 第二天早上又将剩
下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下
的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。
1.程序分析：采取逆向思维的方法，从后往前推断。</p>
<p>【程序18】
题目：两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向
队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。
1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除， 则表明此数不是素数，反
之是素数。</p>
<p>【程序19】
题目：打印出如下图案（菱形）
*</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<p>*
1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重 for循环，第一层控制
行，第二层控制列。</p>
<p>【程序20】
题目：有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13...求出这个数列的前20项之和。
1.程序分析：请抓住分子与分母的变化规律。</p>
<p>【程序21】
题目：求1+2!+3!+...+20!的和
1.程序分析：此程序只是把累加变成了累乘。</p>
<p>【程序22】
题目：利用递归方法求5!。
1.程序分析：递归公式：fn=fn_1*4!</p>
<p>【程序23】
题目：有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问
第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个
人多大？
1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，
依次类推，推到第一人（10岁），再往回推。</p>
<p>【程序24】
题目：给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。</p>
<p>【程序25】
题目：一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</p>
<p>【程序26】
题目：请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续 判断第二个字母。
1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。</p>
<p>【程序27】
题目：求100之内的素数</p>
<p>【程序28】
题目：对10个数进行排序
1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换， 下次类推，即用第
二个元素与后8个进行比较，并进行交换。</p>
<p>【程序29】
题目：求一个3*3矩阵对角线元素之和
1.程序分析：利用双重for循环控制输入二维数组，再将a[i][i]累加后输出。</p>
<p>【程序30】
题目：有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。
\1. 程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，插入后此元素之后的数，
依次后移一个位置。</p>
<p>【程序31】
题目：将一个数组逆序输出。
1.程序分析：用第一个与最后一个交换。</p>
<p>【程序32】
题目：取一个整数a从右端开始的4～7位。
程序分析：可以这样考虑：
(1)先使a右移4位。
(2)设置一个低4位全为1,其余全为0的数。可用~(~0&lt;&lt;4)
(3)将上面二者进行&amp;运算。</p>
<p>【程序33】
题目：打印出杨辉三角形（要求打印出10行如下图）
1.程序分析：
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1</p>
<p>【程序34】
题目：输入3个数a,b,c，按大小顺序输出。
1.程序分析：利用指针方法。</p>
<p>【程序35】
题目：输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。
【程序36】
题目：有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数</p>
<p>【程序37】
题目：有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下
的是原来第几号的那位。</p>
<p>【程序38】
题目：写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。</p>
<p>【程序39】
题目：编写一个函数，输入n为偶数时，调用函数求1/2+1/4+...+1/n,当输入n为奇数时，调用函数
1/1+1/3+...+1/n(利用指针函数)</p>
<p>【程序40】
题目：字符串排序。</p>
<p>【程序41】
题目：海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子凭据分为五份，多了一个，这只猴子把多的一
个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中
，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？</p>
<p>【程序42】
题目：809*??=800*??+9*??+1
其中??代表的两位数,8*??的结果为两位数，9*??的结果为3位数。求??代表的两位数，及809*??后的结果。</p>
<p>【程序43】
题目：求0—7所能组成的奇数个数。</p>
<p>【程序44】
题目：一个偶数总能表示为两个素数之和。</p>
<p>【程序45】
题目：判断一个素数能被几个9整除</p>
<p>【程序46】
题目：两个字符串连接程序
做完【程序47】
题目：读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的＊。</p>
<p>【程序48】
题目：某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字
都加上5,然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。</p>
<p>做完【程序49】
题目：计算字符串中子串出现的次数</p>
<p>【程序50】
题目：有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，况原有的数据和计算出的平均分数存放在磁盘文件&quot;stud&quot;中。</p>
<p>业务问题</p>
<p>\1. 用户注册，将用户的信息进行验证后插入到数据库，密码使用md5加密</p>
<p>\2. 用户登录，要求从数据库验证用户名和密码的正确性</p>
<p>\3. 遍历文件夹，将所有的文件信息输出，如果是文件夹红色输出，如果是文件，蓝色输出</p>
<p>\4. 在第三题的基础上，实现深度遍历（递归），同时要注意缩进方便肉眼看出级别关系</p>
<p>\5. 采用最少三种方式获取一个标准url请求的脚本文件名字</p>
<h1 id="六-php面试" tabindex="-1"><a class="header-anchor" href="#六-php面试" aria-hidden="true">#</a> 六.PHP面试</h1>
<h3 id="_1-设计模式-暂未复习" tabindex="-1"><a class="header-anchor" href="#_1-设计模式-暂未复习" aria-hidden="true">#</a> 1.设计模式（暂未复习）</h3>
<h4 id="_1-你知道哪些设计模式-你平常有使用到吗-可以结合你的业务场景说下吗" tabindex="-1"><a class="header-anchor" href="#_1-你知道哪些设计模式-你平常有使用到吗-可以结合你的业务场景说下吗" aria-hidden="true">#</a> （1）你知道哪些设计模式，你平常有使用到吗？可以结合你的业务场景说下吗？</h4>
<p>答：这里我先举例平常使用 Laravel，里面就用到大量设计模式，比如门面，组合，装饰，观察者…… 具体场景带入，然后根据之前业务上的场景说了下……., 最后也说了设计模式不是银弹，只有在合适的场景使用合适的模式才能体现它的价值。</p>
<h3 id="_2-设计模式" tabindex="-1"><a class="header-anchor" href="#_2-设计模式" aria-hidden="true">#</a> 2.设计模式</h3>
<ol>
<li>
<p>设计模式</p>
</li>
<li>
<ol>
<li>
<p>单例模式</p>
</li>
<li>
<ol>
<li>单例模式解决的是如何在整个项目中创建唯一对象实例的问题，工厂模式解决的是如何不通过new建立实例对象的方法。</li>
<li>三四一公（私有化属性、私有化构造方法、私有化克隆方法、公有化静态方法）</li>
<li>三四</li>
</ol>
</li>
<li>
<p>工厂模式</p>
</li>
<li>
<ol>
<li>工厂模式，工厂方法或者类生成对象，而不是在代码中直接new。</li>
<li>使用工厂模式，可以避免当改变某个类的名字或者方法之后，在调用这个类的所有的代码中都修改它的名字或者参数。</li>
</ol>
</li>
<li>
<p>注册模式</p>
</li>
<li>
<ol>
<li>注册模式，解决全局共享和交换对象。已经创建好的对象，挂在到某个全局可以使用的数组上，在需要使用的时候，直接从该数组上获取即可。将对象注册到全局的树上。任何地方直接去访问。</li>
</ol>
</li>
<li>
<p>策略模式</p>
</li>
<li>
<ol>
<li>策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境。</li>
</ol>
</li>
<li>
<p>观察者模式</p>
</li>
<li>
<ol>
<li>观察者模式(Observer)，当一个对象状态发生变化时，依赖它的对象全部会收到通知，并自动更新。</li>
<li>2：场景:一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理的逻辑。当更新的逻辑增多之后，代码会变得难以维护。这种方式是耦合的，侵入式的，增加新的逻辑需要修改事件的主体代码。</li>
<li>3：观察者模式实现了低耦合，非侵入式的通知与更新机制。</li>
</ol>
</li>
<li>
<p>原型模式</p>
</li>
<li>
<ol>
<li>与工厂模式类似，都是用来创建对象。</li>
<li>2：与工厂模式的实现不同，原型模式是先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建时重复的初始化操作。</li>
<li>3：原型模式适用于大对象的创建，创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需要内存拷贝即可。</li>
</ol>
</li>
<li>
<p>装饰器模式</p>
</li>
<li>
<ol>
<li>装饰器模式，可以动态的添加修改类的功能</li>
<li>2：一个类提供了一项功能，如果要在修改并添加额外的功能，传统的编程模式，需要写一个子类继承它，并重写实现类的方法</li>
<li>3：使用装饰器模式，仅需要在运行时添加一个装饰器对象即可实现，可以实现最大额灵活性。</li>
</ol>
</li>
<li>
<p>适配器模式</p>
</li>
<li>
<ol>
<li>将各种截然不同的函数接口封装成统一的API。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="_3-并发" tabindex="-1"><a class="header-anchor" href="#_3-并发" aria-hidden="true">#</a> 3.并发</h3>
<h4 id="假设现在有多个入口可以同时使用一个账户操作-这个账户只有十块钱-有哪些方法可以使得不超扣消费-开放性题目-只要能解决问题的就是好方案-没有唯一答案。" tabindex="-1"><a class="header-anchor" href="#假设现在有多个入口可以同时使用一个账户操作-这个账户只有十块钱-有哪些方法可以使得不超扣消费-开放性题目-只要能解决问题的就是好方案-没有唯一答案。" aria-hidden="true">#</a> 假设现在有多个入口可以同时使用一个账户操作，这个账户只有十块钱，有哪些方法可以使得不超扣消费？开放性题目，只要能解决问题的就是好方案，没有唯一答案。</h4>
<p>答：mysql：可以直接 where amount&gt;=current_amount and amount&gt;0 …… , 或者悲观锁 for update。</p>
<p>redis:lua 脚本。</p>
<p>php 层面可以利用文件锁，</p>
<p>还可以使用队列的特性，只有一个消费的出口。</p>
<h3 id="-1" tabindex="-1"><a class="header-anchor" href="#-1" aria-hidden="true">#</a> </h3>
<h3 id="_4-php垃圾回收机制-缺点" tabindex="-1"><a class="header-anchor" href="#_4-php垃圾回收机制-缺点" aria-hidden="true">#</a> 4.php垃圾回收机制/缺点</h3>
<h3 id="_5-同步、异步有啥区别" tabindex="-1"><a class="header-anchor" href="#_5-同步、异步有啥区别" aria-hidden="true">#</a> 5.同步、异步有啥区别</h3>
<h3 id="_6-源码解读" tabindex="-1"><a class="header-anchor" href="#_6-源码解读" aria-hidden="true">#</a> 6.源码解读</h3>
<h3 id="_7-如何让php-比较安全" tabindex="-1"><a class="header-anchor" href="#_7-如何让php-比较安全" aria-hidden="true">#</a> 7.如何让php 比较安全</h3>
<h3 id="_8-排序" tabindex="-1"><a class="header-anchor" href="#_8-排序" aria-hidden="true">#</a> 8.排序</h3>
<ol>
<li>
<ol>
<li>sort() 函数用于对数组单元从低到高进行排序。</li>
<li>rsort() 函数用于对数组单元从高到低进行排序。</li>
<li>asort() 函数用于对数组单元从低到高进行排序并保持索引关系。</li>
<li>arsort() 函数用于对数组单元从高到低进行排序并保持索引关系。</li>
<li>ksort() 函数用于对数组单元按照键名从低到高进行排序。</li>
<li>krsort() 函数用于对数组单元按照键名从高到低进行排序。</li>
</ol>
</li>
</ol>
<h3 id="_9-设计-如果我们公司有很多项目都有登录的功能-咋么设计" tabindex="-1"><a class="header-anchor" href="#_9-设计-如果我们公司有很多项目都有登录的功能-咋么设计" aria-hidden="true">#</a> 9.设计：如果我们公司有很多项目都有登录的功能，咋么设计？</h3>
<p>答：需要把这个登录单独抽出来作为一个模块开发，类似于登录中心，所有的其他子系统登录都需要从这个系统中认证。</p>
<h3 id="_10-谈谈你对闭包的理解" tabindex="-1"><a class="header-anchor" href="#_10-谈谈你对闭包的理解" aria-hidden="true">#</a> 10.谈谈你对闭包的理解？</h3>
<p><strong>匿名函数</strong></p>
<p><em>提到闭包就不得不想起匿名函数，也叫闭包函数（closures），貌似PHP闭包实现主要就是靠它。声明一个匿名函数是这样：</em></p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>1 $func = function() {
2  
3 }; //带结束符
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，匿名函数因为没有名字，如果要使用它，需要将其返回给一个变量。匿名函数也像普通函数一样可以声明参数，调用方法也相同：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>1 $func = function( $param ) {
2     echo $param;
3 };
	$func( 'some string' );
4 //输出：
5 //some string
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>顺便提一下，PHP在引入闭包之前，也有一个可以创建匿名函数的函数：create function，但是代码逻辑只能写成字符串，这样看起来很晦涩并且不好维护，所以很少有人用。</p>
<p>**实现闭包
**将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>//例一
//在函数里定义一个匿名函数，并且调用它
function printStr() {
    $func = function( $str ) {
        echo $str;
    };
    $func( 'some string' );
}
printStr();

//例二
//在函数中把匿名函数返回，并且调用它
function getPrintStrFunc() {
    $func = function( $str ) {
        echo $str;
    };
    return $func;
}
$printStrFunc = getPrintStrFunc();
$printStrFunc( 'some string' );


//例三
//把匿名函数当做参数传递，并且调用它
function callFunc( $func ) {
    $func( 'some string' );
}
$printStrFunc = function( $str ) {
    echo $str;
};
callFunc( $printStrFunc );
//也可以直接将匿名函数进行传递。如果你了解js，这种写法可能会很熟悉
callFunc( function( $str ) {
    echo $str;
} );
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>连接闭包和外界变量的关键字：USE</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>function getMoney() {
    $rmb = 1;
    $dollar = 6;
    $func = function() use ( $rmb ) {
        echo $rmb;
        echo $dollar;
    };
    $func();
}
getMoney();
//输出：
//1
//报错，找不到dorllar变量
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>闭包可以保存所在代码块上下文的一些变量和值。PHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。 换一个例子看看：</p>
<p>可以看到，dollar没有在use关键字中声明，在这个匿名函数里也就不能获取到它，所以开发中要注意这个问题。
有人可能会想到，是否可以在匿名函数中改变上下文的变量，但我发现是不可以的：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>function getMoney() {
    $rmb = 1;
    $func = function() use ( $rmb ) {
        echo $rmb;
        //把$rmb的值加1
        $rmb++;
    };
    $func();
    echo $rmb;
}
getMoney();
//输出：
//1
//1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>原来use所引用的也只不过是变量的一个副本而已。但是我想要完全引用变量，而不是复制。 要达到这种效果，其实在变量前加一个 &amp; 符号就可以了：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>function getMoney() {
    $rmb = 1;
    $func = function() use ( &amp;$rmb ) {
        echo $rmb;
        //把$rmb的值加1
        $rmb++;
    };
    $func();
    echo $rmb;
}getMoney();
//输出：
//1
//2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样匿名函数就可以引用上下文的变量了。如果将匿名函数返回给外界，匿名函数会保存use所引用的变量，而外界则不能得到这些变量，这样形成‘闭包'这个概念可能会更清晰一些。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>function getMoneyFunc() {
    $rmb = 1;
    $func = function() use ( &amp;$rmb ) {
        echo $rmb;
        //把$rmb的值加1
        $rmb++;
    };
    return $func;
}$getMoney = getMoneyFunc();
$getMoney();
$getMoney();
$getMoney();
//输出：
//1
//2
//3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结
PHP闭包的特性并没有太大惊喜，其实用CLASS就可以实现类似甚至强大得多的功能，更不能和js的闭包相提并论，只能期待PHP以后对闭 包支持的改进。不过匿名函数还是挺有用的，比如在使用preg_replace_callback等之类的函数可以不用在外部声明回调函数了。</p>
<h3 id="_11-如何解决php内存溢出问题" tabindex="-1"><a class="header-anchor" href="#_11-如何解决php内存溢出问题" aria-hidden="true">#</a> 11.如何解决PHP内存溢出问题？</h3>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>之前有写一个php 爬虫定时任务，发现系统的内存飞快的上涨，直觉告诉我应该是php内存泄漏惹得祸。
于是用。

killall php

杀掉了php 的进程。从内存占用78%，变成了20%

解决方案
方案一
像上面描述。在凌晨的时候把进程给kill 了。
或者查看php 进程内存占用百分比，如果达到 了一定高度时候，给kill了。

方案二
php-fpm.conf中有个参数pm.max_requests，等同于PHP_FCGI_MAX_REQUESTS。该值的意思是一个fpm进程处理多少个请求后自动杀掉另起新进程。（这个好想也不推荐）

优化方案
1。应当尽可能减少静态变量的使用，在需要数据重用时，可以考虑使用引用(&amp;)。
2。数据库操作完成后，要马上关闭连接；
3。一个对象使用完，要及时调用析构函数（__destruct()）
4。用过的变量及时销毁(unset())掉
5。可以使用memory_get_usage()函数,获取当前占用内存 根据当前使用的内存来调整程序
6。unset()函数只能在变量值占用内存空间超过256字节时才会释放内存空间。(PHP内核的gc垃圾回收机制决定)
7。有当指向该变量的所有变量（如引用变量）都被销毁后，才会释放内存(PHP变量底层实现是一个_zval_struct结构体,is_ref__gc表示引用计数 is_ref__gc表示是否为引用)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>有时候我们在运行php程序的时候会发现 Fatal Error: Out of memory 这样的提示。 这有可能是程序中用到了大量的变量和对象，导致分配的内存不够用。

我就遇到这样一个错误怎么改也改不了，后来上网查了一些资料，可是修改了php.ini文件里的memory_limit参数，可是无论我怎么改还是有这个错误提示，特别郁闷！后来我实在没有办法了，就在QQ群里面求助，有人告诉我在我的程序代码中加入“init_set( "memory_limit" , "128M" ) ; ”这行代码就可以了，于是我试了一下，还真的行了。现在我把自己解决这个问题的两种办法分享给大家，希望能帮到和我一样遇到类似问题的人们。

方法一：

我们可以在php.ini文件中把memory_limit参数默认的128M修改为256M或者更大：
memory_limit =128M
方法二：
如果是虚拟主机，我们可以在程序需要用到大内存的地方添加：
init_set(
	"memory_limit","128M"
);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>一．内存溢出解决方案
在做数据统计分析时，经常会遇到大数组，可能会发生内存溢出，这里分享一下我的解决方案。还是用例子来说明这个问题，如下：
假定日志中存放的记录数为500000条，那么解决方案如下：

ini_set(‘memory_limit’,’64M’);　//重置php可以使用的内存大小为64M，一般在远程主机上是不能修改php.ini文件的，只能通过程序设置。注：在safe_mode（安全模式）下，ini_set失效

    set_time_limit(600);//设置超时限制为６分钟
    $farr = $Uarr = $Marr = $IParr = $data = $_sub = array();
    $spt = ”$@#!$”;
    $root = ”/Data/webapps/VisitLog”;
    $path = $dpath = $fpath = NULL;
    $path = $root.”/”.date(“Y-m”,$timestamp);
    $dpath = $path.”/”.date(“m-d”,$timestamp);
    for($j=0;$j&lt;24;$j++){
    $v = ($j &lt; 10) ? ”0″.$j : $j;
    $gpath = $dpath.”/”.$v.”.php”;
    if(!file_exists($gpath)){
        continue;
    } else {
        $arr = file($gpath);////将文件读入数组中
        array_shift($arr);//移出第一个单元－》&lt;?php exit;?>
        $farr = array_merge($farr,$arr);
        unset($arr);
    }

}

if(empty($this->farr)){
    echo ”&lt;p>&lt;center>没有相关记录！&lt;/center>&lt;/p>”;
    exit;
}

while(!empty($farr)){
    $_sub = array_splice($farr, 0, 10000); //每次取出$farr中1000个
    for($i=0,$scount=count($_sub);$i&lt;$scount;$i++){
    $arr = explode($spt,$_sub[$i]);
    $Uarr[] = $arr[1]; //vurl
    $Marr[] = $arr[2]; //vmark
    $IParr[] = $arr[3].” |$nbsp;”.$arr[1]; //IP
}

unset($_sub);//用完及时销毁
}

unset($farr);
这里，不难看出，一方面，我们要增加PHP可用内存大小，另一方面，只要我们想办法对数组进行分批处理，分而治之，将用过的变量及时销毁(unset)，一般是不会出现溢出问题的。

另外，为了节省PHP程序内存损耗，我们应当尽可能减少静态变量的使用，在需要数据重用时，可以考虑使用引用(&amp;)。再一点就是：数据库操作完成后，要马上关闭连接；一个对象使用完，要及时调用析构函数（__destruct()）。

二．unset销毁变量并释放内存问题

PHP的unset()函数用来清除、销毁变量，不用的变量，我们可以用unset()将它销毁。但是某些时候，用unset()却无法达到销毁变 量占用的内存！我们先看一个例子：

&lt;?php
    $s=str_repeat('1',255); //产生由255个1组成的字符串
    $m=memory_get_usage(); //获取当前占用内存
    unset($s);
    $mm=memory_get_usage(); //unset()后再查看当前占用内存
    echo $m-$mm;
?>
最后输出unset()之前占用内存减去unset()之后占用内存，如果是正数，那么说明unset($s)已经将$s从内存中销毁(或者 说，unset()之后内存占用减少了)，可是我在PHP5和windows平台下，得到的结果是：0。这是否可以说明，unset($s)并没有起 到销毁变量$s所占用内存的作用呢？我们再作下面的例子：

&lt;?php
    $s=str_repeat('1',256); //产生由256个1组成的字符串
    $m=memory_get_usage(); //获取当前占用内存
    unset($s);
    $mm=memory_get_usage(); //unset()后再查看当前占用内存
    echo $m-$mm;
?>
这个例子，和上面的例子几乎相同，唯一的不同是，$s由256个1组成，即比第一个例子多了一个1，得到结果是：272。这是否可以说 明，unset($s)已经将$s所占用的内存销毁了？
通过上面两个例子，我们可以得出以下结论：
结论一、unset()函数只能在变量值占用内存空间超过256字节时才会释放内存空间。

那么是不是只要变量值超过256，使用unset就可以释放内存空间呢？我们再通过一个例子来测试一下：

&lt;?php
    $s=str_repeat('1',256); //这和第二个例子完全相同
    $p=&amp;$s;
    $m=memory_get_usage();
    unset($s); //销毁$s
    $mm=memory_get_usage();
    echo $p.'&lt;br />';
    echo $m-$mm;
?>
刷新页面，我们看到第一行有256个1，第二行是0，按理说我们已经销毁了$s，而$p只是引用$s的变量，应该是没有内容了，另 外，unset($s)前后内存占用没变化！现在我们再做以下的例子：

&lt;?php
    $s=str_repeat('1',256); //这和第二个例子完全相同
    $p=&amp;$s;
    $m=memory_get_usage();
    $s=null; //设置$s为null
    $mm=memory_get_usage();
    echo $p.'&lt;br />';
    echo $m-$mm;
?>
现在刷新页面，我们看到，输出$p已经是没有内容了，unset()前后内存占用量之差是272，即已经清除了变量占用的内存。本例中的$s=null也 可以换成unset()，如下：

&lt;?php
    $s=str_repeat('1',256); //这和第二个例子完全相同
    $p=&amp;$s;
    $m=memory_get_usage();
    unset($s); //销毁$s
    unset($p);
    $mm=memory_get_usage();
    echo $p.'&lt;br />';
    echo $m-$mm;
?>
我们将$s和$p都使用unset()销毁，这时再看内存占用量之差也是272，说明这样也可以释放内存。那么，我们可以得到另外一条结论：
结论二、只有当指向该变量的所有变量（如引用变量）都被销毁后，才会释放内存。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>结论一、unset()函数只能在变量值占用内存空间超过256字节时才会释放内存空间。</strong></p>
<p>结论二、只有当指向该变量的所有变量（如引用变量）都被销毁后，才会释放内存。</p>
<h3 id="_12-php7-和-php5-的区别-具体多了哪些新特性" tabindex="-1"><a class="header-anchor" href="#_12-php7-和-php5-的区别-具体多了哪些新特性" aria-hidden="true">#</a> 12.PHP7 和 PHP5 的区别，具体多了哪些新特性？</h3>
<p>性能提升了两倍
结合比较运算符 (&lt;=&gt;)
标量类型声明
返回类型声明
try…catch 增加多条件判断，更多 Error 错误可以进行异常处理
匿名类，现在支持通过new class 来实例化一个匿名类，这可以用来替代一些“用后即焚”的完整类定义
…… 了解更多查看文章底部链接 PHP7 新特性</p>
<h3 id="_13-为什么-php7-比-php5-性能提升了-重点" tabindex="-1"><a class="header-anchor" href="#_13-为什么-php7-比-php5-性能提升了-重点" aria-hidden="true">#</a> 13.为什么 PHP7 比 PHP5 性能提升了？（重点）</h3>
<p>变量存储字节减小，减少内存占用，提升变量操作速度
改善数组结构，数组元素和 hash 映射表被分配在同一块内存里，降低了内存占用、提升了 cpu 缓存命中率
改进了函数的调用机制，通过优化参数传递的环节，减少了一些指令，提高执行效率</p>
<ol>
<li>JIT</li>
<li>Zval的改变（php5所有变量在堆中申请，php7在栈中申请 https://zhidao.baidu.com/question/36918441.html）</li>
<li>内部类型zend_string（php5在引入引用计数后，使用了refcount_gc来记录次数，同时使用is_ref_gc来记录是否是引用类型。php7引入了新的类型IS_REFERENCE来处理这个问题  https://www.cnblogs.com/sjks/p/10961099.html）</li>
<li>PHP数组的变化（HashTable和Zend Array） https://www.xp.cn/b.php/72132.html</li>
<li>函数调用机制（Function Calling Convention）https://blog.csdn.net/hongchangfirst/article/details/8765549</li>
</ol>
<p>通过宏定义和内联函数（inline），让编译器提前完成部分工作。https://blog.csdn.net/lmjy102/article/details/78843271
php的运行模式(fpm/cgi)，GC回收机制（https://blog.csdn.net/qq_36172443/article/details/82291385）
解析地址：https://blog.csdn.net/fish_study_csdn/article/details/80407755</p>
<h3 id="_26-当web访问速度非常慢时怎么解决-从服务器和数据库、sql语句三方面剖析" tabindex="-1"><a class="header-anchor" href="#_26-当web访问速度非常慢时怎么解决-从服务器和数据库、sql语句三方面剖析" aria-hidden="true">#</a> 26.当web访问速度非常慢时怎么解决，从服务器和数据库、SQL语句三方面剖析？</h3>
<p>先打开Mysql慢查询日志，看是否有比较慢的查询语句，有的话先优化掉</p>
<p>然后看数据库常用的字段查询是否加了索引，判断是不是数据库性能瓶颈</p>
<p>如果不是的话，需要分析业务逻辑，看请求中是否有动态和静态文件，有的话把今天文件进行分离</p>
<p>然后如果还是慢的话，这时候要考虑是不是请求太高了，服务器无法承受，如果是这个问题，可以先考虑使用CDN加速，来减轻一部分服务器后端的压力，这时候基本速度就上来了，如果还不行，要考虑增加服务器，使用负载均衡来分流。</p>
<h3 id="_29-您会哪几种主流框架-彼此间对比有哪些区别-在使用该框架之前-是否有测试过该框架的性能" tabindex="-1"><a class="header-anchor" href="#_29-您会哪几种主流框架-彼此间对比有哪些区别-在使用该框架之前-是否有测试过该框架的性能" aria-hidden="true">#</a> 29.您会哪几种主流框架，彼此间对比有哪些区别，在使用该框架之前，是否有测试过该框架的性能？</h3>
<p>整体说起来yii比较好。</p>
<p>Yii</p>
<p>优点：轻量级，缓存好，负载能力强，有很多实现方法很好地避免对php扩展的依赖，执行性能高。基于组件的高性能php框架，用于开发大型Web应用。纯OOP、模型使用方便。开发速度快，运行速度也快。性能优异且功能丰富。</p>
<p>缺点：配置复杂。对Model层的指导和考虑较少、View并不是理想view。理想中的view可能只是html代码，不会涉及PHP代码。英文太多，实例太少。</p>
<p>Laraval</p>
<p>优点：最大的特点是集合了php 比较新的特性，以及各种各样的设计模式、Ioc 容器与依赖注入等</p>
<p>其中，这些设计模式非常适合应用各种开发模式TDD(测试驱动开发), BDD (行为驱动开发)和DDD (领域驱动开发)，composer 是个php 的未来。</p>
<p>缺点：基于组件式的框架，所以比较臃肿。但是Lumen是它的精简版。</p>
<p>ThinkPHP</p>
<p>优点：</p>
<p>1.易于上手，社区火爆有丰富的中文文档；</p>
<p>2.框架的兼容性较强，PHP4和PHP5完全兼容、完全支持UTF8等。</p>
<ol start="3">
<li>适合用于中小项目的开发</li>
</ol>
<p>缺点：</p>
<p>1.对Ajax的支持不是很好；</p>
<p>2.目录结构混乱，需要花时间整理；</p>
<p>3.上手容易，但是深入学习较难。</p>
<p>4.BUG多。跟yii不是一个量级的。yii用配置和组件等方式的效果是，你要什么他就给你什么（重点是你会不会配置，所以难学），tp就是什么都弄好了，看起来什么都好用，实际上层次被别人拉了好几个等级</p>
<p>=====&gt;建议直接拿thinkphp来作为类库。直接从thinkphp里面copy出来常用方法，省的自己网上找了。
————————————————</p>
<h3 id="_30-php查询大量数据循环导致内存过高-你是怎么解决的" tabindex="-1"><a class="header-anchor" href="#_30-php查询大量数据循环导致内存过高-你是怎么解决的" aria-hidden="true">#</a> 30.PHP查询大量数据循环导致内存过高，你是怎么解决的？</h3>
<p>使用php缓冲查询和非缓冲查询，见上面答案</p>
<h3 id="_32-for与foreach哪个更快-为什么" tabindex="-1"><a class="header-anchor" href="#_32-for与foreach哪个更快-为什么" aria-hidden="true">#</a> 32.for与foreach哪个更快，为什么？</h3>
<p>对于for循环来说，每一次都要判断$i 是否到达长度，小于继续，否则终止循环；</p>
<p>对于foreach来说，它依赖于 IEnumerable（迭代器）, 第一次 var a in GetList() 时 调用 GetEnumerator 返回第一个对象 并 赋给a,以后每次再执行 var a in GetList() 的时候 调用 MoveNext.直到循环结束,期间GetList()方法只执行一次.</p>
<p>在固定长度或长度不需要计算的时候for循环效率高于foreach. 在不确定长度,或计算长度有性能损耗的时候,用foreach比较方便.</p>
<p>并且foreach的时候会锁定集合中的对象.期间不能修改.</p>
<ol>
<li>
<p>在固定长度或长度不需要计算的时候for的效率比foreach高</p>
</li>
<li>
<p>在不确定长度或计算长度损耗性能的时候用foreach比较方便</p>
</li>
</ol>
<h3 id="_33-php加速器是针对php执行原理的哪一步进行的加速" tabindex="-1"><a class="header-anchor" href="#_33-php加速器是针对php执行原理的哪一步进行的加速" aria-hidden="true">#</a> 33.PHP加速器是针对PHP执行原理的哪一步进行的加速？</h3>
<p>php的加速器：基于PHP的特殊扩展机制如opcode缓存扩展也可以将opcode缓存于php的共享内存中，从而可以让同一段代码的后续重复执行时跳过编译阶段以提高性能。这些加速器并非真正提高了opcode的运行速度，而仅是通过分析opcode后并将它们重新排列以达到快速执行的目的</p>
<p>Apache中使用mod_php的请求、响应执行流程：</p>
<p>1、Apache接收请求。
　　2、Apache传递请求给mod_php。
　　3、mod_php定位磁盘文件，并加载到内存中。
　　4、mod_php编译源代码成为opcode树。
　　5、mod_php执行opcode树。</p>
<p>PHP加速器相应的就是第四步，它的目的就是防止PHP每次请求都重复编译PHP代码，因为在高访问量的网站上，大量的编译往往没有执行速度快呢？所以这 里面有个瓶颈就是PHP的重复编译既影响了速度又加载了服务器负载，为了解决此问题，PHP加速器就这样诞生了。</p>
<h4 id="常见的php加速器有" tabindex="-1"><a class="header-anchor" href="#常见的php加速器有" aria-hidden="true">#</a> 常见的php加速器有：</h4>
<h5 id="_1、apc-alternative-php-cache" tabindex="-1"><a class="header-anchor" href="#_1、apc-alternative-php-cache" aria-hidden="true">#</a> 1、APC (Alternative PHP Cache)</h5>
<p>遵循PHP License的开源框架，PHP opcode缓存加速器，目前的版本不适用于PHP 5.4项目地址http://pecl.php.net/package/APC</p>
<h5 id="_2、eaccelerator" tabindex="-1"><a class="header-anchor" href="#_2、eaccelerator" aria-hidden="true">#</a> 2、eAccelerator</h5>
<p>源于Turck MMCache，早期的版本包含了一个PHP encoder和PHP loader，目前encoder已经不在支持。项目地址 http://eaccelerator.net/</p>
<h5 id="_3、xcache-本次实验使用的加速器" tabindex="-1"><a class="header-anchor" href="#_3、xcache-本次实验使用的加速器" aria-hidden="true">#</a> 3、XCache（本次实验使用的加速器）</h5>
<p>快速而且稳定的PHP opcode缓存，经过严格测试且被大量用于生产环境。项目地址：http://xcache.lighttpd.net/,收录EPEL源</p>
<h5 id="_4、zend-optimizer和zend-guard-loader" tabindex="-1"><a class="header-anchor" href="#_4、zend-optimizer和zend-guard-loader" aria-hidden="true">#</a> 4、Zend Optimizer和Zend Guard Loader</h5>
<p>Zend Optimizer并非一个opcode加速器，它是由Zend Technologies为PHP5.2及以前的版本提供的一个免费、闭源的PHP扩展，其能够运行由ZendGuard生成的加密的PHP代码或模糊代码。 而Zend Guard Loader则是专为PHP5.3提供的类似于Zend Optimizer功能的扩展。项目地址http://www.zend.com/en/products/guard/runtime-decoders</p>
<h5 id="_5、nusphere-phpexpress" tabindex="-1"><a class="header-anchor" href="#_5、nusphere-phpexpress" aria-hidden="true">#</a> 5、NuSphere PhpExpress</h5>
<p>NuSphere的一款开源PHP加速器，它支持装载通过NuSphere PHP Encoder编码的PHP程序文件，并能够实现对常规PHP文件的执行加速。项目地址，</p>
<h3 id="_34-简述php垃圾的收集机制" tabindex="-1"><a class="header-anchor" href="#_34-简述php垃圾的收集机制" aria-hidden="true">#</a> 34.简述PHP垃圾的收集机制？</h3>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222212213106.png" alt="image-20211222212213106"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222212248919.png" alt="image-20211222212248919"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222212309644.png" alt="image-20211222212309644"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222212323714.png" alt="image-20211222212323714"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222212335381.png" alt="image-20211222212335381"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222212346951.png" alt="image-20211222212346951"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222212401930.png" alt="image-20211222212401930"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222212425000.png" alt="image-20211222212425000"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211222212439442.png" alt="image-20211222212439442"></p>
<h3 id="_35-简述php运行的底层原理" tabindex="-1"><a class="header-anchor" href="#_35-简述php运行的底层原理" aria-hidden="true">#</a> 35.简述PHP运行的底层原理？</h3>
<p>SAPI，即服务器应用编程接口，实质上就是定义了一个统一的接口，它的核心就是一个结构体sapi_module_struct。SAPI提供给了外部应用跟php通信的管道，这个外部应用包括不限于Apache，httpd，liunx终端等，sapi通俗的讲就是php-cgi,php-cli,mod_php等，php就是php内核。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211217163645166.png" alt="image-20211217163645166"></p>
<ul>
<li>什么是CGI</li>
<li>什么是FastCGI</li>
<li>什么是PHP-Fpm</li>
<li>什么是PHP-cgi</li>
<li>Nginx和php-fpm是怎么通信的？</li>
<li>什么是代理和反向代理？</li>
<li>php-fpm支持三种运行模式</li>
<li>如何优化？</li>
</ul>
<p>php-fpm 三种运行方式：
第一种：是pm = static，始终保持一个固定数量的子进程，这个数由pm.max_children定义，这种方式很不灵活，也通常不是默认的。</p>
<p>第二种：是pm = dynamic，他是这样的，启动时，会产生固定数量的子进程（由pm.start_servers控制）可以理解成最小子进程数，而最大子进程数则由pm.max_children去控制，OK，这样的话，子进程数会在最大和最小数范围中变化，还没有完，闲置的子进程数还可以由另2个配置控制，分别是pm.min_spare_servers和pm.max_spare_servers，也就是闲置的子进程也可以有最小和最大的数目，而如果闲置的子进程超出了pm.max_spare_servers，则会被杀掉。</p>
<p>可以看到，pm = dynamic模式非常灵活，也通常是默认的选项。但是，dynamic模式为了最大化地优化服务器响应，会造成更多内存使用，因为这种模式只会杀掉超出最大闲置进程数（pm.max_spare_servers）的闲置进程，比如最大闲置进程数是30，最大进程数是50，然后网站经历了一次访问高峰，此时50个进程全部忙碌，0个闲置进程数，接着过了高峰期，可能没有一个请求，于是会有50个闲置进程，但是此时php-fpm只会杀掉20个子进程，始终剩下30个进程继续作为闲置进程来等待请求，这可能就是为什么过了高峰期后即便请求数大量减少服务器内存使用却也没有大量减少，也可能是为什么有些时候重启下服务器情况就会好很多，因为重启后，php-fpm的子进程数会变成最小闲置进程数，而不是之前的最大闲置进程数。</p>
<p>第三种：就是这篇文章中提到的pm = ondemand模式，这种模式和pm = dynamic相反，把内存放在第一位，他的工作模式很简单，每个闲置进程，在持续闲置了pm.process_idle_timeout秒后就会被杀掉，有了这个模式，到了服务器低峰期内存自然会降下来，如果服务器长时间没有请求，就只会有一个php-fpm主进程，当然弊端是，遇到高峰期或者如果pm.process_idle_timeout的值太短的话，无法避免服务器频繁创建进程的问题，因此pm = dynamic和pm = ondemand谁更适合视实际情况而定。</p>
<h3 id="_38-php-fpm优化方法详解" tabindex="-1"><a class="header-anchor" href="#_38-php-fpm优化方法详解" aria-hidden="true">#</a> 38.php-fpm优化方法详解</h3>
<p>php-fpm优化方法</p>
<p>php-fpm存在两种方式，一种是直接开启指定数量的php-fpm进程，不再增加或者减少；
另一种则是开始时开启一定数量的php-fpm进程，当请求量变大时，动态的增加php-fpm进程数到上限，当空闲时自动释放空闲的进程数到一个下限。
这两种不同的执行方式，可以根据服务器的实际需求来进行调整。</p>
<p>要用到的一些参数，分别是pm、pm.max_children、pm.start_servers、pm.min_spare_servers和pm.max_spare_servers。</p>
<p>pm表示使用那种方式，有两个值可以选择，就是static（静态）或者dynamic（动态）。</p>
<p>下面4个参数的意思分别为：</p>
<p>pm.max_children：静态方式下开启的php-fpm进程数量，在动态方式下他限定php-fpm的最大进程数（这里要注意pm.max_spare_servers的值只能小于等于pm.max_children）
pm.start_servers：动态方式下的起始php-fpm进程数量。
pm.min_spare_servers：动态方式空闲状态下的最小php-fpm进程数量。
pm.max_spare_servers：动态方式空闲状态下的最大php-fpm进程数量。</p>
<p>如果dm设置为static，那么其实只有pm.max_children这个参数生效。系统会开启设置的数量个php-fpm进程。</p>
<p>如果dm设置为dynamic，4个参数都生效。系统会在php-fpm运行开始时启动pm.start_servers个php-fpm进程，然后根据系统的需求动态在pm.min_spare_servers和pm.max_spare_servers之间调整php-fpm进程数。</p>
<p>那么，对于服务器，选择哪种执行方式比较好呢？事实上，跟Apache一样，运行的PHP程序在执行完成后，或多或少会有内存泄露的问题。这也是为什么开始时一个php-fpm进程只占用3M左右内存，运行一段时间后就会上升到20-30M的原因了。（www. 脚本学堂）</p>
<p>所以，动态方式因为会结束掉多余的进程，可以回收释放一些内存，所以推荐在内存较少的服务器或者VPS上使用。具体最大数量根据 内存/20M 得到。
比如说512M的VPS，建议pm.max_spare_servers设置为20（512*0.8/20）。至于pm.min_spare_servers，则建议根据服务器的负载情况来设置，比较合适的值在5~10之间。</p>
<p>然后对于比较大内存的服务器来说，设置为静态的话会提高效率。
因为频繁开关php-fpm进程也会有时滞，所以内存够大的情况下开静态效果会更好。数量也可以根据 内存/30M 得到。
比如说2GB内存的服务器，可以设置为50；4GB内存可以设置为100等。</p>
<p>比如，如果是512M的vps，设置的参数如下：</p>
<p>代码示例:</p>
<p>pm=dynamic
pm.max_children=20
pm.start_servers=5
pm.min_spare_servers=5
pm.max_spare_servers=20</p>
<p>可以最大的节省内存并提高执行效率。</p>
<h3 id="_39-php-是如何保存变量的-什么是引用计数" tabindex="-1"><a class="header-anchor" href="#_39-php-是如何保存变量的-什么是引用计数" aria-hidden="true">#</a> 39.php 是如何保存变量的？什么是引用计数？</h3>
<p>答：每个php变量存在一个叫&quot;zval&quot;的变量容器中。一个zval变量容器，除了包含变量的类型和值，还包括两个字节的额外信息。第一个是&quot;is_ref&quot;，是个bool值，用来标识这个变量是否是属于引用集合(reference set)。通过这个字节，php引擎才能把普通变量和引用变量区分开来，由于php允许用户通过使用&amp;来使用自定义引用，zval变量容器中还有一个内部引用计数机制，来优化内存使用。第二个额外字节是&quot;refcount&quot;，用以表示指向这个zval变量容器的变量(也称符号即symbol)个数。所有的符号存在一个符号表中，其中每个符号都有作用域(scope)，那些主脚本(比如：通过浏览器请求的的脚本)和每个函数或者方法也都有作用域。</p>
<h3 id="_45-php-的运行模式有哪些" tabindex="-1"><a class="header-anchor" href="#_45-php-的运行模式有哪些" aria-hidden="true">#</a> 45.php 的运行模式有哪些？</h3>
<p>答：</p>
<p>1）cgi 通用网关接口（Common Gateway Interface)）
2） fast-cgi 常驻 (long-live) 型的 CGI
3） cli 命令行运行 （Command Line Interface）
4）web模块模式 （apache等web服务器运行的模块模式）</p>
<h3 id="_47-php中serialize和json-encode的性能对比" tabindex="-1"><a class="header-anchor" href="#_47-php中serialize和json-encode的性能对比" aria-hidden="true">#</a> 47.php中serialize和json_encode的性能对比</h3>
<p>serialize和json_encode都是php里面对数据进行序列化的方法，这两个方式到底哪个性能更优呢？什么时候用serialize和json_encode比较合适呢？</p>
<p>最近发现某个项目用了不少的serialize去序列化数据，习惯json_encode的我感觉这里需要更深入了解两者的优势特点。</p>
<p>经过认真学习和操作，现在说是他们的主要区别：</p>
<p>1.serialize后的对象可以被反序列后继续调用其成员方法，即可以$obj-&gt;method();而json_encode后的json_decode后是报错。</p>
<p>2.serialize后的数据长度大比json_encode的长，所以相对来说消耗了存储空间</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>echo strlen(json_encode($_SERVER,JSON_UNESCAPED_UNICODE));
echo '------';
echo strlen(serialize($_SERVER));//4385------4891
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>3.大量数据时serialize执行速度比json_code快很多，简单一个100000的for循环对比，前者耗时0.36秒，后者耗时1.38秒</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>$time = microtime(true);
for ($i=0;$i&lt;100000;$i++){
    $t = json_encode($_SERVER,JSON_UNESCAPED_UNICODE);
}
echo microtime(true)-$time,'&lt;Br>';//1.3815569877625
$time =microtime(true);
for ($i=0;$i&lt;100000;$i++){    
	$t = serialize($_SERVER);
}
echo microtime(true)-$time,'&lt;Br>';//0.36323404312134
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.在数据传输方面用json_encode最好，目前主流还是json活着xml。而serialize少之又少</p>
<p>总结一下：</p>
<p>1.如果需要储存到数据库用json_encode更合适，节省数据库空间</p>
<p>2.作为接口返回用json_encode更加友好</p>
<p>3.处理大量数据又非储存数据库时选用serialize性能更加，如存放在redis中的商品详情、系统配置等</p>
<p>4.为了节省实例化开销的实例化对象可以用serialize，直接反序列化即可自然调用成员</p>
<p>5.有些特殊字符的防止json_encode破坏的数据建议用serialize序列化</p>
<h3 id="_48-php处理上传文件信息数组中的文件类型f-i-l-e-s-t-y-p-e-由-客-户-端-浏-览-器-提-供-有-可-能-是-黑-客-伪-造-的-信-息-请-写-一-个-函-数-来-确-保-用-户-上-传-的-图-像-文-件-类-型-真-实-可-靠" tabindex="-1"><a class="header-anchor" href="#_48-php处理上传文件信息数组中的文件类型f-i-l-e-s-t-y-p-e-由-客-户-端-浏-览-器-提-供-有-可-能-是-黑-客-伪-造-的-信-息-请-写-一-个-函-数-来-确-保-用-户-上-传-的-图-像-文-件-类-型-真-实-可-靠" aria-hidden="true">#</a> 48.PHP处理上传文件信息数组中的文件类型F I L E S [ ‘ t y p e ’ ] 由 客 户 端 浏 览 器 提 供 ， 有 可 能 是 黑 客 伪 造 的 信 息 ， 请 写 一 个 函 数 来 确 保 用 户 上 传 的 图 像 文 件 类 型 真 实 可 靠 ?</h3>
<p>答 ： 用g<strong>e</strong>t<strong>i</strong>m<strong>a</strong>g<strong>e</strong>s<strong>i</strong>z**e()函数来判断上传图片的类型比FILES函数的type更可靠。同一个文件，使用不同的浏览器php返回的type类型是不一样的，由浏览器提供type类型的话，就有可能被黑客利用向服务器提交一个伪装撑图片后缀的可执行文件。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
          $file=$_FILES['file'];
          if(!empty($file))
           {
            var_dump($file);
            var_dump(getimagesize($file["tmp_name"]));
          }  
    ?>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>getimagesize() 函数将测定任何 GIF，JPG，PNG，SWF，SWC，PSD，TIFF，BMP，IFF，JP2，JPX，JB2，JPC，XBM 或 WBMP 图像文件的大小并返回图像的尺寸以及文件类型及图片高度与宽度。</p>
<h6 id="实例1-本地图片文件" tabindex="-1"><a class="header-anchor" href="#实例1-本地图片文件" aria-hidden="true">#</a> 实例1：本地图片文件</h6>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
list($width, $height, $type, $attr) = getimagesize("runoob-logo.png");
echo "宽度为：" . $width;
echo "高度为：" . $height;
echo "类型为：" . $type;
echo "属性：" . $attr;
?>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上实例输出结果为：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>宽度为：290
高度为：69
类型为：3
属性：width="290" height="69"
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h6 id="实例2-远程图片文件" tabindex="-1"><a class="header-anchor" href="#实例2-远程图片文件" aria-hidden="true">#</a> 实例2：远程图片文件</h6>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
$remote_png_url = 'http://www.runoob.com/wp-content/themes/w3cschool.cc/assets/img/logo-domain-green2.png';
$img_data = getimagesize($remote_png_url);
print_r($img_data );
?>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上实例输出结果为：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>Array
(
    [0] => 290
    [1] => 69
    [2] => 3
    [3] => width="290" height="69"
    [bits] => 8
    [mime] => image/png
)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>返回结果说明</p>
<ul>
<li>索引 0 给出的是图像宽度的像素值</li>
<li>索引 1 给出的是图像高度的像素值</li>
<li>索引 2 给出的是图像的类型，返回的是数字，其中1 = GIF，2 = JPG，3 = PNG，4 = SWF，5 = PSD，6 = BMP，7 = TIFF(intel byte order)，8 = TIFF(motorola byte order)，9 = JPC，10 = JP2，11 = JPX，12 = JB2，13 = SWC，14 = IFF，15 = WBMP，16 = XBM</li>
<li>索引 3 给出的是一个宽度和高度的字符串，可以直接用于 HTML 的 <image> 标签</li>
<li>索引 bits 给出的是图像的每种颜色的位数，二进制格式</li>
<li>索引 channels 给出的是图像的通道值，RGB 图像默认是 3</li>
<li>索引 mime 给出的是图像的 MIME 信息，此信息可以用来在 HTTP Content-type 头信息中发送正确的信息，如： header(&quot;Content-type: image/jpeg&quot;);</li>
</ul>
<h3 id="_49-用php代码实现官方var-dump函数" tabindex="-1"><a class="header-anchor" href="#_49-用php代码实现官方var-dump函数" aria-hidden="true">#</a> 49.用PHP代码实现官方var_dump函数</h3>
<p>代码链接：https://github.com/nonfu/php_interviews/blob/master/var_dump.php</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>&lt;?php
class VarDump
{
    private static $isInLoop = false;
    private static $buffer = false;
 
    public static function dump()
    {
        $args = func_get_args();
        $args_num = func_num_args();
        if (self::$buffer &amp;&amp; $args_num == 1) {
            $args = func_get_args();
            $args = isset($args[0]) ? $args[0] : [];
            if (!empty($args) &amp;&amp; (is_array($args) || is_object($args))) {
                $args_num = count($args);
            }
        }
        self::$buffer = false;
        for ($i = 0; $i &lt; $args_num; ++$i) {
            $param = $args[$i];
            $ptype = gettype($param);
            switch ($ptype) {
                case "NULL":
                    self::dump_null();
                    break;
                case "boolean":
                    self::dump_boolean($param);
                    break;
                case "integer":
                    self::dump_integer($param);
                    break;
                case "double":
                    self::dump_double($param);
                    break;
                case "string":
                    self::dump_string($param);
                    break;
                case "array":
                    self::dump_array($param);
                    break;
                case "object":
                    self::dump_object($param);
                    break;
                case "resource":
                    echo "resource";
                    break;
                default:
                    echo "unknown type";
            }
        }
    }
 
    public static function dumpx()
    {
        self::$buffer = true;
        ob_start();
        self::dump(func_get_args());
        $var = ob_get_clean();
        return $var;
    }
 
    public static function dump_null()
    {
        echo "NULL";
        if (!self::$isInLoop) {
            echo "\n";
        }
        self::$isInLoop = false;
    }
 
    public static function dump_boolean($bool)
    {
        if ($bool) {
            echo "bool(true)";
        } else {
            echo "bool(false)";
        }
        if (!self::$isInLoop) {
            echo "\n";
        }
        self::$isInLoop = false;
    }
 
    public static function dump_integer($int)
    {
        echo "int($int)";
        if (!self::$isInLoop) {
            echo "\n";
        }
        self::$isInLoop = false;
    }
 
    public static function dump_double($double)
    {
        echo "float($double)";
        if (!self::$isInLoop) {
            echo "\n";
        }
        self::$isInLoop = false;
    }
 
    public static function dump_string($str)
    {
        $len = strlen($str);
        $value = "string($len) \"$str\"";
        echo $value;
        if (!self::$isInLoop) {
            echo "\n";
        }
        self::$isInLoop = false;
    }
 
    public static function dump_array($arr)
    {
        static $pads = [];
        $keys = array_keys($arr);
        $len = count($arr);
        echo "array($len) {";
        array_push($pads, "    ");
        for ($i = 0; $i &lt; $len; $i++) {
            echo "\n", implode('', $pads), "[\"$keys[$i]\"] => ";
            $index = $keys[$i];
            self::$isInLoop = true;
            self::dump($arr[$index]);
        }
        array_pop($pads);
        $pad = implode('', $pads);
        echo "\n{$pad}}";
        if ($pad == '') {
            echo "\n";
        }
    }
 
    public static function dump_prop($obj)
    {
        static $pads = [];
        $reflect = new ReflectionClass($obj);
        $prop = $reflect->getProperties();
        $len = count($prop);
        echo "($len) {";
        array_push($pads, "    ");
        for ($i = 0; $i &lt; $len; $i++) {
            $index = $i;
            if (!$prop[$index]->isPublic()) {
                continue;
            }
            $prop_name = $prop[$index]->getName();
            echo "\n", implode('', $pads), "[\"{$prop_name}\"] => ";
            self::$isInLoop = true;
            self::dump($prop[$index]->getValue($obj));
        }
        array_pop($pads);
        $pad = implode('', $pads);
        echo "\n{$pad}}";
        if ($pad == '') {
            echo "\n";
        }
    }
 
    public static function dump_object($obj)
    {
        static $objId = 1;
        $className = get_class($obj);
        echo "object($className)#$objId";
        $objId++;
        self::dump_prop($obj);
    }
}
 
 
/* examples */
 
//test string and integer
$string = "I am a string";
$int = 1002;
VarDump::dump($string);
VarDump::dump($int);
 
//test object
class test1
{
    public $var1;
    public static $var2 = 'var2';
    private $var3 = 333;
 
    function test()
    {
        echo "test1 method";
    }
}
class MyClass
{
    public $var4 = 4444;
    protected $var5 = 55555;
    public $test1 = null;
 
    function __construct()
    {
        $this->test1 = new test1();
    }
 
    function test()
    {
        echo "MyClass method";
    }
}
VarDump::dump(new MyClass());
 
//test array
$arrTest = array(
    "name" => "jim",
    "courses" => array(
        "Physics" => "2016-2017",
        "Mathematics" => array(
            "Geometry" => "2017-2018",
            "Algebraic" => "2015-2016",
        )
    ),
    "age" => 20,
    "gender" => 'male',
    "teacher" => array(
        "Physics" => "lucy",
        "Geometry" => "lilei",
        "Algebraic" => "Russell",
    )
);
echo VarDump::dumpx($arrTest);
 
//outputs:
/*
string(13) "I am a string"
int(1002)
object(MyClass)#1(3) {
    ["var4"] => int(4444)
    ["test1"] => object(test1)#2(3) {
        ["var1"] => NULL
        ["var2"] => string(4) "var2"
    }
}
array(5) {
    ["name"] => string(3) "jim"
    ["courses"] => array(2) {
        ["Physics"] => string(9) "2016-2017"
        ["Mathematics"] => array(2) {
            ["Geometry"] => string(9) "2017-2018"
            ["Algebraic"] => string(9) "2015-2016"
        }
    }
    ["age"] => int(20)
    ["gender"] => string(4) "male"
    ["teacher"] => array(3) {
        ["Physics"] => string(4) "lucy"
        ["Geometry"] => string(5) "lilei"
        ["Algebraic"] => string(7) "Russell"
    }
}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_50-require、include、require-once、include-once它们各自的用途是什么-如果某个业务按需加载php文件-你会怎么设计和实现" tabindex="-1"><a class="header-anchor" href="#_50-require、include、require-once、include-once它们各自的用途是什么-如果某个业务按需加载php文件-你会怎么设计和实现" aria-hidden="true">#</a> 50.require、include、require_once、include_once它们各自的用途是什么？如果某个业务按需加载PHP文件，你会怎么设计和实现</h3>
<p>我们把 require、include、require_once、include_once 分成两对，对比着来看：</p>
<p>1、require 和 include 都是用于将另一个php 文件的内容插入到当前 php 文件的引用位置，两者唯一的区别在于对错误的处理上，require 在遇到错误时会产生致命错误（E_COMPILE_ERROR）并退出脚本，而 include 在遇到错误时只发出警告（E_WARNING）并继续执行后续代码，使用哪一个取决于你对引入文件出错的容忍度，如果使用 include 的话即便引入文件不存在也能继续执行后续脚本，所以从稳健性上来讲，require 更好；</p>
<p>2、require_once/include_once 功能和 require/include 也相同，只不过前者会检查引入文件是否已经加载过，如果已经加载过则不再加载，在遇到错误时的处理机制也分别和 require/include 一一对应，由于存在额外的重复加载检查机制，所以 require/include 性能更好。</p>
<p>当然，如果需要引入多个文件，在 PHP 脚本中罗列长长的 require/include 语句显然很不优雅，好在从 PHP5 开始，我们可以通过 spl_autoload_register() 函数定义自动加载器，当代码中遇到未定义的类/接口/函数时，会尝试通过自动加载器去加载，我们通常使用这种机制来实现按需加载。</p>
<p>需要注意的是，require、include、require_once、include_once 和 if、else、for、break、return 一样都是流程控制语句，而不是函数</p>
<h3 id="_55-获取url后缀名" tabindex="-1"><a class="header-anchor" href="#_55-获取url后缀名" aria-hidden="true">#</a> 55.获取URL后缀名</h3>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>pathinfo() 解析文件路径，返回其组成部分；
$path = '/ab/cd/e.php';
print_r( pathinfo($path) );
结果：
Array(
　　[dirname] => /ab/cd  # 文件路径
　　[basename] => e.php  # 文件名+扩展名
　　[extension] => php   # 最后一个扩展名
　　[filename] => e  # 文件名
)
扩展:
打印解析路径 　　 var_dump( pathinfo($path) );
打印路径的父级路径 　　 var_dump( pathinfo($path, PATHINFO_DIRNAME) );
打印路径的尾名 　　 var_dump( pathinfo($path, PATHINFO_BASENAME) );
打印路径的最后的扩展名 　　var_dump( pathinfo($path, PATHINFO_EXTENSION) );
打印路径的文件的名字 　　var_dump( pathinfo($path, PATHINFO_FILENAME) );
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_56-获取上级目录的方法" tabindex="-1"><a class="header-anchor" href="#_56-获取上级目录的方法" aria-hidden="true">#</a> 56.获取上级目录的方法</h3>
<p>echo <strong>FILE</strong> ; // 获取当前所在文件的绝对路径及地址，结果：F:\WWW\index.php</p>
<p>echo dirname(<strong>FILE</strong>); // 取得当前文件所在的绝对目录，结果：F:\WWW</p>
<p>echo dirname(dirname(<strong>FILE</strong>)); //取得当前文件的上一层目录名，结果：F:\</p>
<h3 id="_58-接口与抽象类的区别" tabindex="-1"><a class="header-anchor" href="#_58-接口与抽象类的区别" aria-hidden="true">#</a> 58.接口与抽象类的区别</h3>
<ol>
<li>接口：</li>
</ol>
<p>（1）对接口的使用是通过关键字implements</p>
<p>（2）接口不能定义成员变量（包括类静态变量），能定义常量</p>
<p>（3）子类必须实现接口定义的所有方法</p>
<p>（4）接口只能定义不能实现该方法</p>
<p>（5）接口没有构造函数</p>
<p>（6）接口中的方法和实现它的类默认都是public类型的</p>
<ol start="2">
<li>抽象类：</li>
</ol>
<p>（1）对抽象类的使用是通过关键字extends</p>
<p>（2）不能被实例化，可以定义子类必须实现的方法</p>
<p>（3）子类必须定义父类中的所有抽象方法，这些方法的访问控制必须和父类中一样（或者更为宽松）</p>
<p>（4）如一个类中有一个抽象方法，则该类必须定义为抽象类</p>
<p>（5）抽象类可以有构造函数</p>
<p>（6）抽象类中的方法可以使用private,protected,public来修饰。</p>
<p>（7）一个类可以同时实现多个接口，但一个类只能继承于一个抽象类。</p>
<ol start="3">
<li>Final类/方法：</li>
</ol>
<p>（1）final类不能被继承</p>
<p>（2）final方法不能被重写</p>
<ol start="4">
<li>Static类/方法：</li>
</ol>
<p>(1)可以不实例化类而直接访问</p>
<p>(2)静态属性不可以由对象通过-&gt;操作符来访问,用::方式调用</p>
<h3 id="_59-常见的负载均衡方案" tabindex="-1"><a class="header-anchor" href="#_59-常见的负载均衡方案" aria-hidden="true">#</a> 59.常见的负载均衡方案</h3>
<p>1.基于DNS的负载均衡</p>
<p>2.基于四层交换技术的负载均衡</p>
<p>3.基于七层交换技术的负载均衡</p>
<p>4.四层+七层负载结合方案</p>
<h3 id="_60-opcache有什么作用" tabindex="-1"><a class="header-anchor" href="#_60-opcache有什么作用" aria-hidden="true">#</a> 60.opcache有什么作用？</h3>
<p>opcache可以将php脚本预编译的字节码存放在内存中来避免每次加载和解析php脚本的开销，解析器可以直接从内中读取已缓存的字节码，从而提高php的执行效率</p>
<h3 id="_64-php7有哪些特点-描述下trait的继承优先级-【trait特性】-暂无答案" tabindex="-1"><a class="header-anchor" href="#_64-php7有哪些特点-描述下trait的继承优先级-【trait特性】-暂无答案" aria-hidden="true">#</a> 64.php7有哪些特点？描述下Trait的继承优先级？【Trait特性】（暂无答案）</h3>
<h3 id="_70-设置php错误级别-除通知错误都可以显示" tabindex="-1"><a class="header-anchor" href="#_70-设置php错误级别-除通知错误都可以显示" aria-hidden="true">#</a> 70.设置php错误级别，除通知错误都可以显示</h3>
<p>error_reporting(E_ALL ^ E_NOTICE);</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>在程序开头加一句：
error_reporting(E_ALL &amp; ~E_NOTICE); 或error_reporting(E_ALL ^ E_NOTICE);

或者
修改php.ini
error_reporting = E_ALL &amp; ~E_NOTICE

有关error_reporting()函数：


error_reporting() 设置 PHP 的报错级别并返回当前级别。

; 错误报告是按位的。或者将数字加起来得到想要的错误报告等级。
; E_ALL - 所有的错误和警告
; E_ERROR - 致命性运行时错
; E_WARNING - 运行时警告（非致命性错）
; E_PARSE - 编译时解析错误
; E_NOTICE - 运行时提醒(这些经常是是你的代码的bug引起的，

;也可能是有意的行为造成的。(如：基于未初始化的变量自动初始化为一个
　　　　　　　　　　　　　　;空字符串的事实而使用一个未初始化的变量)

; E_CORE_ERROR - 发生于PHP启动时初始化过程中的致命错误
; E_CORE_WARNING - 发生于PHP启动时初始化过程中的警告(非致命性错)
; E_COMPILE_ERROR - 编译时致命性错
; E_COMPILE_WARNING - 编译时警告(非致命性错)
; E_USER_ERROR - 用户产生的出错消息
; E_USER_WARNING - 用户产生的警告消息
; E_USER_NOTICE - 用户产生的提醒消息

使用方法：

error_reporting(0);//禁用错误报告
error_reporting(E_ALL ^ E_NOTICE);//显示除去 E_NOTICE 之外的所有错误信息
error_reporting(E_ALL^E_WARNING^E_NOTICE);//显示除去E_WARNING E_NOTICE 之外的所有错误信息
error_reporting(E_ERROR | E_WARNING | E_PARSE);//显示运行时错误，与error_reporting(E_ALL ^ E_NOTICE);效果相同。error_reporting(E_ALL);//显示所有错误
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>官网定义了所有的 错误常量，常用的有：</p>
<p>E_STRICT (integer) PHP 对代码的修改建议，以确保代码具有最佳的互操作性和向前兼容性。
E_ALL (integer) E_STRICT外的所有错误和警告信息。
E_ERROR (integer) 致命的运行时错误。这类错误一般是不可恢复的情况，例如内存分配导致的问题。后果是导致脚本终止不再继续运行。
E_WARNING (integer) 运行时警告 (非致命错误)。仅给出提示信息，但是脚本不会终止运行。
E_PARSE (integer) 编译时语法解析错误。解析错误仅仅由分析器产生。
E_NOTICE (integer) 运行时通知。表示脚本遇到可能会表现为错误的情况，但是在可以正常运行的脚本里面也可能会有类似的通知。
在代码中开启并设置显示级别
ini_set() 函数
对于 PHP，可以通过 php.ini 文件设置各种指令。但有时候需要在脚本运行时设置指令，那就需要 ini_set() 函数了。</p>
<p>string ini_set ( string $varname , string $newvalue )</p>
<p>设置指定配置选项的值。这个选项会在脚本运行时保持新的值，并在脚本结束时恢复。</p>
<p>例如：</p>
<p>ini_set('error_reporting', E_ALL);
ini_set('display_errors', 'on');</p>
<p>error_reporting() 函数
error_reporting() 函数能够在运行时设置 error_reporting 指令。 PHP 有诸多错误级别，使用该函数可以设置在脚本运行时的级别。如果没有设置可选参数， error_reporting() 会返回当前的错误报告级别。</p>
<p>PHP7.2 的默认值为 E_ALL &amp; ~E_NOTICE &amp; ~E_STRICT &amp; ~E_DEPRECATED。</p>
<p>在开发阶段建议启用 E_NOTICE 显示更多可能的错误。</p>
<?php

// 关闭所有PHP错误报告，相当于 ini_set('error_reporting', 0);
error_reporting(0);

error_reporting(E_ERROR | E_WARNING | E_PARSE);

// 报告 E_NOTICE  (报告未初始化的变量或捕获变量名的错误拼写)
error_reporting(E_ERROR | E_WARNING | E_PARSE | E_NOTICE);

// 除了 E_NOTICE，报告其他所有错误
error_reporting(E_ALL ^ E_NOTICE);

// 报告所有 PHP 错误 (参见 changelog)
error_reporting(E_ALL);

// 报告所有 PHP 错误
error_reporting(-1);

// 和 error_reporting(E_ALL); 一样
ini_set('error_reporting', E_ALL);

修改 php.ini 配置文件
error_reporting = E_ALL # 报告所有错误
display_errors = On # 显示错误

### 71.安全对一套程序来说至关重要，请说说在开发中应该注意哪些安全机制？



### 72.PHP的 数组底层实现原理

**[php](http://www.cppcns.com/wangluo/php/) 数组具有的特性**

PHP 的数组是一种非常强大灵活的数据类型，在讲它的底层实现之前，先看一下 PHP 的数组都具有哪些特性。

可以使用数字或字符串作为数组健值

```
$arr = [1 => 'ok', 'one' => 'hello'];
```

可按顺序读取数组

```
foreach($arr as $key => $value){echo $arr[$key];}
```

可随机读取数组中的元素

```
$arr = [1 => 'ok', 'one' => 'hello', 'a' => 'world']; echo $arr['one']; echo current($arr);
```

数组的长度是可变的

```
$arr = [1, 2, 3]; $arr[] = 4; array_push($arr, 5);
```

正是基于这些特性，我们可以使用 PHP 中的数组轻易的实现集合、栈、列表、字典等多种数据结构。那么这些特性在底层是如何实现的呢？ 这就得从数据结构说起了。

**数据结构
**

> PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。

PHP 数组的底层实现是散列表（也叫 hashTable )，散列表是根据键（Key）直接访问内存存储位置的数据结构，它的key - value 之间存在一个映射函数，可以根据 key 通过映射函数得到的散列值直接索引到对应的 value 值，无需通过关键字比较，在理想情况下，不考虑散列冲突，散列表的查找效率是非常高的，时间复杂度是 O(1)。

从源码中我们可以看到 zend_array 的结构如下：

```
typedef struct _zend_array zend_array;typedef struct _zend_array hashTable; struct _zend_array {zend_refcounted_h gc;union {struct {ZEND_ENDIAN_LOHI_4(zend_uchar flags,zend_uchar nApplyCount,zend_uchar nIteratorsCount,zend_uchar reserve)} v;uint32_t flags;} u;uint32_t nTableMask; // 哈希值计算掩码，等于nTableSize的负值(nTableMask = -nTableSize)Bucket *arData; // 存储元素数组，指向第一个Bucketuint32_t nNumUsed; // 已用Bucket数（含失效的 Bucket）uint32_t nNumOfElements; // 哈希表有效元素数uint32_t nTableSize; // 哈希表总大小，为2的n次方（包括无效的元素）uint32_t nInternalPointer; // 内部指针，用于遍历zend_long nNextFreeElement; // 下一个可用的数值索引,如:arr[] = 1;arr["a"] = 2;arr[] = 3; 则nNextFreeElement = 2;dtor_func_t pDestructor;};
```

该结构中的 Bucket 即储存元素的数组，arData 指向数组的起始位置，使用映射函数对 key 值进行映射后可以得到偏移值，通过内存起始位置 + 偏移值即可在散列表中进行寻址操作。

Bucket 的数据结构如下：

```
typedef struct _Bucket {zval val; // 存储的具体 value，这里是一个 zval，而不是一个指针zend_ulong h; // 数字 key 或字符串 key 的哈希值。用于查找时 key 的比较zend_string *key; // 当 key 值为字符串时，指向该字符串对应的 zend_string（使用数字索引时该值为 NULL），用于查找时 key 的比较} Bucket;
```

到这里有个问题出现了：存储在散列表里的元素是无序的，PHP 数组如何做到按顺序读取的呢？

答案是中间映射表，为了实现散列表的有序性，PHP 为其增加了一张中间映射表，该表是一个大小与 Bucket 相同的数组，数组中储存整形数据，用于保存元素实际储存的 Value 在 Bucekt 中的下标。Bucekt 中的数据是有序的，而中间映射表中的数据是无序的。

![img](http://img.cppcns.com/pic.php?url=/file_images/article/201908/2019825111144050.jpg?2019725111219)

而通过映射函数映射后的散列值要在中间映射表的区间内，这就对映射函数提出了要求。

**映射函数**

PHP7 数组采用的映射方式：

```
nIndex = h | ht->nTableMask;
```

将 key 经过 time33 算法生成的哈希值 h 和 nTableMask 进行或运算即可得出映射表的下标，其中 nTableMask 数值为 nTableSize 的负数。并且由于 nTableSize 的值为 2 的幂次方，所以 nTableMask 二进制位右侧全部为 0，保证了 h | ht->nTableMask 的取值范围会在 [-nTableSize, -1] 之间，正好在映射表的下标范围内。另外，用按位或运算的方法和其他方法如取余的方法相比运算速度较高，这个映射函数可以说设计的非常巧妙了。

**散列（哈希）冲突**

不同键名的通过映射函数计算得到的散列值有可能相同，此时便发生了散列冲突。

对于散列冲突有以下 4 种常用方法：

1.将散列值放到相邻的最近地址里

2.换个散列函数重新计算散列值

3.将冲突的散列值统一放到另一个地方

4.在冲突位置构造一个单向链表，将散列值相同的元素放到相同槽位对应的链表中。这个方法叫链地址法，PHP 数组就是采用这个方法解决散列冲突的问题。

其具体实现是：将冲突的 Bucket 串成链表，这样中间映射表映射出的就不是某一个元素，而是一个 Bucket 链表，通过散列函数定位到对应的 Bucket 链表时，需要遍历链表，逐个对比 Key 值，继而找到目标元素。而每个 Bucket 之间的链接则是将原 value 的下标保存到新 value 的 zval.u2.next 里，新 value 放在当前位置上，从而形成一个单向链表。

举个例子：

当我们访问 $arr['key'] 的过程中，假设首先通过散列运算得出映射表下标为 -2 ，然后访问映射表发现其内容指向 arData 数组下标为 1 的元素。此时我们将该元素的 key 和要访问的键名相比较，发现两者并不相等，则该元素并非我们所想访问的元素，而元素的 zval.u2.next 保存的值正是另一个具有相同散列值的元素对应 arData 数组的下标，所以我们可以不断通过 zval.u2.next 的值遍历直到找到键名相同的元素。

**扩容**

PHP 的数组在底层实现了自动扩容机制，当插入一个元素且没有空闲空间时，就会触发自动扩容机制，扩容后再执行插入。

扩容的过程为：

如果已删除元素所占比例达到阈值，则会移除已被逻辑删除的 Bucket，然后将后面的 Bucket 向前补上空缺的 Bucket，因为 Bucket 的下标发生了变动，所以还需要更改每个元素在中间映射表中储存的实际下标值。

如果未达到阈值，PHP 则会申请一个大小是原数组两倍的新数组，并将旧数组中的数据复制到新数组中，因为数组长度发生了改变，所以 key-value 的映射关系需要重新计算，这个步骤为重建索引。

**重建散列表**

在删除某一个数组元素时，会先使用标志位对该元素进行逻辑删除，即在删除 value 时只是将 value 的 type 设置为 IS_UNDEF，而不会立即删除该元素所在的 Bucket，因为如果每次删除元素立刻删除 Bucket 的话，每次都需要进行排列操作，会造成不必要的性能开销。

所以，当删除元素达到一定数量或扩容后都需要重建散列表，即移除被标记为删除的 value。因为 value 在 Bucket 位置移动了或哈希数组 nTableSize 变化了导致 key 与 value 的映射关系改变，重建过程就是遍历 Bucket 数组中的 value，然后重新计算映射值更新到散列表。

### 73.PHP的变量底层实现原理

```
变量结构
首先，我们还是先摆上我们的zval结构体，即php所有变量都会以zval结构体的形式实现

struct _zval_struct {
	union {
		long lval;
		double dval;
		struct {
			char *val;
			int len;
		} str;
		HashTable *ht;
		zend_object_value obj;
	} value;					//变量value值
	zend_uint refcount__gc;   //引用计数内存中使用次数，为0删除该变量
	zend_uchar type;		   //变量类型
	zend_uchar is_ref__gc;    //区分是否是引用变量，是引用为1，否则为0
};
复制代码
从上面结构体内容可以看出每一个php变量都会由变量类型、value值、引用计数次数和是否是引用变量四部分组成

注：上面zval结构体是php5.3版本之后，php7版本之前的结构

变量类型
看到这里，可能会有小伙伴们问我，php不是有8种数据类型吗？但是为什么对应的zvalue的value值只有5种？

原因是这样的，php出于对内存节省的考虑，所以对于一些变量类型做了复用，并没有一一对应去定义每个变量类型

下面我们看一下zvalue的每个value值所对应的变量类型

zval.value.lval => 整型、布尔型、资源
zval.value.dval => 浮点型
zval.value.str  => 字符串
zval.value.*ht  => 数组
zval.value.obj  => 对象
复制代码
看到这里大家可能会比较奇怪，布尔型和资源是怎么对应到zval.value的lval上的呢？还有，NULL呢？

布尔型
就像我们会将true和false映射成0和1进行数据库存储一样，php也是这么做的。所以php发现zval的type值是布尔型时，会将布尔型转成0或1存储在zval.value的lval中

资源
资源对于php来说属于一个比较特殊的变量，而php会将每个资源对应的资源标识存储在zval.value的lval中。常见的资源有：文件句柄、数据库句柄等

NULL
对于NULL来说，就更好理解了，因为本身通过zval的type值即可区分，所以并没有将NULL值存储在zval的value中

变量生成
php作为一门动态语言，没有先声明变量后赋值的习惯，所以都是拿来一个变量直接就进行了赋值，那么是如何实现的呢？

举例：

$name = "许铮的技术成长之路";
复制代码
变量容器生成
其实每次变量被常量赋值时，都会对应生成一个变量容器。刚才的例子会生成一个变量容器，容器的type是字符串类型，而value值则是许铮的技术成长之路，且此时该变量容器的ref_count会加1

变量名和变量容器关联
而变量name是如何与变量容器关联起来的呢？其实也是使用了php的一个内部机制，即哈希表。每个变量的变量名和指向zval结构的指针被存储在哈希表内，以此实现了变量名到变量容器的映射

变量作用域
上面我们提到了变量名和变量容器映射的概念。对于php来说，变量有全局变量和局部变量之分；那么，他们都是存储到一个哈希表内了么？

其实不是的，变量存储也有作用域的概念。全局变量被存储到了全局符号表内，而局部变量也就是指函数或对象内的变量，则被存储到了活动符号表内（每个函数或对象都单独维护了自己的活动符号表。活动符号表的生命周期，从函数或对象被调用时开始，到调用完成时结束）

变量销毁
变量销毁，分为以下几种情况：
1、手动销毁
2、垃圾回收机制销毁（引用计数清0销毁和根缓冲区满后销毁）

我们这次主要讲一下手动销毁，即unset，每次销毁时都会将符号表内的变量名和对应的zval结构进行销毁，并将对应的内存归还到php所维护的内存池内（按内存大小划分到对应内存列表中）
```



```
PHP是一门弱类型语言，本身不严格区分变量的类型。PHP在变量申明的时候不需要指定类型。PHP在程序运行期间可能进行变量类型的隐示转换。 和其他强类型语言一样，程序中也可以进行显示的类型转换。


PHP变量可以分为简单类型(int、string、bool)、集合类型(array resource object)和常量(const)。以上所有的变量在底层都是同一种结构 zval。用debug_zval_dump打印查看类型。

debug_zval_dump($name); 
//输出：long(30) refcount(2) 

传值和引用赋值

$name = 'stark';
$age = 30;
1
2
用一个变量$name指定赋值，在内存中分配一块内存，指针指向内存地址。


图①两个变量同时内存中的同一块地址，有时你会看见$name_bak = &$name,这种的操作叫引用赋值，传递的变量的地址，实际操作上用的不多，这个用不好很容易出错。

Zval主要由三部分组成：
type：指定了变量所述的类型（整数、字符串、数组等）
refcount&is_ref：用来实现引用计数(后面具体介绍)
value：核心部分，存储了变量的实际数据
Zvalue是用来保存一个变量的实际数据。因为要存储多种类型，所以zvalue是一个union，也由此实现了弱类型。

变量（zval）需要注意的知识点：
引用计数在内存回收、字符串操作等地方使用非常广泛。 PHP中的变量就是引用计数的典型应用。Zval的引用计数通过成员变量is_ref和ref_count实现，通过引用计数，多个变量可以共享同一份数据。避免频繁拷贝带来的大量消耗。在进行赋值操作时，zend将变量指向相同的zval同时ref_count++，在unset操作时，对应的ref_count-1。只有ref_count减为0时才会真正执行销毁操作。如果是引用赋值，则zend会修改is_ref为1。

PHP变量通过引用计数实现变量共享数据，那如果改变其中一个变量值呢？当试图写入一个变量时，Zend若发现该变量指向的zval被多个变量共 享，则为其复制一份ref_count为1的zval，并递减原zval的refcount，这个过程称为“zval分离”。可见，只有在有写操作发生时 zend才进行拷贝操作，因此也叫copy-on-write(写时拷贝)对于引用型变量，其要求和非引用型相反，引用赋值的变量间必须是捆绑的，修改一个变量就修改了所有捆绑变量。整数、浮点数是PHP中的基础类型之一，也是一个简单型变量。对于整数和浮点数，在zvalue中直接存储对应的值。其类型分别是long和double。

从zvalue结构中可以看出，对于整数类型，和c等强类型语言不同， PHP是不区分int、unsigned int、long、long long等类型的，对它来说，整数只有一种类型也就是long。由此，可以看出，在PHP里面，整数的取值范围是由编译器位数来决定而不是固定不变的。

对于浮点数，类似整数，它也不区分float和double而是统一只有double一种类型。在PHP中，如果整数范围越界了怎么办？这种情况下会自动转换为double类型，这个一定要小心，很多trick都是由此产生。

和整数一样，字符变量也是PHP中的基础类型和简单型变量。通过zvalue结构可以看出，在PHP中，字符串是由由指向实际数据的指针和长度结 构体组成，这点和c++中的string比较类似。由于通过一个实际变量表示长度，和c不同，它的字符串可以是2进制数据（包含\0），同时在PHP中， 求字符串长度strlen是O(1)操作。在新增、修改、追加字符串操作时，PHP都会重新分配内存生成新的字符串。最后，出于安全考虑，PHP在生成一个字符串时末尾仍然会添加。

PHP的数组通过Zend HashTable来天然实现。foreach操作如何实现？对一个数组的foreach就是通过遍历hashtable中的双向链表完成。对于索引数组，通过foreach遍 历效率比for高很多，省去了key->value的查找。count操作直接调用 HashTable->NumOfElements，O(1)操作。对于’123’这样的字符串，zend会转换为其整数形 式。a r r [ ‘ 123 ’ ] 和 arr[‘123’]和arr[‘123’]和arr[123]是等价的。

资源类型变量是PHP中最复杂的一种变量，也是一种复合型结构。 PHP的zval可以表示广泛的数据类型，但是对于自定义的数据类型却很难充分描述。由于没有有效的方式描绘这些复合结构，因此也没有办法对它们使用传统的操作符。要解决这个问题，只需要通过一个本质上任意的标识符（label）引用指针，这种方式被称为资源。

在zval中，对于resource，lval作为指针来使用，直接指向资源所在的地址。Resource可以是任意的复合结构，我们熟悉的mysqli、fsock、memcached等都是资源。

资源(Resource)/数组(Array)
资源 resource 是一种特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。引用计数系统是 Zend 引擎的一部分，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。因此，很少需要手工释放内存。

Note: 持久数据库连接比较特殊，它们不会被垃圾回收系统销毁。
1
PHP 中的数组实际上是一个有序映射。映射是一种把 values 关联到 keys 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。

使用资源发生了什么？

注册：对于一个自定义的数据类型，要想将它作为资源。首先需要进行注册，zend会为它分配全局唯一标示。

获取一个资源变量：对于资源，zend维护了一个id->实际数据的hash_tale。对于一个resource，在zval中只记录了它的id。fetch的时候通过id在hash_table中找到具体的值返回。

资源销毁：资源的数据类型是多种多样的。Zend本身没有办法销毁它。因此需要用户在注册资源的时候提供销毁函数。当unset资源时，zend调用相应的函数完成析构。同时从全局资源表中删除它。

资源可以长期驻留，不只是在所有引用它的变量超出作用域之后，甚至是在一个请求结束了并且新的请求产生之后。这些资源称为持久资源，因为它们贯通 SAPI的整个生命周期持续存在，除非特意销毁。很多情况下，持久化资源可以在一定程度上提高性能。比如我们常见的mysql_pconnect ,持久化资源通过pemalloc分配内存，这样在请求结束的时候不会释放。 对zend来说，对两者本身并不区分。

HashTable，一个经典又不好理解的数据结构，HashTable的数据结构PHP编程快速便捷的灵魂所在。

HashTable
php数组中的应用和redis里的有序集合有点相似，都多处用到了双向链表和散列。在hash table中既有key->value形式的散列结构，也有双向链表模式，使得它能够非常方便的支持快速查找和线性遍历。

1、散列结构：Zend的散列结构是典型的hash表模型，通过链表的方式来解决冲突。需要注意的是zend的hash table是一个自增长的数据结构，当hash表数目满了之后，其本身会动态以2倍的方式扩容并重新元素位置。初始大小均为8。另外，在进行 key->value快速查找时候，zend本身还做了一些优化，通过空间换时间的方式加快速度。比如在每个元素中都会用一个变量 nKeyLength标识key的长度以作快速判定。

2、双向链表：Zend hash table通过一个链表结构，实现了元素的线性遍历。理论上，做遍历使用单向链表就够了，之所以使用双向链表，主要目的是为了快速删除，避免遍历。 Zend hash table是一种复合型的结构，作为数组使用时，即支持常见的关联数组也能够作为顺序索引数字来使用，甚至允许2者的混合。PHP关联数组：关联数组是典型的hash_table应用。一次查询过程经过如下几步（从代码可以看出，这是一个常见的hash查询过程并增加一些快速判定加速查找。）：

getKeyHashValue h;
index = n & nTableMask;
Bucket *p = arBucket[index];
while (p) {
       if ((p->h == h) && (p->nKeyLength == nKeyLength)) {
              RETURN p->data;   
        }
        p=p->next;
}
RETURN FALTURE;
————————————————
版权声明：本文为CSDN博主「stark张宇」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xuezhiwu001/article/details/100108438
```









### 82.判断一个数是否为2的整数次幂

```
2到2的十幂次方
分别为：
1，2，4，8，16，32，64，128，256，512，1024
它们对应的二进制分别为
1
10
100
1000
10000
100000
1000000
10000000
100000000
1000000000
10000000000

十进制转换二进制
计算
520
如
520=512+8
即
1000000000+1000=1000001000

二进制转换十进制
计算
100100100
如：
100100100= 100000000 +100000 +100
即：256+32+4=292
```

```
function handle($num){
	$binnum = decbin($num);
	$len = strlen($binnum);
	for($i=1;$i<$len;$i++){
		if($binnum[$i] > 0){
			return false;
		}
	}

	return true;
}
$a = handle(1024);
if($a){
	echo "是";
}else{
	echo "不是";
}
```





### 84.两数组直接相加，array_merge 与直接相加的区别

首先是以数字为索引的数组， array_merge会将两个数组按照先后顺序组成一个新的数组

```
$array1 = array("a", "b", "c");
$array2 = array("d", "e", "f");

// 输出Array ( [0] => a [1] => b [2] => c [3] => d [4] => e [5] => f )
var_dump(array_merge($array1, $array2));
// 输出Array ( [0] => d [1] => e [2] => f [3] => a [4] => b [5] => c )
var_dump(array_merge($array2, $array1));
```

但是如果两个数字索引的数组直接相加的话，两个数组并不会完全保留，而是保存前者

```
$array1 = array("a", "b", "c");
$array2 = array("d", "e", "f");

// 输出Array ( [0] => a [1] => b [2] => c ) 
print_r($array1 + $array2);
```

那么当两个相加的数组大小不一致呢？

```
$array1 = array("a", "b", "c");
$array2 = array("d", "e", "f");
$array3 = array("g", "h");

// 输出Array ( [0] => d [1] => e [2] => f ) 
print_r($array2 + $array3);
// 输出Array ( [0] => g [1] => h [2] => f )
print_r($array3 + $array2);

```



### 84.合并两个数组有几种方式，试比较它们的异同

答：1、array_merge()
2、’+’
3、array_merge_recursive

array_merge 简单的合并数组
array_merge_recursive 合并两个数组，如果数组中有完全一样的数据，将它们递归合并
array_combine 和 ‘+’ ：合并两个数组，前者的值作为新数组的键

### 85.PHP计算最大公约数

```
//求最大公约数
function max_divisor($a,$b)
{
   $n = min($a, $b);
   for($i=$n; $i>1; $i--)
   {
     if (is_int($a/$i)&&is_int($b/$i))
     {
     return $i;  //此处如果用echo $i;则输出结果为432；故应区分echo、return的区别
     }
   }
   return 1;
}
//求最小公倍数
function  min_multiple($a, $b)
{  
   if($b==0)   //一定要考虑除数不能为零
   {
     return $b;
   }else{
       $m = max($a, $b);
       $n = min($a, $b);
       for($i=2; ; $i++){
             if (is_int($m*$i/$n)){
               return $i;
             }
   	   }
	}
    return $a*$b;
}
//辗转相除法求最大公约数
 function max_divisor2($a, $b){
   if($b==0){
     return $a;
   }else{
     return max_divisor2($b,($a%$b));
   }
}
//加减法求最大公约数
function max_divisor3($a, $b){
   if ($a == $b){
     return $a;
   }elseif($a > $b){
     $a = $a-$b;
   }else{
     $b = $b-$a;
   }
   return max_divisor3($a, $b);
}


```



### 86.PHP的性能优化

什么情况之下，会遇到PHP性能问题？

1：PHP语法使用不恰当。

2：使用PHP语言做了它不擅长的事情。

3：使用PHP语言连接的服务不给力。

4：PHP自身的短板（PHP自身做不了的事情）。

5：我们也不知道的问题？（去探索、分析找到解决办法，提升开发境界）。

![img](https://images2017.cnblogs.com/blog/676372/201801/676372-20180118164523724-1279263576.png)

对线上站点做压力测试的时候，我们一定要将请求数和并发数，特别是并发数要设置的比较低，我们不能对线上的网站造成压力问题，不管是自己的还是别人的。

PHP性能问题一般不会超过占整个项目性能的50%，一般在30%~40%。

PHP性能问题的解决方向，三个层级

1：PHP语言级的性能优化，指的是PHP语法基本功能，这部分优化比较简单易见、快速可行，比较快速看到效果。

 a:少写PHP的代码，多用PHP自身能力解决问题。

性能问题

自写代码冗余较多，可读性不佳，并且性能低，如代码很长很长...PHP代码越长PHP的执行效率越慢。

   为什么性能低？

PHP代码需要解析编译为C语言，底层C语言又要编译成汇编语言机器语言才能执行，这个过程在每次请求过来之后都要处理一遍，所以开销很大（项目变大的话...）。

   解决方法：

多使用PHP内置的变量、常量、函数。我们用PHP代码实现的功能和使用PHP内置的函数实现的同样功能差别是有的。

 b:PHP内置函数的性能优劣。

   情况描述

PHP内置函数之间依然存在快慢差别；少用PHP魔术方法；

   建议：

多去了解PHP内置函数的执行实现复杂度。

   测试方法：比较效率测试，如用microtime()函数，取差值，精确到毫秒级别；Linux的time命令可以查看开销。

 c:产生额外开销的错误抑制符号“@”，最好别用（不管是性能优化和项目的健壮性等方面）。

   @的逻辑是在代码前和代码结束后增加了Opcode，Opcode的作用就是忽略报错，其实就是相当于增加了error_reporting设置，等级报错为忽略（vld扩展可以查看被隐藏的Opcode）；

 d：合理使用内存。

   情况描述：

   PHP有内存回收机制保底，但是也小心使用内存；

建议：

  利用unset()及时释放不使用的内存，比如一些数据库多余字段（注意：unset()有时会出现注销不掉的情况） 

 e：尽量少用正则表达式。

情况描述：

正则表达式的开销大，使用起来简单，但是性能低因为，正则表达式需要回溯；正则表达式越长，回溯的开销越大，优化正则表达式是需要技术水平的，正则技术不达标，不要乱用正则。

 f：避免在循环内做运算。

情况描述：

循环内的计算式将被重复计算（我们在for循环或者while循环，会有重复计算，影响性能问题）。

举例：

错误用法：

```
$str = "hello world";
for($i = 0; $i < strlen($str); $i ++){ ...}
```

正确用法：

```
$str = "hello world";
$strlen = strlen($str);
for($i = 0; $i < $strlen; $i++){...}
```

 g:减少计算密集型业务

情况描述：

PHP不适合密集型（大数据量）运算的场景。

   为什么？

PHP的语言特性决定PHP不适合做大数据量运算，PHP语言由C写的，PHP处于C基础之上，PHP的所有运算处理流程需要转化为C语言，PHP和C想比性能肯定输了，并且

PHP语言还有一些环境问题、语言特性，相比于C而言的开销要大很多的。PHP一段很长的代码，可能C很短就实现了...

PHP适合场景：

适合衔接WebServer与后端服务，WebServer来了请求交给PHP，PHP做一些校验、一些初始化数据处理，将请求转发交给后端，等待后台响应，后端可能是缓存、DB等其他业务，

后端响应之后，PHP再作为纽带，将信息传递给WebServer，这是PHP擅长的。PHP也擅长做UI呈现，也就是配合模板引擎做模板输出，其实就是一些字符串文本处理。

 h：务必使用带引号字符串做键值（数组的Key字段）。

情况描述

PHP会将没有使用引号的键值当做常量，产生查找常量的开销，如果查找到了常量有这个字符串，那么就把常量作为这个值了。

  建议：

严格使用引号作为键值，单引号即可。

2：PHP周边的性能优化：（PHP前面有WebServer，后面有数据库）

3：PHP语言自身的分析、优化（底层C级别的优化）

 

补充：

##### 1:尽量静态化：

  如果一个方法能被静态，那就声明它为静态的，速度可提高1/4，甚至我测试的时候，这个提高了近三倍。
  当然了，这个测试方法需要在十万级以上次执行，效果才明显。
  其实静态方法和非静态方法的效率主要区别在内存：静态方法在程序开始时生成内存,实例方法在程序运行中生成内存，所以静态方法可以直接调用,实例方法要先成生实例,通过实例调用方法，静态速度很快，但是多了会占内存。
 任何语言都是对内存和磁盘的操作,至于是否面向对象,只是软件层的问题,底层都是一样的,只是实现方法不同。静态内存是连续的,因为是在程序开始时就生成了,而实例申请的是离散的空间,所以当然没有静态方法快。
  静态方法始终调用同一块内存，其缺点就是不能自动进行销毁，而是实例化可以销毁。

##### 2.销毁变量去释放内存，特别是大的数组;

 数组和对象在php特别占内存的，这个由于php的底层的zend引擎引起的，
 一般来说，PHP数组的内存利用率只有 1/10, 也就是说，一个在C语言里面100M 内存的数组，在PHP里面就要1G。
 特别是在PHP作为后台服务器的系统中，经常会出现内存耗费太大的问题。

 

以下是我在其他博文收集的

1、如果能将类的方法定义成static，就尽量定义成static，它的速度会提升将近4倍。
2、$row[’id’] 的速度是$row[id]的7倍。
3、注销那些不用的变量尤其是大数组，以便释放内存。
4、尽量避免使用__get，__set，__autoload。
5、require_once()代价昂贵。
6、include文件时尽量使用绝对路径，因为它避免了PHP去include_path里查找文件的速度，解析操作系统路径所需的时间会更少。
7、如果你想知道脚本开始执行(译注：即服务器端收到客户端请求)的时刻，使用$_SERVER[‘REQUEST_TIME’]要好于time()
8、函数代替正则表达式完成相同功能。
9、str_replace函数比preg_replace函数快，但strtr函数的效率是str_replace函数的四倍。
10、如果一个字符串替换函数，可接受数组或字符作为参数，并且参数长度不太长，那么可以考虑额外写一段替换代码，使得每次传递参数是一个字符，而不是只写一行代码接受数组作为查询和替换的参数。
11、使用选择分支语句(译注：即switch case)好于使用多个if，else if语句。
12、用@屏蔽错误消息的做法非常低效，极其低效。
13、打开apache的mod_deflate模块，可以提高网页的浏览速度。
14、数据库连接当使用完毕时应关掉，不要用长连接。
15、在方法中递增局部变量，速度是最快的。几乎与在函数中调用局部变量的速度相当。递增一个全局变量要比递增一个局部变量慢2倍。递增一个对象属性(如：$this->prop++)要比递增一个局部变量慢3倍。递增一个未预定义的局部变量要比递增一个预定义的局部变量慢9至10倍。
16、仅定义一个局部变量而没在函数中调用它，同样会减慢速度(其程度相当于递增一个局部变量)。PHP大概会检查看是否存在全局变量。
17、方法调用看来与类中定义的方法的数量无关，因为我(在测试方法之前和之后都)添加了10个方法，但性能上没有变化。
18、派生类中的方法运行起来要快于在基类中定义的同样的方法。
19、调用带有一个参数的空函数，其花费的时间相当于执行7至8次的局部变量递增操作。类似的方法调用所花费的时间接近于15次的局部变量递增操作。
20、Apache解析一个PHP脚本的时间要比解析一个静态HTML页面慢2至10倍。尽量多用静态HTML页面，少用脚本。
21、除非脚本可以缓存，否则每次调用时都会重新编译一次。引入一套PHP缓存机制通常可以提升25%至100%的性能，以免除编译开销。
22、尽量做缓存，可使用memcached。memcached是一款高性能的内存对象缓存系统，可用来加速动态Web应用程序，减轻数据库负载。对运算码 (OP code)的缓存很有用，使得脚本不必为每个请求做重新编译。
23、当操作字符串并需要检验其长度是否满足某种要求时，你想当然地会使用strlen()函数。此函数执行起来相当快，因为它不做任何计算，只返回在zval 结构(C的内置数据结构，用于存储PHP变量)中存储的已知字符串长度。但是，由于strlen()是函数，多多少少会有些慢，因为函数调用会经过诸多步骤，如字母小写化(译注：指函数名小写化，PHP不区分函数名大小写)、哈希查找，会跟随被调用的函数一起执行。在某些情况下，你可以使用isset() 技巧加速执行你的代码。
24、当执行变量$i的递增或递减时，$i++会比++$i慢一些。这种差异是PHP特有的，并不适用于其他语言，所以请不要修改你的C或Java代码并指望它们能立即变快，没用的。++$i更快是因为它只需要3条指令(opcodes)，$i++则需要4条指令。后置递增实际上会产生一个临时变量，这个临时变量随后被递增。而前置递增直接在原值上递增。这是最优化处理的一种，正如Zend的PHP优化器所作的那样。牢记这个优化处理不失为一个好主意，因为并不是所有的指令优化器都会做同样的优化处理，并且存在大量没有装配指令优化器的互联网服务提供商(ISPs)和服务器。
25、并不是事必面向对象(OOP)，面向对象往往开销很大，每个方法和对象调用都会消耗很多内存。
26、并非要用类实现所有的数据结构，数组也很有用。
27、尽量采用大量的PHP内置函数。
28、如果在代码中存在大量耗时的函数，你可以考虑用C扩展的方式实现它们。
29、评估检验(profile)你的代码。检验器会告诉你，代码的哪些部分消耗了多少时间。Xdebug调试器包含了检验程序，评估检验总体上可以显示出代码的瓶颈。
30、mod_zip可作为Apache模块，用来即时压缩你的数据，并可让数据传输量降低80%。
31、在可以用file_get_contents替代file、fopen、feof、fgets等系列方法的情况下，尽量用file_get_contents，因为他的效率高得多!但是要注意file_get_contents在打开一个URL文件时候的PHP版本问题;
32、尽量的少进行文件操作，虽然PHP的文件操作效率也不低的;
33、优化Select SQL语句，在可能的情况下尽量少的进行Insert、Update操作(在update上，我被恶批过);
34、循环内部不要声明变量，尤其是大变量：对象(这好像不只是PHP里面要注意的问题吧?);
35、多维数组尽量不要循环嵌套赋值;
36、在可以用PHP内部字符串操作函数的情况下，不要用正则表达式;
37、foreach效率更高，尽量用foreach代替while和for循环;
38、用单引号替代双引号引用字符串;
39、“用i+=1代替i=i+1。符合c/c++的习惯，效率还高”;
40、对global变量，应该用完就unset()掉;

### 88.压测工具使用与具体使用参数含义（ab压测）

**ab 的用法是：**ab [options] [http://]hostname[:port]/path

例如：ab -n 5000 -c 200 http://localhost/index.php

上例表示总共访问http://localhost/index.php这个脚本5000次，200并发同时执行。

**ab常用参数的介绍：**

-n ：总共的请求执行数，缺省是1；

-c： 并发数，缺省是1；

-t：测试所进行的总时间，秒为单位，缺省50000s

-p：POST时的数据文件

-w: 以HTML表的格式输出结果

**执行测试用例：ab -n 1000 -c 100 -w http://localhost/index.php >>d:miss.html**

上面的测试用例表示100并发的情况下，共测试访问index.php脚本1000次，并将测试结果保存到**d:miss.html**文件中。

### 90.TCP长连接与短连接的区别，各自的优点与缺点，以及其使用场景

 TCP在真正的读写操作之前，服务端与客户端之间必须建立一个连接，当读写操作完成后，双方不再需要这个连接时它们可以释放这个连接，连接的建立通过三次握手，释放则需要四次挥手，所以说每个连接的建立都是需要资源消耗和时间消耗的。

 

长连接的操作步骤是：

建立连接->数据传输…（保持连接）…数据传输->关闭连接。

短连接的步骤是：

建立连接->数据传输->关闭连接…建立连接->数据传输->关闭连接。

长连接和短链接各自的优缺点：

1、长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间，但是一直连接对于客户端来说比较耗电。
2、对于频繁请求资源的客户来说，较适用长连接。
3、客户端与服务端之间的连接如果一直不关闭的话，会存在一个问题，
4、随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致服务端服务受损；
5、如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某些的客户端连累后端服务。
6、短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。
7、一次TCP连接和断开需要7个来回，如果客户端请求频繁，将在TCP的建立和关闭操作上浪费大量时间和带宽。


TCP长/短连接的应用场景
1、长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况。每个TCP连接都需要三次握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，再次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接，如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。

2、而像WEB网站的http服务一般都用短连接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连接好。

### 91.请写一个函数来检查用户提交的数据是否为整数（不区分数据类型，可以为二进制、八进制、十进制、十六进制数字）

答：其实主要还是is_int和 floor 这个方法

```
if(!is_numeric($jp_total)||strpos($jp_total,".")!==false){  
  echo "不是整数";  
}else{  
  echo "是整数";  
}  
```

### 92．PHP的strtolower()和strtoupper()函数在安装非中文系统的服务器下可能会导致将汉字转换为乱码，请写两个替代的函数实现兼容Unicode文字的字符串大小写转换

答：原因是：中文是由多字节组成的，而只有英文系统的单个英文字符只有一个字节，所以该系统把中文的每一个字节都做了strtolower()处理,改变后的中文字节拼接在一起就成了乱码（新生成的编码映射对应的字符可能就不是中文了）

手动解决：用str_split(string string,int split_length = 1)按每个字节切割，像中文能切割成三个字节。对识别到的字节若是英文字母则进行转换。

```
<?php  
function mystrtoupper($a){  
  $b = str_split($a, 1);  
  $r = '';  
  foreach($b as $v){  
    $v = ord($v);  
    if($v >= 97 && $v<= 122){  
      $v -= 32;  
    }  
    $r .= chr($v);  
  }  
  return $r;  
}  
$a = 'a中你继续F@#$%^&*(BMDJFDoalsdkfjasl';  
echo 'origin string:'.$a."\n";  
echo 'result string:';  
$r = mystrtoupper($a);  
var_dump($r);  
```

### 93.PHP的is_writeable()函数存在Bug，无法准确判断一个目录/文件是否可写，请写一个函数来判断目录/文件是否绝对可写

答：其中bug存在两个方面，
1、在windowns中，当文件只有只读属性时，is_writeable()函数才返回false，当返回true时，该文件不一定是可写的。
如果是目录，在目录中新建文件并通过打开文件来判断；
如果是文件，可以通过打开文件（fopen），来测试文件是否可写。

2、在Unix中，当php配置文件中开启safe_mode时(safe_mode=on)，is_writeable()同样不可用。读取配置文件是否safe_mode是否开启。

```
if ( ! function_exists('is_really_writable'))
{
    function is_really_writable($file)
    {
    // If we're on a Unix server with safe_mode off we call is_writable
    if (DIRECTORY_SEPARATOR == '/' AND @ini_get("safe_mode") == FALSE)
    {
        return is_writable($file);
    }

    // For windows servers and safe_mode "on" installations we'll actually
    // write a file then read it. Bah...
    if (is_dir($file))
    {
        $file = rtrim($file, '/').'/'.md5(mt_rand(1,100).mt_rand(1,100));

        if (($fp = @fopen($file, FOPEN_WRITE_CREATE)) === FALSE)
        {
            return FALSE;
        }

        fclose($fp);
        @chmod($file, DIR_WRITE_MODE);
        @unlink($file);
        return TRUE;
    } elseif ( ! is_file($file) OR ($fp = @fopen($file, FOPEN_WRITE_CREATE)) === FALSE) {
        return FALSE;
    }

    fclose($fp);
    return TRUE;
    }
}
```

### 94.PHP的chmod()函数存在Bug，无法保证设置成功，请写一个函数在指定路径下创建一个目录/文件并确保可以正确设置权限掩码



### 95.PHP通过对数据的URL编码来实现与Javascript的数据交互，但是对于部分特殊字符的编解码与Javascript的规则不尽相同，请具体说明这种差异，并针对UTF-8字符集的数据，写出PHP的编解码函数和Javascript的编解码函数，确保PHP编码数据可以被Javascript正确解码 、Javascript编码的数据可以被PHP正确解码

```
答：

<?php
 $str = '思源博客siyuantlw/tlw/sy/俺只是一个打酱油的';
 $str = iconv("GB2312",'UTF-8',$str);
 $str = urlencode($str);
?>
<p>//js decodeURIComponent  貌似对GB2312编码的格式不识别，必须转为utf-8才可以，然后，如果字符串中有空格的 就转为 + 号了</p>
<html>
 <script>
 var ds = '<?php echo $str;?>';
 var dddd= decodeURIComponent (ds);
 alert(dddd);
 </script>
</html>
```
<h3 id="_98-请列举、你能想到的所有的字符串查找算法-并加注释简单说明。" tabindex="-1"><a class="header-anchor" href="#_98-请列举、你能想到的所有的字符串查找算法-并加注释简单说明。" aria-hidden="true">#</a> 98.请列举、你能想到的所有的字符串查找算法，并加注释简单说明。</h3>
<p>答：
1 顺序查找
2 二分查找
3 分块查找
4 哈希表查找</p>
<p>字符串的一种基本操作就是子字符串查找：给定一段长度为N的文本和一段长度为M的模式字符串，在文本中找到一个和该模式相符的字符串。</p>
<p>模式-&gt; ABCDE
正文-&gt; SJAHDJKS”ABCDE”QWIYUE</p>
<p>上文加引号处就是被搜索出来的结果。
相信这个大家肯定是经常遇到的吧，不管是使用　“CTRL+F”　搜索还是在一些搜索栏中搜索一段文字，将包含该文字的书籍输出中，我们都会遇到，所以在这里对子字符串的查找算法进行一个归纳及汇总。</p>
<p>暴力子字符串查找算法
这种算法是一种比较简单而使用广泛的暴力算法，在最坏的情况下运行时间与MN成正比，但是在许多的正常情况下，它的实际运行时间一般与M+N成正比（在不同情况下，与M+N成正比的概率越高，就越好）。</p>
<p>算法思路
将模式文本的首字母一个个的与文本进行比较，如果相同就比较模式文本的下一个字母，如果在N-M的循环中还没有找到，则表明不匹配，结束循环。这里N-M次循环是因为M为模板文本的长度，N为文本的长度，超过这个数值的话剩下的字符串长度肯定小于M的，就肯定不匹配。因此就不用比较了</p>
<p>代码实现</p>
<p>/**
* 暴力子字符串查找算法
* 利用两层循环
* 一个变量跟踪正文文本，一个变量跟踪模板文本
*
* @param pat
*            模板文本
* @param txt
*            正文文本
* @return
*/
public static String search(String pat, String txt) {
int M = pat.length();
int N = txt.length();</p>
<pre><code>    // 用j来跟踪模板文本
    int j = 0;

    // 用i来跟踪正文文本
    for(int i = 0; i &lt; N - M; i++) {

        // 依次匹配，一个字符一个字符的匹配
        // 如果匹配成功，就返回i的值
        for(j = 0; j &lt; M; j++) {
            if (txt.charAt(i+j) != pat.charAt(j)) {
                break;
            }
        }
        if (j == M) {
            return &quot;找到匹配文本，索引位置为: &quot; + i;
        }
    }
    return &quot;未找到匹配文本, 正文文本长度为&quot; + N;
}
</code></pre>
<p>这一段代码只进行了一个简单的示例，根据需要可以对其进行一个优化，比如说在j的for循环中，就算是整个字符串都被匹配了，仍然后遍历后面的字符串，这就没有必要了。因此可以设置一个标志位，如果整个模板文本已经匹配成功的话就设置标志位为true,同时返回。</p>
<p>当然了，上面的这段代码是只进行一次字符串的重复匹配，就算一个正文文本中存在多个模板文本，也只会搜索出一个，因为搜索到一个之后就return了，根据自己的需要可以再进行算法的优化及更新，因为这篇博客只是一个算法的归纳及汇总，思路及逻辑最重要，就不涉及过多单一算法的优化了，下面介绍的算法类同。</p>
<p>可能出现的问题
例如模板字符串为: ABCD
正文字符串为: AAAAAAAAAAQWEYUQIWABCDISDYQIU
这种算法主要存在的问题就是，如果模板字符串存在一连串的A开头，那么对应的查找就会变得慢了。
总结一下：算法的匹配效率不恒定，正常情况下没问题，极端情况下可能会很慢</p>
<p>KMP子字符串查找算法
这个算法（俗称看毛片算法）需要对模式字符串进行预处理，这里就只归纳一下思路。</p>
<p>思路
KMP算法的基本思想是当出现不匹配时，就能知晓一部分文本的内容(因为匹配失败之前它们已经和模板文本匹配，除了第一次匹配就失败的)。我们就可以利用这些信息避免将指针回退到所有这些已知的字符之前。</p>
<p>例如：
模板文本为:BAAAAAAA
正文文本中又只存在A,B两个字符
党我们开始匹配的时候，如果已经匹配了模板文本中的5个字符，第6个匹配失败，当发现不匹配的字符时，可以指导文本中的前6个字符肯定是BAAAAB（前５个匹配，第６个失败），文本指针现在指向的是第六个字符B。在这个时候，我们就不用回退文本指针了，因为匹配的前４个正文文本字符都是Ａ，与模式的第一个字符不匹配，因此，就可以直接从当前位置开始下一次的循环判断 。</p>
<p>这个理起来有点乱，多熟悉一下就好了，简单理解就是如果匹配失败，而当前文本索引所在位置的字符又是模板文本的开头时，我们不必回退文本指针到第二个位置再依次判断了，而可以根据一个记录来确定我们回退到哪个位置，这在一定程度上减少了循环的次数，提升了效率。</p>
<p>而至于上面的回退方法，其实是利用了一个next数组来实现，通过这个数组我们就可以知道每次回退需要退到哪个位置。</p>
<p>next数组的求法：
将当前序号，例如5前面的4个字符截取出来，然后顺数3个和倒数3个进行比较，如果相同，n就等于3.如果不同就用顺数2个和倒数2个比较，直到为0。
例如： abcde，现在指到了e，那么我们就用abc与bcd比较，它们不相同，就再比较ab与cd，还是不同，就比较a与d。这样就可以得出一个关于n的数组了</p>
<p>Boyer-Moore字符串查找算法
这种算法一般只会检查文本字符串中的一部分字符，现在许多的文本编辑器都使用了这个算法，用以显著的降低字符串查找的响应时间。</p>
<p>思路
当可以在文本字符串中回退时，如果可以从右向左扫描模板字符串并将它和正文文本匹配，那么这种字符串查找算法的速度就会非常快。</p>
<p>例如：
在查找字符串BAABBAA时，如果匹配了第7个和第６个字符，但是在第５个字符处匹配失败，那么马上就可以将模板文本向右移动7个位置并继续检查文本中的第14个字符。这是因为部分匹配找到了XAA而X不是B,而这三个字符在模板文本中是唯一的</p>
<p>这种算法跟上面的KMP的实现类似，也需要一个记录重启位置的数组</p>
<p>Rabin-Karp指纹字符串查找算法
这是一种基于散列（也就是Hash）的字符串查找算法，它与暴力算法几乎一样简单但是运行时间与M+N成正比的概率极高。此外，这种算法还可以拓展到二维的模板文本和正文文本中，这让它更适合于图像处理。</p>
<p>我们需要计算模板文本的散列函数，然后用相同的散列函数计算文本中所有可能的M个字符的子字符串散列值并寻找匹配。如果找到了一个散列值和模板文本相同的子字符串，那么再继续验证两者是否匹配。
可以理解为将模板文本保存在一张散列表中，然后在文本的所有字符串中进行查找。但不需要为散列表预留任何空间，因为它只包含一个元素。</p>
<p>如果直接利用上面的这段描述来实现代码的话肯定是不行的，因为计算散列值将会涉及到字符串中的每个字符，成本肯定是比直接比较字符要高。而RK算法就是一种能够在常数时间内算出M个字符的子字符串散列值的方法(需要预处理)，　这样就得到了一种能够在实际应用中的运行时间为线性级别的字符串查找算法。</p>
<p>思路
长度为Ｍ的字符串对应着一个R进制的M位数，为了用一张大小为Ｑ的散列表来保存这种类型的键，需要一个能够将R进制的M位数转化为一个0到Q-1之间的int值散列函数。这里就可以使用到除留余数法： 将该数除以Q并取余。在实际中会使用一个随机的素数Q，在不溢出的情况下选择一个尽可能大的值（因为并不是真的需要一张散列表）。</p>
<p>简单理解一下：用一个较小的Q和R=10也就是十进制的情况来举例子。
要在正文：　3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3中找到模板文本2 6 5 3 5，首先就要选择散列表的大小Q，Q在这里为997,则散列值为 26535 % 997 = 613，然后计算文本中所有长度为5个数字的子字符串的散列值并寻找匹配。
31415 % 997
14159 % 997
41592 % 997
…..
最后当求到26535时，与模板文本匹配，因此就可以找到了</p>
<p>总结
根据不同的需要选择不同的算法和模式我觉得才是最重要的，这些算法只要能够理解原理，那么在以后用到的时候也能够很快的运用到项目中去，毕竟在很多非算法要求特别高的工程中很有可能用不到很优秀算法，久了不用肯定是会忘的，但是只要懂了思想，哪怕是忘了如何用代码实现，在使用时也可以很快的熟悉它。这也是我总结算法的一个原因吧，思想及原理最重要。</p>
<h3 id="_99-有一个ip地址-192-168-0-1-请写出其32位无符号整数形式。" tabindex="-1"><a class="header-anchor" href="#_99-有一个ip地址-192-168-0-1-请写出其32位无符号整数形式。" aria-hidden="true">#</a> 99.有一个IP地址（192.168.0.1），请写出其32位无符号整数形式。</h3>
<p>答：此题是将十进制转换成二进制 采用取余法即可很简单</p>
<p>答案是：11000000.10101000.00000000.00000001</p>
<h3 id="_110-单点登录的实现" tabindex="-1"><a class="header-anchor" href="#_110-单点登录的实现" aria-hidden="true">#</a> 110.单点登录的实现</h3>
<p>https://blog.csdn.net/skycodes_zyy/article/details/104155968</p>
<h3 id="_118-php如何实现类型自动转换的-暂无答案" tabindex="-1"><a class="header-anchor" href="#_118-php如何实现类型自动转换的-暂无答案" aria-hidden="true">#</a> 118.php如何实现类型自动转换的 （暂无答案）</h3>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211223165412451.png" alt="image-20211223165412451"></p>
<h3 id="_119-php如何做到订单分布式一致性-订单生成需要请求商品服务-红包服务-优惠券服务-三种服务同时成功才能生成订单如何实现-暂无答案" tabindex="-1"><a class="header-anchor" href="#_119-php如何做到订单分布式一致性-订单生成需要请求商品服务-红包服务-优惠券服务-三种服务同时成功才能生成订单如何实现-暂无答案" aria-hidden="true">#</a> 119.php如何做到订单分布式一致性 订单生成需要请求商品服务 ，红包服务，优惠券服务，三种服务同时成功才能生成订单如何实现（暂无答案）</h3>
<h3 id="_120-php的设计理念及特点" tabindex="-1"><a class="header-anchor" href="#_120-php的设计理念及特点" aria-hidden="true">#</a> 120.PHP的设计理念及特点</h3>
<p>多进程模型：由于PHP是多进程模型，不同请求间互不干涉，这样保证了一个请求挂掉不会对全盘服务造成影响，当然，时代发展，PHP也早已支持<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener noreferrer">多线程<ExternalLinkIcon/></a>模型。
弱类型语言：和C/C++、Java、C#等语言不同，PHP是一门弱类型语言。一个变量的类型并不是一开始就确定不变，运行中才会确定并可能发生隐式或显式的类型转换，这种机制的灵活性在web开发中非常方便、高效。
引擎(Zend)+组件(ext)的模式，降低内部耦合。
中间层(sapi)，隔绝web server和PHP。
语法简单灵活，没有太多规范。</p>
<h3 id="_121-php的核心架构" tabindex="-1"><a class="header-anchor" href="#_121-php的核心架构" aria-hidden="true">#</a> 121.PHP的核心架构</h3>
<p>PHP核心架构如下图，从下到上可以简单分为四层体系：
<img src="https://img-blog.csdnimg.cn/20190603184106814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg1MDQwNA==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>Zend引擎：纯C实现，是PHP的内核部分，它将PHP代码翻译（词法、语法解析等一系列编译过程）为可执行opcode的处理并实现相应的处理方法、实现了基本的数据结构（如hashtable、oo）、内存分配及管理、提供了相应的api方法供外部调用，是一切的核心，所有的外围功能均围绕Zend实现。
Extensions：围绕着Zend引擎，extensions通过组件式的方式提供各种基础服务，我们常见的各种内置函数（如array 系列）、标准库等都是通过extension来实现。
Sapi :全称是Server Application Programming Interface服务端应用编程接口，Sapi通过一系列钩子函数，使得PHP可以和外围交互数据，这是PHP非常优雅和成功的一个设计，通过 sapi成功的将PHP本身和上层应用解耦隔离，PHP可以不再考虑如何针对不同应用进行兼容，而应用本身也可以针对自己的特点实现不同的处理方式。
常见的一些sapi有：
apache2handler：这是以apache作为webserver，采用mod_PHP模式运行时候的处理方式，也是现在应用最广泛的一种。
cgi：这是webserver和PHP直接的另一种交互方式，也就是大名鼎鼎的fastcgi协议，在最近今年fastcgi+PHP得到越来越多的应用，也是异步webserver所唯一支持的方式。
cli：命令行调用的应用模式
上层应用：这就是我们平时编写的PHP程序，通过不同的sapi方式得到各种各样的应用模式，如通过webserver实现web应用、在命令行下以脚本方式运行等。</p>
<h3 id="_122-php的执行流程" tabindex="-1"><a class="header-anchor" href="#_122-php的执行流程" aria-hidden="true">#</a> 122.PHP的执行流程</h3>
<p><img src="https://img-blog.csdnimg.cn/20190603184115789.png" alt="img"></p>
<p>PHP实现了一个典型的动态语言执行过程：拿到一段代码后，经过词法解析、语法解析等阶段后，源程序会被翻译成一个个指令 (opcodes)，然后ZEND虚拟机顺次执行这些指令完成操作。PHP本身是用C实现的，因此最终调用的也都是C的函数，实际上，可以把PHP看成是一个C开发的软件。</p>
<p>PHP的执行的核心是翻译出来的一条一条指令，也即opcode。</p>
<p>Opcode是PHP程序执行的最基本单位。一个opcode由两个参数(op1,op2)、返回值和处理函数组成。PHP程序最终被翻译为一组opcode处理函数的顺序执行。</p>
<p>常见的几个处理函数：</p>
<p>ZEND_ASSIGN_SPEC_CV_CV_HANDLER : 变量分配 （ a=b)
ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER：函数调用
ZEND_CONCAT_SPEC_CV_CV_HANDLER：字符串拼接 a.b
ZEND_ADD_SPEC_CV_CONST_HANDLER: 加法运算a+2
ZEND_IS_EQUAL_SPEC_CV_CONST：判断相等 a==1
ZEND_IS_IDENTICAL_SPEC_CV_CONST：判断相等 a===1</p>
<h3 id="_123-zend引擎介绍" tabindex="-1"><a class="header-anchor" href="#_123-zend引擎介绍" aria-hidden="true">#</a> 123.Zend引擎介绍</h3>
<p>Zend引擎作为PHP的内核，有很多经典的设计机制，主要有以下几个：</p>
<h6 id="_4-1-实现hashtable数据机构" tabindex="-1"><a class="header-anchor" href="#_4-1-实现hashtable数据机构" aria-hidden="true">#</a> 4.1 实现HashTable数据机构：</h6>
<p>HashTable是Zend的核心数据结构。在PHP里面几乎用来实现所有常见功能，我们知道的PHP数组即是其典型应用，此外，在zend内部，如函数符号表、全局变量等也都是基于hash table来实现。
Zend hash table实现了典型的hash表散列结构，同时通过附加一个双向链表，提供了正向、反向遍历数组的功能。其结构如下图
<img src="https://img-blog.csdnimg.cn/2019060318413298.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg1MDQwNA==,size_16,color_FFFFFF,t_70" alt="img">
可以看到，在hash table中既有key-&gt;value形式的散列结构，也有双向链表模式，使得它能够非常方便的支持快速查找和线性遍历。
散列结构：Zend的散列结构是典型的hash表模型，通过链表的方式来解决冲突。需要注意的是zend的hash table是一个自增长的数据结构，当hash表数目满了之后，其本身会动态以2倍的方式扩容并重新元素位置。初始大小均为8。另外，在进行 key-&gt;value快速查找时候，zend本身还做了一些优化，通过空间换时间的方式加快速度。比如在每个元素中都会用一个变量 nKeyLength标识key的长度以作快速判定。
双向链表：Zend hash table通过一个链表结构，实现了元素的线性遍历。理论上，做遍历使用单向链表就够了，之所以使用双向链表，主要目的是为了快速删除，避免遍历。 Zend hash table是一种复合型的结构，作为数组使用时，即支持常见的关联数组也能够作为顺序索引数字来使用，甚至允许2者的混合。
PHP关联数组：关联数组是典型的hash_table应用。一次查询过程经过如下几步（从代码可以看出，这是一个常见的hash查询过程并增加一些快速判定加速查找）：</p>
<div class="language-php line-numbers-mode" data-ext="php"><pre v-pre class="language-php"><code><span class="token number">01</span>  getKeyHashValue h<span class="token punctuation">;</span>
<span class="token number">02</span>  index <span class="token operator">=</span> n <span class="token operator">&amp;</span> nTableMask<span class="token punctuation">;</span>
<span class="token number">03</span>  Bucket <span class="token operator">*</span>p <span class="token operator">=</span> arBucket<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token number">04</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">05</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p<span class="token operator">-></span><span class="token property">h</span> <span class="token operator">==</span> h<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p<span class="token operator">-></span><span class="token property">nKeyLength</span> <span class="token operator">==</span> nKeyLength<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token number">06</span>          <span class="token keyword">RETURN</span> p<span class="token operator">-></span><span class="token property">data</span><span class="token punctuation">;</span>   
<span class="token number">07</span>      <span class="token punctuation">}</span>
<span class="token number">08</span>      p<span class="token operator">=</span>p<span class="token operator">-></span><span class="token property">next</span><span class="token punctuation">;</span>
<span class="token number">09</span>  <span class="token punctuation">}</span>
<span class="token number">10</span>  <span class="token keyword">RETURN</span> <span class="token constant">FALTURE</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PHP索引数组：索引数组就是我们常见的数组，通过下标访问。例如 arr[0]，Zend HashTable内部进行了归一化处理，对于index类型key同样分配了hash值和nKeyLength(为0)。内部成员变量 nNextFreeElement就是当前分配到的最大id，每次push后自动加一。正是这种归一化处理，PHP才能够实现关联和非关联的混合。由于 push操作的特殊性，索引key在PHP数组中先后顺序并不是通过下标大小来决定，而是由push的先后决定。例如 arr[1] = 2; arr[2] = 3;对于double类型的key，Zend HashTable会将他当做索引key处理</p>
<h6 id="_4-2-php变量实现原理" tabindex="-1"><a class="header-anchor" href="#_4-2-php变量实现原理" aria-hidden="true">#</a> 4.2 PHP变量实现原理：</h6>
<p>PHP是一门弱类型语言，不严格区分变量的类型。PHP在变量申明的时候不需要指定类型。PHP在程序运行期间可能进行变量类型的隐示 转换。 和其他强类型语言一样，程序中也可以进行显示的类型转换。PHP变量可以分为简单类型(int、string、bool)、集合类型(array 、resource 、object)和常量(const)。以上所有的变量在底层都是同一种结构 zval。</p>
<p>Zval是zend中另一个非常重要的数据结构，用来标识并实现PHP变量，其数据结构如下：
<img src="https://img-blog.csdnimg.cn/20190603184041195.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTg1MDQwNA==,size_16,color_FFFFFF,t_70" alt="img">
Zval结构体主要由三部分组成：
type：指定了变量所述的类型（整数、字符串、数组等）
refcount&amp;is_ref：用来实现引用计数(后面具体介绍)
value：核心部分，存储了变量的实际数据
Zvalue是用来保存一个变量的实际数据。因为要存储多种类型，所以zvalue是一个union，也由此实现了弱类型。</p>
<p>PHP变量类型和其实际存储对应关系如下：</p>
<div class="language-rust line-numbers-mode" data-ext="rs"><pre v-pre class="language-rust"><code><span class="token number">1</span>   <span class="token constant">IS_LONG</span>   <span class="token punctuation">-></span> lvalue
<span class="token number">2</span>   <span class="token constant">IS_DOUBLE</span> <span class="token punctuation">-></span> dvalue
<span class="token number">3</span>   <span class="token constant">IS_ARRAY</span>  <span class="token punctuation">-></span> ht
<span class="token number">4</span>   <span class="token constant">IS_STRING</span> <span class="token punctuation">-></span> <span class="token keyword">str</span>
<span class="token number">5</span>   <span class="token constant">IS_RESOURCE</span> <span class="token punctuation">-></span> lvalue
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>4.2.1 整数、浮点数变量
整数、浮点数是PHP中的基础类型之一，也是一个简单型变量。对于整数和浮点数，在zvalue中直接存储对应的值。其类型分别是long和double。
从zvalue结构中可以看出，对于整数类型，和c等强类型语言不同，PHP是不区分int、unsigned int、long、long long等类型的，对它来说，整数只有一种类型也就是long。由此，可以看出，在PHP里面，整数的取值范围是由编译器位数来决定而不是固定不变的。
对于浮点数，类似整数，它也不区分float和double而是统一只有double一种类型。</p>
<p>在PHP中，如果整数范围越界了怎么办？这种情况下会自动转换为double类型，这个一定要小心，很多trick都是由此产生。</p>
<p>4.2.2 字符变量</p>
<p>和整数一样，字符变量也是PHP中的基础类型和简单型变量。通过zvalue结构可以看出，在PHP中，字符串是由由指向实际数据的指针和长度结 构体组成，这点和c++中的string比较类似。由于通过一个实际变量表示长度，和c不同，它的字符串可以是2进制数据（包含\0），同时在PHP中， 求字符串长度strlen是O(1)操作。</p>
<p>在新增、修改、追加字符串操作时，PHP都会重新分配内存生成新的字符串。最后，出于安全考虑，PHP在生成一个字符串时末尾仍然会添加\0</p>
<p>常见的字符串拼接方式及速度比较：</p>
<p>假设有如下4个变量：strA=‘123’; strB = ‘456’; intA=123; intB=456;
现在对如下的几种字符串拼接方式做一个比较和说明：
1 res = strA.strB和res = “strAstrB”
这种情况下，zend会重新malloc一块内存并进行相应处理，其速度一般。
2 strA = strA.strB
这种是速度最快的，zend会在当前strA基础上直接relloc，避免重复拷贝
3 res = intA.intB
这种速度较慢，因为需要做隐式的格式转换，实际编写程序中也应该注意尽量避免
4 strA = sprintf (“%s%s”,strA，strB);
这会是最慢的一种方式，因为sprintf在PHP中并不是一个语言结构，本身对于格式识别和处理就需要耗费比较多时间，另外本身机制也是malloc。不过sprintf的方式最具可读性，实际中可以根据具体情况灵活选择。</p>
<p>4.2.3 数组变量</p>
<p>PHP的数组通过Zend HashTable来天然实现。</p>
<p>foreach操作如何实现？对一个数组的foreach就是通过遍历hashtable中的双向链表完成。对于索引数组，通过foreach遍 历效率比for高很多，省去了key-&gt;value的查找。count操作直接调用 HashTable-&gt;NumOfElements，O(1)操作。对于’123’这样的字符串，zend会转换为其整数形 式。arr[‘123’]和arr[123]是等价的</p>
<p>4.2.4 资源变量</p>
<p>资源类型变量是PHP中最复杂的一种变量，也是一种复合型结构。</p>
<p>PHP的zval可以表示广泛的数据类型，但是对于自定义的数据类型却很难充分描述。由于没有有效的方式描绘这些复合结构，因此也没有办法对它们使用传统的操作符。要解决这个问题，只需要通过一个本质上任意的标识符（label）引用指针，这种方式被称为资源。</p>
<p>在zval中，对于resource，lval作为指针来使用，直接指向资源所在的地址。Resource可以是任意的复合结构，我们熟悉的mysqli、fsock、memcached等都是资源。</p>
<p>如何使用资源：</p>
<p>1 注册：对于一个自定义的数据类型，要想将它作为资源。首先需要进行注册，zend会为它分配全局唯一标示。
2 获取一个资源变量：对于资源，zend维护了一个id-&gt;实际数据的hash_tale。对于一个resource，在zval中只记录了它的id。fetch的时候通过id在hash_table中找到具体的值返回。
3 资源销毁：资源的数据类型是多种多样的。Zend本身没有办法销毁它。因此需要用户在注册资源的时候提供销毁函数。当unset资源时，zend调用相应的函数完成析构。同时从全局资源表中删除它。
资源可以长期驻留，不只是在所有引用它的变量超出作用域之后，甚至是在一个请求结束并且新的请求产生之后。这些资源称为持久资源，因为它们贯通 SAPI的整个生命周期持续存在，除非特意销毁。很多情况下，持久化资源可以在一定程度上提高性能。比如我们常见的mysql_pconnect ,持久化资源通过pemalloc分配内存，这样在请求结束的时候不会释放。 对zend来说，对两者本身并不区分。</p>
<h6 id="_4-3-php变量管理——引用计数和写时拷贝" tabindex="-1"><a class="header-anchor" href="#_4-3-php变量管理——引用计数和写时拷贝" aria-hidden="true">#</a> 4-3 . PHP变量管理——引用计数和写时拷贝：</h6>
<p>引用计数在内存回收、字符串操作等地方使用非常广泛。Zval的引用计数通过成员变量is_ref和ref_count实现，通过引用计数，多个变量可以共享同一份数据。避免频繁拷贝带来的大量消耗。在进行赋值操作时，zend将变量指向相同的zval同时ref_count++，在unset操作时，对应的ref_count-1。只有ref_count减为0时才会真正执行销毁操作。如果是引用赋值，则zend会修改is_ref为1。</p>
<p>PHP变量通过引用计数实现变量共享数据，那如果改变其中一个变量值呢？当试图写入一个变量时，Zend若发现该变量指向的zval被多个变量共享，则为其复制一份ref_count为1的zval，并递减原zval的refcount，这个过程称为“zval分离”。可见，只有在有写操作发生时 zend才进行拷贝操作，因此也叫copy-on-write(写时拷贝)</p>
<p>对于引用型变量，其要求和非引用型相反，引用赋值的变量间必须是捆绑的，修改一个变量就修改了所有捆绑变量。</p>
<h6 id="_4-4-php局部变量和全局变量的实现" tabindex="-1"><a class="header-anchor" href="#_4-4-php局部变量和全局变量的实现" aria-hidden="true">#</a> 4-4 . PHP局部变量和全局变量的实现：</h6>
<p>PHP中的局部变量和全局变量是如何实现的？对于一个请求，任意时刻PHP都可以看到两个符号表(symbol_table和 active_symbol_table)，其中前者用来维护全局变量。后者是一个指针，指向当前活动的变量符号表，当程序进入到某个函数中时，zend 就会为它分配一个符号表x同时将active_symbol_table指向a。通过这样的方式实现全局、局部变量的区分。</p>
<p>获取变量值：PHP的符号表是通过hash_table实现的，对于每个变量都分配唯一标识，获取的时候根据标识从表中找到相应zval返回。</p>
<p>函数中使用全局变量：在函数中，我们可以通过显式申明global来使用全局变量。在active_symbol_table中创建symbol_table中同名变量的引用（引用变量的值要更新大家会一起更新），如果symbol_table中没有同名变量则会先创建。</p>
<h3 id="_124-php内存管理其他参考地址" tabindex="-1"><a class="header-anchor" href="#_124-php内存管理其他参考地址" aria-hidden="true">#</a> 124.PHP内存管理其他参考地址：</h3>
<p>1、http://www.cnblogs.com/zcy_soft/archive/2013/03/14/2959396.html
2、http://www.laruence.com/2011/11/09/2277.html
3、https://blog.csdn.net/lili0710432/article/details/47816365/</p>
<h3 id="_6、jwt-生成-token-原理" tabindex="-1"><a class="header-anchor" href="#_6、jwt-生成-token-原理" aria-hidden="true">#</a> 6、JWT 生成 token 原理？</h3>
<h3 id="_7、jwt-token-加密-过程是否了解" tabindex="-1"><a class="header-anchor" href="#_7、jwt-token-加密-过程是否了解" aria-hidden="true">#</a> 7、JWT token 加密 过程是否了解 ?</h3>
<h3 id="_8、如何防止劫持-token" tabindex="-1"><a class="header-anchor" href="#_8、如何防止劫持-token" aria-hidden="true">#</a> 8、如何防止劫持 token ？</h3>
<h3 id="_9、通过代码层面实现-指定的用户访问接口" tabindex="-1"><a class="header-anchor" href="#_9、通过代码层面实现-指定的用户访问接口" aria-hidden="true">#</a> 9、通过代码层面实现 指定的用户访问接口？</h3>
<h3 id="_10、数据签名是否了解-签名怎么还原" tabindex="-1"><a class="header-anchor" href="#_10、数据签名是否了解-签名怎么还原" aria-hidden="true">#</a> 10、数据签名是否了解，签名怎么还原？</h3>
<h3 id="_9、怎么实现防盗链" tabindex="-1"><a class="header-anchor" href="#_9、怎么实现防盗链" aria-hidden="true">#</a> 9、怎么实现防盗链 ？</h3>
<h3 id="_10、token-优点和缺点" tabindex="-1"><a class="header-anchor" href="#_10、token-优点和缺点" aria-hidden="true">#</a> 10、token 优点和缺点 ？</h3>
<h3 id="_11、cookie-session-token区别" tabindex="-1"><a class="header-anchor" href="#_11、cookie-session-token区别" aria-hidden="true">#</a> 11、cookie session token区别 ？</h3>
<h3 id="_1、比较-sort-、asirt-、ksort-三个函数的用法以及使用环境" tabindex="-1"><a class="header-anchor" href="#_1、比较-sort-、asirt-、ksort-三个函数的用法以及使用环境" aria-hidden="true">#</a> 1、比较 sort() 、asirt()、ksort() 三个函数的用法以及使用环境</h3>
<h3 id="_2、加载类库方法" tabindex="-1"><a class="header-anchor" href="#_2、加载类库方法" aria-hidden="true">#</a> 2、加载类库方法</h3>
<h3 id="_3、php-的魔术方法函数列举5个以上-并举例说明用法" tabindex="-1"><a class="header-anchor" href="#_3、php-的魔术方法函数列举5个以上-并举例说明用法" aria-hidden="true">#</a> 3、PHP 的魔术方法函数列举5个以上，并举例说明用法 ？</h3>
<h3 id="_4、private、protected、public-修饰符的访问权限" tabindex="-1"><a class="header-anchor" href="#_4、private、protected、public-修饰符的访问权限" aria-hidden="true">#</a> 4、private、protected、public 修饰符的访问权限 ？</h3>
<h3 id="_5、php-生成-excel-表单-并下载-简单描述一下你使用的方法或插件" tabindex="-1"><a class="header-anchor" href="#_5、php-生成-excel-表单-并下载-简单描述一下你使用的方法或插件" aria-hidden="true">#</a> 5、PHP 生成 Excel 表单，并下载；简单描述一下你使用的方法或插件 ？</h3>
<h3 id="_6、说明一下我们如何在-php-中处理异常" tabindex="-1"><a class="header-anchor" href="#_6、说明一下我们如何在-php-中处理异常" aria-hidden="true">#</a> 6、说明一下我们如何在 PHP 中处理异常 ？</h3>
<h3 id="_7、在大多流量频繁的社区系统里-我们常用php-es-redis应用在一些模块中-这里redis-起什么作用-如何解决数据不同步的问题" tabindex="-1"><a class="header-anchor" href="#_7、在大多流量频繁的社区系统里-我们常用php-es-redis应用在一些模块中-这里redis-起什么作用-如何解决数据不同步的问题" aria-hidden="true">#</a> 7、在大多流量频繁的社区系统里，我们常用PHP+ES+Redis应用在一些模块中，这里Redis 起什么作用，如何解决数据不同步的问题 ？</h3>
<h3 id="_8、简单说一下php有哪几种设计模式" tabindex="-1"><a class="header-anchor" href="#_8、简单说一下php有哪几种设计模式" aria-hidden="true">#</a> 8、简单说一下PHP有哪几种设计模式 ？</h3>
<h3 id="_16、composer-和-php-的自动类加载有什么区别" tabindex="-1"><a class="header-anchor" href="#_16、composer-和-php-的自动类加载有什么区别" aria-hidden="true">#</a> 16、Composer 和 PHP 的自动类加载有什么区别 ?</h3>
<h3 id="说说php的魔术变量-要能全部说出来" tabindex="-1"><a class="header-anchor" href="#说说php的魔术变量-要能全部说出来" aria-hidden="true">#</a> 说说php的魔术变量, 要能全部说出来.</h3>
<h3 id="php的设计模式-要能清晰说出单例-工厂-注册模式的实际应用" tabindex="-1"><a class="header-anchor" href="#php的设计模式-要能清晰说出单例-工厂-注册模式的实际应用" aria-hidden="true">#</a> php的设计模式, 要能清晰说出单例, 工厂, 注册模式的实际应用.</h3>
<h3 id="session与cookie的区别及如何解决session的跨域共享" tabindex="-1"><a class="header-anchor" href="#session与cookie的区别及如何解决session的跨域共享" aria-hidden="true">#</a> session与cookie的区别及如何解决session的跨域共享.</h3>
<h3 id="如何防止sql注入及数据安全问题" tabindex="-1"><a class="header-anchor" href="#如何防止sql注入及数据安全问题" aria-hidden="true">#</a> 如何防止sql注入及数据安全问题.</h3>
<h3 id="php的生命周期-启动流程-多看tipi" tabindex="-1"><a class="header-anchor" href="#php的生命周期-启动流程-多看tipi" aria-hidden="true">#</a> php的生命周期, 启动流程, 多看TIPI.</h3>
<h3 id="php的垃圾回收机制-php变量-数组-c源代码如何实现" tabindex="-1"><a class="header-anchor" href="#php的垃圾回收机制-php变量-数组-c源代码如何实现" aria-hidden="true">#</a> php的垃圾回收机制, php变量,数组 c源代码如何实现.</h3>
<h3 id="fastcgi-比-php-cgi-的优势在哪里" tabindex="-1"><a class="header-anchor" href="#fastcgi-比-php-cgi-的优势在哪里" aria-hidden="true">#</a> fastcgi 比 php-cgi 的优势在哪里.</h3>
<h3 id="_11-优先级队列如何实现" tabindex="-1"><a class="header-anchor" href="#_11-优先级队列如何实现" aria-hidden="true">#</a> 11.优先级队列如何实现</h3>
<h3 id="_12-什么是epoll-你怎么用的-简单写下代码-accept阻塞在哪儿了-如果是epoll为什么不阻塞了" tabindex="-1"><a class="header-anchor" href="#_12-什么是epoll-你怎么用的-简单写下代码-accept阻塞在哪儿了-如果是epoll为什么不阻塞了" aria-hidden="true">#</a> 12.什么是epoll？你怎么用的，简单写下代码？accept阻塞在哪儿了？如果是epoll为什么不阻塞了？</h3>
<h3 id="_13-异步和非阻塞的区别-说详细" tabindex="-1"><a class="header-anchor" href="#_13-异步和非阻塞的区别-说详细" aria-hidden="true">#</a> 13.异步和非阻塞的区别，说详细</h3>
<h3 id="_14-php中使用epoll的伪代码流程" tabindex="-1"><a class="header-anchor" href="#_14-php中使用epoll的伪代码流程" aria-hidden="true">#</a> 14.php中使用epoll的伪代码流程</h3>
<h3 id="_15-进程-线程-协程的区别" tabindex="-1"><a class="header-anchor" href="#_15-进程-线程-协程的区别" aria-hidden="true">#</a> 15.进程，线程，协程的区别</h3>
<h3 id="_16-最大堆最小堆实现优先级队列" tabindex="-1"><a class="header-anchor" href="#_16-最大堆最小堆实现优先级队列" aria-hidden="true">#</a> 16.最大堆最小堆实现优先级队列</h3>
<h3 id="_17-arp协议和rarp协议-说下arp劫持" tabindex="-1"><a class="header-anchor" href="#_17-arp协议和rarp协议-说下arp劫持" aria-hidden="true">#</a> 17.arp协议和rarp协议，说下arp劫持</h3>
<h3 id="_18-epoll的常用模式是哪两种-区别是什么" tabindex="-1"><a class="header-anchor" href="#_18-epoll的常用模式是哪两种-区别是什么" aria-hidden="true">#</a> 18.epoll的常用模式是哪两种？区别是什么？</h3>
<h3 id="nginx与php数据通信原理是什么" tabindex="-1"><a class="header-anchor" href="#nginx与php数据通信原理是什么" aria-hidden="true">#</a> nginx与php数据通信原理是什么.</h3>
<h3 id="如何实现跨域请求" tabindex="-1"><a class="header-anchor" href="#如何实现跨域请求" aria-hidden="true">#</a> 如何实现跨域请求.</h3>
<h3 id="关于header的各种参数的作用" tabindex="-1"><a class="header-anchor" href="#关于header的各种参数的作用" aria-hidden="true">#</a> 关于header的各种参数的作用.</h3>
<h3 id="长连接的优势在哪里" tabindex="-1"><a class="header-anchor" href="#长连接的优势在哪里" aria-hidden="true">#</a> 长连接的优势在哪里.</h3>
<h3 id="_28-php内存池分析" tabindex="-1"><a class="header-anchor" href="#_28-php内存池分析" aria-hidden="true">#</a> 28.php内存池分析？</h3>
<p>1、PHP的内存分配主要是围绕两个数组来展开：free_buckets和large_free_buckets，其中前者用来管理小块内存，后者用来管理大块内存。</p>
<p>2、对于小块内存，做到尽量可以再次使用，分成64个区段，每段管理的内存字节间隔为8，即下标为0管理16-23，下标1管理24-31，依此类推……</p>
<p>3、对于大块内存，数组不宜过大，所以数组的长度也是64，但是为了不浪费内存，采用树+双向列表来管理，方便快速查找，也不会浪费太多内存。</p>
<p>4、内存分配时先从操作系统分配较大块内存，分配完后放入上述相应的数组中，方便下次使用。</p>
<h3 id="_101-请写出http头-并符合以下要求" tabindex="-1"><a class="header-anchor" href="#_101-请写出http头-并符合以下要求" aria-hidden="true">#</a> 101.请写出HTTP头，并符合以下要求：</h3>
<p>１）这是一个post请求
２）目标：http://www.example.com:8080/test
３）POST变量：
username: test
pwd: test2
intro: Hello world!</p>
<p>４）包含以下COOKIE信息：
cur_query: you&amp;me
说明：</p>
<p>１）如果，你记不得某个HTTP协议中的指令字了，那么，无奈这举是用“汉字”代替。
２）如果，你能记住更多的HTTP协议指令字，那么多写几句，总是没坏处，对吧？
３）最关键的，只需要画出正确的“轮廓”（还记得httpwatch等工具打印出来的头部吗？那就是“轮廓”的含义），也会有分数，但如果，连“轮廓”都写错了，那么就很遗憾了。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>Accept: text/html 可以接受的数据类型
Accept-Encoding: gzip 接受的压缩类型
Accept-Language: zh-CN 接受语言
Cache-Control: no-cache 是否有缓存
Connection : keep-alive 是否保持链接
Host:http://www.example.com:8080/test
Cookie：intro=Hello world!
Content-Disposition: form-data; username=”test”&amp;pwd=”test2”&amp;intro=”hello world!”
User-Agent: 浏览器信息
Referer: 前一个页面地址
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_103-简单介绍一下http的长连接和短连接" tabindex="-1"><a class="header-anchor" href="#_103-简单介绍一下http的长连接和短连接" aria-hidden="true">#</a> 103.简单介绍一下HTTP的长连接和短连接</h3>
<p>HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议.</p>
<p><strong>短连接:</strong></p>
<p>浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。</p>
<p><strong>长连接:</strong></p>
<p>当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。</p>
<p><strong>TCP短连接:</strong></p>
<p>client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作.短连接一般只会在 client/server间传递一次读写操作</p>
<p><strong>TCP长连接:</strong></p>
<p>client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。</p>
<h3 id="_104-列举几种常见的协议-并简述他们的作用" tabindex="-1"><a class="header-anchor" href="#_104-列举几种常见的协议-并简述他们的作用" aria-hidden="true">#</a> 104.列举几种常见的协议，并简述他们的作用</h3>
<p>ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。</p>
<p>TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。</p>
<p>HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。</p>
<p>DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。</p>
<p>NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，</p>
<p>DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。</p>
<h3 id="_274-堆和栈的区别" tabindex="-1"><a class="header-anchor" href="#_274-堆和栈的区别" aria-hidden="true">#</a> 274.堆和栈的区别？</h3>
<p>栈是编译期间就分配好的内存空间，因此你的代码中必须就栈的大小有明确的定义；</p>
<p>堆是程序运行期间动态分配的内存空间，你可以根据程序的运行情况确定要分配的堆内存的大小。</p>
<h3 id="_275-autoload-方法的工作原理是什么" tabindex="-1"><a class="header-anchor" href="#_275-autoload-方法的工作原理是什么" aria-hidden="true">#</a> 275.__autoload()方法的工作原理是什么？</h3>
<p>使用这个魔术函数的基本条件是类文件的文件名要和类的名字保持一致。</p>
<p>当程序执行到实例化某个类的时候，如果在实例化前没有引入这个类文件，那么就自动执行__autoload()函数。</p>
<p>这个函数会根据实例化的类的名称来查找这个类文件的路径，当判断这个类文件路径下确实存在这个类文件后</p>
<p>就执行include或者require来载入该类，然后程序继续执行，如果这个路径下不存在该文件时就提示错误。</p>
<p>使用自动载入的魔术函数可以不必要写很多个include或者require函数。</p>
<h3 id="_2-使用mod-rewrite-在服务器上没有-archivers-567-html这个物理文件时-重定向到index-php-id-567-请先打开mod-rewrite" tabindex="-1"><a class="header-anchor" href="#_2-使用mod-rewrite-在服务器上没有-archivers-567-html这个物理文件时-重定向到index-php-id-567-请先打开mod-rewrite" aria-hidden="true">#</a> 2.使用mod_rewrite,在服务器上没有/archivers/567.html这个物理文件时，重定向到index.php?id=567 ,请先打开mod_rewrite.</h3>
<p>首先，打开mod_rewrite模块。</p>
<p>其次，http.conf找到以下代码段：</p>
<Directory /><p>Options FollowSymLinks
AllowOverride None</p>
</Directory>
将其中的：AllowOverride None 改为 AllowOverride All ，重启httpd服务即可。
<p>然后，在项目根目录下简历 .htaccess 文件，填写规则。</p>
<h3 id="_4-写出一种排序算法-原理-并说出优化它的方法。" tabindex="-1"><a class="header-anchor" href="#_4-写出一种排序算法-原理-并说出优化它的方法。" aria-hidden="true">#</a> 4.写出一种排序算法（原理），并说出优化它的方法。</h3>
<h3 id="_1-php7底层原理问题" tabindex="-1"><a class="header-anchor" href="#_1-php7底层原理问题" aria-hidden="true">#</a> 1.php7底层原理问题：</h3>
<p>（1）本章将会介绍PHP简史与新特性，以及PHP7安装和调试方法。</p>
<p>（2）初步了解一下PHP 7核心源码中ext、main、sapi、TSRM、Zend目录下都有哪些文件，以及各自的功能是什么。此外，本章还以一段示例代码介绍了PHP 7代码的执行流程。通过对PHP 7执行流程的初步了解</p>
<p>介绍了其在PHP 7中的执行原理和大概过程</p>
<p>（3）研究PHP 7中基本变量的实现，PHP中的变量是弱类型的，使用者在使用时无需对变量的类型进行声明，那这是怎么做到的呢？同时，PHP 7中zval的实现相对于PHP 5有了很大的改动，而这些改动为PHP 7带来了巨大的性能提升。那么PHP 7中zval是如何设计的呢？其大小有什么样的变化？能否直接在栈上申请呢？</p>
<p>理解PHP 7基本变量的设计与实现</p>
<p>对PHP 7中zval实现细节的阐述，分析PHP 7中zval有了哪些改变，这些改变带来了什么样的好处。</p>
<blockquote>
<blockquote>
<p>数组是PHP代码中比较重要的一个结构，本质上PHP的数组是有序的字典，即它们表示key-value对的有序列表，其中key-value映射是使用HashTable实现的。PHP将字符串key通过哈希函数运算返回一个整数。这个整数被用作“普通”数组的索引。但是带来新的问题是，两个不同的字符串可能得到相同的哈希值，因此这样的HashTable需要实现某种机制来解决冲突。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>头部的gc结构体解决数组的引用计数和循环引用的问题</p>
</blockquote>
</blockquote>
<p>（4）字符串是编程语言中非常重要的变量类型，字符串由1个或者多个字符组成，是大多数编程语言中重要的数据类型。以C语言为例，它借助标准函数库提供的一系列高性能字符串接口，实现字符串的管理。PHP 7基于此封装了一套字符串管理接口，在注重开发效率的同时，也兼顾了运行效率。PHP 7的字符串以zend_string为载体，实现了字符串的构建、扩充、截断、判等、复制、取长度、释放等操作。不仅于此，还提供了性能高效的字符串扩展方法集合smart_str API。本章将根据zend_string和smart_str结构及对应API的实现，来逐步分析PHP 7对字符串的管理。相信读完这章，读者能较清晰地理解PHP 7底层字符串的实现原理。</p>
<blockquote>
<blockquote>
<p>1）PHP 7值存储为何采用的是char[1]，而不是延用PHP 5的char *？</p>
<p>2）为什么使用char val[1]占位，而不是char val[]或者char val[0]占位？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于第1个问题，char[1]称为柔性数组，当结构体中仅有一个变长的字符串且为最后一个字段时，就可采用这种实现方式。</p>
<p>那么使用柔性数组的优势是什么呢？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在分配字符串内存时，一次申请的内存大小不仅仅是结构体的大小，还要额外加上字符串值的长度len+1。至此，柔性数组val字段就占用了末尾连续的一块内存，用于存储不定长度的字符串值。这样，struct中字符串的值与其他成员便存储在同一块连续的空间中，在分配、释放内存时便可将struct当成整体处理。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>char[]的好处很明显，读写字符串值时可以省一次内存读写，假设val字段还沿用PHP5中的char*，要去读写val时，需访问两块内存。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于第2个问题，是因为val[]、val[0]在C99标准中是合法的，这种定义被称为变长数组（variable-length array）。由于下标为空，这里的val就像是一个占位符，只有符号意义，但却并不实际占用空间。在C99以前的标准中，是不允许变长数组出现的，但支持val[1], val[1]会实际占用1字节。PHP 7采用val[1]而不用val[]占位是为了兼容不同版本的C编译器。</p>
</blockquote>
</blockquote>
<p>（5）</p>
<blockquote>
<blockquote>
<p>如何基于HashTable实现高效优雅的数组呢？有些读者可能会想，既然是HashTable，如果通过链地址法解决哈希冲突，那么链表是必然需要的。同时为了保证顺序性，的确需要再维护一个全局链表，看起来PHP 5的实现已经是无懈可击了。难道PHP 7数组采用了其他哈希冲突解决方案（比如开放地址法）？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>实际上，PHP 7的思路依然是通过链地址法解决哈希冲突。不过此“链”非彼“链”。PHP 5的链表是物理上的链表，链表中bucket之间的上下游关系通过真实存在的指针来维护。而PHP 7的链表是一种逻辑上的链表，所有bucket都分配在连续的数组内存中，不再通过指针维护上下游关系，每一个bucket只维护下一个bucket在数组中的索引（因为是连续内存，通过索引可以快速定位到bucket），即可完成链表上bucket的遍历。</p>
</blockquote>
</blockquote>
<p>（7）本章将对PHP 7的生命周期进行详细的探讨。PHP 7的生命周期主要分为5大阶段，我们会对每个阶段进行细致的研究和阐述，以理解PHP代码的整个执行过程，从而对PHP 7的执行有一个全局的认识。另外，PHP 7有多种模式运行，比如常用的CLI（命令行）模式、FPM模式，以及CGI模式、embed模式、Apache2Handler模式、litespeed模式等，本章主要对CLI模式和FPM模式进行展开，讨论一下各种模式下PHP代码是如何执行的，相信读者学习完本章，会对PHP 7的运行模式有更深刻的理解。</p>
<p>下面我们从多进程管理角度对PHP-FPM展开阐述，首先讨论master进程和worker进程是如何创建的，然后讨论进程之间是如何通信的，比如worker进程意外退出，master进程是如何感知并重新创建新的worker进程的。</p>
<p>在CLI模式下，PHP的执行过程主要分为5大阶段，分别是模块初始化、请求初始化、执行、请求关闭和模块关闭。这5个阶段分别对应php_module_startup、php_request_startup、php_execute_script、php_request_shutdown以及php_module_shutdown</p>
<p>与CLI模式类似，FPM模式的生命周期也有5个阶段，但是又与CLI模式的生命周期不同，因为FPM是常驻内存的进程，所以其模块初始化只做一次，便进入循环，而模块关闭在进程退出时也只做一次</p>
<p>（8）php.ini是PHP的配置文件，通过这个文件中的配置项，我们可以控制PHP在运行时候的一些行为，如上传文件的大小、时区、加载的扩展等，那么这个文件是怎么配置和解析的呢？</p>
<p>（9）本章将详细介绍PHP 7中内存管理器的实现，从内存申请、释放等方面，分析PHP 7的内存管理策略。</p>
<p>（9）</p>
<blockquote>
<blockquote>
<p>既然操作系统已经提供了一套内存管理的函数，那为什么PHP 7还要自己实现一套内存管理方案呢？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>PHP 7的使用者不需要像C/C++那样手动申请和释放内存。在开发者对内存随用随取（定义对象、数组等）的背后，是PHP 7内核的内存管理提供的支撑，让开发者可以专注于于业务逻辑，而不用关心内存的申请和释放，大大提高了业务支撑的效率。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>向操作系统申请内存以及释放内存、回收内存，会产生用户态和内核态的切换，是高耗时的操作。PHP 7内存管理器充当了应用层和操作系统内核的中间人，大大减少应用直接向内核频繁申请小块内存的操作，同时PHP 7内存管理器会择时释放，提升系统的整体性能。</p>
</blockquote>
</blockquote>
<p>PHP 7内存管理还会减少内存“碎片化”问题。没有内存管理器，如果PHP程序持续运行、反复申请与释放内存导致连续内存产生大量碎片，会使得内存利用率降低；内存管理器的内存池技术能按块大小分级分配和回收，减少碎片化。</p>
<p>PHP脚本运行所需的内存空间不是直接从系统申请，而是调用Zend Memory Manager（Zend内存管理器，以下简称MM）提供的一系列接口函数（如zend_mm_alloc_small）申请：如果MM中的可用内存够用，直接分配给PHP程序；如果MM中的可用内存不够，MM再从系统申请。可见这样能有效减少系统调用的次数，并优化内存空间的使用效率。</p>
<p>（10）在PHP 5中，从PHP代码到opcode的执行过程如下：先进行词法扫描分析，将源文件转换成Token；然后进行语法分析，在此阶段生成Op_array。相比PHP 5, PHP 7的执行过程多了一步，其执行过程如下：先进行词法扫描分析，将源文件转换成Token；然后进行语法分析生成AST，最后AST生成Op_array。PHP 7的执行过程比PHP 5的多了一步，所以按常理来说这会增加程序的执行时间，同时会增加内存的消耗。但事实上内存的消耗确实增加了，但是执行时间上有所降低。具体可以使用PHP 7的测试用例验证：https://gist.github.com/nikic/289b0c7538b46c2220bc。得出的结论是使用AST之后程序的执行时间整体上有10%～15%的提升，但是内存的消耗也在增加，在大文件单次编译中增加明显，但是在整个项目执行过程中并不是很严重。</p>
<p>AST解决了很多语法问题，比如括号不影响行为</p>
<p>（11）PHP 7完成基本的准备工作后，会启动Zend引擎，加载注册的扩展模块，然后读取对应的脚本文件，Zend引擎会对文件进行词法和语法分析，生成AST，接着AST被编译成opcode，如果开启了opcache，编译的环节会被跳过从opcache中直接读取opcode进行执行。</p>
<p>Zend虚拟机主要分为解释层、中间数据层和执行层</p>
<blockquote>
<blockquote>
<p>（1）解释层这一层主要负责对PHP代码进行词法和语法分析，生成对应的AST；另一个工作就是对AST进行编译，生成符号表和指令集。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）中间数据层这一层主要包含了虚拟机的核心部分——执行栈的维护、指令集和符号表的存储，而这些是执行引擎调度执行的基础。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）执行层这一层是执行指令集的引擎，负责最终的执行并生成结果，这一层实现了大量的底层函数。</p>
</blockquote>
</blockquote>
<p>（12）foreach结构由3部分组成，即expression（可以是数组或者对象）和foreach变量key、value。这里不论是数组还是对象，本质上是对HashTable进行遍历，因为PHP 7中的数组实现就是HashTable，而遍历对象实际上是对对象的属性进行遍历。</p>
<p>foreach关键字会创建一个kind为ZEND_AST_FOREACH的节点。以该节点为根，共有4个孩子，分别对应为expression（需要遍历的变量）、variable1（foreach变量key）、variable（foreach变量value）和statement（普通表达式）。</p>
<p>（13）本章从用户定义函数的方向分析了PHP 7函数机制的原理，并简单介绍了内置函数的实现和两者的不同之处。</p>
<blockquote>
<blockquote>
<p>PHP函数的实现与其类似。不同的是，PHP不使用操作系统提供的栈，而是在堆上申请内存，用数据结构execute_data模拟栈帧，支持函数调用的层级、嵌套关系。在引擎执行过程中，该结构保存了执行器的现场环境，是执行器最重要的数据结构。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>PHP实现函数调用的过程共分为3个阶段。</p>
<p>第一阶段：调用栈空间初始化。这部分会分配函数执行期间需要的操作空间，并根据参数的实际调用情况（实际传入参数个数）对新分配的空间做进一步赋值。</p>
<p>第二阶段：切换作用域，执行函数实体。</p>
<p>第三阶段：传递执行结果，释放操作空间，引擎执行位置切换回原始调用位置。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>下面详细说明函数调用的过程。</p>
<p>1）根据函数名在EG(function_table) 中进行查找，确认函数是否存在，若不存在则会提示“Call toundefined function”。被查找的函数名由opline-&gt;op2获得。</p>
<p>2）分配运行时栈作为函数执行时的操作空间。当引擎执行到函数调用时，会创建新的zend_execute_data结构作为当前函数调用的运行栈。所以，对于递归调用的情况，会逐层创建递归调用栈，消耗大量的调用栈空间及执行时间，这也是我们在一些情况下规避递归的原因。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>PHP函数执行的关键就是自定义数据结构来模拟栈，完成函数调用，好处是能避免操作系统提供的栈的内存大小限制。</p>
</blockquote>
<p>PHP脚本的编译过程主要经历词法分析、语法分析和编译3个阶段，其中词法分析阶段把脚本内容切割为符合词法规则的Token；语法分析阶段将词法分析产生的Token集合组装成AST（抽象语法树）；最后经过编译，由AST生成可调用指令集opcodes。</p>
</blockquote>
<p>独立分散的Token是没有意义的，只有按照语法规则组装成AST之后才能表达语义。Token生成AST需经过yyparse的解析，之后，AST被存储到complier_globals.ast中，等待下一步的处理。</p>
<p>当函数被调用时，调用者根据函数名找到函数定义的指令集合、执行指令并返回结果给调用者。</p>
<p>内置函数无须经过Zend引擎的词法、语法解析即可直接调用。其速度优于用户定义函数。</p>
<p>include_once和require_once会将解析出的文件路径加入到全局的hashtable表EG(included_files)中，下次再被引入时，会优先从EG(included_files)中查找。如果文件已经编译过，则不再对文件进行编译。</p>
<h3 id="_3-php的cg和eg" tabindex="-1"><a class="header-anchor" href="#_3-php的cg和eg" aria-hidden="true">#</a> 3.php的CG和EG？</h3>
<p>php中有CG和EG两个宏，分别获取compile_global数据和excutor_global的数据，它们分别有各自的function_table和class_table，另外php中的require是作为函数来执行的，因此这个时候需要知道EG和CG之间是如何转换的。</p>
<p>这里的问题查找是先通过zend_language_parser.y里找到类结束之后的代码，看编译阶段的问题，然后再定位编译出错时，如果做。</p>
<h3 id="禁用-cookie-后-seesion-还能用吗-不登陆有session吗" tabindex="-1"><a class="header-anchor" href="#禁用-cookie-后-seesion-还能用吗-不登陆有session吗" aria-hidden="true">#</a> 禁用 COOKIE 后 SEESION 还能用吗？不登陆有session吗？</h3>
<h3 id="抓取远程图片到本地-你会用什么函数" tabindex="-1"><a class="header-anchor" href="#抓取远程图片到本地-你会用什么函数" aria-hidden="true">#</a> 抓取远程图片到本地, 你会用什么函数?</h3>
<h3 id="谈谈您对mvc的认识及设计模式的理解" tabindex="-1"><a class="header-anchor" href="#谈谈您对mvc的认识及设计模式的理解" aria-hidden="true">#</a> 谈谈您对mvc的认识及设计模式的理解</h3>
<h3 id="您用过那些版本控制软件-这些版本控制软件各自优缺点" tabindex="-1"><a class="header-anchor" href="#您用过那些版本控制软件-这些版本控制软件各自优缺点" aria-hidden="true">#</a> 您用过那些版本控制软件? 这些版本控制软件各自优缺点</h3>
<h3 id="如何实现购物车功能" tabindex="-1"><a class="header-anchor" href="#如何实现购物车功能" aria-hidden="true">#</a> 如何实现购物车功能</h3>
<h3 id="面向对象的机制与实现" tabindex="-1"><a class="header-anchor" href="#面向对象的机制与实现" aria-hidden="true">#</a> 面向对象的机制与实现</h3>
<h3 id="如何测试php性能和找出瓶颈的方法" tabindex="-1"><a class="header-anchor" href="#如何测试php性能和找出瓶颈的方法" aria-hidden="true">#</a> 如何测试php性能和找出瓶颈的方法</h3>
<h3 id="拼接字符串往往是影响效率-如何寻找一种更有效的方法代替" tabindex="-1"><a class="header-anchor" href="#拼接字符串往往是影响效率-如何寻找一种更有效的方法代替" aria-hidden="true">#</a> 拼接字符串往往是影响效率，如何寻找一种更有效的方法代替</h3>
<h3 id="请举例说明在你的开发过程中用什么方法来加快页面的加载速度" tabindex="-1"><a class="header-anchor" href="#请举例说明在你的开发过程中用什么方法来加快页面的加载速度" aria-hidden="true">#</a> 请举例说明在你的开发过程中用什么方法来加快页面的加载速度</h3>
<h3 id="请列出php中的缓存技术" tabindex="-1"><a class="header-anchor" href="#请列出php中的缓存技术" aria-hidden="true">#</a> 请列出PHP中的缓存技术</h3>
<h3 id="_19-高并发如何处理" tabindex="-1"><a class="header-anchor" href="#_19-高并发如何处理" aria-hidden="true">#</a> 19.高并发如何处理？</h3>
<p>需要对服务器的架构分层，重新布局，负载均衡，集群策略。
负载均衡器（硬件和软件）
硬件：F5-Bigip:立竿见影，价格昂贵，网游公司或大网站用的比较多
软件：lvs(linux virtual server 虚拟服务，集成到内核中)，nginx(可以做 web 服务器，也可以做负载均衡使用)
负载均衡策略：
（1）轮询技术：把客户端的请求轮流分发给服务器。
（2）最少连接；负载均衡把请求给最空闲的服务器
（3）ip 哈希：同一地址的客户端，始终请求同一台服务器。</p>
<h3 id="_20-前后台数据交互时用到那些技术" tabindex="-1"><a class="header-anchor" href="#_20-前后台数据交互时用到那些技术" aria-hidden="true">#</a> 20.前后台数据交互时用到那些技术？</h3>
<p>Ajax，Ajax 的跨域请求常用的有两种方式：
1）使用中间层过渡的方式：
中间过渡，很明显，就是在 AJAX 与不同域的服务器进行通讯的中间加一层过渡，这一层过渡可以是 PHP 、JSP、c++等任何具备网络通讯功能的语言，由中间层向不同域的服务器进行读取数据的操作。拿 PHP 做 一个例子，如果需要对不同域的某一个 php 进行通讯，现在客户端的xmlhttprequest 先 query 本域的一个 PHP，然后由本域的这个 PHP 去和不同域的 PHP 进行通讯，然后由本域的 PHP 输出 response；
2）使用标签
这个方法是利用标签中的 src 来 query 一个 PHP 获得 response，因为标签 的 src 属性不存在跨域的问题。</p>
<h3 id="_21-什么是-ajax-ajax-异步处理" tabindex="-1"><a class="header-anchor" href="#_21-什么是-ajax-ajax-异步处理" aria-hidden="true">#</a> 21.什么是 Ajax，Ajax 异步处理？</h3>
<p>Ajax 是一种在页面没有刷新的情况下，通过客户端（浏览器）与服务器交互的一种技术。
Ajax 语言的载体是 javascript,最大特点：页面不刷新完成请求。
open 方法：如 xhr.open(‘get’,’demo.php’,true)open 方法，第三个参数表示是异步请求，默认 true 表示异步请求处理</p>
<h3 id="_23-http-协议请求的状态-404-是什么-500" tabindex="-1"><a class="header-anchor" href="#_23-http-协议请求的状态-404-是什么-500" aria-hidden="true">#</a> 23.http 协议请求的状态？404 是什么？500？</h3>
<p>**200（成功）：**服务器已成功处理了请求。通常，这表示服务器提供了请求的网页
**201（已创建）：**请求成功并且服务器创建了新的资源
**202（已接受）：**服务器已接受请求，但尚未处理
**203（非授权信息）：**服务器已成功处理了请求，但返回的信息可能来自另一来源
**204（无内容）：**服务器成功处理了请求，但没有返回任何内容
**205（重置内容）：**服务器成功处理了请求，但没有返回任何内容
**206 （部分内容）：**服务器成功处理了部分 GET 请求
**404（未找到）：**服务器找不到请求的网页
**500（服务器内部错误）：**服务器遇到错误，无法完成请求</p>
<h3 id="_12-使用过-memcache-缓存吗-请简述一下" tabindex="-1"><a class="header-anchor" href="#_12-使用过-memcache-缓存吗-请简述一下" aria-hidden="true">#</a> 12.使用过 Memcache 缓存吗？请简述一下</h3>
<p>Memcache 是把所有的数据保存在内存中，采用 hash 表的方式，把每条数据有 key 和 value组成，每个 key 独一无二的，当要访问的某个值的时候先按照找到值，然后在返回结果，Memcache采用 LRU 算法来逐渐把过期的数据清除掉</p>
<h3 id="以apache模块的方式安装php-在文件http-conf中首先要用语句-动态装载php模块-然后再用语句-使得apache把所有扩展名为php的文件都作为php脚本处理。" tabindex="-1"><a class="header-anchor" href="#以apache模块的方式安装php-在文件http-conf中首先要用语句-动态装载php模块-然后再用语句-使得apache把所有扩展名为php的文件都作为php脚本处理。" aria-hidden="true">#</a> 以Apache模块的方式安装PHP，在文件http.conf中首先要用语句;动态装载PHP模块，然后再用语句;使得Apache把所有扩展名为php的文件都作为PHP脚本处理。</h3>
<h3 id="安装apache服务器-apache那些地方须要优化。" tabindex="-1"><a class="header-anchor" href="#安装apache服务器-apache那些地方须要优化。" aria-hidden="true">#</a> 安装apache服务器，apache那些地方须要优化。</h3>
<h3 id="php-mysql中几个版本的进化史-比如mysql4-0到4-1-php-4-x到5-1的重大改进等等。" tabindex="-1"><a class="header-anchor" href="#php-mysql中几个版本的进化史-比如mysql4-0到4-1-php-4-x到5-1的重大改进等等。" aria-hidden="true">#</a> PHP/Mysql中几个版本的进化史，比如mysql4.0到4.1，PHP 4.x到5.1的重大改进等等。</h3>
<h3 id="posix和perl标准的正则表达式区别。" tabindex="-1"><a class="header-anchor" href="#posix和perl标准的正则表达式区别。" aria-hidden="true">#</a> posix和perl标准的正则表达式区别。</h3>
<h3 id="safe-mode-打开后哪些地方受限。-参考这篇文章-php特点之安全模式2——被安全模式限制或屏蔽的函数" tabindex="-1"><a class="header-anchor" href="#safe-mode-打开后哪些地方受限。-参考这篇文章-php特点之安全模式2——被安全模式限制或屏蔽的函数" aria-hidden="true">#</a> safe_mode 打开后哪些地方受限。（参考这篇文章：PHP特点之安全模式2——被安全模式限制或屏蔽的函数）</h3>
<h3 id="写代码来解决多进程-线程同时读写一个文件的问题。" tabindex="-1"><a class="header-anchor" href="#写代码来解决多进程-线程同时读写一个文件的问题。" aria-hidden="true">#</a> 写代码来解决多进程/线程同时读写一个文件的问题。</h3>
<h3 id="写一段上传文件的代码。-参考这篇文章-php特点之文件上传1——使用post方法上传单文件和多文件" tabindex="-1"><a class="header-anchor" href="#写一段上传文件的代码。-参考这篇文章-php特点之文件上传1——使用post方法上传单文件和多文件" aria-hidden="true">#</a> 写一段上传文件的代码。（参考这篇文章：PHP特点之文件上传1——使用POST方法上传单文件和多文件）</h3>
<h3 id="测试php性能和mysql数据库性能的工具-和找出瓶颈的方法。" tabindex="-1"><a class="header-anchor" href="#测试php性能和mysql数据库性能的工具-和找出瓶颈的方法。" aria-hidden="true">#</a> 测试php性能和mysql数据库性能的工具,和找出瓶颈的方法。</h3>
<h3 id="正则提出一个网页中的所有链接。" tabindex="-1"><a class="header-anchor" href="#正则提出一个网页中的所有链接。" aria-hidden="true">#</a> 正则提出一个网页中的所有链接。</h3>
<h3 id="介绍一下常见的sso-单点登陆-方案-比如dedecms整合discuz的passport-的原理。" tabindex="-1"><a class="header-anchor" href="#介绍一下常见的sso-单点登陆-方案-比如dedecms整合discuz的passport-的原理。" aria-hidden="true">#</a> 介绍一下常见的SSO(单点登陆)方案(比如dedecms整合discuz的passport)的原理。</h3>
<h3 id="您写过的php框架的特点-主要解决什么问题-与其他框架的不同点。" tabindex="-1"><a class="header-anchor" href="#您写过的php框架的特点-主要解决什么问题-与其他框架的不同点。" aria-hidden="true">#</a> 您写过的PHP框架的特点，主要解决什么问题，与其他框架的不同点。</h3>
<h3 id="大型的论坛-新闻文章系统-sns网站在性能优化上有什么区别" tabindex="-1"><a class="header-anchor" href="#大型的论坛-新闻文章系统-sns网站在性能优化上有什么区别" aria-hidden="true">#</a> 大型的论坛/新闻文章系统/SNS网站在性能优化上有什么区别?</h3>
<h3 id="相册类应用-要求在浏览器中能同时选中并上传多个文件-图片要求能剪裁-压缩包在服务器端解压。能上传单个达50m的文件。上传过程中有进度条显示。每个图片能生成四种大小缩略图-视频文件要转成flv供flash播放。叙述要涉及的各类开源软件和简单用途。" tabindex="-1"><a class="header-anchor" href="#相册类应用-要求在浏览器中能同时选中并上传多个文件-图片要求能剪裁-压缩包在服务器端解压。能上传单个达50m的文件。上传过程中有进度条显示。每个图片能生成四种大小缩略图-视频文件要转成flv供flash播放。叙述要涉及的各类开源软件和简单用途。" aria-hidden="true">#</a> 相册类应用:要求在浏览器中能同时选中并上传多个文件，图片要求能剪裁，压缩包在服务器端解压。能上传单个达50M的文件。上传过程中有进度条显示。每个图片能生成四种大小缩略图，视频文件要转成flv供flash播放。叙述要涉及的各类开源软件和简单用途。</h3>
<h3 id="_7-常见的数据结构并列举出它们的应用场景" tabindex="-1"><a class="header-anchor" href="#_7-常见的数据结构并列举出它们的应用场景" aria-hidden="true">#</a> 7.常见的数据结构并列举出它们的应用场景？</h3>
<h3 id="_8-什么是-csrf-攻击-xss-攻击-如何防范" tabindex="-1"><a class="header-anchor" href="#_8-什么是-csrf-攻击-xss-攻击-如何防范" aria-hidden="true">#</a> 8.什么是 CSRF 攻击 ？XSS 攻击？如何防范？</h3>
<h3 id="_9-写一段代码-实现php内部的通知机制-如当一个类的其中一个属性发生变化时-另外一个类就可以收到通知。" tabindex="-1"><a class="header-anchor" href="#_9-写一段代码-实现php内部的通知机制-如当一个类的其中一个属性发生变化时-另外一个类就可以收到通知。" aria-hidden="true">#</a> 9.写一段代码，实现PHP内部的通知机制，如当一个类的其中一个属性发生变化时，另外一个类就可以收到通知。</h3>
<h3 id="如何解决多线程或者多进程同时读写一个文件的问题。" tabindex="-1"><a class="header-anchor" href="#如何解决多线程或者多进程同时读写一个文件的问题。" aria-hidden="true">#</a> 如何解决多线程或者多进程同时读写一个文件的问题。</h3>
<h3 id="写一段程序求出一段正负整数的最大连续和-如-1-2-5-9-12-15-10-13-7-最大的连续和就是12-15-10-13" tabindex="-1"><a class="header-anchor" href="#写一段程序求出一段正负整数的最大连续和-如-1-2-5-9-12-15-10-13-7-最大的连续和就是12-15-10-13" aria-hidden="true">#</a> 写一段程序求出一段正负整数的最大连续和，如 1，2，5，-9， 12 ，15 -10，13 ，-7 最大的连续和就是12+15-10+13</h3>
<h3 id="php内存管理" tabindex="-1"><a class="header-anchor" href="#php内存管理" aria-hidden="true">#</a> PHP内存管理：</h3>
<h3 id="php的垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#php的垃圾回收机制" aria-hidden="true">#</a> php的垃圾回收机制：</h3>
<blockquote>
<blockquote>
<p>PHP 7中复杂类型的引用计数都维护在各个结构体头部的gc中，那么gc的作用是什么？答案是对垃圾回收的支持。什么是垃圾回收呢？垃圾回收是一种自动的内存管理机制，当一个变量在程序中不再被需要时，应该予以释放，这种内存资源管理称为垃圾回收。其中一种垃圾回收的方式是使用引用计数，通过对数据存储的物理空间多附加一个计数器空间，当其他数据与其相关时，计数器加一，反之，相关解除时计数器减一。定期检查各存储对象的计数器，计数器为零的话，则认为该对象已经被抛弃而应将其所占物理空间回收。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>PHP 7中垃圾回收的实现方法是定期遍历和标记若干存储对象的数组，再通过算法将是垃圾的物理空间回收。</p>
</blockquote>
</blockquote>
<p>PHP 7垃圾回收实际包含两部分，垃圾收集器和垃圾回收算法。垃圾收集器是将可能是垃圾的元素收集在回收池中，然后由垃圾回收算法回收。</p>
<p>（2）循环引用问题</p>
<p>以数组为例，在PHP 7中使用“&amp;”会改变等号两边zval的类型（改为IS_REFERENCE），引用计数记录在新的结构体（zend_reference）中，并且引用计数为2。这时如果等号两边是同一变量，那么这个变量的引用计数就变为2，自己引用自己。</p>
<p><img src="@source/docs/theme-reco/img/php面试题最全篇/image-20211205164710116.png" alt="image-20211205164710116"></p>
<p>当执行unset操作后，图3-14中$a所在的zval类型被标记为IS_UNDEF, zend_reference结构体的引用计数减1，但仍然大于0，这时候，后面的结构可能会成为垃圾，如图3-15所示，对此不处理可能会造成内存泄露。垃圾收集器会将这部分可能是垃圾的数据收集到缓冲区，同时加入到root环。</p>
<p>当缓冲区满了，再收集到新的元素就会触发垃圾回收算法。为了将右边的独立元素回收该如何实现这个算法。引用计数大于0说明它还在其他地方使用，那么先将元素的引用计数减1。如果发现引用计数为0，则说明任何地方都不再使用它，那么它就是垃圾，需要被回收掉。反之说明不是垃圾，需要将其从回收池移出去。而垃圾回收算法也是围绕这个核心条件进行的。</p>
<p>不是所有的PHP变量赋值都会用到引用计数，对于一个能否使用引用计数的变量也分以下几个类别：</p>
<p>1）变量是简单类型（true/false/double/long/null）时直接拷贝值，不需要引用计数；</p>
<p>2）变量是临时的字符串，在赋值时会用到引用计数，但如果变量是字符常量，则不会用到；</p>
<p>3）变量是对象（zval.v.type=IS_OBJECT）、资源（zval.v.type=IS_RESOURCE）、引用（zval.v.type=IS_REFERENCE，即$a=&amp;$b）类型时，赋值一定会用到引用计数；</p>
<p>4）变量是普通的数组，赋值时也会用到引用计数，变量是IS_ARRAY_IMMUTABLE时，赋值不使用引用计数。</p>
<p>一个zval是否支持引用计数，是通过zval.u1.type_flag来标识的，当type_flag的第三位被标识成1（IS_TYPE_REFCOUNTED标识），则代表可以引用计数。当然type_flag除了标识zval是否支持引用计数外，剩下的几位还可做其他标识，按位分割使用。</p>
<p>线程安全机制主要为了保证共享资源的安全。PHP的线程安全机制简洁直观——在多线程环境下，为每个线程提供独立的全局变量副本。具体实施是通过TSRM为每个线程分配（分配前加锁）一个独立ID（自增）作为当前线程的全局变量内存区索引，在以后的全局变量访问中，实现线程之间的完全独立。</p>
<h3 id="谈谈php的内存池" tabindex="-1"><a class="header-anchor" href="#谈谈php的内存池" aria-hidden="true">#</a> 谈谈php的内存池？</h3>
<blockquote>
<blockquote>
<p>PHP 7在内存管理上的CPU时间节省达到了21%，提升巨大。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>PHP 7的Zend MM借鉴了jemalloc和tcmalloc这两个成熟的内存管理方案。两者都在业内广泛应用：jemalloc是Firfox浏览器的默认内存管理器，而tcmalloc则是Chrome和Safari的默认内存管理器。抛开jemalloc和tcmalloc的实现细节，MM和“前辈”的内存分配思想是一致的：系统申请大块内存，再按固定的几种规格分割成较小的内存块，由内存池统一管理。当调用方申请内存时，从池子中匹配已经预分配的合适大小的内存块返回。</p>
<blockquote>
<blockquote>
<p>PHP 7的MM的核心代码在zend_alloc.c中实现，它维护了3种规格的内存，分别是chunk、page、slot，其中一个chunk大小是2MB，一个page是4KB，一个chunk可以划分成多个page，而一个page又可划分成多个slot，每种规格的内存的应用场景不同，因此它们的分配方式有所不同，对于MM而言，只有chunk是通过malloc的方式向系统申请内存的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>PHP是C实现的，在堆中运行。Zend MM也在堆内存运行，它根据完善的运行机制管理着内存的申请和释放。对于堆内存管理而言，chunk是最小操作单位。从本质上来说，所有类型的chunk都是内存中一块连续的区域，一个chunk的大小是2MB。</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/php面试题最全篇/image-20211210170426227.png" alt="image-20211210170426227"></p>
<p><img src="@source/docs/theme-reco/img/php面试题最全篇/image-20211210170505396.png" alt="image-20211210170505396"></p>
<p><img src="@source/docs/theme-reco/img/php面试题最全篇/image-20211210170514761.png" alt="image-20211210170514761"></p>
<h3 id="fastcgi及php运行流程" tabindex="-1"><a class="header-anchor" href="#fastcgi及php运行流程" aria-hidden="true">#</a> <strong>FastCGI及PHP运行流程</strong>：</h3>
<img src=".\img\高级PHP开发面试题目\image-20211210175459670.png" alt="image-20211210175459670" style="zoom:150%;" />
<h3 id="di、ioc-常用设计模式及使用场景" tabindex="-1"><a class="header-anchor" href="#di、ioc-常用设计模式及使用场景" aria-hidden="true">#</a> DI、IOC，常用设计模式及使用场景</h3>
<h3 id="php7-性能优化点及新特性有哪些" tabindex="-1"><a class="header-anchor" href="#php7-性能优化点及新特性有哪些" aria-hidden="true">#</a> PHP7 性能优化点及新特性有哪些</h3>
<h3 id="底层原理、垃圾回收机制" tabindex="-1"><a class="header-anchor" href="#底层原理、垃圾回收机制" aria-hidden="true">#</a> 底层原理、垃圾回收机制</h3>
<h3 id="php-fpm和nginx通讯的两种方式" tabindex="-1"><a class="header-anchor" href="#php-fpm和nginx通讯的两种方式" aria-hidden="true">#</a> php-fpm和nginx通讯的两种方式？</h3>
<p>tcp socket通信方式，需要在nginx配置文件中填写php-fpm运行的ip地址和端口号。</p>
<p>location ~ .php$ { include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; }</p>
<p>unix socket通信方式，需要在nginx配置文件中填写php-fpm运行的pid文件地址。</p>
<p>fastcgi_pass unix:/var/run/php5-fpm.sock;</p>
<h3 id="composer自动加载原理" tabindex="-1"><a class="header-anchor" href="#composer自动加载原理" aria-hidden="true">#</a> composer自动加载原理</h3>
<h3 id="_15-如何实现字符串翻转" tabindex="-1"><a class="header-anchor" href="#_15-如何实现字符串翻转" aria-hidden="true">#</a> 15.如何实现字符串翻转</h3>
<p>php内置函数处理英文字符串反转</p>
<p>strrev()</p>
<p>自定义函数处理字符串反转</p>
<p>function my_strrev($str) {</p>
<p>//获取字符串长度</p>
<p>$len = mbstrwidth($str);</p>
<p>$arr = $rev_arr = array();</p>
<p>//拆分字符串为数组</p>
<p>for($i=0;$i&lt;$len;$i++) {</p>
<p>​     $arr[] = mb_substr($str,$i,1);</p>
<p>}</p>
<p>//反转数组元素</p>
<p>$rev_arr = array_reverse($arr);</p>
<p>//重组数组为字符串</p>
<p>return implode(‘’,$rev_arr);</p>
<p>}</p>
<h3 id="_16-mysql取得当前时间的函数以及格式化日期的函数" tabindex="-1"><a class="header-anchor" href="#_16-mysql取得当前时间的函数以及格式化日期的函数" aria-hidden="true">#</a> 16.MYSQL取得当前时间的函数以及格式化日期的函数</h3>
<p>current_timestamp</p>
<p>date_format</p>
<h3 id="_17-如何修改session的生存时间" tabindex="-1"><a class="header-anchor" href="#_17-如何修改session的生存时间" aria-hidden="true">#</a> 17.如何修改SESSION的生存时间</h3>
<p>session_set_cookie_params</p>
<h3 id="_19-在php中-heredoc是一种特殊的字符串-如何使用" tabindex="-1"><a class="header-anchor" href="#_19-在php中-heredoc是一种特殊的字符串-如何使用" aria-hidden="true">#</a> 19.在PHP中，heredoc是一种特殊的字符串，如何使用</h3>
<p>作用相当于引号，成对出现</p>
<p>$a = &lt;&lt;HEREDOC</p>
<p>this is a test</p>
<p>HEREDOC;</p>
<h1 id="七-thinkphp框架面试题" tabindex="-1"><a class="header-anchor" href="#七-thinkphp框架面试题" aria-hidden="true">#</a> 七.thinkphp框架面试题</h1>
<h3 id="_1-如何理解thinkphp框架中的单一入口文件" tabindex="-1"><a class="header-anchor" href="#_1-如何理解thinkphp框架中的单一入口文件" aria-hidden="true">#</a> 1.如何理解ThinkPHP框架中的单一入口文件？</h3>
<p>答：ThinkPHP采用单一入口模式进行项目部署和访问，无论完成什么功能，一个项目都有一个统一（但不一定是唯一）的入口。应该说，所有项目都是从入口文件开始的，并且所有的项目的入口文件是类似的，入口文件中主要包括：</p>
<p>定义框架路径、项目路径和项目名称（可选）</p>
<p>定义调试模式和运行模式的相关常量（可选）</p>
<p>载入框架入口文件（必须）</p>
<p>ThinkPHP如何防止SQL注入？（理解）
（1）查询条件尽量使用数组方式，这是更为安全的方式；</p>
<p>（2）如果不得已必须使用字符串查询条件，使用预处理机制；</p>
<p>（3）开启数据字段类型验证，可以对数值数据类型做强制转换；（3.1版本开始已经强制进行字段类型验证了）</p>
<p>（4）使用自动验证和自动完成机制进行针对应用的自定义过滤；</p>
<p>（5）使用字段类型检查、自动验证和自动完成机制等避免恶意数据的输入。</p>
<h3 id="_2-thinkphp中的mvc分层是什么-理解" tabindex="-1"><a class="header-anchor" href="#_2-thinkphp中的mvc分层是什么-理解" aria-hidden="true">#</a> 2.ThinkPHP中的MVC分层是什么？（理解）</h3>
<p>MVC 是一种将应用程序的逻辑层和表现层进行分离的方法。ThinkPHP 也是基于MVC设计模式的</p>
<p>MVC只是一个抽象的概念，并没有特别明确的规定，ThinkPHP中的MVC分层大致体现在：</p>
<p>模型（M）：模型的定义由Model类来完成。</p>
<p>控制器（C）：应用控制器（核心控制器App类）和Action控制器都承担了控制器的角色，Action控制器完成业务过程控制，而应用控制器负责调度控制。</p>
<p>视图（V）：由View类和模板文件组成，模板做到了100％分离，可以独立预览和制作。</p>
<p>但实际上，ThinkPHP并不依赖M或者V ，也就是说没有模型或者视图也一样可以工作。甚至也不依赖C，这是因为ThinkPHP在Action之上还有一个总控制器，即App控制器，负责应用的总调度。在没有C的情况下，必然存在视图V，否则就不再是一个完整的应用。</p>
<p>总而言之，ThinkPHP的MVC模式只是提供了一种敏捷开发的手段，而不是拘泥于MVC本身。</p>
<p>如何理解 ThinkPHP架构（核心 + 行为 + 驱动）中的行为？
TP官方简称为：CBD</p>
<p>核心（Core）：就是框架的核心代码，不可缺少的东西，TP本身是基于MVC思想开发的框架。</p>
<p>行为（Behavior） ：行为在新版ThinkPHP的架构里面起着举足轻重的作用，在系统核心之上，设置了很多标签扩展位，而每个标签位置可以依次执行各自的独立行为。行为扩展就因此而诞生了，而且很多系统功能也是通过内置的行为扩展完成的，所有行为扩展都是可替换和增加的，由此形成了底层框架可组装的基础。</p>
<p>驱动（ Driver ）：数据库驱动、缓存驱动、标签库驱动和模板引擎驱动，以及外置的类扩展。</p>
<p>框架，即framework。其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。而且，框架一般是成熟的，不断升级的软件。</p>
<h3 id="_3-thinkphp-与-laravel-框架的区别" tabindex="-1"><a class="header-anchor" href="#_3-thinkphp-与-laravel-框架的区别" aria-hidden="true">#</a> 3.ThinkPHP 与 Laravel 框架的区别</h3>
<p>一、渲染模版方式的不同</p>
<p>在Laravel框架里，使用return view()来渲染模版；而ThinkPHP里则使用了$this-&gt;display()的方式渲染模版。</p>
<p>二、POST提交数据的方式</p>
<p>Laravel在提交表单时需要在表单中加入下面的标签信息来防止跨域攻击，而TP不会。
<input type="hidden" name="_token" value="{{csrf_token()}}" /></p>
<p>三、路由</p>
<p>Laravel必须先定义，再使用，路由文件为routes.php；TP在配置文件中开启路由后，路由格式是：’路由表达式’ =&gt; ‘路由地址和参数’（使用路由的前提是URL支持phthinfo并且开启路由），路由可以使URL更符合SEO。</p>
<p>四、中间件</p>
<p>Laravel特点，可以实现访问前后的处理，例如请求和返回，权限认证等;</p>
<p>TP5版本中，5.1支持中间件，5.0不支持，但是在TP6版本中则直接支持中间件，跟Laravel的几乎相同。</p>
<h3 id="_10、-thinkphp如何防止sql注入-理解" tabindex="-1"><a class="header-anchor" href="#_10、-thinkphp如何防止sql注入-理解" aria-hidden="true">#</a> <strong>10、 ThinkPHP如何防止SQL注入？（理解）</strong></h3>
<p>（1）查询条件尽量使用数组方式，这是更为安全的方式；</p>
<p>（2）如果不得已必须使用字符串查询条件，使用预处理机制；</p>
<p>（3）开启数据字段类型验证，可以对数值数据类型做强制转换；（3.1版本开始已经强制进行字段类型验证了）</p>
<p>（4）使用自动验证和自动完成机制进行针对应用的自定义过滤；</p>
<p>（5）使用字段类型检查、自动验证和自动完成机制等避免恶意数据的输入。</p>
<h3 id="_11、-如何开启调试模式-调试模式有什么好处" tabindex="-1"><a class="header-anchor" href="#_11、-如何开启调试模式-调试模式有什么好处" aria-hidden="true">#</a> <strong>11、 如何开启调试模式？调试模式有什么好处？</strong></h3>
<p>开启调试模式很简单，只需要在入口文件中增加一行常量定义代码：</p>
<?php

　　//开启调试模式

　　 define('APP_DEBUG', true);

　　//加载框架入口文件

　　 require './ThinkPHP/ThinkPHP.php';

　　在完成开发阶段部署到生产环境后，只需要删除调试模式定义代码即可切换到部署模式。开启调试模式后，系统会首先加载系统默认的调试配置文件，然后加载项目的调试配置文件，调试模式的优势在于：

　　开启日志记录，任何错误信息和调试信息都会详细记录，便于调试；

　　关闭模板缓存，模板修改可以即时生效；

　　记录SQL日志，方便分析SQL；

　　关闭字段缓存，数据表字段修改不受缓存影响；

　　严格检查文件大小写（即使是Windows平台），帮助你提前发现Linux部署问题；

　　可以方便用于开发过程的不同阶段，包括开发、测试和演示等任何需要的情况，不同的应用模式可以配置独立的项目配置文件。

**12.、TP中支持哪些配置模式？优先级？**

ThinkPHP在项目配置上面创造了自己独有的分层配置模式，其配置层次体现在：

　　惯例配置->项目配置->调试配置->分组配置->扩展配置->动态配置

　　以上是配置文件的加载顺序，因为后面的配置会覆盖之前的同名配置（在没有生效的前提下），所以优先顺序从右到左。

**13. TP中的URL模式有哪几种？默认是哪种？**

ThinkPHP支持四种URL模式，可以通过设置URL_MODEL参数来定义，包括普通模式、PATHINFO、REWRITE和兼容模式。

　　默认模式为：PATHINFO模式，设置URL_MODEL 为1

**14、TP中系统变量有哪些？如何获取系统变量？**

获取系统变量的方法：

　　只需要在Action中调用下面方法：

$this->方法名("变量名",["过滤方法"],["默认值"])

**15、ThinkPHP框架中D函数与M函数的区别是什么？**

答：M方法实例化模型无需用户为每个数据表定义模型类，D方法可以自动检测模型类，如果存在自定义的模型类，则实例化自定义模型类，如果不存在，则会自动调用M方法去实例化Model基类。同时对于已实例化过的模型，不会重复去实例化（单例模式）。

**16、双引号和单引号的区别**
双引号解释变量，单引号不解释变量
双引号里插入单引号，其中单引号里如果有变量的话，变量解释
双引号的变量名后面必须要有一个非数字、字母、下划线的特殊字符，或者用{}讲变量括起来，否则会将变量名后面的部分当做一个整体，引起语法错误
双引号解释转义字符，单引号不解释转义字符，但是解释'\和\\
能使单引号字符尽量使用单引号，单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，而单引号则不需要判断）

**17、对于大流量网站，采用什么方法来解决访问量的问题**
确认服务器硬件是否能够支持当前的流量
数据库读写分离，优化数据表
程序功能规则，禁止外部的盗链
控制大文件的下载
使用不同主机分流主要流量



由于TP5.0是一个全新的颠覆重构版本，所以现在面试很多面试官喜欢问TP3.2和TP5之间的区别，那他们之间到底有哪些区别呢？
一、目录
TP3.2目录

![img](.\img\最高级多方面面试题\093119intu6f3wpzlwpgtf.jpg.thumb.jpg)

TP5目录

![img](.\img\最高级多方面面试题\092855e7vr6paf6vw7r0wm.png.thumb.jpg)


二、需要摒弃的 3.X 旧思想

模型的变动
       新版的模型查询返回默认‘对象’，系统默认增加了'toArray'方法，许多开发者在'all'或'select'尝试使用'toArray'来 转换为数组，但是 'all'或'select'结果是对象的数组集合，是无法使用'toArray'进行转换的，如果你强行使用foreach进行转换，后期会增加很多操作，也会出现很多意想不到的bug。所以我们在开发的时候，要去理解‘对象’的概念，尝试使用‘对象’进行数据的使用。

三、TP5新版的变化
命名规范
目录和文件名采用‘小写+下划线’，并且以小写字母开头；
类库、函数文件统一以.php 为后缀；
类的文件名均以命名空间定义，并且命名空间的路径和类库文件所在路径一致（包括大小写）；
类名和类文件名保持一致，并统一采用驼峰法命名（首字母大写）
函数
系统已经不依赖任何函数，只是对常用的操作封装提供了助手函数；
单字母函数废弃，默认系统加载助手函数；
路由
        5.0 的 URL 访问不再支持普通 URL 模式，路由也不支持正则路由定义，而是全部改为规则路由配合变量规则（正则定义）的方式。
控制器
        控制器的命名空间有所调整，并且可以无需继承任何的控制器类。
应用类库的命名空间统一为 app（可修改）而不是模块名；
控制器的类名默认不带Controller后缀，可以配置开启controller_suffix参数启用控制器类后缀；
控制器操作方法采用return方式返回数据，而非直接输出；
废除原来的操作前后置方法；

控制器版本对比
tp3

![img](.\img\最高级多方面面试题\095017r1431m4g1xmlxhzz.jpg.thumb.jpg)

tp5

![img](.\img\最高级多方面面试题\095017il9y2z6bdy6y62mj.jpg.thumb.jpg)

       TP3.2控制器命名必须以Controller.class.php结尾，而TP5是以.php结尾；
       TP3.2控制器模版输出使用$this->display()方法，而在TP5中如果继承基础控制器使用$this->fetch()方法，没有继承使用view()助手函数即可；
模型
        5.0 的数据库查询功能增强，原先需要通过模型才能使用的链式查询可以直接通过 Db 类调用，原来的 M 函数调用可以改用 db 函数，例如：
3.2 版本
M('User')->where(['name'=>'thinkphp'])->find();
5.0 版本
db('User')->where('name','thinkphp')->find();
       新版的模型查询增加了静态方法，例如：

![img](.\img\最高级多方面面试题\101330ai8jvofike64k6fu.jpg.thumb.jpg)


系统常量的废弃
          对于TP3.2，TP5废弃了很多的常量，如果开发这有需求可以自定义，有些常量的功能可以通过request()获取,其中废弃的常量有：
REQUEST_METHOD
IS_GET
IS_POST
IS_PUT
IS_DELETE
IS_AJAX
__EXT__
COMMON_MODULE
MODULE_NAME
CONTROLLER_NAME
ACTION_NAME
APP_NAMESPACE
APP_DEBUG
MODULE_PATH
        
模型
       TP5支持think命令创建控制器模型，而TP3.2不支持；

四、助手函数

![img](.\img\最高级多方面面试题\102608kqyibjiki73553cg.jpg.thumb.jpg)





# 八.laravel面试题：

### 17、写出常用的 laravel artisan 常用命令 ？

### 11、什么情况下使用到队列？

### 12、延时队列使用场景？

### 13、laravel 中 队列相关的命令？

### 14、laravel 基于什么来做队列？

### 20.简述laravel运行原理？(重点)

```
一、生命周期
1. 入口文件：
Laravel框架所有请求入口统一进入/public/index.php文件，请求通过Ngxin/Apache指向该文件。
index.php文件是加载其他文件入口，本身代码不多。index.php文件载入通过Composer生产的自动加载配置，然后从bootstrap/app.php获取应用实例，创建服务容器。
2.Http/Console内核
接上面，请求被发送到HTTP内核或Console内核，取决于应用请求类型（会在下篇文章说明）。这两个内核为所有请求必须经过的中央处理器，
下面介绍App\Http\Kernel的HTTP内核：
HTTP内核 继承自Illuminate\Foundation\Http\Kernel类，该类定义了一个bootstrappers数组，该数组中的类在请求被执行前运行，bootstrappers配置了错误处理、日志、检测应用环境、其他在请求被处理前需要处理的任务。
HTTP内核还定义请求处理前需要经过HTTP中间件，该中间件处理HTTP会话的读写、判断应用是否处于维护模式，验证CSRF令牌（防止CSRF攻击）等。
HTTP内核标签方法handle：获取一个Request，返回一个Response，输入HTTP请求，返回HTTP响应。
3.服务提供者
内核启动会为应用载入服务提供者，服务提供者都被配置在config/app.php配置文件的providers数组中。服务提供者被注册后，boot方法被调用。
服务提供者负责启动框架的所有组件，如数据库、队列、验证器、路由组件等。因他们启动并配置框架提供的所有特性，服务提供者是整个Laravel启动过程中最重要部分。
「延迟」提供器：即providers数组中较多服务都是提供的实际服务需要才会加载。
4. 分发请求
一旦应用被启动且所有服务提供者被注册，Request将会被交给路由器进行分发，路由器将会分发请求到路由或控制器，同时运行所有路由指定的中间件。
二、服务提供者
服务提供是启动Laravel关键部分，应用实例被创建，服务提供被注册，请求被启动后的应用进行处理。
默认存放在app/Providers目录下。
```

### 125、laravel 源码是否看过 ?

### 126、laravel 中间件的配置 ?

### 127、laravel 在路由中的使用 ? 

### 4、laravel 的 依赖注入 的原理 ?

### 21.laravel路由实现原理？(重点)

### **1、什么是 HTTP 中间件？**

HTTP 中间件是一种用于过滤 HTTP 请求的技术。Laravel 包含一个中间件，用于检查应用程序用户是否已通过身份验证。

### **2、聚合查询生成器的方法名称**

查询构建器的聚合方法是：1) max ()，2) min ()，3) sum ()，4) avg () 和 5) count ()。

### **3、什么是 Route ?**

路由基本上是由 URI (统一资源标识符) 指定的端点。它在 Laravel 应用程序中充当指针。

最常见的是，路由指向控制器上的方法，还指出哪些 HTTP 方法可以访问该 URI。

### **4、 解释 Laravel 中的反向路由。**

反向路由是一种基于符号或名称生成 URL 的方法。它使您的 Laravel 应用程序变得灵活。

### **5、解释 Laravel 中 traits 的特征**

Laravel traits 是包含在另一个类中的一组函数。一个 trait 就像一个抽象类。您不能直接实例化它，但是可以在其他的类中试用它的方法。

### **6、 解释 Laravel 中契约的概念。**

它们是 Laravel 框架的接口集合。这些契约提供核心服务。Laravel 中的契约包括相应的框架实现。

**laravel跟tp都是PHP主流的框架，点击这里还有tp的面试题，感兴趣的小伙伴可以去了解一下。**

### **7、如何注册您的服务提供者？**

您可以在 config/app.php 配置文件中注册服务提供者，该配置文件包含一个数组，您可以在其中配置服务提供者的类名。

### **8、如何定义 Laravel 的门面？**

所有的门面都定义在 Illuminate.upport.acades 命名空间当中。

### **9、 Laravel 中的服务容器是什么**

服务容器是用于在 Laravel 中执行依赖注入的工具。用于存储各种注入到容器中的类库对象，首先会经过绑定到容器，然后在通过反射机制获取里面的对象，或者的时候会根据绑定的类型进行判断，例如有类、闭包、实例对象。会根据类型进行获取。

IOC:控制反转，从容器获取相关对象就为控制反转。控制正转就是自己实例自己的对象，给自己使用。而有了容器，就是由它帮助我们完整创建对象的过程。

DI:依赖注入，例如A类需要B类提供的功能，它们就存在依赖关系，而注入只是把对象B交给对象A。

### **10、如何在 Laravel 中开启查询日志？**

您可以使用 enableQueryLog 方法在 Laravel 中启用查询日志。

### **11、 解释 Laravel 中事件的概念。**

事件是一种动作或者操作，可以帮助您订阅和侦听 Laravel 应用程序中发生的事件。当发生任何活动时，Laravel 会自动出发某些事件。

### **12、 说一下依赖注入和依赖注入的类型.**

它是‘其中一种对象依赖于另一个对象’的技术。
依赖注入有三种类型:

• 1) 构造函数注入

• 2) setter 注入

• 3) 接口注入.

### **13、 使用 laravel 有什么优势吗？**

下面是 laravel 的主要优点:

• Laravel 具有 blade 模板引擎，可创建动态布局并增加编译任务.

• 可以很简单的复用代码.

• 您不需要手动维护和包含路径，因为 Laravel 具有自动加载功能.

• 该框架可帮助您使用 LOC 容器制作新工具.

• Laravel 提供了一个版本控制系统，可帮助简化迁移管理.

### **14、 说明 Laravel 中验证的概念.**

在设计任何 Laravel 应用程序时，验证是一个重要的概念。它可以确保在将数据存储到数据库之前，数据始终采用预期的格式。Laravel 提供了多种验证数据的方法。
基础控制器特征是使用 ValidatesRequests 类，该类提供了一种有用的方法来验证来自客户端计算机的请求。

### **15、 ORM 代表什么？**

ORM 代表对象关系映射，把数据库相关字段映射到对应的模型对象里面，相当于有多个一个抽象层。后面直接操作对象

### **16、 如何减少 Laravel 中的内存使用？**

在处理大量数据时，可以使用 cursor 方法以减少内存使用量

### **17、定义一下 Laravel 使用的模板引擎.\*，加载原理是什么？**

Blade 是 Laravel 使用的功能强大的模板引擎。laravel根据路由检查到需要展示视图的时候，会根据请求文件的后缀找到对应的引擎，然后在进行渲染，并缓存为对应的静态文件。

### **18、为什么迁移很重要？**

迁移非常重要是因为它允许您通过维护数据库一致性来共享应用程序。
如果不进行迁移，则很难共享任何 Laravel 应用程序。
它还允许您同步数据库。

### **19、 解释 PHP artisan**

artisan 是 Laravel 的命令行工具。它提供的命令可帮助您轻松构建 Laravel 应用程序。

### **20、 如何生成软链接？**

Laravel 用 php artisan storage:link 生成软链接。这样可以让不显示的目录供给公共请求的访问到资源。

### **21、哪个类用于处理异常？**

Laravel 异常由 App.exceptions.handler 类处理。

### **22、 什么是常见的 HTTP 错误代码？**

最常见的 HTTP 错误代码是：

\- 错误 404 –未找到页面时显示。
\- 错误 - 401 –未授权错误时显示

### **23、 在 Laravel 中解释 Fluent 查询生成器。**

它是一个数据库查询生成器，它提供了方便，快捷的界面来创建和运行数据库查询。

### **24、 列出 Laravel 中使用的常见 artisan 命令。**

Laravel 支持以下工匠命令：

• PHP artisan down;

• PHP artisan up;

• PHP artisan make:controller;

• PHP artisan make:model;

• PHP artisan make:migration;

• PHP artisan make:middleware;

### **25、 在 Laravel 中 如何配置邮件发送？**

Laravel 提供了一些 API，可以在本地和实时服务器上发送电子邮件。

### **26、授权是什么东西**

这是一种使用密码标识用户登录凭据的方法。在 Laravel 中，可以使用带有两个参数 1) 用户名和 2) 密码的会话来管理它。

### **27、 delete ()：从数据库表中删除所有记录**

-delete ()：从数据库表中删除所有记录。
-softDeletes ()：不会从表中删除数据。它用于将任何记录标记为已删除。但需要安装好软删除。

### **28、您将如何检查表是否在数据库中存在？**

使用 Laravel 中的 hasTable () 函数检查所需的表是否在数据库中存在。

**29、 Laravel 中 insert () 和 insertGetId () 函数之间的显著区别是什么？**

• Insert (): 此函数仅用于将记录插入数据库。不返回自增 ID

• InsertGetId (): 此函数会在表中插入一条记录，但当 ID 字段自动递增时使用。（插入记录并返回自增的 ID）

### **30、 定义隐式控制器。**

隐式控制器可帮助您定义适当的路由来处理控制器操作。您可以使用 Route :: controller () 方法在 route.php 文件中定义它们。

### **31、 如何在 Laravel 模型中自定义表名？**

自定义表名，您可以重写 protected 变量 $ table 的值。

### **32、 定义 @include.**

@include 用于加载多个模板视图文件。它可以帮助您将视图包括在另一个视图中。用户还可以在一个视图中加载多个文件。

### **33、 什么是 Eloquent?**

Eloquent 是 在 laravel 中使用的 ORM 。它提供了简单的 active record 实现， 配合数据库使用。每个数据库表都有其模型，该模型用于与表进行交互。

### **34、 解释 Laravel guard (卫兵)**

Laravel Guard 是一个用于查找经过身份验用户的特殊组件。
最初将请求的传入路由通过此防护来验证用户输入的凭据。防护措施在../config/auth.php 文件中定义。

### **35、 什么是 Laravel API 限流？**

这是 Laravel 的功能。它提供了限流处理功能。限流可帮助 Laravel 开发人员开发安全的应用程序并防止 DOS 攻击。

### **36、 解释laravel 中的集合 Collections.**

集合 Collections 是用于数组的包装器类。Laravel Eloquent 的查询使用一组最常用的函数来返回数据库结果。

### **37、 DB Facade 的用途是什么？**

DB Facade 用于运行 SQL 查询，例如创建，查询，更新，插入和删除。主要是用到了门面的静态代理，通过门面把相关类库代理到容器里面的操作类库。

### **38、** **对象关系映射的用途是什么？**

对象关系映射是一种技术，可帮助开发人员在不考虑对象及其数据源之间的关系的情况下寻址，访问和操纵对象。

### **39、** **解释 Laravel 中的路由概念。**

它允许将您所有的应用程序请求路由到控制器。Laravel 路由确认并接受带闭包的统一资源标识符。

### **40、说明身份验证和授权之间的区别。**

认证是指通过凭据确认用户身份，而授权是指收集对系统的访问权限。

### **41、什么监听器 - listeners，应用场景有哪些**

在EventServiceProvider的linsten数组里面加上事件和监听器，键名是事件，键值里面的数组是一个或者多个监听器，当某一个事件发生的时候，传送给数组里面的那些个监听器，在执行一系列相关的操作

场景： 发送短信验证码事件、邮件、通知类相关

### **42、什么策略类？**

策略类包括 Laravel 应用程序的授权逻辑。这些类用于特定的模型或资源。

### **43、什么是IOC(控制反转)？**

IOC是一种设计思想，它主要控制了外部资源获取（不只是对象包括比如文件等）。并且由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以叫控制反转。

### **43、** **具体讲讲依赖注入？**

由容器动态的将某个依赖关系注入到组件之中，依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。

“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。

### **44、** **什么是反射？**

反射可以理解成根据类名返回该类的任何信息，它主要用来动态地获取系统中类、实例对象、方法等语言构件的信息，通过反射API函数可以实现对这些语言构件信息的动态获取和动态操作等。同时反射添加了对类、接口、函数、方法和扩展进行反向工作的能力。在Laravel框架中，服务容器解析服务的过程中就用到了反射机制。

### **45、** **service服务容器是什么？**

服务容器是一个用于管理类依赖和执行依赖注入的强大工具，也可以理解为就是一个自动产生类的工厂。

### **46、** **Laravel+Redis广播如何实现？**

Redis 广播使用 Redis 的 pub/sub 功能进行广播；同时你需要将其和能够接受 Redis 消息的 Websocket 服务器进行配对以便将消息广播到 Websocket 频道。

当 Redis 广播发布事件时，事件将会被发布到指定的频道上，传递的数据是一个 JSON 格式的字符串，其中包含了事件名称、数据明细 data、以及生成事件socket ID 的用户。

在消息推送的场景下，我们可以使用 WebSocket 协议来处理实时交互，它是一种双向协议，允许服务端主动推送信息到客户端。需要涉及内容如下：

1>Laravel Event

2>Redis

3>[http://Socket.io](https://link.zhihu.com/?target=http%3A//Socket.io)

4>Node.js

具体配置步骤如下：

1.安装Predis库

composer require predis/predis
2.安装 laravel-echo-server

npm install -g laravel-echo-server

3.初始化 Socket 服务：

laravel-echo-server init

4.启动服务

laravel-echo-server start 启动

**其实这个广播可以拆解为几个部分，消息队列，发布订阅，广播，这些内容我都是有讲过对应的一些视频，有需要的小伙伴也可以关注私聊我获取。**

### **47、** **任务调度是什么？**

Cron 脚本能使计划任务定期地在系统后台自动运行。一般会在队列场景应用。

可以定时周期的去进行实现，比如时间节点，比如每周一，周末，每十分钟这些。

### **48、** **Blade模板是什么？它的模板继承优势在哪？为什么要使用它？**

Blade模板是Laravel提供一个既简单又强大的模板引擎；

和其他流行的PHP模板引擎不一样，他并不限制你在视图里使用原生PHP代码；

### 1) 什么是 Laravel ?

Laravel 是一个开源的、广泛使用的 PHP 框架。该平台主要用于利用 MVC 架构模式开发 web 应用程序。Laravel 是在 MIT 许可下发布的。

因此，其源代码托管在 GitHub 上。它遵循可靠且准确的语言规则，因此是可靠的 PHP 框架。

Laravel是一个基于Symfony的免费开源PHP Web框架。 它由Taylor Otwell创建，允许开发人员编写富有表现力的优雅语法。 Laravel内置了对用户身份验证和授权的支持，这在一些最流行的PHP框架（如CodeIgniter，CakePHP）中缺失。

### 2) 定义 Composer.

它是 PHP 的应用程序级程序包管理器。它提供了用于管理 PHP 软件依赖项和库的标准格式。

### 3.Laravel的依赖注入实现原理

### 88) 解释 Laravel 中加密和解密的概念.

加密是使用某些算法以第三用户无法读取信息的方式转换任何信息的过程。加密可以保护您的敏感信息不受入侵。

使用加密过程执行加密。要加密的消息称为纯消息。加密后获得的消息称为密码消息。将密文转换为纯文本或消息时，此过程称为解密。

### 87) 定义 Laravel 中的 hashing .

这是将文本转换为显示原始文本的 key 的方法。 Laravel 使用 Hash facade 以哈希方式安全地存储密码。

### 85) 解释 Laravel 中的 Loggin 。

它是一种生成系统错误日志的技术。 Loggin 有助于提高系统的可靠性。 Laravel 支持各种日志记录模式，例如 syslog，每日，单次和错误日志记录模式。

### 86) 什么是本地化？

Laravel 的一个功能是支持应用程序中使用的各种语言。开发人员可以在文件中存储不同语言的字符串，这些文件存储在 resources /views 文件夹中。开发人员应为每种支持的语言创建一个单独的文件夹。

### 3) 什么是 HTTP 中间件？

HTTP 中间件是一种用于过滤 HTTP 请求的技术。 Laravel 包含一个中间件，用于检查应用程序用户是否已通过身份验证。

Laravel中有两种类型的中间件。

- 全局中间件：将在应用程序的每个HTTP请求上运行。
- 路由中间件：将被分配到特定路由。

### 4) 聚合查询生成器的方法名称

查询构建器的聚合方法是：1) max ()，2) min ()，3) sum ()，4) avg () 和 5) count ()。

### 5) 什么是 Route ?

路由基本上是由 URI (统一资源标识符) 指定的端点。它在 Laravel 应用程序中充当指针。

最常见的是，路由指向控制器上的方法，还指出哪些 HTTP 方法可以访问该 URI。

### 1、Laravel Ioc是什么？请简述Ioc的实现原理

控制反转（IOC）模式(又称DI：DependencyInjection)就是Inversion ofControl，控制反转。在Java开发中，IoC意 味着将你设计好的类交给系统去控制，而不是在你的类内部控制。这称为控制反转。

IoC(Inversion of Control)是近年来兴起的一种思想，不仅仅是编程思想。主要是协调各组件间相互的依赖关系，同时大大提高了组件的可移植性，组件的重用机会也变得更多。在传统的实现中，由程序内部代码来控制程序之间的关系。我们经常使用new关键字来实现两组键间关系的组合，这种实现的方式会造成组件之间耦合(一个好的设计，不但要实现代码重用，还要将组件间关系解耦)。IoC很好的解决了该问题，它将实现组件间关系从程序内部提到外部容器来管理。也就是说由容器在运行期将组件间的某种依赖关系动态的注入组件中。控制程序间关系的实现交给了外部的容器来完成。即常说的好莱坞原则“Don't call us, we'll call you”。
![image-20211217142632313](.\img\最高级多方面面试题\image-20211217142632313.png)

在请求流程图中可以看到有两个比较重要的文件start.php和Application.php，其中，start.php文件中引入了全局变量$app = new Illuminate\Foundation\Application;注意该全局变量$app就是为我们解决所有注入依赖关系的“管家婆”，它会把应用中所用到的工具类提前存储起来，当用到的时候可以随时的提取。

利用控制反转和别名的好处：

Laravel中通过控制反转的方式可以解决相同的调用方式，但可以采取不同的实现方式。这样我们就不用更改业务逻辑中的代码，就能更换不同的解决问题的方式。

例如，Laravel用到的Cache，在业务逻辑代码中只需要使用Cache::set()，就可以设置cache缓存了。但是，具体是用什么方式做的cache我们是不用关心的。因为，$app[‘cache’]中即可以存放redis的实例，也可以存放memcache的实例，这个是可以通过配置文件来确定的。

如果要是用传统的cache方式，将会是Redis::set()或者是Memcache::set()的方式，这样我们在想换不同的cache存储方式的时候就要通过更改业务逻辑代码才能完成。

### 2、基于Laravel开发的web系统，有哪些方式可以提升系统的整体性能

### 7、如果让你设计一个后台管理系统，要求进行权限分级，你如何设计

### 8、如何让你设计一个多商户平台，你会如何设计数据库

### 4.你了解哪些设计模式，请简要说明3个

单例模式，策略模式，工厂模式，观察者模式

### 6) 为什么使用 Route?

路由存储在项目根目录下 /routes 文件夹下的文件内。默认情况下，有几个不同的文件对应于应用程序的不同 “面”(“面” 来自六角形体系结构方法)。

### 8) 解释通用 Laravel 应用程序中使用的重要目录。

常见的 Laravel 应用程序中使用的目录是：

- App/: 这是我们的应用程序代码所在的源文件夹。所有控制器，策略和模型都在此文件夹中。
- Config/: 保存应用程序的配置文件。这些通常不会直接修改，而是取决于在应用程序根目录下的 .env (环境) 文件中设置的值。
- Database/: 存放数据库文件，包括 迁移，数据填充，和测试工厂。
- Public/: 可公开访问的文件夹，其中包含已编译资源，当然还有 index.php 文件。

### 10) 解释 Laravel 中的反向路由。

反向路由是一种基于符号或名称生成 URL 的方法。它使您的 Laravel 应用程序变得灵活。

Laravel反向路由根据路由声明生成URL。反向路由使应用程序更加灵活。 它定义了链接和Laravel路由之间的关系。 使用现有路径的名称创建链接时，Laravel会自动创建相应的Uri。 下面是反向路由的一个例子。

```
// route declaration
Route::get('login', 'users@login');
```

使用反向路由，我们可以创建一个链接，并传入定义的任何参数。 如果未提供，可选参数将从生成的链接中删除。

```css
{{ HTML::link_to_action('users@login') }}
```

PHP它会在视图中自动生成类似 http://xyz.com/login 的网址。

### 20. 如何通过 composer 来安装laravel？

可以通过运行以下命令来使用 composer 安装Laravel。

```ruby
$ composer create-project laravel/laravel your-project-name version
```

### 12) 解释 Laravel 中 traits 的特征。

Laravel traits 是包含在另一个类中的一组函数。 一个 trait 就像一个抽象类。您不能直接实例化它，但是可以在其他的类中试用它的方法。创建了Trait以减少PHP中单一继承的限制。

```
trait Sharable {
  public function share($item)
  {
    return 'share this item';
  }
}
```

然后，可以将此Trait包含在其他类中，如下所示：

```
class Post {
  use Sharable;
}
class Comment {
  use Sharable;
}
```

现在，如果要从这些类中创建新对象，会发现它们都有`share()`方法可用：

```
$post = new Post;
echo $post->share(''); // 'share this item' 
 
$comment = new Comment;
echo $comment->share(''); // 'share this item'\n
```



### 13) 解释 Laravel 中契约的概念。

它们是 Laravel 框架的接口集合。 这些契约提供核心服务。 Laravel 中的契约包括相应的框架实现。契约(Contracts) 只不过是一组定义Laravel框架提供的核心服务的接口。

### 14) 如何注册您的服务提供者？

您可以在 config/app.php 配置文件中注册服务提供者，该配置文件包含一个数组，您可以在其中配置服务提供者的类名。

### 13. 什么是服务提供商/提供者？

服务提供商是所有laravel应用程序引导的中心位置。 您的应用程序以及所有Laravel核心服务也由服务提供商引导。
所有服务提供商都扩展了`IlluminateSupportServiceProvider`类。 大多数服务提供者包含寄存器和引导方法。 在`register`方法中，应该只将事物绑定到服务容器中。永远不应尝试在`register`方法中注册任何事件侦听器，路由或任何其他功能。

### 15. 请解释laravel中的验证？

在编程中，验证是一种方便的方法，可确保数据在进入数据库之前始终处于干净且预期的格式。 Laravel提供了几种不同的方法来验证应用程序传入数据。默认情况下，Laravel的基本控制器类使用`ValidatesRequests`特性，它提供了一种方便的方法来验证来自客户端的所有传入HTTP请求。还可以通过创建表单请求来验证laravel中的数据。

### 15) 如何定义 Laravel 的门面？

所有的门面都定义在 Illuminate\Support\Facades 命名空间当中。

### 17) 列出 Laravel 5.6 中的软件包

Laravel 5.6 中的默认软件包为：
1) Envoy, 2) Passport, 3) Socialite, 4) Cashier, 5) Horizon, 6) Scout.

### 18) Laravel 中的服务容器是什么

服务容器是用于在 Laravel 中执行依赖注入的工具。

### 5. Laravel中的依赖注入是什么？

在软件工程中，依赖注入是一种技术，其中一个对象提供另一个对象的依赖关系。 依赖项是可以使用的对象（服务）。 注入是将依赖项传递给将使用它的依赖对象（客户端）。 该服务成为客户所在州的一部分。将服务传递给客户端，而不是允许客户端构建或查找服务，是模式的基本要求。

参考：https://en.wikipedia.org/wiki/Dependency_injection

可以通过Constructor，setter和property injection进行依赖注入。

### 7. 如何关闭Laravel中特定路由的CSRF保护？

要在Laravel中关闭CSRF保护，请在文件：*app/Http/Middleware/VerifyCsrfToken.php* 中添加以下代码 -

```
//add an array of Routes to skip CSRF check
private $exceptUrls = ['controller/route1', 'controller/route2'];
 //modify this function
public function handle($request, Closure $next) {
 //add this condition foreach($this->exceptUrls as $route) {
 if ($request->is($route)) {
  return $next($request);
 }
}
return parent::handle($request, $next);
}
```

### 11. 如何检查请求为ajax请求？

在Laravel中，可以使用`$request-> ajax()`方法检查请求是否为`ajax`。

示例：

```php
public function saveData(Request $request)
{
    if($request->ajax()){
        return "Request is of Ajax Type";
    }
    return "Request is of Http type";
}
```

### 19) 如何在 Laravel 中开启查询日志？

您可以使用 enableQueryLog 方法在 Laravel 中启用查询日志。

```
DB::connection()->enableQueryLog(); 
 
// 可以使用getQueryLog方法获取已执行查询的数组：
$queries = DB::getQueryLog();
```

### 2. 使用Laravel框架有哪些优缺点？

**使用Laravel框架的优点**

- Laravel框架具有内置的轻量级刀片模板引擎，可加快编译任务并轻松创建具有动态内容的布局。
- 提高代码可重用性。
- Eloquent ORM与PHP活动记录实现。
- 内置命令行工具“Artisan”，用于创建代码框架，数据库结构并构建其迁移。

**使用laravel框架的缺点**

- 开发过程要求您使用标准，并且应该对编程有真正的了解
- Laravel是新的框架，与npm（对于node.js），ruby gems和python pip相比，Laravel并不是那么强大。
- 与ruby on rails相比，laravel的开发速度并不快。
- Laravel是轻量级的，因此与django和rails相比，它具有较少的内置支持。 但是这个问题可以通过集成第三方工具来解决，但对于大型和非常自定义的网站来说，这可能是一项单调乏味的任务。



### 20) 解释 Laravel 中事件的概念。

事件是一种动作或者操作，可以帮助您订阅和侦听 Laravel 应用程序中发生的事件。当发生任何活动时，Laravel 会自动出发某些事件。

### 21) 说一下依赖注入和依赖注入的类型.

它是‘其中一种对象依赖于另一个对象’的技术。
依赖注入有三种类型:

1. 构造函数注入
2. setter 注入
3. 接口注入.

### 22) 使用 laravel 有什么优势吗？

下面是 laravel 的主要优点:

- Laravel 具有 blade 模板引擎，可创建动态布局并增加编译任务.
- 可以很简单的复用代码.
- 您不需要手动维护和包含路径，因为 Laravel 具有自动加载功能.
- 该框架可帮助您使用 LOC 容器制作新工具.
- Laravel 提供了一个版本控制系统，可帮助简化迁移管理.

### 23) 说明 Laravel 中验证的概念.

在设计任何 Laravel 应用程序时，验证是一个重要的概念。它可以确保在将数据存储到数据库之前，数据始终采用预期的格式。 Laravel 提供了多种验证数据的方法。
基础控制器特征是使用 ValidatesRequests 类，该类提供了一种有用的方法来验证来自客户端计算机的请求。

### 24) ORM 代表什么？

ORM 代表对象关系映射

### 25) 如何减少 Laravel 中的内存使用？

在处理大量数据时，可以使用 cursor 方法以减少内存使用量

### 26) 列出 Laravel Eloquent 中可用的关系类型。

Laravel Eloquent 中可用的关系类型有:

1. 一对一
2. 一对多
3. 多对多
4. 多对多关联 hasManyThrough
5. 多态关系

### 27) 定义一下 Laravel 使用的模板引擎.

Blade 是 Laravel 使用的功能强大的模板引擎。

### 28) 列出 Laravel 支持的数据库.

Laravel 支持以下数据库：

- PostgreSQL
- SQL Server
- SQLite
- MySQL

### 29) 为什么迁移很重要？

迁移非常重要是因为它允许您通过维护数据库一致性来共享应用程序。
如果不进行迁移，则很难共享任何 Laravel 应用程序。
它还允许您同步数据库。

### 30) 定义 Lumen

Lumen 是一个微型框架。它是基于 Laravel 服务和 REST API 的更小，更快的版本。

### 31) 解释 PHP artisan

artisan 是 Laravel 的命令行工具。 它提供的命令可帮助您轻松构建 Laravel 应用程序。

### 32) 如何生成链接？

Laravel 用 helpers 函数 来生成链接。 当您在模板和 API 响应中建立链接时，这将很有帮助。

### 33) 哪个类用于处理异常？

Laravel 异常由 App.exceptions.handler 类处理。

### 34) 什么是常见的 HTTP 错误代码？

最常见的 HTTP 错误代码是：

\- 错误 404 –未找到页面时显示。
\- 错误 - 401 –未授权错误时显示

### 35) 在 Laravel 中解释 Fluent 查询生成器。

它是一个数据库查询生成器，它提供了方便，快捷的界面来创建和运行数据库查询。

### 36) dd () 函数的用途是什么？

此函数用于将变量的内容打印到浏览器。 dd 的完整格式是 Dump and Die。

### 37) 列出 Laravel 中使用的常见 artisan 命令。

Laravel 支持以下工匠命令：

```

```

1. `PHP artisan down;`
2. `PHP artisan up;`
3. `PHP artisan make:controller;`
4. `PHP artisan make:model;`
5. `PHP artisan make:migration;`
6. `PHP artisan make:middleware;`

###  38) 在 Laravel 中 如何配置邮件发送？

Laravel 提供了一些 API，可以在本地和实时服务器上发送电子邮件。

### 39) 解释授权

这是一种使用密码标识用户登录凭据的方法。在 Laravel 中，可以使用带有两个参数 1) 用户名和 2) 密码的会话来管理它。

### 40) delete ()：从数据库表中删除所有记录

-delete ()：从数据库表中删除所有记录。
-softDeletes ()：不会从表中删除数据。它用于将任何记录标记为已删除。

### 41) 如何在 Laravel 中制作实时的 sitemap.xml 文件？

您可以创建网站的所有网页，以告知搜索引擎有关组织网站内容的信息。搜索引擎的搜寻器会智能地读取此文件以对网站进行搜寻。

### 42) 解释说明 Laravel 中的 faker.

它是用于创建伪造数据的一种模块或软件包。此数据可用于测试目的

它也可以用于生成：

1. 数字
2. 地址
3. DateTime
4. 付款
5. Lorem 文本。
6. 您将如何检查表是否在数据库中存在？

使用 Laravel 中的 hasTable () 函数检查所需的表是否在数据库中存在。

### 44) Laravel 中 insert () 和 insertGetId () 函数之间的显著区别是什么？

Insert (): 此函数仅用于将记录插入数据库。 不返回自增 ID
InsertGetId (): 此函数会在表中插入一条记录，但当 ID 字段自动递增时使用。（插入记录并返回自增的 ID）

### 45) 解释说明 Laravel 中的活动记录 - active record

在活动记录中，类映射到您的数据库表。它可以帮助您处理 CRUD 操作。

### 46) 列出 Laravel 中的基础概念

以下是 laravel 中用到的基础概念：

- 路由
- Eloquent ORM
- 中间件
- 安全
- 缓存
- Blade 模板

### 47) 定义隐式控制器。

隐式控制器可帮助您定义适当的路由来处理控制器操作。您可以使用 Route :: controller () 方法在 route.php 文件中定义它们。

### 48) 如何在 Laravel 模型中自定义表名？

自定义表名，您可以重写 protected 变量 $ table 的值。

### 50) 定义 @include.

@include 用于加载多个模板视图文件。它可以帮助您将视图包括在另一个视图中。用户还可以在一个视图中加载多个文件。

### 53) 什么是 Eloquent?

Eloquent 是 在 laravel 中使用的 ORM 。它提供了简单的 active record 实现， 配合数据库使用。每个数据库表都有其模型，该模型用于与表进行交互。

Laravel的Eloquent ORM是用于处理数据库的简单Active Record实现。 Laravel提供了许多与数据库交互的不同方式，Eloquent最引人注目。 每个数据库表都有一个相应的“模型”，用于与该表进行交互。 模型可用于查询表中的数据，以及在表中插入新记录。

下面是使用 Eloquent 在Database中查询和插入新记录的示例用法。

![image-20211217142119067](.\img\最高级多方面面试题\image-20211217142119067.png)

### 24. 如何在Laravel Modal中使用自定义表？

可以通过覆盖Eloquent的受保护`$table`属性来在Laravel中使用自定义表。

**示例：**

```scala
class User extends Eloquent{
 protected $table="my_user_table";
}
```

### 25. Laravel是否支持缓存？

当然支持。Laravel支持流行的缓存后端，如：Memcached和Redis。
默认情况下，Laravel配置为使用文件缓存驱动程序，该驱动程序将序列化的缓存对象存储在文件系统中。对于大型项目，建议使用Memcached或Redis。

### 22. 请列出laravel 5.0的一些功能？

laravel 5.0的一些功能如下所示 -

- 内置CSRF（跨站点请求伪造）保护。
- 内置分页
- 反向路由
- 查询构建器
- 路由缓存
- 数据库迁移
- IOC（控制反转）容器或服务容器。

### 54) 列出 Laravel 的一些内置身份验证控制器。

Laravel 安装具有一组内置的通用身份验证控制器。这些控制器是：

RegisterController
LoginController
ResetPasswordController
ForgetPasswordController

### 55) 解释 Laravel guard (卫兵) 。

Laravel Guard 是一个用于查找经过身份验证用户的特殊组件。
最初将请求的传入路由通过此防护来验证用户输入的凭据。防护措施在../config/auth.php 文件中定义。

### 56) 什么是 Laravel API 限流？

这是 Laravel 的功能。它提供了限流处理功能。限流可帮助 Laravel 开发人员开发安全的应用程序并防止 DOS 攻击。

### 57) 解释依稀 laravel 中的集合 Collections.

集合 Collections 是用于数组的包装器类。 Laravel Eloquent 的查询使用一组最常用的函数来返回数据库结果。

### 58) DB Facade 的用途是什么？

DB Facade 用于运行 SQL 查询，例如创建，查询，更新，插入和删除。

### 59) 对象关系映射的用途是什么？

对象关系映射是一种技术，可帮助开发人员在不考虑对象及其数据源之间的关系的情况下寻址，访问和操纵对象。

### 60) 解释 Laravel 中的路由概念。

它允许将您所有的应用程序请求路由到控制器。 Laravel 路由确认并接受带闭包的统一资源标识符。

### 61) Laravel 中的 Ajax 是什么？

Ajax 代表异步 JavaScript，XML 是一种 Web 开发技术，用于创建异步 Web 应用程序。在 Laravel 中，response () 和 json () 函数用于创建异步 Web 应用程序。

### 62) Laravel 中的 session 是什么？

session 用于将用户信息从一个网页传递到另一网页。 Laravel 提供了各种驱动程序 (例如 cookie，数组，文件，Memcached 和 Redis) 来处理会话数据。

### 64) 说明身份验证和授权之间的区别。

认证是指通过凭据确认用户身份，而授权是指收集对系统的访问权限。

### 65) 解释监听器 - listeners.

监听器 - listeners 用于处理事件和异常。 Laravel 中用于登录事件的最常见的监听器是 LoginListener。

### 66) 什么策略类？

策略类包括 Laravel 应用程序的授权逻辑。这些类用于特定的模型或资源。

### 67) 如何回滚上一次 migration 迁移？

需要使用 artisan 命令回滚上一次迁移。

### 68) 您所说的 Laravel Dusk 是什么意思？

Laravel Dusk 是用于测试启用 JavaScript 的应用程序的工具。它提供了强大的浏览器自动化和测试 API。

### 69) 解释 Laravel echo.

它是一个 JavaScript 库，可以订阅和收听通道 Laravel 事件。您可以使用 NPM 软件包管理器来安装 echo。

### 70) 什么是 make 方法？

Laravel 开发人员可以使用 make 方法来绑定接口以创建类。此方法返回类或接口的实例。 Laravel 自动注入在类构造函数中定义的依赖项。

### 71) 解释一下 Laravel 中的 Response。

所有控制器和路由都应返回响应，然后将其发送回 Web 浏览器。 Laravel 提供了多种方法来返回此响应。最基本的响应是从控制器或路由返回一个字符串。

### 72) ) 什么是查询范围？

Laravel 的一个功能是我们可以重复使用类似的查询。我们不需要在 Laravel 项目中再次编写相同类型的查询。定义范围后，只需在查询模型时调用 scope 方法即可。

### 73) 解释一下 Laravel 中的 homestead 。

Laravel homestead 是官方的，一次性的，预包装的 vagrant box ，它具有强大的开发环境， 而且无需在计算机上安装 HHVM，Web 服务器和 PHP。

### 74) Laravel 中的命名空间是什么？

命名空间允许用户使用特定名称将函数，类和常量分组。

![image-20211217134955352](.\img\最高级多方面面试题\image-20211217134955352.png)

### 77) 什么是观察员 Observers？

Model Observers 是 Laravel 的功能。它用于为模型建立事件监听器的群集。这些类的方法名称描述了 Eloquent 事件。Observers 类方法将模型作为参数接收。

### 78) bootstrap 目录的用途是什么？

它用于初始化 Laravel 项目。这个引导目录包含负责引导框架的 app.php 文件。

### 79) 默认的会话超时时间是多少？

Laravel 会话的默认超时时间为 2 小时。

### 80) 如何删除已编译的类文件？

使用 clear-compiled 命令删除已编译的类文件。

### 81) robot.txt 放在哪个文件夹中？

Robot.txt 文件放置在 “Public” 目录中。

### 82) 解释 API.PHP 路由。

其路由对应于 API 集群。它具有在 Laravel 中默认启用的 API 中间件。这些路由没有任何状态和交叉请求内存，也没有 session 会话。

### 83) 什么是定义路由？

定义路由是一种生成路由路径的方法。 这些路由的链接可以通过在定义路由方法中进行说明

### 84) 什么是开源软件？

开源软件是可以免费获得源代码的软件。源代码可以根据用户要求进行共享和修改。

### 85) 解释 Laravel 中的 Loggin 。

它是一种生成系统错误日志的技术。 Loggin 有助于提高系统的可靠性。 Laravel 支持各种日志记录模式，例如 syslog，每日，单次和错误日志记录模式。

### 86) 什么是本地化？

Laravel 的一个功能是支持应用程序中使用的各种语言。开发人员可以在文件中存储不同语言的字符串，这些文件存储在 resources /views 文件夹中。开发人员应为每种支持的语言创建一个单独的文件夹。

### 87) 定义 Laravel 中的 hashing .

这是将文本转换为显示原始文本的 key 的方法。 Laravel 使用 Hash facade 以哈希方式安全地存储密码。

### 88) 解释 Laravel 中加密和解密的概念.

加密是使用某些算法以第三用户无法读取信息的方式转换任何信息的过程。加密可以保护您的敏感信息不受入侵。

使用加密过程执行加密。要加密的消息称为纯消息。加密后获得的消息称为密码消息。将密文转换为纯文本或消息时，此过程称为解密。

### 89) 如何与视图共享数据？

要将数据传递给 Laravel 中的所有视图，请使用称为 share () 的方法。此方法采用两个参数，即 key 和 value。
通常，从 Laravel 应用程序 service provider 的 boot 方法调用 share () 方法。开发人员可以使用任何 service provider，AppServiceProvider 或我们自己的 service provider。

### 90) 解释 web.php 路由.

Web.php 是基于公众的 “浏览器” 路由。 这是最常见的途径，也是网络浏览器会遇到的问题。 它们遍历 Web 中间件组，还包含 CSRF 保护工具 (有助于防御基于表单的恶意攻击和黑客攻击)，并且通常包含一定程度的 “状态” (我的意思是他们利用 session 会话).

### 91) 如何在 Laravel 中生成请求？

在 Laravel 中使用以下 artisan 命令生成请求：

```go
php artisan make：request UploadFileRequest
```

### 92.laravel 模块

- 服务提供者是什么？

服务提供者是所有 Laravel 应用程序引导启动的中心, Laravel 的核心服务器、注册服务容器绑定、事件监听、中间件、路由注册以及我们的应用程序都是由服务提供者引导启动的。

- IoC 容器是什么？

IoC（Inversion of Control）译为 「控制反转」，也被叫做「依赖注入」(DI)。什么是「控制反转」？对象 A 功能依赖于对象 B，但是控制权由对象 A 来控制，控制权被颠倒，所以叫做「控制反转」，而「依赖注入」是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态地将某种依赖关系注入到对象之中。

其作用简单来讲就是利用依赖关系注入的方式，把复杂的应用程序分解为互相合作的对象，从而降低解决问题的复杂度，实现应用程序代码的低耦合、高扩展。

Laravel 中的服务容器是用于管理类的依赖和执行依赖注入的工具。

- Facades 是什么？

Facades（一种设计模式，通常翻译为外观模式）提供了一个"static"（静态）接口去访问注册到 IoC 容器中的类。提供了简单、易记的语法，而无需记住必须手动注入或配置的长长的类名。此外，由于对 PHP 动态方法的独特用法，也使测试起来非常容易。

- Contract 是什么？

Contract（契约）是 laravel 定义框架提供的核心服务的接口。Contract 和 Facades 并没有本质意义上的区别，其作用就是使接口低耦合、更简单。

- 依赖注入的原理？

这个就不解释了吧，这是理解 IoC 容器的前提。

### 93.LUMEN的中间件原理

### 94.什么是静态延迟绑定

### 95.laravel autoload实现原理

### 96.laravel队列的延迟分发（delay）

最近在面试，然后整理下 Laravel 所需的面试题，以备不时之需。

1. laravel 的生命周期。
laravel 的声明周期都是从 public/index.php 开始，所有请求都会被 web 服务器导入到此文件中，接下来，请求发送到 http 内核或者 console 内核（分别处理 web 请求和 artisan 命令。）内核请求过程中最重要的内容就是为应用载入服务提供者。应用所有的服务提供者都被配置在 config/app 配置文件的 providers 数组中，接下来就是分发请求，一旦应用被启动且所有服务提供者被注册，request 将会给路由器分发，路由器将会分发请求到路由或者控制器，同时运行所有路由指定的中间件。

2. laravel 路由隐式绑定的原理
Laravel 会自动处理在路由或控制器方法中，与类型提示的变量名相匹配的路由段名称的的 Eloquent 模型。

3. IoC 容器
IoC （Inversion of Control ） 译为 [控制反转]，也被叫做 [依赖注入]。 什么是 [控制反转]？ 对象 A 功能依赖于对象 B， 但是控制权由对象 A 来控制，控制权被颠倒，所以叫做 [控制反转
]，而 [依赖注入] 是实现 IoC 的方法，就是由 IoC 容器在运行期间，动态的将某种依赖关系注入到对象之中。

4. Composer aotuload 的原理。
composer 加载核心思想是通过 composer 的配置文件在引用入口文件 (autoload.php) 时，将类和路径的对应关系加载到内存中，最后将具体加载的实现注册到 spl_autoload_register 函数中。最后将需要的文件包含进来。

### 5、laravel 框架的优缺点 ?



# 九.计算机原理面试





# 十.linux面试

### 1.什么是Linux

Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和Unix的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的Unix工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。

Unix和Linux有什么区别？
Linux和Unix都是功能强大的操作系统，都是应用广泛的服务器操作系统，有很多相似之处，甚至有一部分人错误地认为Unix和Linux操作系统是一样的，然而，事实并非如此，以下是两者的区别。

开源性
Linux是一款开源操作系统，不需要付费，即可使用；Unix是一款对源码实行知识产权保护的传统商业软件，使用需要付费授权使用。

跨平台性
Linux操作系统具有良好的跨平台性能，可运行在多种硬件平台上；Unix操作系统跨平台性能较弱，大多需与硬件配套使用。

可视化界面
Linux除了进行命令行操作，还有窗体管理系统；Unix只是命令行下的系统。

硬件环境
Linux操作系统对硬件的要求较低，安装方法更易掌握；Unix对硬件要求比较苛刻，按照难度较大。

用户群体
Linux的用户群体很广泛，个人和企业均可使用；Unix的用户群体比较窄，多是安全性要求高的大型企业使用，如银行、电信部门等，或者Unix硬件厂商使用，如Sun等。
相比于Unix操作系统，Linux操作系统更受广大计算机爱好者的喜爱，主要原因是Linux操作系统具有Unix操作系统的全部功能，并且能够在普通PC计算机上实现全部的Unix特性，开源免费的特性，更容易普及使用！
————————————————

### 2.什么是 Linux 内核？

Linux 系统的核心是内核。内核控制着计算机系统上的所有硬件和软件，在必要时分配硬件，并根据需要执行软件。

系统内存管理
应用程序管理
硬件设备管理
文件系统管理

### 3.Linux的基本组件是什么？

内核，shell和GUI

### 4.Linux系统缺省的运行级别？

关机。
单机用户模式。
字符界面的多用户模式(不支持网络)。
字符界面的多用户模式。
未分配使用。
图形界面的多用户模式。
重启。

### 5.什么是CLI？

命令行界面（英语**：command-line interface**，缩写]：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。也有人称之为字符用户界面（CUI）。

通常认为，命令行界面（CLI）没有图形用户界面（GUI）那么方便用户操作。因为，命令行界面的软件通常需要用户记忆操作的命令，但是，由于其本身的特点，命令行界面要较图形用户界面节约计算机系统的资源。在熟记命令的前提下，使用命令行界面往往要较使用图形用户界面的操作速度要快。所以，图形用户界面的操作系统中，都保留着可选的命令行界面。

### 6.什么是GUI？

图形用户界面（Graphical User Interface，简称 GUI，又称图形用户接口）是指采用图形方式显示的计算机操作用户界面。

图形用户界面是一种人与计算机通信的界面显示格式，允许用户使用鼠标等输入设备操纵屏幕上的图标或菜单选项，以选择命令、调用文件、启动程序或执行其它一些日常任务。与通过键盘输入文本或字符命令来完成例行任务的字符界面相比，图形用户界面有许多优点。
————————————————

### 7.简单 Linux 文件系统？

**一切都是文件\****

![image-20211218225421580](.\img\最高级多方面面试题\image-20211218225421580.png)

### 8.什么是硬链接和软链接？

1）硬链接

由于 Linux 下的文件是通过索引节点(inode)来识别文件，硬链接可以认为是一个指针，指向文件索引节点的指针，系统并不为它重新分配 inode 。每添加一个一个硬链接，文件的链接数就加 1 。

不足：1）不可以在不同文件系统的文件间建立链接；2）只有超级用户才可以为目录创建硬链接。
2）软链接

软链接克服了硬链接的不足，没有任何文件系统的限制，任何用户可以创建指向目录的符号链接。因而现在更为广泛使用，它具有更大的灵活性，甚至可以跨越不同机器、不同网络对文件进行链接。

不足：因为链接文件包含有原文件的路径信息，所以当原文件从一个目录下移到其他目录中，再访问链接文件，系统就找不到了，而硬链接就没有这个缺陷，你想怎么移就怎么移；还有它要系统分配额外的空间用于建立新的索引节点和保存原文件的路径。

**实际场景下，基本是使用软链接**。总结区别如下：

- 硬链接不可以跨分区，软件链可以跨分区。
- 硬链接指向一个 inode 节点，而软链接则是创建一个新的 inode 节点。
- 删除硬链接文件，不会删除原文件，删除软链接文件，会把原文件删除。

### 9.一台 Linux 系统初始化环境后需要做一些什么安全工作？

1、添加普通用户登陆，禁止 root 用户登陆，更改 SSH 端口号。

修改 SSH 端口不一定绝对哈。当然，如果要暴露在外网，建议改下。l

2、服务器使用密钥登陆，禁止密码登陆。

3、开启防火墙，关闭 SElinux ，根据业务需求设置相应的防火墙规则。

4、装 fail2ban 这种防止 SSH 暴力破击的软件。

5、设置只允许公司办公网出口 IP 能登陆服务器(看公司实际需要)

也可以安装 VPN 等软件，只允许连接 VPN 到服务器上。

6、修改历史命令记录的条数为 10 条。

7、只允许有需要的服务器可以访问外网，其它全部禁止。

8、做好软件层面的防护。

8.1 设置 nginx_waf 模块防止 SQL 注入。
8.2 把 Web 服务使用 www 用户启动，更改网站目录的所有者和所属组为 www 。
————————————————



### 10.什么叫 CC 攻击？什么叫 DDOS 攻击？

CC 攻击，主要是用来攻击页面的，模拟多个用户不停的对你的页面进行访问，从而使你的系统资源消耗殆尽。

DDOS 攻击，中文名叫分布式拒绝服务攻击，指借助服务器技术将多个计算机联合起来作为攻击平台，来对一个或多个目标发动 DDOS 攻击。

攻击，即是通过大量合法的请求占用大量网络资源，以达到瘫痪网络的目的。

怎么预防 CC 攻击和 DDOS 攻击？

防 CC、DDOS 攻击，这些只能是用硬件防火墙做流量清洗，将攻击流量引入黑洞。

流量清洗这一块，主要是买 ISP 服务商的防攻击的服务就可以，机房一般有空余流量，我们一般是买服务，毕竟攻击不会是持续长时间。

### 11.请问当用户反馈网站访问慢，你会如何处理？

**有哪些方面的因素会导致网站网站访问慢？**

1、服务器出口带宽不够用

本身服务器购买的出口带宽比较小。一旦并发量大的话，就会造成分给每个用户的出口带宽就小，访问速度自然就会慢。
跨运营商网络导致带宽缩减。例如，公司网站放在电信的网络上，那么客户这边对接是长城宽带或联通，这也可能导致带宽的缩减。
2、服务器负载过大，导致响应不过来

可以从两个方面入手分析：

分析系统负载，使用 w 命令或者 uptime 命令查看系统负载。如果负载很高，则使用 top 命令查看 CPU ，MEM 等占用情况，要么是 CPU 繁忙，要么是内存不够。
如果这二者都正常，再去使用 sar 命令分析网卡流量，分析是不是遭到了攻击。一旦分析出问题的原因，采取对应的措施解决，如决定要不要杀死一些进程，或者禁止一些访问等。
3、数据库瓶颈

如果慢查询比较多。那么就要开发人员或 DBA 协助进行 SQL 语句的优化。
如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等。然后，也可以搭建 MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。
4、网站开发代码没有优化好

例如 SQL 语句没有优化，导致数据库读写相当耗时。

**针对网站访问慢，怎么去排查？**

1、首先要确定是用户端还是服务端的问题。当接到用户反馈访问慢，那边自己立即访问网站看看，如果自己这边访问快，基本断定是用户端问题，就需要耐心跟客户解释，协助客户解决问题。

不要上来就看服务端的问题。一定要从源头开始，逐步逐步往下。

2、如果访问也慢，那么可以利用浏览器的调试功能，看看加载那一项数据消耗时间过多，是图片加载慢，还是某些数据加载慢。

3、针对服务器负载情况。查看服务器硬件(网络、CPU、内存)的消耗情况。如果是购买的云主机，比如阿里云，可以登录阿里云平台提供各方面的监控，比如 CPU、内存、带宽的使用情况。

4、如果发现硬件资源消耗都不高，那么就需要通过查日志，比如看看 MySQL慢查询的日志，看看是不是某条 SQL 语句查询慢，导致网站访问慢。

**怎么去解决？**

1、如果是出口带宽问题，那么久申请加大出口带宽。
2、如果慢查询比较多，那么就要开发人员或 DBA 协助进行 SQL 语句的优化。
3、如果数据库响应慢，考虑可以加一个数据库缓存，如 Redis 等等。然后也可以搭建MySQL 主从，一台 MySQL 服务器负责写，其他几台从数据库负责读。
4、申请购买 CDN 服务，加载用户的访问。
5、如果访问还比较慢，那就需要从整体架构上进行优化咯。做到专角色专用，多台服务器提供同一个服务。

### 12.Linux 性能调优都有哪几种方法？

1、Disabling daemons (关闭 daemons)。
2、Shutting down the GUI (关闭 GUI)。
3、Changing kernel parameters (改变内核参数)。
4、Kernel parameters (内核参数)。
5、Tuning the processor subsystem (处理器子系统调优)。
6、Tuning the memory subsystem (内存子系统调优)。
7、Tuning the file system (文件系统子系统调优)。
8、Tuning the network subsystem（网络子系统调优)。
————————————————



### 13.如何选择 Linux 操作系统版本?

一般来讲，桌面用户首选 Ubuntu ；服务器首选 RHEL 或 CentOS ，两者中首选 CentOS 。

根据具体要求：

安全性要求较高，则选择 Debian 或者 FreeBSD 。

需要使用数据库高级服务和电子邮件网络应用的用户可以选择 SUSE 。

想要新技术新功能可以选择 Feddora ，Feddora 是 RHEL 和 CentOS 的一个测试版和预发布版本。

【重点】根据现有状况，绝大多数互联网公司选择 CentOS 。现在比较常用的是 6 系列，现在市场占有大概一半左右。另外的原因是 CentOS 更侧重服务器领域，并且无版权约束。

CentOS 7 系列，也慢慢使用的会比较多了。

### 14.Shell 脚本是什么？

一个 Shell 脚本是一个文本文件，包含一个或多个命令。作为系统管理员，我们经常需要使用多个命令来完成一项任务，我们可以添加这些所有命令在一个文本文件(Shell 脚本)来完成这些日常工作任务。

###### 系统定义变量

系统变量是由系统系统自己创建的。这些变量通常由大写字母组成，可以通过 set 命令查看。

###### 用户定义变量

用户变量由系统用户来生成和定义，变量的值可以通过命令 "echo $<变量名>" 查看。

##### Shell 脚本中 `if` 语法如何嵌套?

```
if [ 条件 ]
then
命令1
命令2
…..
else
if [ 条件 ]
then
命令1
命令2
….
else
命令1
命令2
…..
fi
fi
```

##### Shell 脚本中 `case` 语句的语法?

```
case 变量 in
值1)
命令1
命令2
…..
最后命令
!!
值2)
命令1
命令2
……
最后命令
;;
esac
```

##### Shell 脚本中 `for` 循环语法？

```
for 变量 in 循环列表
do
命令1
命令2
….
最后命令
done
```

##### Shell 脚本中 `while` 循环语法？

如同 `for` 循环，`while` 循环只要条件成立就重复它的命令块。
不同于 `for`循环，`while` 循环会不断迭代，直到它的条件不为真。

基础语法：

```
while [ 条件 ]
do
命令…
done
```

### 15.如何使脚本可执行?

使用 chmod 命令来使脚本可执行。例子如下：chmod a+x myscript.sh 。

#!/bin/bash 的作用？

#!/bin/bash 是 Shell 脚本的第一行，称为释伴（shebang）行。

这里 # 符号叫做 hash ，而 ! 叫做 bang。
它的意思是命令通过 /bin/bash 来执行。

### 16.如何调试 Shell脚本？

使用 -x' 数（sh -x myscript.sh）可以调试 Shell脚本。
另一个种方法是使用 -nv 参数(sh -nv myscript.sh)。



1. 启动Linux系统，用ssh工具（xshell或者SecureCRT等）连上Linux系统。我用的是SecureCRT，若SecureCRT不会用，可以自己百度或者留言沟通。用SecureCRT连上之后，如图所示。

   ![shell脚本怎么调试](.\img\最高级多方面面试题\11111)

2. 

   shell脚本调试不需要什么特殊的工具。bash自带了一些调试选项。具体选项包含：

   -x : 在执行时显示参数和命令；

   +x：禁止调试

   -v：当命令行进行读取时显示输入；

   +v：禁止打印输入。

   在shell脚本启动时或者在脚本内都可以添加这些调试选项。测试脚本debug.sh，代码如图所示。

   ![shell脚本怎么调试](.\img\最高级多方面面试题\2322)

3. 

   在脚本启动时添加调试选项。来调试debug.sh，可以在启动脚本时，输入以下命令：bash -x ./debug.sh 或者 sh -x ./debug.sh。

   ![shell脚本怎么调试](.\img\最高级多方面面试题\wq)

   ![shell脚本怎么调试](.\img\最高级多方面面试题\fdsfsd)

4. 

   在脚本内添加调试选项，使用set 命令。例如要开启-x选项，则在脚本内容中添加命令：set -x 

   set +x 是关闭调试。

   ![shell脚本怎么调试](.\img\最高级多方面面试题\ffdsfsdfsdsd)

5. 

   现在要看debug.sh脚本执行的调试信息，就不需要使用bash -x ./debug.sh执行了。直接./debug.sh 就可以看到调试信息。

   ![shell脚本怎么调试](.\img\最高级多方面面试题\eerere)

6. 

   还有一种更便捷的方法，就是在脚本开头添加-xv选项，例如将#!/bin/sh 改成

   \#!/bin/sh -xv

   ![shell脚本怎么调试](.\img\最高级多方面面试题\vcvxcv)

7. 

   同样现在执行./debug.sh，也可打印出调试信息。

   ![shell脚本怎么调试](.\img\最高级多方面面试题\bbxcbzx)

8. 

   除了bash内置的选项来调试shell，还可以自定义调试函数。自定义调试函数可以更加灵活的应用。

   ![shell脚本怎么调试](.\img\最高级多方面面试题\vcxvcxzvczxvze)

9. 

   打开自定义调试函数，在启动脚本时，_DEBUG=on ./script。如果不开启调试开关，就直接执行./script。

   ![shell脚本怎么调试](.\img\最高级多方面面试题\dsfsd)

   ![shell脚本怎么调试](.\img\最高级多方面面试题\fdsfsfdf)

### 17.如何将标准输出和错误输出同时重定向到同一位置?

方法一：2>&1 (如# ls /usr/share/doc > out.txt 2>&1 ) 。
方法二：&> (如# ls /usr/share/doc &> out.txt ) 。

### 18.怎么查看当前进程？怎么执行退出？怎么查看当前路径？

答案：
查看当前进程： ps
执行退出： exit
查看当前路径： pwd

### 19.Linux 中进程有哪几种状态？在 ps 显示出来的信息中，分别用什么符号表示的？（重点）

答案：
（1）、不可中断状态：进程处于睡眠状态，但是此刻进程是不可中断的。不可中断， 指进程不响应异步信号。
（2）、暂停状态/跟踪状态：向进程发送一个 SIGSTOP 信号，它就会因响应该信号 而进入 TASK_STOPPED 状态;当进程正在被跟踪时，它处于 TASK_TRACED 这个特殊的状态。
“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。

（3）、就绪状态：在 run_queue 队列里的状态

（4）、运行状态：在 run_queue 队列里的状态
（5）、可中断睡眠状态：处于这个状态的进程因为等待某某事件的发生（比如等待 socket 连接、等待信号量），而被挂起
（6）、zombie 状态（僵尸）：父亲没有通过 wait 系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉
（7）、退出状态

D 不可中断 Uninterruptible（usually IO）
R 正在运行，或在队列中的进程
S 处于休眠状态
T 停止或被追踪
Z 僵尸进程
W 进入内存交换（从内核 2.6 开始无效）
X 死掉的进程

### 20.基本命令

```
cd 切换目录
cd .. 返回上一级
pwd 显示工作路径 
ls 查看目录中的文件 
tree 显示文件和目录由根目录开始的树形结构
mkdir 创建目录  （-p 创建目录树）
touch   创建文件
cat file1 从第一个字节开始正向查看文件的内容 
less 与more类似，浏览文件。但是可以随意移动
vi/vim  编辑文件
tail 命令可用于查看文件的内容
ls  列出目录下所有文件
rm 删除文件
rmdir 删除目录
rm -rf 强制删除非空目录
mv 移动文件
cp 复制文件 （-a复制目录）
ln 创建软连接
find / -name * 从 '/' 开始进入根文件系统搜索文件和目录 
grep  文本搜索命令
locate \*.ps 寻找以 '.ps' 结尾的文件 - 先运行 'updatedb' 命令 
whereis halt 显示一个二进制文件、源码或man的位置 
which halt 显示一个二进制文件或可执行文件的完整路径 
mount 挂载
umount 卸载
df -h 显示已经挂载的分区列表 
groupadd group_name 创建一个新用户组 
groupdel group_name 删除一个用户组 
useradd user1 创建一个新用户 
userdel -r user1 删除一个用户 ( '-r' 排除主目录) 
ls -lh 显示权
chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r /4）、写(w/2)和执行(x/1)的权限 
chown user1 file1 改变一个文件的所有人属性 
chown user1 file1 改变一个文件的所有人属性 
```

备份

dump -0aj -f /tmp/home0.bak /home 制作一个 '/home' 目录的完整备份 

rsync -rogpav --delete /home /tmp 同步两边的目录 

打包和压缩文件

gzip file1 压缩一个叫做 'file1'的文件 

tar -cvf archive.tar file1 创建一个非压缩的 tarball 

tar -xvf archive.tar 释放一个包 (tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 )

zip file1.zip file1 创建一个zip格式的压缩包 

unzip file1.zip 解压一个zip格式压缩包 

rpm -ivh package.rpm 安装一个rpm包 

yum install package_name 下载并安装一个rpm包 

yum update package_name 更新一个rpm包 

yum list 列出当前系统中安装的所有包 

apt-get install package_name 安装/更新一个 deb 包 

cat /proc/meminfo 校验内存使用 

cat /proc/swaps 显示哪些swap被使用 

cat /proc/version 显示内核的版本 

shutdown -h now 关闭系统

shutdown -r now 重启

初始化一个文件系统 

mkfs /dev/hda1 在hda1分区创建一个文件系统 

fdformat -n /dev/fd0 格式化一个软盘 

SWAP文件系统 
mkswap /dev/hda3 创建一个swap文件系统 
swapon /dev/hda3 启用一个新的swap文件系统 
swapon /dev/hda2 /dev/hdb3 启用两个swap分区 

网络 - （以太网和WIFI无线） 

ifconfig 用于查看和配置 Linux 系统的网络接口。
ifconfig eth0 显示一个以太网卡的配置 

ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址 

netstat命令用于显示网络状态。（netstat -lnp  查看系统开启了那些端口）

telnet命令用于远端登入。

怎么清屏？怎么退出当前命令？怎么执行睡眠？怎么查看当前用户 id？查看指定帮助用什么命令？
**答案：**
清屏： clear
退出当前命令： ctrl+c 彻底退出
执行睡眠 ： ctrl+z 挂起当前进程fg 恢复后台
查看当前用户 id： ”id“：查看显示目前登陆账户的 uid 和 gid 及所属分组及用户名
查看指定帮助： 如 man adduser 这个很全 而且有例子； adduser --help 这个告诉你一些常用参数； info adduesr；

建立软链接(快捷方式)，以及硬链接的命令。
**答案：**
软链接： ln -s slink source
硬链接： ln link source

文件权限修改： chmod
格式如下：

> $ chmod u+x file 给 file 的属主增加执行权限
> $ chmod 751 file 给 file 的属主分配读、写、执行(7)的权限，给 file 的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限
> $ chmod u=rwx,g=rx,o=x file 上例的另一种形式
> $ chmod =r file 为所有用户分配读权限
> $ chmod 444 file 同上例
> $ chmod a-wx,a+r file同上例
> $ chmod -R u+r directory 递归地给 directory 目录下所有文件和子目录的属主分配读的权限

查看文件内容有哪些命令可以使用？
**答案：**
vi 文件名 #编辑方式查看，可修改
cat 文件名 #显示全部文件内容
more 文件名 #分页显示文件内容
less 文件名 #与 more 相似，更好的是可以往前翻页
tail 文件名 #仅查看尾部，还可以指定行数
head 文件名 #仅查看头部,还可以指定行数

终端是哪个文件夹下的哪个文件？黑洞文件是哪个文件夹下的哪个命令？
**答案：**
终端 /dev/tty

黑洞文件 /dev/null

[Linux](https://so.csdn.net/so/search?from=pc_blog_highlight&q=Linux) 下命令有哪几种可使用的通配符？分别代表什么含义?
**答案：**
“？”可替代单个字符。

“*”可替代任意多个字符。

方括号“[charset]”可替代 charset 集中的任何单个字符，如[a-z]，[abABC]

用什么命令对一个文件的内容进行统计？(行号、单词数、字节数)
**答案：**

wc 命令 - c 统计字节数 - l 统计行数 - w 统计字数。

利用 ps 怎么显示所有的进程? 怎么利用 ps 查看指定进程的信息？
**答案：**
ps -ef (system v 输出) 

ps -aux bsd 格式输出

ps -ef | grep pid

哪个命令专门用来查看后台任务? 

**答案：**

job -l



把后台任务调到前台执行使用什么命令?把停下的后台任务在后台执行起来用什么命令?
**答案：**
把后台任务调到前台执行 fg

把停下的后台任务在后台执行起来 bg



终止进程用什么命令? 带什么参数? 

**答案：**

kill [-s <信息名称或编号>][程序] 或 kill [-l <信息编号>] 

kill-9 pid



怎么查看系统支持的所有信号？

**答案：**

kill -l



搜索文件用什么命令? 格式是怎么样的? 

**答案：**

find <指定目录> <指定条件> <指定动作>

whereis 加参数与文件名

locate 只加文件名

find 直接搜索磁盘，较慢。

find / -name "string*"



查看当前谁在使用该主机用什么命令? 查找自己所在的终端信息用什么命令?
**答案：**
查找自己所在的终端信息：who am i

查看当前谁在使用该主机：who



使用什么命令查看用过的命令列表?

**答案：**

history

**问题二十七：**

使用什么命令查看磁盘使用空间？ 空闲空间呢?

答案：

df -hl
文件系统 容量 已用 可用 已用% 挂载点
Filesystem Size Used Avail Use% Mounted on /dev/hda2 45G 19G 24G 44% /
/dev/hda1 494M 19M 450M 4% /boot

**问题二十八：**

使用什么命令查看网络是否连通?
**答案：**
netstat

**问题二十九：**

使用什么命令查看 ip 地址及接口信息？

**答案：**

ifconfig

**问题三十：**

查看各类环境变量用什么命令?

**答案：**

查看所有 env
查看某个，如 home： env $HOME

**问题三十一：**

通过什么命令指定命令提示符?

**答案：**

> \u：显示当前用户账号
>
> \h：显示当前主机名
>
> \W：只显示当前路径最后一个目录
>
> \w：显示当前绝对路径（当前用户目录会以~代替）
>
> $PWD：显示当前全路径
>
> \$：显示命令行’$'或者’#'符号
>
> \#：下达的第几个命令
>
> \d：代表日期，格式为week day month date，例如："MonAug1"
>
> \t：显示时间为24小时格式，如：HH：MM：SS
>
> \T：显示时间为12小时格式
>
> \A：显示时间为24小时格式：HH：MM
>
> \v：BASH的版本信息 如export PS1=’[\u@\h\w\#]\$‘

**问题三十二：**

查找命令的可执行文件是去哪查找的? 怎么对其进行设置及添加? 

**答案：**

whereis [-bfmsu][-B <目录>...][-M <目录>...][-S <目录>...][文件...]

补充说明：whereis 指令会在特定目录中查找符合条件的文件。这些文件的烈性应属于原始代码，二进制文件，或是帮助文件。

> -b  只查找二进制文件。
>
> -B<目录> 只在设置的目录下查找二进制文件。 -f 不显示文件名前的路径名称。
> -m  只查找说明文件。
> -M<目录> 只在设置的目录下查找说明文件。 -s 只查找原始代码文件。
> -S<目录> 只在设置的目录下查找原始代码文件。 -u 查找不包含指定类型的文件。
> which 指令会在 PATH 变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。
> -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。
> -p 与-n 参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位的宽度。
> -V  显示版本信息

**问题三十三：**

通过什么命令查找执行命令?
**答案：**
which 只能查可执行文件

whereis 只能查二进制文件、说明文档，源文件等


**问题三十四：**

怎么对命令进行取别名？
**答案：**
alias la='ls -a'

**问题三十五：**

du 和 df 的定义，以及区别？
**答案：**

du 显示目录或文件的大小

df 显示每个<文件>所在的文件系统的信息，默认是显示所有文件系统。
（文件系统分配其中的一些磁盘块用来记录它自身的一些数据，如 i 节点，磁盘分布图，间接块，超级块等。这些数据对大多数用户级的程序来说是不可见的，通常称为 Meta Data。） du 命令是用户级的程序，它不考虑 Meta Data，而 df 命令则查看文件系统的磁盘分配图并考虑 Meta Data。
df 命令获得真正的文件系统数据，而 du 命令只查看文件系统的部分情况。

**问题三十六：**

awk 详解。
**答案：**

> ```
> > awk '{pattern + action}' {filenames}
> > \#cat /etc/passwd |awk -F ':' '{print $1"\t"$7}' //-F 的意思是以':'分隔 root /bin/bash
> > daemon /bin/sh 搜索/etc/passwd 有 root 关键字的所有行
> 
> > \#awk -F: '/root/' /etc/passwd root:x:0:0:root:/root:/bin/bash
> ```
>
> 

**问题三十七：**

当你需要给命令绑定一个宏或者按键的时候，应该怎么做呢？

**答案：**

可以使用bind命令，bind可以很方便地在shell中实现宏或按键的绑定。

在进行按键绑定的时候，我们需要先获取到绑定按键对应的字符序列。

比如获取F12的字符序列获取方法如下：先按下Ctrl+V,然后按下F12 .我们就可以得到F12的字符序列 ^[[24~。

接着使用bind进行绑定。

[root@localhost ~]# bind ‘”\e[24~":"date"'

注意：相同的按键在不同的终端或终端模拟器下可能会产生不同的字符序列。

【附】也可以使用showkey -a命令查看按键对应的字符序列。

**问题三十八：**

如果一个linux新手想要知道当前系统支持的所有命令的列表，他需要怎么做？

**答案：**

使用命令compgen ­-c，可以打印出所有支持的命令列表。

> [root@localhost ~]$ compgen -c
>
> l.
>
> ll
>
> ls
>
> which
>
> if
>
> then
>
> else
>
> elif
>
> fi
>
> case
>
> esac
>
> for
>
> select
>
> while
>
> until
>
> do
>
> done
>
> …

**问题三十九：**

如果你的助手想要打印出当前的目录栈，你会建议他怎么做？

**答案：**

使用Linux 命令dirs可以将当前的目录栈打印出来。

> [root@localhost ~]# dirs

> /usr/share/X11

【附】：目录栈通过pushd popd 来操作。

**问题四十：**

你的系统目前有许多正在运行的任务，在不重启机器的条件下，有什么方法可以把所有正在运行的进程移除呢？

**答案：**

使用linux命令 ’disown -r ’可以将所有正在运行的进程移除。

**问题四十一：**

bash shell 中的hash 命令有什么作用？

**答案：**

linux命令’hash’管理着一个内置的哈希表，记录了已执行过的命令的完整路径, 用该命令可以打印出你所使用过的命令以及执行的次数。

> [root@localhost ~]# hash
>
> hits command
>
> 2 /bin/ls
>
> 2 /bin/su

**问题四十二：**

哪一个bash内置命令能够进行数学运算。

**答案：**

bash shell 的内置命令let 可以进行整型数的数学运算。

> \#! /bin/bash
> …
> …
> let c=a+b
> …
> …

**问题四十三：**

怎样一页一页地查看一个大文件的内容呢？

**答案：**

通过管道将命令”cat file_name.txt” 和 ’more’ 连接在一起可以实现这个需要.

[root@localhost ~]# cat file_name.txt | more

**问题四十四：**

数据字典属于哪一个用户的？

**答案：**

数据字典是属于’SYS’用户的，用户‘SYS’ 和 ’SYSEM’是由系统默认自动创建的

**问题四十五：**

怎样查看一个linux命令的概要与用法？假设你在/bin目录中偶然看到一个你从没见过的的命令，怎样才能知道它的作用和用法呢？

**答案：**

使用命令whatis 可以先出显示出这个命令的用法简要，比如，你可以使用whatis zcat 去查看‘zcat’的介绍以及使用简要。

> [root@localhost ~]# whatis zcat
>
> zcat [gzip] (1) – compress or expand files

**问题四十六：**

使用哪一个命令可以查看自己文件系统的磁盘空间配额呢？

**答案：**

使用命令repquota 能够显示出一个文件系统的配额信息



### 22.问题：Linux查看内存、磁盘存储、io 读写、端口占用、进程等命令

答案：
1、查看内存：top
2、查看磁盘存储情况：df -h
3、查看磁盘IO读写情况：iotop（需要安装一下：yum install iotop）、iotop -o（直接查看输出比较高的磁盘读写程序）
4、查看端口占用情况：netstat -tunlp | grep 端口号
5、查看进程：ps aux     

### 23.**SDRAM、DDR2、DDR3…**

答：

1、（Synchronous Dynamic Random Access Memory）同步动态随机存储器。SDRAM在一个时钟周期内只传输一次数据，它是在时钟的上升期进行
数据传输。

2、（Double Data Rate）双倍速率同步动态随机存储器。DDR内存则是一个时钟周期内传输两次数据，它能够在时钟的上升期和下降期各传输一
次数据。
DDR2（Double Data Rate 2）。它与上一代DDR内存技术标准最大的不同就是，虽然同是采用了在时钟的上升/下降延同时进行数据传输的基本方
式，但DDR2内存却拥有两倍于上一代DDR内存预读取能力（即：4bit数据预读取）。换句话说，DDR2内存每个时钟能够以4倍外部总线的速度读/写数据
，并且能够以内部控制总线4倍的速度运行。
而DDR3的预取为8bit，所以突发传输周期（Burst Length，BL）也固定为8。



### 24.**下列哪个命令不能退出vi编辑器：:x,:q,:q!,:bye**

答：最后一个,即：bye
:x(写入文件并退出。仅当文件被修改时才写入，并更新文件修改时间，否则不会更新文件修改时间。)
:q(普通退出，如果有写入操作，则提示）
:q!(强制退出，如果有写入操作，则不会保存）

### 25.下列哪种协议既有TCP又有UDP的：telnet,SMTP,DNS…**

答：telnet (TCP)
SMTP(TCP)
DNS(tcp/udp)
DNS一般使用UDP，DNS的主辅名字服务器在同步时使用TCP协议

### 26.**到相同目的地有下面几条路由，静态、RIP、OSPF，问数据包会经过哪一条。**

答：默认使用出站接口配置的静态路由和使用下一跳地址配置的静态路由的AD为1，所以选静态。
附：
路由源        默认AD
连接接口      0
静态路由      1
EIGRP        90
IGRP        100
OSPF        110
RIP         120
External EIGRP  170
未知         255(这个路由将绝不会被使用)

### 1.SAN的中文名称是_存储域网络（Storage Area Network）_______；NAS的中文名称是___网络存储设备（NAS：Network Attached Storage）.



### 2.写出除linux外的三种类Unix系统__Solaris____、__FreeBSD_____、_AIX______.



### 3.假如有3个文档…………，用一个最简单的命令将其合并为一个文档___cat file1.out file2.out file3.out ＞ file4.out ______.



### 4.字符串的匹配，c[?]c 

答：该题目应该是没有出完整，大括号内为任意字符

```
grep .a file.txt #匹配任意一个字符 例如 aa,ba等

[]		grep "[abc]c" file.txt #匹配[]里的任意一个字符，例如ac或者bc或者cc，注意加引号
		grep "[a-z]a" file.txt #匹配a-z间的26个字母任意一个字符，例如aa
	
[^]		grep "[^ab]a" #匹配除ab之外的任意一个字符，例如da
	
\w		grep "\w"  file.txt #匹配文字和数字字符，也就是[A-Za-z0-9]

\W		grep "\W"  file.txt #\w的反置形式，匹配一个或多个非单词字符，如点号句号等
```



### 5.某IP地址192.168.48.10，掩码为255.255.255.128，其所在的子网为__192.168.48.0________，广播地址为______192.168.48.127________，有效的主机IP地址范围从______192.168.48.1_________到___192.168.48.126_____________.



### 6.查看TCP连接的命令____netstat______.

### 7.在OSI模型中，HTTP协议工作在第__7__层，交换机工作在第_1-2___层。(此题不够严谨，个人认为后面填2层，1-2层都不能算错）

### 8.写出一些成熟的虚拟机技术____VMWare、__XEN、Bochs______________。（个人认为填写的越多，越能证明你的知识面广，加感情分）



### **1.32位操作系统和64位操作系统的区别，并说明它们的优点和缺点。**

答：优点：可以进行更大范围的整数运算；可以支持更大的内存。如支持更多的可寻址空间大于4GB。支持更大的虚拟内存16TB，支持更多的页面文件
512TB，支持更多的系统缓存1TB。支持更高的颜色质量（2的64次方）
缺点：缺点是向下兼容性差、支持硬件驱动较少。支持应用程序较少。需要硬件支持。

### **2.固态硬盘和传统硬盘有什么区别，并说明它们的优点和缺点。**

答：有点：抗震性强，机械故障点小。噪声小。发热量小，体积小。读写速度快。
缺点：容量小，价格贵。数据恢复能力差。

### **3.多核CPU和单核CPU的优点和缺点，是否所有程序在多核CPU上运行速度都快？为什么？**

答：不是。
由单核处理器增加到多核处理器，如果主频不变的话，IPC（每个时钟周期内执行的指令数）理论上可以提高一倍，功耗理论上也就最多提高一倍，因为功耗的增加是线性的。但是有些程序只能在单核下运行。

### **4.给你6个150G硬盘，列出RAID排列方式，哪种方式容量最大，并解释。**

答：

磁盘阵列（Redundant Arrays of Independent Disks，RAID），有“独立磁盘构成的具有冗余能力的阵列”之意。 [1] 

磁盘阵列是由很多块独立的[磁盘](https://baike.baidu.com/item/磁盘/2842227)，组合成一个容量巨大的磁盘组，利用个别磁盘提供数据所产生加成效果提升整个磁盘系统效能。利用这项技术，将数据切割成许多区段，分别存放在各个硬盘上。 [1] 

磁盘阵列还能利用同位检查（Parity Check）的观念，当[数组](https://baike.baidu.com/item/数组/3794097)中任意一个硬盘发生故障时，仍可读出数据。在数据重构时，可将数据经计算后重新置入新硬盘中。 [1] 

6块硬盘全部利用无法做出RAID01个阵列。最大只能做RAID0 ：容量150*4
raid5:容量150*(6-1)
raid0+1:容量150*(6/2)
所以答案是RAID5

### 

### 如何统计日志文件中访问次数最多的十个ip地址.

```
cat ip.txt | awk "{print $1}" | sort | uniq -c | sort -r
```



### 源码编译过lamp 或 lnmp 软件吗

### 在当前目录下,如何查找包含keyword文件.

![image-20220207102247832](.\img\最高级多方面面试题\image-20220207102247832.png)

### 如何重启php 或 nginx.

```
关闭PHP

killall php-fpm 

php重启

/usr/local/php/sbin/php-fpm &

关闭nginx

/usr/local/nginx/sbin/nginx -s stop   //关闭服务器

重启nginx

/usr/local/nginx/sbin/nginx  开启服务器

设置为service后就可以用命令重启了

service nginx restart
```



### 107.Linux高级运维工程师(面试题):打印文本的后20-30行的数据

打印最后的20行：	tail -n 20 filename

打印前20行：head -20 /data/seq100.txt

打印20-30行：sed -n '20,30p' /data/seq100.txt


​    sed命令 中-n 参数搭配p 一起来使用
​    1.打印文件的第二行
​    sed -n ‘2p’ file
​    2.打印1到3行
​    sed -n ‘1,3p’ file
​    3.品配单词用/patten/模式，eg，/Hello/
​    sed -n ‘/Hello/’p file
​    4.使用模式和行号进行品配,在第4行查询Hello
​    sed -n ‘4,/Hello/’ file
​    5.配原字符(显示原字符$之前，必须使用\屏蔽其特殊含义)
​    sed -n ‘/$/’p file
​    上述命令将把file中含有$的行打印出来
​    6.显示整个文件(只需将范围设置为1到最后于一行)
​    $代表最后一行
​    sed -n ‘1,$p’ file
​    7.任意字符 ，模式/.*/,如/.*ing/匹配任意以ing结尾的单词
​    sed -n ‘/.*ing/’p file
​    8.打印首行
​    sed -n ‘1p’ file
​    9.打印尾行
​    sed -n ‘$p’ file
​    ————————————————

### 83.linux 中存在一日志文件非常大，打开速度很慢，如何查找其中部分指定内容

在Linux环境下如果日志文件不是很大（PS：小于1G的情况），我们一般都习惯使用vim打开文件，然后通过以下两个vim命令搜索指定关键字：

- /：从前往后搜索
- ?：从后往前搜索

但是，当日志文件达到好几G的时候，甚至几十G的时候，如果我们还用这种方式查找日志的话，那么速度将会慢得让人难以忍受，这种情况下就可以考虑使用下面这个技巧了：

###### （1）使用grep命令查找到指定关键字所在行号：

grep -n -e 'php' swoole_table.cc  | head -n 30

1. -n参数的作用是显示查找结果的所在行号
2. -e参数表示我们需要搜索的关键字，多个关键字就用多个 -e 参数
3. ws.log表示待搜索的大日志文件
4. head -n 3 表示显示前面查询结果的前三条记录

![img](https://www.zifangsky.cn/wp-content/uploads/2017/12/20171229174653.png)

###### （2）使用vim命令打开文件的指定行：

vim打开文件的时候可以使用“+行号”的形式打开文件的指定行，比如我们上面查询出来的行号是27796016，因此可以使用以下命令打开文件跳转到指定行：

| 1    | [root@excbjdcpapp01 logs]# vim +27796016 ws.log |
| ---- | ----------------------------------------------- |
|      |                                                 |

![img](https://www.zifangsky.cn/wp-content/uploads/2017/12/20171229175259.png)



### 3.1 linux下查看当前系统负载信息的一些方法。

### 3.2 vim的基本快捷键。

### 3.3 ssh 安全增强方法;密码方式和rsa key 方式的配置。

### 3.4 rpm/apt/yum/ports 装包，查询，删除的基本命令。

### 3.5 Makefile的基本格式，gcc 编译，连接的命令,-O0 和-O3区别。

### 3.6 gdb,strace,valgrind的基本使用.

 1.请解释下列10个shell命令的用途（新浪网技术部）

top、ps、mv、find、df、cat、chmod、chgrp、grep、wc

top：该命令提供了实时对系统处理器状态的监控，它能够实时显示系统中各个进程的资源占用情况。该命令可以按照对CPU、内存使用和执行时间对系统任务进程进行排序显示，同时还可以通过交互式命令进行设定显示。
ps：显示系统进程在瞬间的运行动态。
mv：文件/目录改名或变更存储位置。
find：在指定的路径下查找指定文件。
df：检查磁盘空间占用情况。
cat：将文件的内容打印到标准输出。
chmod：改变文件的权限。
chgrp：改变文件所属组。Linux chgrp（英文全拼：change group）命令用于变更文件或目录的所属群组。

与 [chown](https://www.runoob.com/linux/linux-comm-chown.html) 命令不同，chgrp 允许普通用户改变文件所属的组，只要该用户是该组的一员。grep：过滤文本，根据指定的字符串，对文件的每一行进行搜索，如找到，则输出该行内容。
wc：统计指定文件中的字节数、字数、行数，并将统计结果显示输出。

###### 相关题目：写出15个以上你所知道的常用的[Linux](https://so.csdn.net/so/search?from=pc_blog_highlight&q=Linux)命令和它的功能。

ls：列出目录
cp：复制
rm：删除
cat：将文件的内容打印到标准输出
mkdir：建立目录
tar：打包压缩
ps：查看进程
top：查看机器使用情况
df：检查磁盘空间占用情况
find：在指定路径下查找指定文件
grep：过滤文本
cd：改变当前工作目录
mount：挂载/卸载指定的文件系统
ifconfig：配置网络或显示当前网络接口状态
[telnet:：远程登录](https://blog.csdn.net/s1070/article/details/51174660)

###### 2.vi编辑器中，选中、复制、粘贴、删除的命令各是什么(酷讯)

选中：v（以字符为单位），V（以行为单位）
复制：y，如yy，nyy，y1G，yG，y0，y$
粘贴：p（粘贴在光标之后），P（粘贴在光标之前）
删除：d，如dd，ndd，d1G，dG，d$,d0

###### 3.获取文件行数(酷讯)

wc-l filename

###### 4.输入文件的最后5行到另一个文件中(酷讯)

tail-n 5 file1>>file2

###### 5.查找文件中包含hello的行(酷讯)

grep hello filename

###### 6.查找当前目录下所有目录名为gogs的子目录的命令(酷讯)

```
find ./gogs -maxdepth 1 -type d -print
```



###### 7.如何让一个程序在后台运行并把输入定向到指定的文件(酷讯)

可使用命令：nohup程序>>文件名2>&1
注意，2>&1要放在输出文件名的后面）

###### 8.如何把一个文件的内容添加到另一个文件的末尾(酷讯)

cat file1>>file2

###### 9.如何实时的显示一个文件的输出(酷讯)

使用more或者less

###### 10.定时执行一个程序的方法有什么(酷讯)

可以使用at或者crontab，其中at是处理仅执行一次就结束调度的命令，适用于突发性工作，而crontab将会循环一直进行下去，适用于例行性工作。

###### 11.vi编辑器中，如何替换指定的字符串(酷讯)

使用s命令，例如：
：n1,n2s/word1/word2/g，将第n1行与n2行之间的word1替换为word2
：1,$s/word1/word2/g，从第一行到最后一行中的word1替换为word2

###### [!]12.当更新后，cvs中文件有冲突时。如何判断哪些你编辑的内容和更新下来的内容(酷讯)

使用CVS时，如果出现冲突，双击冲突的文件（标识为红色），显示文件比较窗口。其中蓝色为需要传入的更新，其中灰色为需要传出的修改，其中红色为需要手工解决的冲突。
可以首先将蓝色需要传入的更新，然后手工解决红色部分，自行选择保留左边还是右边，并选择mark as merge将文件标志为合并，此时将以左边窗口中的内容为依据向服务器提示传出，即灰色和红色部分都会以左边窗口的内容为依据向服务器提交。
如果冲突文件打开无任何的颜色提示，可选择update and override，使用服务器上的文
件更新本地文件。

###### 13.Linux下，如何查看所有用户______

cat/etc/passwd

###### 14.Linux上的crond服务可对服务器设置计划任务，请问如果我需设置每2分钟执行一次/tmp/test.sh的脚本应如何设置计划任务，请写出操作方法。

1. 首先用root用户的权限登录。
2. 切换到/etc/init.d/目录下，使用命令：crond start启动crond服务
3. 切换到/etc/目录下，使用命令：crontab–e
4. 编辑如下：/2***/tmp/test.sh

###### 15.查看磁盘空间使用率的Linux命令是什么？查看有哪些系统进程正在运行命令是什么？检测Linux性能（cpu，磁盘io，内存，网络等）都用到哪些命令？（卓望）

查看磁盘空间使用率的命令：df
查看系统进程命令：top
检测Linux性能的命令：ps，free，vmstat，netstat

###### 16.Linux下终止一个进程用什么命令？打包压缩和解包用什么命令？软连接和硬链接有什么区别？建立软连接的命令是？（卓望）

终止进程的命令：kill
打包压缩和解包命令：tar
建立软连接的命令：ln-s源文件目标链接名
硬链接是通过文件系统的inode来产生新文件名，而不是新文件，它只是在某个目录新建一条文件名链接到某inode号码的管理记录而已，而软链接是创建一个独立的文件，该文件会让数据的读取指向它链接的那个文件的文件名，类似于windows中的快捷方式。

###### 17.说说Linux下的find命令和grep命令的区别

find：在磁盘/分区中找到文件，可以配type可以配size time等，通过文件名或文件大小或访问时间找到指定文件。
grep：查找文件里符合条件的字符串，并把匹配的行打印出来，可以使用正则表达式。

###### 18.有mail.log的一个文档，内容为若干邮件地址，其中用'\n'将邮件地址分隔。要求从中

挑选出sina.com的邮件地址（包括从文件读取、过滤到列印出来）。
mail.log内容如下：
[james@sina.com.cn](mailto:james@sina.com.cn)
[jack@163.com](mailto:jack@163.com)
[zhansan@sohu.com](mailto:zhansan@sohu.com)
[lisi@hotmail.com](mailto:lisi@hotmail.com)
[wangwu@gmail.com](mailto:wangwu@gmail.com)
参考答案：
`cat mail.log|grep sina.com`
或者：









### 简述Linux下安装PHP的过程？

### 简述Linux下安装Mysql的过程？

### 简述Linux下安装apache的过程？

### 监视一个日志文件a.log 的最新内容?

tail -f a.log

### 查看当前服务器的HTTP连接有哪些？

netstat -an | grep ESTABLISHED | wc -l

### 如何实现每天0点钟重新启动服务器? 

```
分    时 日 月 星期

Crontab -e

00 00  *   *  * /sbin/reboot   

分  时  日  月 周
```

### rm -rf  是什么意思，其中 f 有什么作用?

强制删除目录及子目录，f是强制删除的意思

### Linux的目录进行遍历，编写shell脚本?

### apache默认使用进程管理还是线程管理？如何判断并设置最大连接数？

```
apache功能强大，应用十分广泛。

为了使不同平台的apache都能得到优化，apache支持MPM模块。

linux/unix下的好的2个模块分别为prefork和worker。

最初设计unix的时候，并没有线程这个概念，所以无论系统内核还是应用软件，都不支持线程的应用。最小的作业单位是进程。

windows是一个完全支持线程的操作系统。线程比进程更小，能提高系统效率，减少系统开支。

现在无论是linux还是freebsd，都在积极改进，在内核中加入线程的支持。

apache本身即支持线程也支持进程。它怎么实现的呢？就是用MPM。

prefork模块：基于进程的web服务器

默认配置段如下：
<IfModule prefork.c>
StartServers 5
MinSpareServers 5
MaxSpareServers 10
MaxClients 150
MaxRequestsPerChild 0
</IfModule>

prefork的工作原理是，由主控制进程生成“StartServers”个子进程，当空闲进程小于MinSpareServers时，系统生成一个又一个进程，直到进程数达到MaxSpareThreads；而MaxClients设置允许的最大客户连接数。每个子进程处理服务请求次数由MaxRequestPerChild定义。 缺省的设置值为0，即响应无限此请求。

worker模块：基于线程程的web服务器

默认配置如下：
<IfModule worker.c>
StartServers 2
MaxClients 150
MinSpareThreads 25
MaxSpareThreads 75
ThreadsPerChild 25
MaxRequestsPerChild 0
</IfModule>

worker的工作原理是，由主控制进程生成“StartServers”个子进程，每个子进程中包含固定的ThreadsPerChild线程数，各个线程独立地处理请求。同样，为了不在请求到来时再生成线程，MinSpareThreads和MaxSpareThreads设置了最少和最多的空闲线程数；而MaxClients设置允许的最大线程总数。如果现有子进程中的线程总数不能满足负载，控制进程将派生新的子进程。每个子线程处理服务请求次数由MaxRequestPerChild定义。 缺省的设置值为0，即响应无限此请求。
————————————————
版权声明：本文为CSDN博主「mayabin」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/mayabin/article/details/1042642
```



### 当前目录下有一个文件为 showme.sh , 如何修改文件，将其指定为使用 /bin/bash 运行，如何修改其权限为所有用户可读写，所有用户可执行?

在文件开头写上：#!/bin/bash

### 当前目录下有一个文件为 showme.sh,如何修改其所有人为root?

chown  root showme.sh

### 在linux请写出一种自动定时备份某一个文件的方法和具体实施流程，要求每天凌晨3点的时候备份一次。

###  使用命令可以查看Linux的启动信息？

​		demesg











# **十一.推理题**

1.在太平洋一岛上住着土人，他们不喜欢外人来打扰。有一天一位探险家来到了岛上，被土人抓住，土人的祭司告诉探险家，他在临时之前有机会留
下一句话，如果这句话是真的，他将被烧死，如果这句话是假的，他将被五马分尸，可怜的探险家如何才能活下来？并解释。
答：我将被五马分尸
如果是真话，游客将被烧死，而不会被五马分尸，因此游客所说为假话！矛盾！
如果是假话，游客将被五马分尸，的确如他所说，因此游客所说为真话！矛盾！
这样，无法断定游客所说是真是假！岛上人也就无法执行他们的规则！

###### 



# 十二.redis面试题

### 1.Redis、Memecached 这两者有什么区别？

- Redis 支持更加丰富的数据存储类型，String、Hash、List、Set 和 Sorted Set。

- Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。

  在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基 数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。

  但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。

  Memcached 仅支持简单的 key-value 结构。

- Memcached key-value存储比 Redis 采用 hash 结构来做 key-value 存储的内存利用率更高。

- Redis 提供了事务的功能，可以保证一系列命令的原子性

- Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中

- Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis 在存储小数据时比 Memcached 性能更高。

- Redis 如何实现持久化？
  - RDB 持久化，将 redis 在内存中的的状态保存到硬盘中，相当于备份数据库状态。
  - AOF 持久化（Append-Only-File），AOF 持久化是通过保存 Redis 服务器锁执行的写状态来记录数据库的。相当于备份数据库接收到的命令，所有被写入 AOF 的命令都是以 redis 的协议格式来保存的。

### 2.什么是穿透？如何解决？

redis缓存和数据库中没有相关数据，请求无法进行拦截，直接被穿透到数据库，导致数据库压力过大宕机

解决方案：

1. 将不存在的数据也缓存到redis中，设置一个较短的过期时间

2. 采用布隆过滤器，将所有可能的数据都hash到一个足够大的bitmap中，一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层查询系统的压力

3. 拉黑该ip地址

### 3.什么是击穿？如何解决？

某一个热点key在不停的扛着高并发，当这个key失效的一瞬间，持续的高并发就会直接访问数据库，导致数据库压力过大宕机

解决方案：

1. 热点数据设置永不过期
2. 实现互斥锁，在第一次查询时使用互斥锁锁住它，等第一个线程查询到了数据将数据存入缓存，之后的线程就可以直接走缓存



### 4.为什么Redis是单线程的？Redis单线程的优劣势

```
因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。
既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。
```

1.单进程单线程优势
  1) 代码更清晰，处理逻辑更简单
  2) 不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗
  3) 不存在多进程或者多线程导致的切换而消耗CPU

2.单进程单线程弊端
  无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善；

### 5.redis 持久化策略

reids是一个key-value存储系统，为了保证效率，缓存在内存中，但是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，以保证数据的持久化。

所以：redis是一个支持持久化的内存数据库，可以将内存中的数据同步到磁盘保证持久化。

Redis的持久化策略：2种

    rdb:快照形式是直接把内存中的数据保存到一个dump文件中，定时保存，保存策略
    aof：把所有的对redis的服务器进行修改的命令都存到一个文件里，命令的集合


rdb：

默认情况下，是快照rdb的持久化方式，将内存中的数据以快照的方式写入二进制文件中，默认的文件名是dump.rdb

```
redis.conf配置：
    save 900 1 
    save 300 10
    save 60 10000
```

默认是如上配置：900秒之内，如果超过1个key被修改，则发起快照保存；

300秒内，如果超过10个key被修改，则发起快照保存

1分钟之内，如果1万个key被修改，则发起快照保存

这种方式不能完全保证数据持久化，因为是定时保存，所以当redis服务down掉，就会丢失一部分数据，而且数据量大，写操作多的情况下，会引起大量的磁盘IO操作，会影响性能。

所以，如果这两种方式同时开启，如果对数据进行恢复，不应该用rdb持久化方式对数据库进行恢复。

**RDB的优点：**

对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。使用RDB文件进行数据恢复比使用AOF要快很多。

**RDB的缺点：**

快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间，影响Redis对外提供服务的能力。

采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。AOF默认是关闭的，如要开启，进行如下配置：

appendonly yes

AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：

appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢appendfsync everysec：折中的做法，交由后台线程每秒fsync一次

随着AOF不断地记录写操作日志，因为所有的操作都会记录，所以必定会出现一些无用的日志。大量无用的日志会让AOF文件过大，也会让数据恢复的时间过长。不过Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。

AOF rewrite可以通过BGREWRITEAOF命令触发，也可以配置Redis定期自动进行：

auto-aof-rewrite-percentage 100

auto-aof-rewrite-min-size 64mb

上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。

 

**AOF的优点：**

最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。

 

**AOF的缺点：**

AOF文件通常比RDB文件更大，性能消耗比RDB高，数据恢复速度比RDB慢

数据持久化引发的延迟

Redis的数据持久化工作本身就会带来延迟，需要根据数据的安全级别和性能要求制定合理的持久化策略：

AOF + fsync always的设置虽然能够绝对确保数据安全，但每个操作都会触发一次fsync，会对Redis的性能有比较明显的影响AOF + fsync every second是比较好的折中方案，每秒fsync一次AOF + fsync never会提供AOF持久化方案下的最优性能使用RDB持久化通常会提供比使用AOF更高的性能，但需要注意RDB的策略配置每一次RDB快照和AOF Rewrite都需要Redis主进程进行fork操作。fork操作本身可能会产生较高的耗时，与CPU和Redis占用的内存大小有关。根据具体的情况合理配置RDB快照和AOF Rewrite时机，避免过于频繁的fork带来的延迟

Redis在fork子进程时需要将内存分页表拷贝至子进程，以占用了24GB内存的Redis实例为例，共需要拷贝24GB / 4kB * 8 = 48MB的数据。在使用单Xeon 2.27Ghz的物理机上，这一fork操作耗时216ms。

可以通过INFO命令返回的latest_fork_usec字段查看上一次fork操作的耗时（微秒）

不过大多数应用场景下，建议至少开启RDB方式的数据持久化。Redis 对于数据备份是非常友好的， 因为你可以在服务器运行的时候对 RDB 文件进行复制： RDB 文件一旦被创建， 就不会进行任何修改。 当服务器要创建一个新的 RDB 文件时， 它先将文件的内容保存在一个临时文件里面， 当临时文件写入完毕时， 程序才使用 rename(2) 原子地用临时文件替换原来的 RDB 文件。
————————————————
版权声明：本文为CSDN博主「bamboo_cqh」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/bamboo_cqh/article/details/91955745

### 6.Redis淘汰策略

**Reids的6种淘汰策略：**

- noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外, 如 DEL )。
- allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
- volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
- allkeys-random: 所有key通用; 随机删除一部分 key。
- volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。
- volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。

maxmemory 用于指定 Redis 能使用的最大内存。既可以在 redis.conf 文件中设置, 也可以在运行过程中通过 CONFIG SET 命令动态修改。

例如, 要设置 100MB 的内存限制, 可以在 redis.conf 文件中这样配置：

```
maxmemory 100mb
```

当内存使用达到最大限制时, 如果需要存储新数据, 根据配置的策略(policies)的不同, Redis可能直接返回错误信息, 或者删除部分老的数据。

**策略选择：**

- 如果分为热数据与冷数据, 推荐使用 allkeys-lru 策略。 也就是, 其中一部分key经常被读写. 如果不确定具体的业务特征, 那么 allkeys-lru 是一个很好的选择。
- 如果需要循环读写所有的key, 或者各个key的访问频率差不多, 可以使用 allkeys-random 策略, 即读写所有元素的概率差不多。
- 假如要让 Redis 根据 TTL 来筛选需要删除的key, 请使用 volatile-ttl 策略。

volatile-lru 和 volatile-random 策略主要应用场景是: 既有缓存,又有持久key的实例中。 一般来说, 像这类场景, 应该使用两个单独的 Redis 实例。

值得一提的是, 设置 expire 会消耗额外的内存, 所以使用 allkeys-lru 策略, 可以更高效地利用内存, 因为这样就可以不再设置过期时间了。





**Redis内存不足的缓存淘汰策略提供了8种。**
noeviction：当内存使用超过配置的时候会返回错误，不会驱逐任何键
allkeys-lru：加入键的时候，如果过限，首先通过LRU算法驱逐最久没有使用的键
volatile-lru：加入键的时候如果过限，首先从设置了过期时间的键集合中驱逐最久没有使用的键
allkeys-random：加入键的时候如果过限，从所有key随机删除
volatile-random：加入键的时候如果过限，从过期键的集合中随机驱逐
volatile-ttl：从配置了过期时间的键中驱逐马上就要过期的键
volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键
allkeys-lfu：从所有键中驱逐使用频率最少的键
**这八种大体上可以分为4中，lru、lfu、random、ttl。**
lru：Least Recently Used)，最近最少使用
lfu：Least Frequently Used，最不经常使用法
ttl：Time To Live，生存时间
random：随机
默认是noeviction。对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外
eviction：“逐出；赶出；收回”。
volatile：“不稳定的”。

### 7.Redis高可用

在生产环境下,单机部署的Redis服务一旦宕机,所有依赖Redis服务的主流服务都会受到影响, 这时就需要一种Redis高可用方案。
一般来说, 一个高可用的方案要满足以下三点要求:

- 数据备份(冗余) 数据冗余在不同的节点上,防止数据丢失
- 故障自动切换 正在服务的节点故障时,可以自动地切换到备用节点。
- 在线扩容(缩容) 即可以根据需要动态地增加、减少服务实例。

#### 一、主从复制

类似于MYSQL的主从同步, 是将一台Redis服务器的数据(主节点)复制到其他的Redis服务器上(从节点),且数据的复制是**单向**的，只能由主节点到从节点。Redis 主从复制支持 **主从同步** 和 **从从同步** 两种，后者是 Redis 后续版本新增的功能，以减轻主节点的同步负担。

#### 主从复制原理

1.slave节点初次启动时主动向master发起TCP连接,并发起同步请求(psync命令), master接收连接(可要求授权认证),并将slave的信息保存起来。

2.master节点收到同步请求,执行BGSAVE命令生成rdb文件,文件生成后发送给slave。

3.slave收到后首先清楚自己的旧数据, 然后载入收到的rdb文件, slave更新至master执行bgsave命令前的状态。

4.master将保存rdb文件期间收到的写命令发送给slave, slave更新至主节点的最新状态。

5.此后master每有写命令,就会主动发送给slave节点。

主从节点会分别维护一个复制便宜量(复制的字节数), 当出现网络中断等情况时,重连后会从偏移量处开始进行部分复制,避免了全量复制的重型操作。

#### 主从复制配置

主从复制master节点不需要做任何配置, 只需要在slave的配置文件中加入: `slaveof <masterip> <masterport>`
从节点启动时就会自动向主节点发起连接,完成主从同步的一系列过程。

##### 优点

主从复制提供了基本的数据多节点备份功能, 当主节点发生故障时,可以启用从节点继续提供服务。

##### 缺点

无法实现故障的自动切换, 主节点故障时,需要手动将程序(客户端)的配置从主节点切换为从节点,然后重启客户端程序。
**Tips**: 主从复制的机制是其他高可用方式的基础, 下面介绍的哨兵方式和集群方式都依赖于主从复制机制。

#### 二、哨兵

![img](https://img2020.cnblogs.com/blog/932665/202011/932665-20201105132000540-352641714.png)

*上图* 展示了一个典型的哨兵架构图，它由两部分组成，哨兵节点和数据节点(主节点+从节点)

- **哨兵节点**: 哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的 Redis 节点，不存储数据。
- **数据节点：** 主节点和从节点都是数据节点。

哨兵方式在主从复制的基础上, 实现了故障自动切换的功能:

- **监控（Monitoring）：** 哨兵会不断地检查主节点和从节点是否运作正常。
- **自动故障转移（Automatic failover）：** 当 **主节点** 不能正常工作时，哨兵会开始 **自动故障转移操作**，它会将失效主节点的其中一个 **从节点升级为新的主节点**，并让其他从节点改为复制新的主节点。
- **配置提供者（Configuration provider）：** 客户端在初始化时，通过连接哨兵来获得当前 Redis 服务的主节点地址。
- **通知（Notification）：** 哨兵可以将故障转移的结果发送给客户端。

快速开始

以下我们以一主二从三哨兵的架构来搭建一个哨兵系统

找到 `redis.conf` 文件复制三份分别命名为 `redis-master.conf` redis-slave1.conf
redis-slave2.conf 分别作为一个主节点和两个从节点的配置

配置如下:

```
#redis-master.conf    master配置
port 6379
daemonize yes
logfile "6379.log"
dbfilename "dump-6379.rdb"
 
#redis-slave1.conf   slave1配置
port 6380
daemonize yes
logfile "6380.log"
dbfilename "dump-6380.rdb"
slaveof 127.0.0.1 6379
 
#redis-slave2.conf    slave2配置
port 6381
daemonize yes
logfile "6381.log"
dbfilename "dump-6381.rdb"
slaveof 127.0.0.1 6379
```

然后启动三个redis实例:

```
redis-server redis-master.conf
redis-server redis-slave1.conf
redis-server redis-slave2.conf
```

节点启动后，我们执行 `redis-cli` 默认连接到我们端口为 `6379` 的主节点执行 `info Replication` 检查一下主从状态是否正常

![img](https://img2020.cnblogs.com/blog/932665/202011/932665-20201106150740391-1045900983.png)

按照上面同样的方法，我们给哨兵节点也创建三个配置文件。*(哨兵节点本质上是特殊的 Redis 节点，所以配置几乎没什么差别，只是在端口上做区分就好)*

```
# redis-sentinel-1.conf
port 26379
daemonize yes
logfile "26379.log"
sentinel monitor mymaster 127.0.0.1 6379 2

# redis-sentinel-2.conf
port 26380
daemonize yes
logfile "26380.log"
sentinel monitor mymaster 127.0.0.1 6379 2

# redis-sentinel-3.conf
port 26381
daemonize yes
logfile "26381.log"
sentinel monitor mymaster 127.0.0.1 6379 2
```

其中，`sentinel monitor mymaster 127.0.0.1 6379 2` 配置的含义是：该哨兵节点监控 `127.0.0.1:6379` 这个主节点，该主节点的名称是 `mymaster`，最后的 `2` 的含义与主节点的故障判定有关：至少需要 `2` 个哨兵节点同意，才能判定主节点故障并进行故障转移。

执行下方命令将哨兵节点启动起来：

```
redis-server redis-sentinel-1.conf --sentinel
redis-server redis-sentinel-2.conf --sentinel
redis-server redis-sentinel-3.conf --sentinel
```

使用 `redis-cil` 工具连接哨兵节点，并执行 `info Sentinel` 命令来查看是否已经在监视主节点了

```
# 连接端口为 26379 的 Redis 节点
➜  ~ redis-cli -p 26379
127.0.0.1:26379> info Sentinel
# Sentinel
sentinel_masters:1
sentinel_tilt:0
sentinel_running_scripts:0
sentinel_scripts_queue_length:0
sentinel_simulate_failure_flags:0
master0:name=mymaster,status=ok,address=127.0.0.1:6379,slaves=2,sentinels=3
```

#### 三、集群方式

哨兵方式虽然实现了故障自动切换, 但是实际为客户端提供读写服务的Redis仍然只有主节点一个,所以受限于单机的内存容量。

- 集群方式采用数据分片的方式将数据存储在多个节点上,突破了单机的存储限制。
- 集群中的每个节点都可以对客户端提供读写服务, 集群相对于单机拥有更高的并发能力。

![img](https://img2020.cnblogs.com/blog/932665/202011/932665-20201106150559832-97457079.png)

*上图* 展示了 **Redis Cluster** 典型的架构图，集群中的每一个 Redis 节点都 **互相两两相连**，客户端任意 **直连** 到集群中的 **任意一台**，就可以对其他 Redis 节点进行 **读写** 的操作。

###### 数据分片

Redis 集群使用数据分片来实现, 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽。集群中的每个节点负责处理一部分哈希槽。

###### 搭建Redis集群

要让集群正常工作至少需要3个主节点，在这里我们要创建6个redis节点，其中三个为主节点，三个为从节点。为了方便演示,这6个redis部署在同一台机器, 采用不同的端口号(7000 ~ 7005)。

###### 准备配置文件

6个Redis节点的配置文件分别命名为node_7000.conf, node_7001.conf , ......, node_7005.conf,

除了端口号不同外,其余配置相同, 配置如下:

```
# 后台执行
daemonize yes
# 端口号
port 7000
# 为每一个集群节点指定一个 pid_file
pidfile ~/Desktop/redis-cluster/redis_7000.pid
# 启动集群模式
cluster-enabled yes
# 每一个集群节点都有一个配置文件，这个文件是不能手动编辑的。确保每一个集群节点的配置文件不通
cluster-config-file nodes-7000.conf
# 集群节点的超时时间，单位：ms，超时后集群会认为该节点失败
cluster-node-timeout 5000
# 最后将 appendonly 改成 yes(AOF 持久化)
appendonly yes
```

启动6个Redis实例

```
redis-server redis_7000.conf
redis-server redis_7001.conf
redis-server redis_7002.conf
redis-server redis_7003.conf
redis-server redis_7004.conf
redis-server redis_7005.conf
```

使用ps -ef | grep redis查看

![img](https://img2020.cnblogs.com/blog/932665/202011/932665-20201105132137348-1318497534.png)

可以看到6个Redis实例都以cluster的方式启动了

实例启动后还处于各自独立的状态,还没有形成集群,需要手动执行命令建立集群。

建立集群

执行命令:

```
redis-cli --cluster create --cluster-replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
```

`--replicas 1` 的意思是：我们希望为集群中的每个主节点创建一个从节点。

![img](https://img2020.cnblogs.com/blog/932665/202011/932665-20201105132235761-1112075326.png)

看到 `[OK]` 的信息之后，就表示集群已经搭建成功了，可以看到，这里我们正确地创建了三主三从的集群。

验证集群

使用 `redic-cli` 任意连接一个节点：

```
redis-cli -c -h 127.0.0.1 -p 7000
127.0.0.1:7000>
```

- `-c`表示集群模式；`-h` 指定 ip 地址；`-p` 指定端口。

```
127.0.0.1:7000> SET name xiaoming
-> Redirected to slot [5798] located at 127.0.0.1:7001
OK
127.0.0.1:7001>
```

可以看到这里 Redis 自动帮我们进行了 `Redirected` 操作跳转到了 `7001` 这个实例上

我们可以在任意节点使用`cluster nodes` 查看节点列表

![img](https://img2020.cnblogs.com/blog/932665/202011/932665-20201105132314871-382578368.png)

**故障模拟**

从图中我们可以看到7005实例是7001实例的从节点, 我们现在停掉7001的实例(kill -9)

![img](https://img2020.cnblogs.com/blog/932665/202011/932665-20201105132344235-2006082319.png)

然后我们连接现存的任一节点,读取name值

![img](https://img2020.cnblogs.com/blog/932665/202011/932665-20201105132410794-126440982.png)

发现仍然可以从7005的实例上读取到值,集群仍然是正常运转的。

当我们把7005实例也停掉后,集群就会变得不可用

![img](https://img2020.cnblogs.com/blog/932665/202011/932665-20201105132430139-649335906.png)

### 8.分布式的环境下， MySQL和Redis如何保持数据的一致性？

数据库和缓存之间一般不需要强一致性。

一般缓存是这样的：

- 读的顺序是先读缓存，后读数据库
- 写的顺序是先写数据库，然后写缓存
- 每次更新了相关的数据，都要把该缓存清理掉
- 为了避免极端条件下造成的缓存与数据库之间的数据不一致，缓存需要设置一个失效时间。时间到了，缓存自动被清理，达到缓存和数据库数据的“最终一致性”





作者：彼得潘大叔
链接：https://www.zhihu.com/question/36413559/answer/71303343
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



说个大概吧，我们热数据基本都是redis，增删改都是操作mysql，对于读是保存到redis，这样就涉及到数据同步操作，同步操作分为两大块，我们的叫法是，一个是全量(将全部数据一次写入到redis，时间几小时不等)，一个是增量（实时更新）。这里说的是增量，主要问题是即时性，因为增删改都是直接操作mysql变更都在MySQL（这里高并发的问题是用分库分表加外层的负载均衡） 所以我们的方向是读取binlog然后分析 ，利用消息推送到某服务器A，再进行分析，然后更新各台redis，消息推送工具用的是rabbitMQ，可设定某表的变更推送(分三类update insert delate 包含变更前后的数据)，这里有个问题是：mysql数据操作太频繁产生的推送可能会很多，所以分析处理脚本处理速度一定要跟得上（我用Python写，前期多线程（坑），后来改成多进程），还有一个问题是，对于mysql-redis的数据关系映射设定不要太复杂，一表对一表就行，数据组合交给业务层做，这样分析处理脚本不会太多负担，处理速度更快，而且操作redis也更简单，redis每个对应mysql数据表的可使用多端口多实例，redis是单线程而且这样对于redis的主从和负载均衡有利，

题外话：对于服务器A 可以再给其它服务做一个数据表增量变更数据获取接口，利用数据纬度，获取时间段的变更数据。

追加，对于订单类部分，都是完全使用mysql，这个做好数据服务器，DB，table，分区，的拆分就好了，看并发请求越多拆分越多。

### 9.redis分布式集群：

集群方案：

1、 主从高可用（该方案就是单实例形式，只是为了保证数据的安全，对于用户数据少，业务的前期可以采用，目前我司缓存架构就是采用该方案）

2、 客户端分片（典型代表：Jedis。自主写分片算法，代码掌握在自己手中，可控性强，但是需要专业的开发运维人员维护，技术要求和维护成本高）

3、代理分片（典型代表：Twemproxy，redis集群没有正式推出之前官网推荐的方案，也是目前使用最多的）

4、 Redis cluster（3版本推出的集群方案，历时四年之多的开发）

5、 Codis集群（豌豆荚15年开源的解决方案，开源之前其已经用了2年之多，与其同期官网推出redis cluster）

6、 各大互联网公司自主研发的集群架构，但是还没有开源，可能也不会开源

- codis架构

[![redis分布式集群3种架构方案](http://p3.pstatp.com/large/pgc-image/7db0c78c77b84553ab6f8c7728e84095)](http://p3.pstatp.com/large/pgc-image/7db0c78c77b84553ab6f8c7728e84095)

 

简单说明：

1、codis-proxy提供连接集群redis的服务入口

2、codis-config管理工具，支持包括添加/删除redis/proxy节点，发起数据迁移等操 作，自带一个dashboard工具，浏览器可以直观查看集群的运行状态

3、codis-server-group实现redis读写的水平扩展、高性能

4、codis-server实现redis实例服务，通过codis-ha实现服务的高可用

5、Zookeeper/etcd存放数据路由表和codis-proxy节点的元信息，codis-config发起的命令通过其同步到各个存活的codis-proxy，则zookeeper如果出问题则可能导致数据不一致的情况或者严重的会对外提供服务造成影响

- Twemproxy

[![redis分布式集群3种架构方案](http://p9.pstatp.com/large/pgc-image/92aed36b843a407390f5cf0b2a442d87)](http://p9.pstatp.com/large/pgc-image/92aed36b843a407390f5cf0b2a442d87)

 

简单说明：

1、proxy提供分片算法和redis服务入口，支持高可用

2、Redis提供实现实例，并且通过sentinel支持高可用

3、Redis-Twemporxy提供通知底层HA切换至proxy

4、每个层结构出现问题或者变更节点信息等所有操作都需要重新规划分片算法，则需要重启服务

- redis-cluster架构

[![redis分布式集群3种架构方案](http://p1.pstatp.com/large/pgc-image/619e878171a84091bc8235890e5dd179)](http://p1.pstatp.com/large/pgc-image/619e878171a84091bc8235890e5dd179)

 

简单说明：

1、redis cluster本身集群方案，客户端可以任一连接一个节点

2、redis-trib.rb脚本为集群的管理工具，比如自动添加节点，规划槽位，迁移数据等一系列操作（ruby语言）

3、每个节点都和N-1个节点通信，所以要维护好这个集群架构的每个节点信息，不然会导致整个集群不可工作

### 10.如何保证redis缓存与数据一致性问题

对于读多写少的高并发场景，我们会经常使用缓存来进行优化。比如说支付宝的余额展示功能，实际上99%的时候都是查询，1%的请求是变更（除非是土豪，每秒钟都有收入在不断更改余额），所以，我们在这样的场景下，可以加入缓存，用户->余额。





以下这张图是我们读取数据的操作。

![img](https:////upload-images.jianshu.io/upload_images/4017523-375ed4c07fa58b2c.png?imageMogr2/auto-orient/strip|imageView2/2/w/459/format/webp)

Redis缓存与数据一致性问题

那么基于上面的这个出发点，问题就来了，当用户的余额发生变化的时候，如何更新缓存中的数据，也就是说。

1. 我是先更新缓存中的数据再更新数据库的数据；
2. 还是先修改数据库中的数据再更新缓存中的数据

这就是我们经常会在面试遇到的问题，数据库的数据和缓存中的数据如何达到一致性？首先，可以肯定的是，redis中的数据和数据库中的数据不可能保证事务性达到统一的，这个是毫无疑问的，所以在实际应用中，我们都是基于当前的场景进行权衡降低出现不一致问题的出现概率。

此外我们还可以通过给缓存设置一个过期时间，无论以上的两种操作使用哪一种，都能够在理论上保持数据的最终一致性。这种方案下，在写数据的时候，都以数据库为主，先把数据库数据写入后，再更新缓存，如果失败了，那么原来的缓存无论是否存在，那么只要经过过期时间，那么读操作时，就会重新从数据库中读出，然后同步到缓存中。

我们接着讨论以上两种操作:

1.先删除缓存，再更新数据库。在大型分布式系统环境下，就需要考虑并发时的问题了。

这种处理方式，可能会有如下情况，线程A，写入(更新)数据时，先删除缓存后，同时，有一个线程B，此时去读数据，先去缓存中读，此时刚被线程A删除了，于是去数据库读还未被线程A更新的数据，这时候就会读到脏数据了。  紧接着，线程B会把脏数据写入缓存，而线程A会把更新后的数据写入数据库。导致缓存与数据不一致。

参考方式: 给缓存设置过期时间，否则会一直读到脏数据。

处理方式:

网上有几种处理方式:

1. 双删策略
    处理步骤:
2. 先删除缓存。
    2.写入数据库
    3.休眠一秒。执行删除缓存(目的是把1秒内产生的脏数据重新从缓存中删除)

缺点: 需要把控好休眠时间，同时时间可能会过长，当请求量很大时，再短的时间也会造成响应过长。其次这个请求时间是跟读操作时，会产生脏数据的时间有关的。

如果采用读写分离数据库的情况呢？ 跟以上情况的区别就在于，当线程B去读数据库时，可能读到的是还未更新到从库的脏数据，因为当我们休眠是，不仅需要考虑读操作的完整执行完的时间，还需要加主从复制这段时间的几百Ms。

还是继续这个问题，分为两次删除，如果第二次删除失败了呢？

先说下，第一次删除失败，是不影响什么的。所以说下第二次删除失败的情况，此时删除失败，还是会造成脏数据的问题，也就是缓存一致性问题。  继续说第二种解决方案

1. 先修改数据库中的数据再更新缓存中的数据

同样存在这种情况，线程A查询操作(读操作)，线程B更新操作。

线程A先执行，线程B后执行。线程A先查询时，去缓存读取时，缓存失效了，此时继续去数据库读，这时候线程B修改数据库后，把数据写入缓存了。在此之后，线程A才执行把数据写入缓存中，此时缓存中的任然是脏数据。

分为以下几个步骤:
 （1）缓存刚好失效
 （2）请求A查询数据库，得一个旧值
 （3）请求B将新值写入数据库
 （4）请求B删除缓存
 （5）请求A将查到的旧值写入缓存

然而，发生这种情况的概率又有多少呢？
 发生上述情况有一个先天性条件，就是步骤（3）的写数据库操作比步骤（2）的读数据库操作耗时更短，才有可能使得步骤（4）先于步骤（5）。可是，大家想想，数据库的读操作的速度远快于写操作的（不然做读写分离干嘛，做读写分离的意义就是因为读操作比较快，耗资源少），因此步骤（3）耗时比步骤（2）更短，这一情形很难出现。

意思就是该情况下，只有当线程B的写步骤比线程比线程A的读数据库更快很多才会出现。

如果一定需要做控制的话，可以考虑以下几点:

1. 做redis过期策略。(时间上不好控制)
2. 上面说的延迟删除策略。(删除不一定成功)

基于第二种的话，如果删除失败，就会有一致性问题了。可以使用以下方案:
 1: 可以使用消息队列做重试保障机制



![img](https:////upload-images.jianshu.io/upload_images/4017523-63499fb2005582e9.png?imageMogr2/auto-orient/strip|imageView2/2/w/625/format/webp)



缺点: 1. 对业务代码造成大量侵入。2. 造成不必要的请求冗余。

1. 

   

   方案二

   ![img](https:////upload-images.jianshu.io/upload_images/4017523-62e16279fb6c4940.png?imageMogr2/auto-orient/strip|imageView2/2/w/835/format/webp)

   上述的订阅binlog程序在mysql中有现成的中间件叫canal，也可以使用定时任务等去控制。控制删除失败重试次数、时间、频率。

最后还有一种， 更新数据库，并且更新缓存。
 但是这种情况基本上都不推荐，（线程安全角度）
 同时有请求A和请求B进行更新操作，那么会出现
 （1）线程A更新了数据库
 （2）线程B更新了数据库
 （3）线程B更新了缓存
 （4）线程A更新了缓存
 这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据。

参考自:
 [https://www.cnblogs.com/rjzheng/p/9041659.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Frjzheng%2Fp%2F9041659.html)



### 11.Redis分布式锁怎么实现的？分布式系统中还有其他方式吗？

分布式锁常见的三种实现方式：

1. 数据库乐观锁；
2. 基于Redis的分布式锁；
3. 基于ZooKeeper的分布式锁。

本地面试考点是，你对Redis使用熟悉吗？Redis中是如何实现分布式锁的。

Redis要实现分布式锁，以下条件应该得到满足

**互斥性**

- 在任意时刻，只有一个客户端能持有锁。

**不能死锁**

- 客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。

**容错性**

- 只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。

###### 实现

可以直接通过 `set key value px milliseconds nx` 命令实现加锁， 通过Lua脚本实现解锁。

```
//获取锁（unique_value可以是UUID等）
SET resource_name unique_value NX PX  30000

//释放锁（lua脚本中，一定要比较value，防止误解锁）
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

**代码解释**

- set 命令要用 `set key value px milliseconds nx`，替代 `setnx + expire` 需要分两次执行命令的方式，保证了原子性，
- value 要具有唯一性，可以使用`UUID.randomUUID().toString()`方法生成，用来标识这把锁是属于哪个请求加的，在解锁的时候就可以有依据；
- 释放锁时要验证 value 值，防止误解锁；
- 通过 Lua 脚本来避免 Check And Set 模型的并发问题，因为在释放锁的时候因为涉及到多个Redis操作 （利用了eval命令执行Lua脚本的原子性）；

**加锁代码分析**

首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，用来标识这把锁是属于哪个请求加的，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。

**解锁代码分析**

将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。在执行的时候，首先会获取锁对应的value值，检查是否与requestId相等，如果相等则解锁（删除key）。

**存在的风险**

如果存储锁对应key的那个节点挂了的话，就可能存在丢失锁的风险，导致出现多个客户端持有锁的情况，这样就不能实现资源的独享了。

1. 客户端A从master获取到锁
2. 在master将锁同步到slave之前，master宕掉了（Redis的主从同步通常是异步的）。
   主从切换，slave节点被晋级为master节点
3. 客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。导致存在同一时刻存不止一个线程获取到锁的情况。

###### redlock算法出现

这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：

1. 获取当前时间戳，单位是毫秒；
2. 跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；
3. 尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1；
4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；
5. 要是锁建立失败了，那么就依次之前建立过的锁删除；
6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。

 

![【07期】Redis中是如何实现分布式锁的？](https://www.javazhiyin.com/wp-content/uploads/2019/10/java7-1571978049.png)

Redis 官方给出了以上两种基于 Redis 实现分布式锁的方法，详细说明可以查看：

> https://redis.io/topics/distlock 。

###### Redisson实现

Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还实现了可重入锁（Reentrant Lock）、公平锁（Fair Lock、联锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）等，还提供了许多分布式服务。

Redisson提供了使用Redis的最简单和最便捷的方法。Redisson的宗旨是促进使用者对Redis的关注分离（Separation of Concern），从而让使用者能够将精力更集中地放在处理业务逻辑上。

**Redisson 分布式重入锁用法**

Redisson 支持单点模式、主从模式、哨兵模式、集群模式，这里以单点模式为例：

```
// 1.构造redisson实现分布式锁必要的Config
Config config = new Config();
config.useSingleServer().setAddress("redis://127.0.0.1:5379").setPassword("123456").setDatabase(0);
// 2.构造RedissonClient
RedissonClient redissonClient = Redisson.create(config);
// 3.获取锁对象实例（无法保证是按线程的顺序获取到）
RLock rLock = redissonClient.getLock(lockKey);
try {
    /**
     * 4.尝试获取锁
     * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败
     * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）
     */
    boolean res = rLock.tryLock((long)waitTimeout, (long)leaseTime, TimeUnit.SECONDS);
    if (res) {
        //成功获得锁，在这里处理业务
    }
} catch (Exception e) {
    throw new RuntimeException("aquire lock fail");
}finally{
    //无论如何, 最后都要解锁
    rLock.unlock();
}
```



 

加锁流程图

![【07期】Redis中是如何实现分布式锁的？](.\img\最高级多方面面试题\java4-1571978050.png)

解锁流程图

![【07期】Redis中是如何实现分布式锁的？](.\img\最高级多方面面试题\java6-1571978050.png)

我们可以看到，RedissonLock是可重入的，并且考虑了失败重试，可以设置锁的最大等待时间， 在实现上也做了一些优化，减少了无效的锁申请，提升了资源的利用率。

需要特别注意的是，RedissonLock 同样没有解决 节点挂掉的时候，存在丢失锁的风险的问题。而现实情况是有一些场景无法容忍的，所以 Redisson 提供了实现了redlock算法的 RedissonRedLock，RedissonRedLock 真正解决了单点失败的问题，代价是需要额外的为 RedissonRedLock 搭建Redis环境。

所以，如果业务场景可以容忍这种小概率的错误，则推荐使用 RedissonLock， 如果无法容忍，则推荐使用 RedissonRedLock。

###### 参考

> https://github.com/javazhiyin/advanced-java/
> https://crazyfzw.github.io/2019/04/15/distributed-locks-with-redis/

### 12.为什么一线大厂面试必问redis，有啥好问的？

**速度快**

- 纯内存操作，速度可想而知
- C语言实现，天生的跟操作系统有亲戚
- 单线程架构，无并发问题，避免了上下文切换问题

### **13.多种优秀的数据结构**

[Redis常用命令、5种数据类型的内部编码实现以及实用场景](http://mp.weixin.qq.com/s?__biz=MzU5MDgzOTYzMw==&mid=2247484129&idx=1&sn=81fb9ff41a2e7f278e0912fc649721ca&chksm=fe3968dfc94ee1c940bcf4ddb2194a3909834ea2d18c78b19e05d167c21be6ae9e0e82b3d397&scene=21#wechat_redirect)

除了5种常用类型，还有bitmaps、hyperloglogs 、geospatial等类型。

##### **丰富的功能**

- 键过期功能
- 发布订阅功能
- Lua脚本功能
- 简单的事务功能，[Redis中的事务与Lua脚本](http://mp.weixin.qq.com/s?__biz=MzU5MDgzOTYzMw==&mid=2247484154&idx=1&sn=abe8edb75369957ba5497a5e4bb70f3c&chksm=fe3968c4c94ee1d2b9de9325063ed3e14894c943ff565f471367098fe933284285a44becb7c2&scene=21#wechat_redirect)
- 提供了流水线功能

##### **持久化**

[Redis的两种持久化方式：RDB和](http://mp.weixin.qq.com/s?__biz=MzU5MDgzOTYzMw==&mid=2247484135&idx=1&sn=583ad497304a5da567d1a73ae7b001c6&chksm=fe3968d9c94ee1cfe6d2a7dce86b001fce0c022cf390f52db4c9c5985ce0777b416103d25715&scene=21#wechat_redirect)[AOF](http://mp.weixin.qq.com/s?__biz=MzU5MDgzOTYzMw==&mid=2247484135&idx=1&sn=583ad497304a5da567d1a73ae7b001c6&chksm=fe3968d9c94ee1cfe6d2a7dce86b001fce0c022cf390f52db4c9c5985ce0777b416103d25715&scene=21#wechat_redirect)



##### **主从复制**

[Redis主从复制](http://mp.weixin.qq.com/s?__biz=MzU5MDgzOTYzMw==&mid=2247484138&idx=1&sn=c1d710915241fd39f5e136f184b5ab66&chksm=fe3968d4c94ee1c2fffc2cf602fc7c2d74353cc4e7949d2be961078c08fd44366b584b185ed5&scene=21#wechat_redirect)



##### **高可用和分布式**

[Redis哨兵环境搭建](http://mp.weixin.qq.com/s?__biz=MzU5MDgzOTYzMw==&mid=2247484141&idx=1&sn=fcd0cb241406a25d8ffc40c00f3e7ebc&chksm=fe3968d3c94ee1c5826352b71e3a6b0a53336458442ff9f88d12caf3eb48a7865e2402925b4f&scene=21#wechat_redirect)

[Redis集群环境搭建](http://mp.weixin.qq.com/s?__biz=MzU5MDgzOTYzMw==&mid=2247484157&idx=1&sn=bdcb3cbc11b13101f6e78a163cf51871&chksm=fe3968c3c94ee1d5b3f9a9541d6de0e3216541ce198b60fd9927d6b7553f0ecfd7a6a7b04c27&scene=21#wechat_redirect)



##### **高频面试题汇总**

[缓存淘汰、缓存穿透、缓存击穿、缓存雪崩、数据库缓存双写一致性](http://mp.weixin.qq.com/s?__biz=MzU5MDgzOTYzMw==&mid=2247484165&idx=1&sn=98d208db5ca8de72a9fc95da6e9eca51&chksm=fe39693bc94ee02d9725216938c0221d6ea04a3ccdb820a3b6603cf964c4de42fa8756aea283&scene=21#wechat_redirect)



##### Redis有几种架构模式？

- 单机版，自己用来学习的，没人用在生产吧
- 一主n从架构，实现读写分离，但是无法实现高可用
- 哨兵，保证了高可用、可以实现自动故障转移
- 集群，海量数据的高并发高可用场景，运维起来比较复杂

##### Redis哨兵和集群的区别是什么？

哨兵专注于高可用，集群专注于可扩展

##### 分布式系统下的哈希一致性算法

哈希槽：

redis中每个集群都有固定的 16384 个哈希槽，这些哈希槽被分配到集群中的每个master节点中。每个 key 在操作使都要先计算 CRC16 值，然后对 16384 取模，获取 key 对应的哈希槽然后再操作具体的节点。

##### 如何让一批数据分布在集群中的一个节点上？

为什么有时候要让相关键都分配到同一个节点？

因为如果命令涉及到多个键，那么只有这些键都位于同一个节点里，Redis才能正常支持该命令。

Redis是按照什么路由规则，分配键到节点的？

因为Redis集群内置插槽为16384个，所以Redis会将每个键的键名的有效部分使用CRC16算法计算出散列值，然后对16384的取余。余数为多少就表示该键应该被分配到哪个节点，这样的话，每个键都可以被分配到16384个插槽中，而集群中的每个节点都会被分配一定的插槽。

关键就在每个键的键名的有效部分，因为Redis是根据每个键的键名的有效部分使用CRC16算法计算出的散列值来分配键的，那么如果想要让相关键都分配到集群中的同一个节点里，只需要让相关键的键名的有效部分相同即可。

那么键名的有效部分指的是什么？

如果键名包含{符号，且在{符号后面存在}符号，并且{和}之间有至少一个字符，则有效部分是指{和}之间的内容。

如果不满足前一条规则，那么整个键名都为有效部分。

比如键user.name的有效部分就是“user.name”，键{user}.name的有效部分就是”user”。

需求：让id为101的用户的username和age属性分配到同一个节点，方便之后批量取出。

操作示例：

![在这里插入图片描述](.\img\最高级多方面面试题\4343535)



可以发现设值操作时，username和age都被分配到了6382端口节点实例，属于同一个节点，所以之后可以支持mget命令一次操作两个键。



##### Redis并发写问题

- 客户端并发可以基于 zookeeper 实现分布式锁
- 服务端使用setnx实现锁

##### 如何进行批量操作？

Pipeline

```
1.redis list 批量push

redis 批量push很简单，因为lpush名的参数，是可变长参数，只要push时放入多个参数即可。

LPUSH key value [value ...]
#将一个或多个值 value 插入到列表 key 的表头
 

2.redis list 批量pop

RPOP key
#移除并返回列表 key 的尾元素。
rpop命令只能每次操作一个命令

这个时候就要用到 redis pipeline 实现批量操作。

 

2.1.redis pipeline

redis pipeline(管道机制)是redis批量提交的一种方式，也就是把多个命令操作建立一次连接发给redis去执行，在性能方面会比循环的单次提交会好很多。这个mysql executeBatch很相似。

 

2.1.redis pipeline批量操作案例代码

/**
     * 批量消费redis消息
     * @param key redis KEY
     * @param batchSize 消费的数量
     * @return
     */
    public List<Object> batchGetCallBackMessge(String key,int batchSize){
        List<Object> results = redisTemplate.executePipelined(
                new RedisCallback<Object>() {
                    public Object doInRedis(RedisConnection connection) throws DataAccessException {
                        for(int i=0;i<batchSize;i++){
                            connection.rPop(key.getBytes());
                        }
                        return null;
                    }
                }
                );
        return  results;
    }
```

### 14.Redis集群进行批量操作的几种方式-

《redis并发与运维》

###### 串行命令

由于n个key是比较均匀的分布在Redis Cluster的各个节点上，因此无法使用mget命令一次性获取，所以通常来讲要获取n个key的值，最简单的方法就是逐次执行n个get命令，这种操作的时间复杂度较高，它的操作时间 = n次网络时间 + n次命令时间，网络次数是n。很显然这种方案不是最优的，但是实现起来比较简单。

###### 串行IO

Redis Cluster使用CRC16算法计算出散列值，再取对16383的余数就可以算出slot值，同时我们可以使用Smart客户端保存slot和节点的对应关系，有了这两个数据就可以将属于同一个节点的key进行归档，得到每个节点的key子列表，之后对每个节点执行mget或Pipeline操作，它的操作时间 = node次网络时间 + n次命令时间，网络次数是node的个数，很明显这种方案比第一种要好很多，但是如果节点数太多，还是有一定的性能问题。

###### 并行IO

此方案是将方案2中的最后一步改为多线程执行，网络次数虽然还是节点个数，但由于使用多线程网络时间变为O(1)，这种方案会增加编程的复杂度。它的操作时间为：

> max_slow(node网络时间) + n次命令时间

###### hash_tag实现

Redis Cluster提供了hash_tag功能，可以将多个key强制分配到一个节点上，它的操作时间 = 1次网络时间 + n次命令时间。

###### 总结

![img](https://www.my607.com/d/file/jianzhanjingyan/2020-10-29/7515447a0ebbb12d458efaa1cf0f6136.jpeg)

批量操作方案对比

### 15.Redis技巧:分片技术和Hash Tag

twitter的 [twemproxy](https://link.jianshu.com?t=https://github.com/twitter/twemproxy) 是一个Redis的代理服务程序,能够实现key的分片。分片能使key均匀地分布到集群的机器上去，能保证数据的一致性，有着众多的优点。

但从Redis单实例切换到twemproxy集群时，还是有些需要注意的地方：

不支持的方法：

KEYS,MIGRATE,SCAN等

支持但需特殊处理的方法：

MSET,SINTERSTORE,SUNIONSTORE,ZINTERSTORE,ZUNIONSTORE等

全部请查看 [Redis命令列表](https://link.jianshu.com?t=https://github.com/twitter/twemproxy/blob/master/notes/redis.md).

对于不支持的方法，在使用时需要寻找替代方案。本文主要解决一下需特殊处理的方法。

###### MSET

单实例上的MSET是一个原子性(atomic)操作，所有给定 key 都会在同一时间内被设置，某些给定 key 被更新而另一些给定 key 没有改变的情况，不可能发生。

而集群上虽然也支持同时设置多个key，但不再是原子性操作。会存在某些给定 key 被更新而另外一些给定 key 没有改变的情况。其原因是需要设置的多个key可能分配到不同的机器上。

###### SINTERSTORE,SUNIONSTORE,ZINTERSTORE,ZUNIONSTORE

这四个命令属于同一类型。它们的共同之处是都需要对一组key进行运算或操作，但要求这些key都被分配到相同机器上。

这就是分片技术的矛盾之处：

**即要求key尽可能地分散到不同机器，又要求某些相关联的key分配到相同机器。**

###### Hash Tags

解铃还需系铃人。解决方法还是从分片技术的原理上找。

分片，就是一个hash的过程：对key做md5，sha1等hash算法，根据hash值分配到不同的机器上。

为了实现将key分到相同机器，就需要相同的hash值，即相同的key（改变hash算法也行，但不简单）。

但key相同是不现实的，因为key都有不同的用途。例如user:user1:ids保存用户的tweets ID，user:user1:tweets保存tweet的具体内容，两个key不可能同名。

仔细观察user:user1:ids和user:user1:tweets，两个key其实有相同的地方，即user1。能不能拿这一部分去计算hash呢？

这就是 [Hash Tag](https://link.jianshu.com?t=https://github.com/twitter/twemproxy/blob/master/notes/recommendation.md#hash-tags) 。允许用key的部分字符串来计算hash。

**当一个key包含 {} 的时候，就不对整个key做hash，而仅对 {} 包括的字符串做hash。**

假设hash算法为sha1。对user:{user1}:ids和user:{user1}:tweets，其hash值都等同于sha1(user1)。

###### Hash Tag 配置

Hash Tag是用于hash的部分字符串开始和结束的标记，例如"{}"、"$$"等。
 配置时，只需更改hash_tag字段即可



```css
beta:
  listen: 127.0.0.1:22122
  hash: fnv1a_64
  hash_tag: "{}"
  distribution: ketama
  auto_eject_hosts: false
  timeout: 400
  redis: true
  servers:
   - 127.0.0.1:6380:1 server1
   - 127.0.0.1:6381:1 server2
   - 127.0.0.1:6382:1 server3
   - 127.0.0.1:6383:1 server4
```



作者：兔子David
链接：https://www.jianshu.com/p/c441b882c1c6
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### **15.Redis 的数据类型？**

答： Redis 支持五种数据类型： string（ 字符串），hash（ 哈希）， list（ 列表）， set（ 集合） 及 zsetsorted set： 有序集合)。

我们实际项目中比较常用的是 string，hash 如果你是 Redis 中高级用户，还需要加上下面几种数据结构HyperLogLog、Geo、Pub/Sub。

如果你说还玩过 Redis Module，像 BloomFilter，RedisSearch，Redis-ML，面试官得眼睛就开始发亮了。



### 16.使用Redis 有哪些好处？

1、速度快， 因为数据存在内存中， 类似于 HashMap， HashMap 的优势就是查找和操作的时间复杂度都是 O1

2、支持丰富数据类型， 支持 string， list， set， Zset， hash 等
3、支持事务， 单个操作都是原子性， 所谓的原子性就是对数据的更改要么全部执行， 要么全部不执行。

单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。

事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。

4、丰富的特性：可用于缓存，消息，按 key 设置过期时间，过期后将会自动删除



### 17、Redis 是单进程单线程的？

答： Redis 是单进程单线程的， redis 利用队列技术将并发访问变为串行访问， 消除了传统数据库串行控制的开销。

### 18、一个字符串类型的值能存储最大容量是多少？

答 ： 512M

### **19、Redis 的持久化机制是什么？各自的优缺点？**

**Redis 提供两种持久化机制 RDB 和 AOF 机制:**

1、RDBRedis DataBase)持久化方式： 是指用数据集快照的方式半持久化模式) 记录 redis 数据库的所有键值对,在某个时间点将数据写入一个临时文件， 持久化结束后， 用这个临时文件替换上次持久化的文件， 达到数据恢复。

**RDB：**

1、只有一个文件 dump.rdb， 方便持久化。

2、容灾性好， 一个文件可以保存到安全的磁盘。

3、性能最大化， fork 子进程来完成写操作， 让主进程继续处理命令， 所以是 IO 最大化。使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能) 4.相对于数据集大时， 比 AOF 的启动效率更高。

**缺点:**

1、数据安全性低。RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障， 会发生数据丢失。所以这种方式更适合数据要求不严谨的时候)

**AOFAppend-only file)持久化方式**： 是指所有的命令行记录以 redis 命令请求协议的格式完全持久化存储)保存为aof 文件。

**优点：**

1、数据安全， aof 持久化可以配置 appendfsync 属性， 有 always， 每进行一次命令操作就记录到 aof 文件中一次。

2、通过 append 模式写文件， 即使中途服务器宕机， 可以通过 redis-check-aof 工具解决数据一致性问题。

3、AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（ 文件过大时会对命令进行合并重写）， 可以删除其中的某些命令（ 比如误操作的 flushall）)

**缺点：**

1、AOF 文件比 RDB 文件大， 且恢复速度慢。

2、数据集大的时候， 比 rdb 启动效率低。

### **20、Redis 常见性能问题和解决方案：**

1、Master 最好不要写内存快照，如果 Master 写内存快照，save 命令调度 rdbSave 函数， 会阻塞主线程的工作， 当快照比较大时对性能影响是非常大的， 会间断性暂停服务

2、如果数据比较重要， 某个 Slave 开启 AOF 备份数据， 策略设置为每秒同步一

3、为了主从复制的速度和连接的稳定性， Master 和 Slave 最好在同一个局域网

4、尽量避免在压力很大的主库上增加从

5、主从复制不要用图状结构， 用单向链表结构更为稳定， 即：Master <- Slave1

<- Slave2 <- Slave3… 这样的结构方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master 挂了， 可以立刻启用 Slave1 做 Master， 其他不变。





1、.Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，
 会间断性暂停服务，所以Master最好不要写内存快照
				 2、.Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF
 				文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是
 不要日用内存快照做持久化，如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次
 				3、.Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，
 出现短暂服务暂停现象。
 				4、.Reids主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内

### **21、redis 过期键的删除策略？**

1、定时删除:在设置键的过期时间的同时，创建一个定时器 timer). 让定时器在键的过期时间来临时， 立即执行对键的删除操作。

2、惰性删除:放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是 否过期， 如果过期的话， 就删除该键;如果没有过期， 就返回该键。

3、定期删除:每隔一段时间程序就对数据库进行一次检查，删除里面的过期键。至 于要删除多少过期键， 以及要检查多少个数据库， 则由算法决定。



### 22、为什么 redis 需要把所有数据放到内存中？

答：Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 redis 具有快速和数据持久化的特征。如果不将数据放在内存中， 磁盘 I/O 速度为严重影响 redis 的性能。在内存越来越便宜的今天， redis 将会越来越受欢迎。如果设置了最大使用的内存， 则数据已有记录数达到内存限值后不能继续插入新值。

### 23、Redis 的同步机制了解么？

答：Redis 可以使用主从同步，从从同步。第一次同步时，主节点做一次 bgsave， 并同时将后续修改操作记录到内 存 buffer， 待完成后将 rdb 文件全量同步到复制节点， 复制节点接受完成后将 rdb 镜像加载到内存。加载完成后， 再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。

### 24、Pipeline 有什么好处，为什么要用 pipeline？

答：可以将多次 IO 往返的时间缩减为一次，前提是 pipeline 执行的指令之间没有因果相关性。使用
redis-benchmark 进行压测的时候可以发现影响 redis 的 QPS 峰值的一个重要因素是 pipeline 批次指令的数目。

### **25、是否使用过 Redis 集群，集群的原理是什么？**

1.Redis Sentinal 着眼于高可用， 在 master 宕机时会自动将 slave 提升为master， 继续提供服务。
2.Redis Cluster 着眼于扩展性， 在单个 redis 内存不足时， 使用 Cluster 进行分片存储。

### **26、Redis 集群方案什么情况下会导致整个集群不可用？**

答： 有 A， B， C 三个节点的集群,在没有复制模型的情况下,如果节点 B 失败了， 那么整个集群就会以为缺少5501-11000 这个范围的槽而不可用。

### **27、Redis 支持的Java 客户端都有哪些？官方推荐用哪个？**

答： Redisson、Jedis、lettuce 等等， 官方推荐使用 Redisson。

### **28、Jedis 与 Redisson 对比有什么优缺点？**

答： Jedis 是 Redis 的 Java 实现的客户端， 其 API 提供了比较全面的 Redis 命令的支持；Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单， 不支持字符串操作， 不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。

### **29、Redis 如何设置密码及验证密码？**

设置密码： config set requirepass 123456 授权密码： auth 123456

### **30、说说 Redis 哈希槽的概念？**

答： Redis 集群没有使用一致性 hash,而是引入了哈希槽的概念， Redis 集群有 16384 个哈希槽，每个 key 通过CRC16 校验后对 16384 取模来决定放置哪个槽， 集群的每个节点负责一部分 hash 槽。

### **31、Redis 集群的主从复制模型是怎样的？**

答： 为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用， 所以集群使用了主从复制模型,每个节点都会有 N-1 个复制品.

### **32、Redis 集群会有写操作丢失吗？为什么？**

答：Redis 并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。

### **33、Redis 集群之间是如何复制的？**

答： 异步复制

### **34、Redis 集群如何选择数据库？**

答： Redis 集群目前无法做数据库选择， 默认在 0 数据库。

### **35、怎么测试 Redis 的连通性？**

答： 使用 ping 命令。

### **36、怎么理解 Redis 事务？**

1） 事务是一个单独的隔离操作： 事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中， 不会被其他客户端发送来的命令请求所打断。

单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。

事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。

Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：

- 批量操作在发送 EXEC 命令前被放入队列缓存。
- 收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行。
- 在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。

一个事务从开始到执行会经历以下三个阶段：

- 开始事务。
- 命令入队。
- 执行事务。

### 37、Redis 事务相关的命令有哪几个？

答： MULTI、EXEC、DISCARD、WATCH

![image-20220205234030011](.\img\最高级多方面面试题\image-20220205234030011.png)

### 38、Redis key 的过期时间和永久有效分别怎么设置？

答 ： EXPIRE 和 PERSIST 命 令 。

### **39、Redis 如何做内存优化？**

答： 尽可能使用散列表（ hashes）， 散列表（ 是说散列表里面存储的数少） 使用的内存非常小， 所以你应该尽可能的将你的数据模型抽象到一个散列表里面。比如你的 web 系统中有一个用户对象， 不要为这个用户的名称， 姓氏， 邮箱， 密码设置单独的 key,而是应该把这个用户的所有信息存储到一张散列表里面。

### **40、Redis 回收进程如何工作的?**

答： 一个客户端运行了新的命令， 添加了新的数据。Redi 检查内存使用情况， 如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。一个新的命令被执行， 等等。所以我们不断地穿越内存限制的边界， 通过不断达到边界然后不断地回收回到边界以下。如果一个命令的结果导致大量内存被使用（ 例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。

### **41、都有哪些办法可以降低 Redis 的内存占用?**

答：如果你使用的是 32 位的 Redis 实例，可以好好利用 Hash,list,sorted set,set 等集合类型数据， 因为通常情况下很多小的 Key-Value 可以用更紧凑的方式存放到一起。



1、降低redis内存占用的优点

　　1、有助于减少创建快照和加载快照所用的时间

　　2、提升载入AOF文件和重写AOF文件时的效率

　　3、缩短从服务器进行同步所需的时间

　　4、无需添加额外的硬件就可以让redis存贮更多的数据

回到顶部

##### 2、短结构

　　Redis为列表、集合、散列、有序集合提供了一组配置选项，这些选项可以让redis以更节约的方式存储较短的结构。



##### 　　2.1、ziplist压缩列表（列表、散列、有续集和）

　　通常情况下使用的存储方式

　　当列表、散列、有序集合的长度较短或者体积较小的时候，redis将会采用一种名为ziplist的紧凑存储方式来存储这些结构。

　　ziplist是列表、散列、有序集合这三种不同类型的对象的一种非结构化表示，它会以序列化的方式存储数据，这些序列化的数据每次被读取的时候都需要进行解码，每次写入的时候也要进行编码。

#####    **双向列表与压缩列表的区别：**

　　为了了解压缩列表比其他数据结构更加节约内存，我们以列表结构为例进行深入研究。

　　**典型的双向列表**

　　　　在典型双向列表里面，每个值都都会有一个节点表示。每个节点都会带有指向链表前一个节点和后一个节点的指针，以及一个指向节点包含的字符串值的指针。

　　　　每个节点包含的字符串值都会分为三部分进行存储。包括字符串长度、字符串值中剩余可用字节数量、以空字符结尾的字符串本身。

　　例子：

　　假若一个某个节点存储了’abc’字符串，在32位的平台下保守估计需要21个字节的额外开销（三个指针+两个int+空字符即：3*4+2*4+1=21）

　　由例子可知存储一个3字节字符串就需要付出至少21个字节的额外开销。

　　**ziplist**

　　　　压缩列表是由节点组成的序列，每个节点包含两个长度和一个字符串。第一个长度记录前一个节点的长度（用于对压缩列表从后向前遍历）；第二个长度是记录本当前点的长度；被存储的字符串。

　　例子：

　　存储字符串’abc’，两个长度都可以用1字节来存储，因此所带来的额外开销为2字节（两个长度即1+1=2）

　　**结论：**

　　压缩列表是通过避免存储额外的指针和元数据，从而达到降低额外的开销。

### **42、Redis 的内存用完了会发生什么？**

答：如果达到设置的上限，Redis 的写命令会返回错误信息（ 但是读命令还可以正常返回。） 或者你可以将 Redis 当缓存来使用配置淘汰机制， 当 Redis 达到内存上限时会冲刷掉旧的内容。

### **43、一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素?**

答：理论上 Redis 可以处理多达 2<sup>32</sup> 的 keys，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。我们正在测试一些较大的值。任何 list、set、和 sorted set 都可以放 2<sup>32</sup>  个元素。换句话说， Redis 的存储极限是系统中的可用内存值。



### **44、MySQL 里有 2000w 数据，redis 中只存 20w 的数据，如何保证 redis 中的数据都是热点数据？**

答： Redis 内存数据集大小上升到一定大小的时候， 就会施行数据淘汰策略。相关知识： Redis 提供 6 种数据淘汰策略：

volatile-lru：从已设置过期时间的数据集（ server.db[i].expires）中挑选最近最少使用的数据淘汰
volatile-ttl： 从已设置过期时间的数据集（ server.db[i].expires） 中挑选将要过期的数据淘汰

volatile-random： 从已设置过期时间的数据集（ server.db[i].expires） 中任意选择数据淘汰

allkeys-lru： 从数据集（ server.db[i].dict） 中挑选最近最少使用的数据淘汰
allkeys-random： 从数据集（ server.db[i].dict） 中任意选择数据淘汰no-enviction（ 驱逐） ： 禁止驱逐数据



 设置maxmemory为20W数据的容量，然后用allkeys-lru

### **45、Redis 最适合的场景？**

**1、会话缓存（ Session Cache）**

最常用的一种使用 Redis 的情景是会话缓存（ session cache）。用 Redis 缓存会话比其他存储（ 如 Memcached） 的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时， 如果用户的购物车信息全部丢失， 大部分人都会不高兴的， 现在， 他们还会这样吗？ 幸运的是， 随着 Redis 这些年的改进， 很容易找到怎么恰当的使用Redis 来缓存会话的文档。甚至广为人知的商业平台Magento 也提供 Redis 的插件。

**2、全页缓存（ FPC）**

除基本的会话 token 之外， Redis 还提供很简便的 FPC 平台。回到一致性问题， 即使重启了 Redis 实例， 因为有磁盘的持久化， 用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP 本地 FPC。 再次以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。 此外， 对 WordPress 的用户来说， Pantheon 有一个非常好的插件 wp-redis， 这个插件能帮助你以最快速度加载你曾浏览过的页面。

**3、队列**

Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作， 这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（ 如 Python）对 list 的 push/pop 操作。 如果你快速的在 Google 中搜索“ Redis queues”， 你马上就能找到大量的开源项目， 这些项目的目的就是利用 Redis 创建非常好的后端工具， 以满足各种队列需求。例如， Celery 有一个后台就是使用 Redis 作为 broker， 你可以从这里去查看。

**4， 排行榜/计数器**

Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（ Set） 和有序集合（ Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis 只是正好提供了这两种数据结构。所以， 我们要从排序集合中获取到排名最靠前的 10 个用户– 我们称之为“ user_scores”， 我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数， 你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子， 用 Ruby 实现的， 它的排行榜就是使用 Redis 来存储数据的， 你可以在这里看到。

**5、发布/订阅**

最后（ 但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用， 还可作为基于发布/订阅的脚本触发器， 甚至用 Redis 的发布/订阅功能来建立聊天系统！

### **46、假如 Redis 里面有 1 亿个key，其中有 10w 个key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？**

答： 使用 keys 指令可以扫出指定模式的 key 列表。

对方接着追问： 如果这个 redis 正在给线上的业务提供服务， 那使用 keys 指令会有什么问题？

这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一段时间， 线上服务会停顿， 直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表， 但是会有一定的重复概率， 在客户端做一次去重就可以了， 但是整体所花费的时间会比直接用 keys 指令长。

### **47、如果有大量的 key 需要设置同一时间过期，一般需要注意什么？**

答：如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，redis 可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值， 使得过期时间分散一些。

### **48、使用过 Redis 做异步队列么，你是怎么用的？**

答：一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候， 要适当 sleep 一会再重试。

###### 如果对方追问可不可以不用 sleep 呢？

list 还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。如果对方追问能不能生产一次消费多次呢？ 使用 pub/sub 主题订阅者模式， 可以实现 1:N 的消息队列。

###### 如果对方追问 pub/sub 有什么缺点？

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ 等。

###### 如果对方追问 redis 如何实现延时队列？

使用 sortedset，拿时间戳作为score，消息内容作为 key 调用 zadd 来生产消息，消费者用zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。



**那接下来开始讲讲我们的Redis在队列中如何实现延时的情况：**

在我们日常生活中，我们可以发现：

- 在淘宝、京东等购物平台上下单，超过一定时间未付款，订单会自动取消。
- 打车的时候，在规定时间没有车主接单，平台会取消你的单并提醒你暂时没有车主接单。
- 点外卖的时候，如果商家在10分钟还没接单，就会自动取消订单。
- 收快递的时候，如果我们没有点确认收货，在一段时间后程序会自动完成订单。
- 在平台完成订单后，如果我们没有在规定时间评论商品，会自动默认买家不评论。
- .......

 

**这时，我们可以想想为什么要这样做？**

因为这样可以保证商品的库存可以释放给其他人购买，你可以不用一直等待打车却得不到回复，你可以及时换一家店点到外卖。

**那么这些情况都是如何实现的呢？**

这时我们可以看看这个图，来看看消息延迟是如何处理的：

![img](.\img\最高级多方面面试题\1323607-20200702061910379-1864468139.png)

 当用户发送一个消息请求给服务器后台的时候，服务器会检测这条消息是否需要进行延时处理，如果需要就放入到延时队列中，由延时任务检测器进行检测和处理，对于不需要进行延时处理的任务，服务器会立马对消息进行处理，并把处理后的结果返会给用户。

 

![img](.\img\最高级多方面面试题\1323607-20200702055737295-275210721.png)

 对于在延时任务检测器内部的话，有查询延迟任务和执行延时任务两个职能，任务检测器会先去延时任务队列进行队列中信息读取，判断当前队列中哪些任务已经时间到期并将已经到期的任务输出执行（设置一个定时任务）。

 

**这时，我们可以想一想在Redis的数据结构中有哪些能进行时间设置标志的命令？**

是不是想到的 zset 这个命令，具有去重有序（分数排序）的功能。没错，你想对了呀！

我们可以使用 zset（sortedset）这个命令，用设置好的时间戳作为score进行排序，使用 zadd score1 value1 ....命令就可以一直往内存中生产消息。再利用 zrangebysocre 查询符合条件的所有待处理的任务，通过循环执行队列任务即可。也可以通过 zrangebyscore key min max withscores limit 0 1 查询最早的一条任务，来进行消费。

![img](.\img\最高级多方面面试题\1323607-20200702083502806-654371890.png)

总的来说，你可以通过以下两种方式来实现（(*^▽^*)如果你想到其他方法，也可以告诉我下呀~）：

（1）使用zrangebyscore来查询当前延时队列中所有任务，找出所有需要进行处理的延时任务，在依次进行操作。

（2）查找当前最早的一条任务，通过score值来判断任务执行的时候是否大于了当前系统的时候，比如说：最早的任务执行时间在3点，系统时间在2点58分），表示这个应该需要立马被执行啦，时间快到了（冲冲冲，他来了他来了，他带着死神的步伐来了）。

 

**我们可以想一想Redis来实现延时队列有何优势呢？**

**其实，Redis用来进行实现延时队列是具有这些优势的：**

1. Redis zset支持高性能的 score 排序。
2. Redis是在内存上进行操作的，速度非常快。
3. Redis可以搭建集群，当消息很多时候，我们可以用集群来提高消息处理的速度，提高可用性。
4. Redis具有持久化机制，当出现故障的时候，可以通过AOF和RDB方式来对数据进行恢复，保证了数据的可靠性

这时候，会有小伙伴问了还有没有其他实现延时队列的方式呀！emmm....当然有的，只有想不到的没有做不到。

 

###### **一、用消息中间件实现延时队列**

###### **（1）通过 RabbitMQ 来实现延时队列**

方法一：在MQ中我们可以对Queue设置 x-expires 过期时间或者对 Message设置超时时间x-message-ttl。

（这里要注意下：延时相同的消息我们要扔到同一个队列中，对于每一个延时要建立一个与之对应的队列—这是由于MQ的过期检测是惰性检测的。）

方法二：我们可以用RabbitMQ的插件rabbitmq-delayed-message-exchange插件来实现延时队列。达到可投递时间时并将其通过 x-delayed-type 类型标记的交换机类型投递至目标队列。

![img](.\img\最高级多方面面试题\1323607-20200702083119402-1566927058.png)

**（2）RocketMQ实现延时队列**

rocketmq在发送延时消息时，是先把消息按照延迟时间段发送到指定的队列中（把延时时间段相同的消息放到同一个队列中，保证了消息处理的顺序性，可以让同一个队列中消息延时时间是相同的，整个RocketMQ中延时消息时按照递增顺序排序，保证信息处理的先后顺序性。）。之后，通过一个定时器来轮询处理这些队列里的信息，判断是否到期。对于到期的消息会发送到相应的处理队列中，进行处理。

注意 ：目前RocketMQ只支持特定的延时时间段，1s,5s,10s,...2h，不能支持任意时间段的延时设置。有兴趣的小伙伴可以去了解下它是相关知识呀~

 

###### **二、Kafka实现延时队**

Kafka基于时间轮自定义了一个用于实现延迟功能的定时器（SystemTimer），Kafka中的时间轮（TimingWheel）是一个存储定时任务的环形队列，可以进行相关的延时队列设置。

![img](.\img\最高级多方面面试题\1323607-20200702161757716-63017960.png)

 

###### **三、Netty实现延时队列**

Netty也有基于时间轮算法来实现延时队列。Netty在构建延时队列主要用HashedWheelTimer，HashedWheelTimer底层数据结构是使用DelayedQueue，采用时间轮的算法来实现。

![img](.\img\最高级多方面面试题\1323607-20200702090136855-2087712548.png)

 

###### **四、DelayQueue来实现延时队列**

Java中有自带的DelayQueue数据类型，我们可以用这个来实现延时队列。DelayQueue是封装了一个PriorityQueue（优先队列），在向DelayQueue队列中添加元素时，会给元素一个Delay（延迟时间）作为排序条件，队列中最小的元素会优先放在队首，对于队列中的元素只有到了Delay时间才允许从队列中取出。这种实现方式是数据保存在内存中，可能面临数据丢失的情况，同时它是无法支持分布式系统的。

![img](.\img\最高级多方面面试题\1323607-20200702081155517-145733708.png)

### **49、使用过 Redis 分布式锁么，它是什么回事？**

先拿 setnx 来争抢锁， 抢到之后， 再用 expire 给锁加一个过期时间防止锁忘记了释放。

这时候对方会告诉你说你回答得不错， 然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了， 那会怎么样？

这时候你要给予惊讶的反馈： 唉， 是喔， 这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋， 故作思考片刻， 好像接下来的结果是你主动思考出来的， 然后回答： 我记得 set 指令有非常复杂的参数， 这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！ 对方这时会显露笑容， 心里开始默念： 摁， 这小子还不错。

### 50.PHP 使用 Redis 实现分布式锁

#### 锁实现的注意点

1. 互斥: 任意时刻, 只能有一个客户端获得锁
2. 不会死锁: 客户端持有锁期间崩溃, 没有主动解除锁, 能保证后续的其他客户端获得锁
3. 锁归属标识: 加锁和解锁的必须是同一个客户端, 客户端不能解掉非自己持有的锁(锁应具备标识)

如果是Redis集群, 还得考虑具有**容错性:** 只要大部分Redis节点正常运行, 客户端就可以加锁和解锁.

以下只考虑 Redis单机部署的 场景.

如果是Redis集群部署, 可以使用

#### 加锁

php 加锁示例

```php
$redis = new Redis();
$redis->pconnect("127.0.0.1", 6379);
$redis->auth("password");    // 密码验证
$redis->select(1);    // 选择所使用的数据库, 默认有16个

$key = "...";
$value = "...";
$expire = 3;

// 参数解释 ↓
// $value 加锁的客户端请求标识, 必须保证在所有获取锁清秋的客户端里保持唯一, 满足上面的第3个条件: 加锁/解锁的是同一客户端
// "NX" 仅在key不存在时加锁, 满足条件1: 互斥型
// "EX" 设置锁过期时间, 满足条件2: 避免死锁
$redis->set($key, $value, ["NX", "EX" => $expire])
```

setex命令

执行上面代码结果:

1. $key 对应的锁不存在, 进行加锁操作
2. $key 对应的锁已存在, 什么也不做

加锁容易错误的点:

- 使用

   

  ```
  setnx
  ```

   

  和

   

  ```
  expire
  ```

   

  的组合

  原因: 若在 `setnx` 后脚本崩溃会导致死锁

`$value` 客户端标识的:

- 简单点就用 毫秒级unix时间戳 + 客户端标识(大部分情况下够用了)
- 使用其他算法确保生成唯一随机值

#### connect 与 pconnect

在php中, 若使用 `pconnect` 连接redis, 则在当前脚本声明周期结束后, 与redis建立的连接仍会保留, 直到对应fpm进程的生命周期结束, 同时在下一次请求时, fpm会重用该连接.

即该连接的生命周期是 fpm 进程的生命周期, 而非一次php脚本的执行.

若代码使用 `pconnect`, `close` 的作用仅是使当前php脚本不能再进行redis请求, 并没有真正关闭与redis的连接, 连接在后续请求中仍然会被重用.

> pconnect函数在线程版本中不能被使用

![clipboard.png](https://segmentfault.com/img/bVbtyiy?w=668&h=52)

![clipboard.png](https://segmentfault.com/img/bVbtyiA?w=792&h=78)

> 上图中, php-fpm 与redis建立的连接并未随请求结束后马上断开

#### 解锁

php解锁示例: 使用lua脚本

```php
$key = "...";
$identification = "...";
// KEYS 和 ARGV 是lua脚本中的全局变量
$script = <<< EOF
if redis.call("get", KEYS[1]) == ARGV[1] then
    return redis.call("del", KEYS[1])
else
    return 0
end
EOF;
# $result = $redis->eval($script, [$key, $identification], 1);
// 返回结果 >0 表示解锁成功
// php中参数的传递顺序与标准不一样, 注意区分
// 第2个参数表示传入的 KEYS 和 ARGV, 通过第3个参数来区分, KEYS 在前, ARGV 在后
// 第3个参数表示传入的 KEYS 的个数
$result = $redis->evaluate($script, [$key, $identification], 1);    
```

使用Lua脚本的原因:

- 避免误删其他客户端加的锁

  > eg. 某个客户端获取锁后做其他操作过久导致锁被自动释放, 这时候要避免这个客户端删除已经被其他客户端获取的锁, 这就用到了锁的标识.

- lua 脚本中执行 `get` 和 `del` 是原子性的, 整个lua脚本会被当做一条命令来执行

- 即使 `get` 后锁刚好过期, 此时也不会被其他客户端加锁

> eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。
>
> 由于 script 执行的原子性, 所以不要在script中执行过长开销的程序，否则会验证影响其它请求的执行。

解锁容易错误的点:

- 直接

  ```
del
  ```
  
  删除键

  原因: 可能移除掉其他客户端加的锁(在自己的锁已过期情况下)

- ```
  get
  ```

  判断锁归属, 若符合再

  ```
del
  ```
  
  原因: 非原子性操作, 若在 `get` 后锁过期了, 此时别的客户端进行加锁操作, 这里的 `del` 就会错误的将其他客户端加的锁解开.

#### Redis 中使用 Lua 脚本的注意点

**注意点:**

1. Redis 会把**所有执行过的脚本都缓存在内存中**

2. Redis 在**重启**的时候会**释放掉**之前保存的脚本

3. Lua 脚本中所需要用到的键名以及参数一定要使用 KEYS 和 ARGV 来替换，千万不要写死在代码中，除非你百分百确定每次请求时他们是固定不变的值，特别是涉及到 时间，随机数的，一定要用参数代入，因为Redis 每次使用 script 都会校验脚本缓存中是否已存在相同脚本，否则就会存储到缓存中，如果你的脚本很长，且每次请求存在不同的变量值，则会生成无数多个脚本缓存，你将会发现Redis占用的内存会唰唰唰的往上涨，我一开始因为key 和 参数太多，分开写太麻烦了，就图省事方便，直接把变量拼接到脚本里面，结果发现内存不停的涨，很是抓狂，找了好久才发现是这么个原因。

   ![clipboard.png](https://segmentfault.com/img/bVbtyi3?w=1226&h=487)

义变量一定要**使用局部变量**, 即 `local var = 1`, 局部变量只在所定义的块(指控制结构, 函数或chunk等)内有效, 使用局部变量可以避免命名冲突 并且访问更快(lua中局部变量和全局变量存储方式是不一样的)

1. 如果Lua脚本写的比较长，非本地或局域网的情况下，建议使用 **SHA 签名**的方法来调用，这样节省带宽，但对性能似乎没什么直接的提升。这里对小白普及下我理解的原理就是 Redis 会把每个脚本都生成唯一签名，把脚本作为函数体，并使用该签名作为脚本的函数名放到缓存中，所以后面调用就只需要传一个 SHA 签名就可以调用该函数了，精简很多了。同一个脚本生成的签名都是相同的，所以SHA签名可以先在本地生成，然后在服务器上 script load 一次脚本，程序中只需保存和使用该签名即可。另外需要注意的是，脚本如果被改动哪怕一个换行或一个空格（这些容易被忽略或误操作）都必须重新 load 来获取新的 SHA

   > 注意：获取 SHA 签名是单独的功能，不要放在你的正常流程中，当本地开发时就可以生成SHA，把字符串写死在流程中。同样的脚本，Reids是始终生成相同的签名的。

   ![clipboard.png](https://segmentfault.com/img/bVbtyiB?w=1425&h=345)

2. 通过 eval 带入的 **ARGV 参数如果原来是数字的，会被转换为字符串**，如果你的逻辑中需要判断该变量 > 0 或 < 0 之类的数字判断则必须进行字符串到数字的转换，使用 `tonumber()` 方法` if (tonumber(ARGV[1]) > 0) then return 1; end;`

3. 我测试了几个 lua script 与 PIPELINE 处理对比，发现 script 的效率一般比 PIPELINE 高 30% ~ 40% 左右

   ![clipboard.png](https://segmentfault.com/img/bVbtyiD?w=762&h=493)

#### Redis集群分布式锁

Redis 集群相对单机来说, 需要考虑一个 **容错性**, 设计上更为复杂

#### RedLock 算法

官方给出了一个 RedLock 算法

情景: 当前有N个完全独立的Redis master节点, 分别部署在不同的主机上

客户端获取锁的操作:

1. 使用相同key和唯一值(作为value)同时向这N个redis节点请求锁, 锁的超时时间应该 >> 超时时间(考虑到请求耗时), 若某个节点阻塞了了应尽快跳过
2. 计算步骤1消耗的时间, 若总消耗时间超过超时时间, 则认为锁失败. 客户端需在大多数(超过一半)的节点上成功获取锁, 才认为是锁成功.
3. 如果锁成功了, 则该锁有效时间就是 锁原始有效时间 - 步骤1消耗的时间
4. 如果锁失败了(超时或无法获取超过一半 N/2 + 1 实例的锁), 客户端会到每个节点释放锁(是每个, 即使之前认为加锁失败的节点)

### **51、如何实现集群中的 session 共享存储？**

Session 是运行在一台服务器上的，所有的访问都会到达我们的唯一服务器上，这样我们可以根据客户端传来的sessionID，来获取 session，或在对应 Session 不存在的情况下（ session 生命周期到了/用户第一次登录），创建一个新的 Session； 但是， 如果我们在集群环境下， 假设我们有两台服务器 A， B， 用户的请求会由 Nginx 服务器进行转发（ 别的方案也是同理）， 用户登录时， Nginx 将请求转发至服务器 A 上，A 创建了新的 session，并将 SessionID 返回给客户端，用户在浏览其他页面时， 客户端验证登录状态， Nginx 将请求转发至服务器 B， 由于 B 上并没有对应客户端发来 sessionId 的 session，所以会重新创建一个新的 session，并且再将这个新的sessionID 返回给客户端， 这样， 我们可以想象一下， 用户每一次操作都有 1/2 的概率进行再次的登录， 这样不仅对用户体验特别差， 还会让服务器上的 session 激增， 加大服务器的运行压力。

为了解决集群环境下的 seesion 共享问题， 共有 4 种解决方案：
1.粘 性 session
		粘性 session 是指 Ngnix 每次都将同一用户的所有请求转发至同一台服务器上， 即将用户与服务器绑定。
2.服务器 session 复制
		即每次 session 发生变化时， 创建或者修改， 就广播给所有集群中的服务器， 使所有的服务器上的 session 相同。

3.session 共 享

4.缓存 session， 使用 redis， memcached。

​		session 持久化将 session 存储至数据库中， 像操作数据一样才做 session。



### 52.集群间session共享问题

 session共享实现方案
 session共享有多重解决办法，常用的有四种：

客户端Cookie保存，

服务器间session同步、

使用集群管理Session、

把session持久化到数据库

 集群中session共享解决方案
 1、客户端存储方案
 2、集中式session共享方案
 3、session复制方案
 4、把session持久化到数据库

 session保存到redis简单实现
 1、配置web.xml过滤器sessionFilter
 2、在spring配置文件中配置对应的过滤器名字：
 3、sessionFilter的实现
 4、TerryHttpServletRequestWrapper的实现（关于session增删改查的四个方法）
 5、CacheHttpSession的实现
 6、HttpSessionWrapper的实现

### 53、请用Redis和任意语言实现一段恶意登录保护的代码，限制一小时内每用户ID最多只能登录5次。

 具体登录函数或功能用空函数即可，不用详细写出。
 用列表实现：列表中每个元素代表登录时间，只要最后的第5次登录时间和现在时间差不多超过1小时就禁止登录。
 用Python写的代码如下：

### 54.redis、memcache、mongodb彼此间区别？

###### >>Memcached

**Memcached的优点：**
Memcached可以利用多核优势，单实例吞吐量极高，可以达到几十万QPS（取决于key、value的字节大小以及服务器硬件性能，日常环境中QPS高峰大约在4-6w左右）。适用于最大程度扛量。
支持直接配置为session handle。
**Memcached的局限性：**
只支持简单的key/value数据结构，不像Redis可以支持丰富的数据类型。
无法进行持久化，数据不能备份，只能用于缓存使用，且重启后数据全部丢失。
无法进行数据同步，不能将MC中的数据迁移到其他MC实例中。
Memcached内存分配采用Slab Allocation机制管理内存，value大小分布差异较大时会造成内存利用率降低，并引发低利用率时依然出现踢出等问题。需要用户注重value设计。

###### >>Redis

**Redis的优点：**
支持多种数据结构，如 string（字符串）、 list(双向链表)、dict(hash表)、set(集合）、zset(排序set)、hyperloglog（基数估算）
支持持久化操作，可以进行aof及rdb数据持久化到磁盘，从而进行数据备份或数据恢复等操作，较好的防止数据丢失的手段。
支持通过Replication进行数据复制，通过master-slave机制，可以实时进行数据的同步复制，支持多级复制和增量复制，master-slave机制是Redis进行HA的重要手段。
单线程请求，所有命令串行执行，并发情况下不需要考虑数据一致性问题。
支持pub/sub消息订阅机制，可以用来进行消息订阅与通知。
支持简单的事务需求，但业界使用场景很少，并不成熟。

**Redis的局限性：**
Redis只能使用单线程，性能受限于CPU性能，故单实例CPU最高才可能达到5-6wQPS每秒（取决于数据结构，数据大小以及服务器硬件性能，日常环境中QPS高峰大约在1-2w左右）。
支持简单的事务需求，但业界使用场景很少，并不成熟，既是优点也是缺点。
Redis在string类型上会消耗较多内存，可以使用dict（hash表）压缩存储以降低内存耗用。

Mc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。比如redis的keys pattern这种匹配操作，对redis的性能是灾难。

###### >>mongoDB 

mongoDB 是一种文档性的数据库。先解释一下文档的数据库，即可以存放xml、json、bson类型系那个的数据。

这些数据具备自述性（self-describing），呈现分层的树状数据结构。redis可以用hash存放简单关系型数据。

*mongoDB 存放json格式数据。*

**适合场景：事件记录、内容管理或者博客平台，比如评论系统。**



### 55.redis和memcached的区别

 如果简单地比较redis和memcached的区别，大多数都会得到以下观点：
 1、redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储。
 2、redis支持数据的备份，即master-slave模式的数据备份
 3、redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用
 在redis中，并不是所有的数据都一直存储在内存中的。这是和memcached相比一个最大的却别（我个人是这么认为的）

 redis
 用户发出查询类似的请求，Nix判断是pc端还是M端，假如是pc端，先从redis缓存里面查询所需要的数据
 如果有则直接返回，如果没有则通过API数据接口（做一个查询的接口）直接从数据库（DB mysql等）里面查 
 把最新查新查询的结果先放到redis缓存里，再将查询的结果返回给PC客户端 
 nigix有个功能叫静态代理 先把储存静态文件的nfs给配置到nigix中  nfs文件系统主要用来存储静态得东西，css 图片 js

 redis是一种高级的key:value存储系统，其中value支持五中数据类型
 1、字符串（string）
 2、字符串列表（list）
 3、字符串集合（sets）
 5、哈希（hashes）
 而关于key，有几点要提醒大家：
 1、key不要太长，计量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率
 2、key也不要太短，太短的话，key的可读性会降低
 3、在一个项目中，key最好使用同一的命名模式，例如user:10000:password.
 redis中的lists在底层实现上并不是数组，而是链表。
 redis的集合是一种无序的集合，集合中的元素没有先后的顺序
 redis中的hashes存的是字符串和字符串之间的映射

 redis提供了两种持久化的方式，分别是RDB(redis dataBase)和AOF（Append Only File）
 RDB，简而言之，就是在不同的时间点，将redis存储的数据生成快照并存储到磁盘等介质上
 AOF,则是换了一个角度来实现持久化，那就是讲redis执行过的所有写指令记录下来，在下次redis重新启动时，
 只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。
 其实RDB和AOF两种方式也可以同时使用，在这种情况下，如果redis重启的话，则会优先采用AOF方式来进行数据恢复
 这是因为AOF方式的数据恢复完整度更高。

 redis的事务处理
 1、MULTI用来组装一个事务
 2、EXEC用来执行一个事务
 3、DISCARD用来取消一个事物
 4、WATCH用来监视一些key，一点这些key在事务执行之前被改变，则取消事务的执行



### 56.mongodb持久化原理

mongodb与mysql不同，mysql的每一次更新操作都会直接写入硬盘，但是mongo不会，做为内存型数据库，数据操作会先写入内存，然后再会持久化到硬盘中去，那么mongo是如何持久化的呢
mongodb在启动时，专门初始化一个线程不断循环（除非应用crash掉），用于在一定时间周期内来从defer队列中获取要持久化的数据并写入到磁盘的journal(日志)和mongofile(数据)处，当然因为它不是在用户添加记录时就写到磁盘上，所以按mongodb开发者说，它不会造成性能上的损耗，因为看过代码发现，当进行CUD操作时，记录(Record类型)都被放入到defer队列中以供延时批量（groupcommit）提交写入，但相信其中时间周期参数是个要认真考量的参数，系统为90毫秒，如果该值更低的话，可能会造成频繁磁盘操作，过高又会造成系统宕机时数据丢失过。



### **57.什么是NoSQL数据库？NoSQL和RDBMS有什么区别？在哪些情况下使用和不使用NoSQL数据库？**

NoSQL是非关系型数据库，NoSQL = Not Only SQL。
关系型数据库采用的结构化的数据，NoSQL采用的是键值对的方式存储数据。
在处理非结构化/半结构化的大数据时；在水平方向上进行扩展时；随时应对动态增加的数据项时可以优先考虑使用NoSQL数据库。
在考虑数据库的成熟度；支持；分析和商业智能；管理及专业性等问题时，应优先考虑关系型数据库。

### **58.MongoDB的特点是什么？**

（1）面向文档（2）高性能（3）高可用（4）易扩展（5）丰富的查询语言

### **59.MongoDB支持存储过程吗？如果支持的话，怎么用？**

MongoDB支持存储过程，它是javascript写的，保存在db.system.js表中。

### **60.如何理解MongoDB中的GridFS机制，MongoDB为何使用GridFS来存储文件？**

GridFS是一种将大型文件存储在MongoDB中的文件规范。使用GridFS可以将大文件分隔成多个小文档存放，这样我们能够有效的保存大文档，而且解决了BSON对象有限制的问题。

### **61.为什么MongoDB的数据文件很大？**

MongoDB采用的预分配空间的方式来防止文件碎片。

### **62.当更新一个正在被迁移的块（Chunk）上的文档时会发生什么？**

更新操作会立即发生在旧的块（Chunk）上，然后更改才会在所有权转移前复制到新的分片上。

### **63.MongoDB在A:{B,C}上建立索引，查询A:{B,C}和A:{C,B}都会使用索引吗？**

不会，只会在A:{B,C}上使用索引。

### **64.如果一个分片（Shard）停止或很慢的时候，发起一个查询会怎样？**

如果一个分片停止了，除非查询设置了“Partial”选项，否则查询会返回一个错误。如果一个分片响应很慢，MongoDB会等待它的响应。

![img](.\img\最高级多方面面试题\15080-20191219170031701-1665904980.png)

### 65.redis之bigkey（看这一篇就够）

#### bigkey

##### 1、bigkey带来的问题

1. 如果是集群模式下，无法做到负载均衡，导致请求倾斜到某个实例上，而这个实例的QPS会比较大，内存占用也较多；对于Redis单线程模型又容易出现CPU瓶颈，当内存出现瓶颈时，只能进行纵向库容，使用更牛逼的服务器。
2. 涉及到大key的操作，尤其是使用hgetall、lrange 0 -1、get、hmget 等操作时，网卡可能会成为瓶颈，也会到导致堵塞其它操作，qps 就有可能出现突降或者突升的情况，趋势上看起来十分不平滑，严重时会导致应用程序连不上，实例或者集群在某些时间段内不可用的状态。
3. 假如这个key需要进行删除操作，如果直接进行DEL 操作，被操作的实例会被Block住，导致无法响应应用的请求，而这个Block的时间会随着key的变大而变长。

##### 2、bigkey是如何产生的

一般来说，bigkey是由于程序员的程序设计不当，或对数据规模预料不清楚造成的：
1、社交类：粉丝列表，如果某些明显或大V，一定是bigkey
2、统计类：如果按天存储某项功能或网站的用户集合，除非没几个人用，否则必定是bigkey
3、缓存类：作为数据库数据的冗余存储，这种是redis的最常用场景，但有2点要注意：
1）是不是有必要把所有数据都缓存
2）有没有相关关联的数据
举个例子，该同学把某明星一个专辑下的所有视频信息都缓存成了一个巨大的json，这个json达到了6MB。

##### 3、查找bigKey的方法

1. 在redis实例上执行bgsave，然后我们对dump出来的rdb文件进行分析，找到其中的大KEY
2. 有个不太推荐的命令，debug object xxx 可以看到这个key在内存中序列化后的大小，当然我们可以通过SCAN+debug object xxx 得到当前实例所有key的大小。
3. redis-cli 原生自带 –bigkeys 功能，可以找到某个实例 5种数据类型(String、hash、list、set、zset)的最大key。

##### 4、直接删除bigkey的风险

[DEL命令](https://link.juejin.im/?target=http%3A%2F%2Fredis.io%2Fcommands%2Fdel)在删除单个集合类型的Key时，命令的时间复杂度是O(M)，其中M是集合类型Key包含的元素个数。

> DEL keyTime complexity: O(N) where N is the number of keys that will be removed. When a key to remove holds a value other than a string, the individual complexity for this key is O(M) where M is the number of elements in the list, set, sorted set or hash. Removing a single key that holds a string value is O(1).

生产环境中遇到过多次因业务删除大Key，导致Redis阻塞，出现故障切换和应用程序雪崩的故障。测试删除集合类型大Key耗时，一般每秒可清理100w~数百w个元素; 如果数千w个元素的大Key时，会导致Redis阻塞上10秒可能导致集群判断Redis已经故障，出现故障切换；或应用程序出现雪崩的情况。

> 说明：Redis是单线程处理。单个耗时过大命令，导致阻塞其他命令，容易引起应用程序雪崩或Redis集群发生故障切换。所以避免在生产环境中使用耗时过大命令。

Redis删除大的集合键的耗时, 测试估算，可参考；和硬件环境、Redis版本和负载等因素有关

| Key类型    | Item数量 | 耗时    |
| :--------- | :------- | :------ |
| Hash       | ~100万   | ~1000ms |
| List       | ~100万   | ~1000ms |
| Set        | ~100万   | ~1000ms |
| Sorted Set | ~100万   | ~1000ms |

##### 5、如何优雅地删除各类大Key

从Redis2.8版本开始支持[SCAN](https://link.juejin.im/?target=http%3A%2F%2Fredis.io%2Fcommands%2Fscan)命令，通过m次时间复杂度为O(1)的方式，遍历包含n个元素的大key.这样避免单个O(n)的大命令，导致Redis阻塞。 这里删除大key操作的思想也是如此。

先给键改名。

###### 5.1 Delete Large Hash Key

通过[hscan命令](https://link.juejin.im/?target=http%3A%2F%2Fredis.io%2Fcommands%2Fhscan)，每次获取500个字段，再用[hdel命令](https://link.juejin.im/?target=http%3A%2F%2Fredis.io%2Fcommands%2Fhdel)，每次删除1个字段。Python代码：

```python
def del_large_hash():
  r = redis.StrictRedis(host='redis-host1', port=6379)
    large_hash_key ="xxx" 
    cursor = '0'
    while cursor != 0:
        cursor, data = r.hscan(large_hash_key, cursor=cursor, count=500)
        for item in data.items():
                r.hdel(large_hash_key, item[0])
```

###### 5.2 Delete Large Set Key

删除大set键，使用[sscan命令](https://link.juejin.im/?target=http%3A%2F%2Fredis.io%2Fcommands%2Fsscan)，每次扫描集合中500个元素，再用[srem命令](https://link.juejin.im/?target=http%3A%2F%2Fredis.io%2Fcommands%2Fsrem)每次删除一个键Python代码：

```python
def del_large_set():
  r = redis.StrictRedis(host='redis-host1', port=6379)
  large_set_key = 'xxx'   
  cursor = '0'
  while cursor != 0:
    cursor, data = r.sscan(large_set_key, cursor=cursor, count=500)
    for item in data:
      r.srem(large_size_key, item)
```

###### 5.3 Delete Large List Key

删除大的List键，未使用scan命令； 通过[ltrim命令](https://link.juejin.im/?target=http%3A%2F%2Fredis.io%2Fcommands%2Fltrim)每次删除少量元素。Python代码：

```python
def del_large_list():
  r = redis.StrictRedis(host='redis-host1', port=6379)
  large_list_key = 'xxx'  
  while r.llen(large_list_key)>0:
      r.ltrim(large_list_key, 0, -101) 
```

###### 5.4 Delete Large Sorted set key

删除大的有序集合键，和List类似，使用sortedset自带的[zremrangebyrank命令](https://link.juejin.im/?target=http%3A%2F%2Fredis.io%2Fcommands%2Fzremrangebyrank),每次删除top 100个元素。Python代码：

```python
def del_large_sortedset():
  r = redis.StrictRedis(host='large_sortedset_key', port=6379)
  large_sortedset_key='xxx'
  while r.zcard(large_sortedset_key)>0:
    r.zremrangebyrank(large_sortedset_key,0,99)
```



### 66.Redis 有哪些数据结构？

##### Redis五种数据结构如下：

### ![img](.\img\最高级多方面面试题\1289934-20190621163930814-1395015700.png)

对redis来说，所有的key（键）都是字符串。

###### 1.String 字符串类型

是redis中最基本的数据类型，一个key对应一个value。

String类型是二进制安全的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。

使用：get 、 set 、 del 、 incr、 decr 等

```
127.0.0.1:6379> set hello world
OK
127.0.0.1:6379> get hello
"world"
127.0.0.1:6379> del hello
(integer) 1
127.0.0.1:6379> get hello
(nil)
127.0.0.1:6379> get counter
"2"
127.0.0.1:6379> incr counter
(integer) 3
127.0.0.1:6379> get counter
"3"
127.0.0.1:6379> incrby counter 100
(integer) 103
127.0.0.1:6379> get counter
"103"
127.0.0.1:6379> decr counter
(integer) 102
127.0.0.1:6379> get counter
"102"
```

实战场景：

1.缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql的读写压力。

2.计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。

3.session：常见方案spring session + redis实现session共享，

 

###### 2.Hash （哈希）

是一个Mapmap，指值本身又是一种键值对结构，如 value={{field1,value1},......fieldN,valueN}}

![img](.\img\最高级多方面面试题\1289934-20190621232209365-1000366002.png)

 

使用：所有hash的命令都是 h  开头的   hget 、hset 、 hdel 等

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
127.0.0.1:6379> hset user name1 hao
(integer) 1
127.0.0.1:6379> hset user email1 hao@163.com
(integer) 1
127.0.0.1:6379> hgetall user
1) "name1"
2) "hao"
3) "email1"
4) "hao@163.com"
127.0.0.1:6379> hget user user
(nil)
127.0.0.1:6379> hget user name1
"hao"
127.0.0.1:6379> hset user name2 xiaohao
(integer) 1
127.0.0.1:6379> hset user email2 xiaohao@163.com
(integer) 1
127.0.0.1:6379> hgetall user
1) "name1"
2) "hao"
3) "email1"
4) "hao@163.com"
5) "name2"
6) "xiaohao"
7) "email2"
8) "xiaohao@163.com"
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

实战场景：

1.缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。

 

######  3.链表 

List 说白了就是链表（redis 使用双端链表实现的 List），是有序的，value可以重复，可以通过下标取出对应的value值，左右两边都能进行插入和删除数据。

![img](.\img\最高级多方面面试题\1289934-20190621233618769-504231907.png)

使用列表的技巧

- lpush+lpop=Stack(栈)
- lpush+rpop=Queue（队列）
- lpush+ltrim=Capped Collection（有限集合）
- lpush+brpop=Message Queue（消息队列）

 

使用：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
127.0.0.1:6379> lpush mylist 1 2 ll ls mem
(integer) 5
127.0.0.1:6379> lrange mylist 0 -1
1) "mem"
2) "ls"
3) "ll"
4) "2"
5) "1"
127.0.0.1:6379>
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

实战场景：

1.timeline：例如微博的时间轴，有人发布微博，用lpush加入时间轴，展示新的列表信息。

 

###### 4.Set  集合

集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 1. 不允许有重复的元素，2.集合中的元素是无序的，不能通过索引下标获取元素，3.支持集合间的操作，可以取多个集合取交集、并集、差集。

![img](.\img\最高级多方面面试题\1289934-20190622001013515-677922001.png)

 

 

使用：命令都是以s开头的 sset 、srem、scard、smembers、sismember

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
127.0.0.1:6379> sadd myset hao hao1 xiaohao hao
(integer) 3
127.0.0.1:6379> SMEMBERS myset
1) "xiaohao"
2) "hao1"
3) "hao"
127.0.0.1:6379> SISMEMBER myset hao
(integer) 1
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

实战场景;

1.标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人。

2.点赞，或点踩，收藏等，可以放到set中实现

 

###### 5.zset 有序集合

有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它给每个元素设置一个分数，作为排序的依据。

（有序集合中的元素不可以重复，但是score 分数 可以重复，就和一个班里的同学学号不能重复，但考试成绩可以相同）。

![img](.\img\最高级多方面面试题\1289934-20190622000959260-539243592.png)

 

使用： 有序集合的命令都是 以 z 开头  zadd 、 zrange、 zscore

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
127.0.0.1:6379> zadd myscoreset 100 hao 90 xiaohao
(integer) 2
127.0.0.1:6379> ZRANGE myscoreset 0 -1
1) "xiaohao"
2) "hao"
127.0.0.1:6379> ZSCORE myscoreset hao
"100"
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

实战场景：

1.排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行。



### 67.单线程的 Redis 如何实现高性能读写？

1、基本原理

采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）
（1）为什么不采用多进程或多线程处理？

多线程处理可能涉及到锁 
多线程处理会涉及到线程切换而消耗CPU
（2）单线程处理的缺点？

无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善
2、Redis不存在线程安全问题？

Redis采用了线程封闭的方式，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁

3、什么是多路I/O复用（Epoll）

（1） 网络IO都是通过Socket实现，Server在某一个端口持续监听，客户端通过Socket（IP+Port）与服务器建立连接（ServerSocket.accept），成功建立连接之后，就可以使用Socket中封装的InputStream和OutputStream进行IO交互了。针对每个客户端，Server都会创建一个新线程专门用于处理
（2） 默认情况下，网络IO是阻塞模式，即服务器线程在数据到来之前处于【阻塞】状态，等到数据到达，会自动唤醒服务器线程，着手进行处理。阻塞模式下，一个线程只能处理一个流的IO事件
（3） 为了提升服务器线程处理效率，有以下三种思路



（1）非阻塞【忙轮询】：采用死循环方式轮询每一个流，如果有IO事件就处理，这样可以使得一个线程可以处理多个流，但是效率不高，容易导致CPU空转

（2）Select代理（无差别轮询）：可以观察多个流的IO事件，如果所有流都没有IO事件，则将线程进入阻塞状态，如果有一个或多个发生了IO事件，则唤醒线程去处理。但是还是得遍历所有的流，才能找出哪些流需要处理。如果流个数为N，则时间复杂度为O（N）

（3）Epoll代理：Select代理有一个缺点，线程在被唤醒后轮询所有的Stream，还是存在无效操作。 Epoll会哪个流发生了怎样的I/O事件通知处理线程，因此对这些流的操作都是有意义的，复杂度降低到了O(1)
多路I/O复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络 IO 的时间消耗），且 Redis 在内存中操作数据的速度非常快，也就是说内存内的操作不会成为影响Redis性能的瓶颈

4、其它开源软件采用的模型
Nginx：多进程单线程模型 
Memcached：单进程多线程模型


Redis为什么是单线程的？

因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。（以上主要来自官方FAQ）既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。关于redis的性能，官方网站也有，普通笔记本轻松处理每秒几十万的请求，参见：How fast is Redis?

 

如果万一CPU成为你的Redis瓶颈了，或者，你就是不想让服务器其他核闲置，那怎么办？

那也很简单，你多起几个Redis进程就好了。Redis是keyvalue数据库，又不是关系数据库，数据之间没有约束。只要客户端分清哪些key放在哪个Redis进程上就可以了。redis-cluster可以帮你做的更好。

 

单线程可以处理高并发请求吗？

当然可以了，Redis都实现了。

有一点概念需要澄清，并发并不是并行。

（相关概念：并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元）

 

### 68.Redis总体快速的原因：

采用队列模式将并发访问变为串行访问（？）

单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），其他模块仍用了多个线程。

总体来说快速的原因如下：

1）绝大部分请求是纯粹的内存操作（非常快速）

2）采用单线程,避免了不必要的上下文切换和竞争条件

3）非阻塞IO（epoll方式的多路IO复用技术）

内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间

这3个条件不是相互独立的，特别是第一条，如果请求都是耗时的，采用单线程吞吐量及性能可想而知了。应该说redis为特殊的场景选择了合适的技术方案。

 

### 69.redis的一些其他特点：

##### （1）Redis是单进程单线程的


redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销

##### （2）读写分离模型

通过增加Slave DB的数量，读的性能可以线性增长。为了避免Master DB的单点故障，集群一般都会采用两台Master DB做双机热备，所以整个集群的读和写的可用性都非常高。
读写分离架构的缺陷在于，不管是Master还是Slave，每个节点都必须保存完整的数据，如果在数据量很大的情况下，集群的扩展能力还是受限于单个节点的存储能力，而且对于Write-intensive类型的应用，读写分离架构并不适合。

##### （3）数据分片模型


为了解决读写分离模型的缺陷，可以将数据分片模型应用进来。

可以将每个节点看成都是独立的master，然后通过业务实现数据分片。

结合上面两种模型，可以将每个master设计成由一个master和多个slave组成的模型。

##### （4）Redis的回收策略，如何保持热点数据


volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰

allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰

allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰

no-enviction（驱逐）：禁止驱逐数据

 

注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。

　　使用策略规则：

　　1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru

　　2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random



### 70.Redis 支持事务吗？

MULTI、EXEC、DISCARD和WATCH命令是Redis事务功能的基础。Redis事务允许在一次单独的步骤中执行一组命令，并且可以保证如下两个重要事项：

\>Redis会将一个事务中的所有命令序列化，然后按顺序执行。Redis不可能在一个Redis事务的执行过程中插入执行另一个客户端发出的请求。这样便能保证Redis将这些命令作为一个单独的隔离操作执行。

 > 在一个Redis事务中，Redis要么执行其中的所有命令，要么什么都不执行。因此，Redis事务能够保证原子性。EXEC命令会触发执行事务中的所有命令。因此，当某个客户端正在执行一次事务时，如果它在调用MULTI命令之前就从Redis服务端断开连接，那么就不会执行事务中的任何操作；相反，如果它在调用EXEC命令之后才从Redis服务端断开连接，那么就会执行事务中的所有操作。当Redis使用只增文件（AOF：Append-only File）时，Redis能够确保使用一个单独的write(2)系统调用，这样便能将事务写入磁盘。然而，如果Redis服务器宕机，或者系统管理员以某种方式停止Redis服务进程的运行，那么Redis很有可能只执行了事务中的一部分操作。Redis将会在重新启动时检查上述状态，然后退出运行，并且输出报错信息。使用redis-check-aof工具可以修复上述的只增文件，这个工具将会从上述文件中删除执行不完全的事务，这样Redis服务器才能再次启动。

从2.2版本开始，除了上述两项保证之外，Redis还能够以乐观锁的形式提供更多的保证，这种形式非常类似于“检查再设置”（CAS：Check And Set）操作。本文稍后会对Redis的乐观锁进行描述。



#### 一、相关命令

##### 1. MULTI

用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。

这个命令的运行格式如下所示：

MULTI

这个命令的返回值是一个简单的字符串，总是OK。

##### 2. EXEC

在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。

当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。

这个命令的运行格式如下所示：

EXEC

这个命令的返回值是一个数组，其中的每个元素分别是原子化事务中的每个命令的返回值。 当使用WATCH命令时，如果事务执行中止，那么EXEC命令就会返回一个Null值。

##### 3. DISCARD

清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。

如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。

这个命令的运行格式如下所示：

```
DISCARD
```

这个命令的返回值是一个简单的字符串，总是OK。

##### 4. WATCH

当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的。

这个命令的运行格式如下所示：

```
WATCH key [key ...]
```

这个命令的返回值是一个简单的字符串，总是OK。

对于每个键来说，时间复杂度总是O(1)。

##### 5. UNWATCH

清除所有先前为一个事务监控的键。

如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。

这个命令的运行格式如下所示：

```
UNWATCH
```

这个命令的返回值是一个简单的字符串，总是OK。

时间复杂度总是O(1)。

#### 二、使用方法

使用MULTI命令便可以进入一个Redis事务。这个命令的返回值总是OK。此时，用户可以发出多个Redis命令。Redis会将这些命令放入队列，而不是执行这些命令。一旦调用EXEC命令，那么Redis就会执行事务中的所有命令。

相反，调用DISCARD命令将会清除事务队列，然后退出事务。

以下示例会原子化地递增foo键和bar键的值：



![<img>](https://img-blog.csdn.net/20161013224917435)



正如从上面的会话所看到的一样，EXEC命令的返回值是一个数组，其中的每个元素都分别是事务中的每个命令的返回值，返回值的顺序和命令的发出顺序是相同的。

当一个Redis连接正处于MULTI请求的上下文中时，通过这个连接发出的所有命令的返回值都是QUEUE字符串（从Redis协议的角度来看，返回值是作为状态回复（Status Reply）来发送的）。当调用EXEC命令时，Redis会简单地调度执行事务队列中的命令。

#### 三、事务内部的错误

在一个事务的运行期间，可能会遇到两种类型的命令错误：

> 一个命令可能会在被放入队列时失败。因此，事务有可能在调用EXEC命令之前就发生错误。例如，这个命令可能会有语法错误（参数的数量错误、命令名称错误，等等），或者可能会有某些临界条件（例如：如果使用maxmemory指令，为Redis服务器配置内存限制，那么就可能会有内存溢出条件）。
> 在调用EXEC命令之后，事务中的某个命令可能会执行失败。例如，我们对某个键执行了错误类型的操作（例如，对一个字符串（String）类型的键执行列表（List）类型的操作）。

可以使用Redis客户端检测第一种类型的错误，在调用EXEC命令之前，这些客户端可以检查被放入队列的命令的返回值：如果命令的返回值是QUEUE字符串，那么就表示已经正确地将这个命令放入队列；否则，Redis将返回一个错误。如果将某个命令放入队列时发生错误，那么大多数客户端将会中止事务，并且丢弃这个事务。

然而，从Redis 2.6.5版本开始，服务器会记住事务积累命令期间发生的错误。然后，Redis会拒绝执行这个事务，在运行EXEC命令之后，便会返回一个错误消息。最后，Redis会自动丢弃这个事务。

在Redis 2.6.5版本之前，如果发生了上述的错误，那么在客户端调用了EXEC命令之后，Redis还是会运行这个出错的事务，执行已经成功放入事务队列的命令，而不会关心先前发生的错误。从2.6.5版本开始，Redis在遭遇上述错误时，会采用先前描述的新行为，这样便能轻松地混合使用事务和管道。在这种情况下，客户端可以一次性地将整个事务发送至Redis服务器，稍后再一次性地读取所有的返回值。

相反，在调用EXEC命令之后发生的事务错误，Redis不会进行任何特殊处理：在事务运行期间，即使某个命令运行失败，所有其他的命令也将会继续执行。

这种行为在协议层面上更加清晰。在以下示例中，当事务正在运行时，有一条命令将会执行失败，即使这条命令的语法是正确的：



![<img>](https://img-blog.csdn.net/20161013224958279)



上述示例的EXEC命令的返回值是批量的字符串，包含两个元素，一个是OK代码，另一个是-ERR错误消息。客户端会根据自身的程序库，选择一种合适的方式，将错误信息提供给用户

需要注意的是，即使某个命令执行失败，事务队列中的所有其他命令仍然会执行 —— Redis不会停止执行事务中的命令。

再看另一个示例，再次使用telnet通信协议，观察命令的语法错误是如何尽快报告给用户的：



![<img>](https://img-blog.csdn.net/20161013225025092)



这一次，由于INCR命令的语法错误，Redis根本就没有将这个命令放入事务队列。

#### 四、为什么Redis不支持回滚？

如果你具备关系型数据库的知识背景，你就会发现一个事实：在事务运行期间，虽然Redis命令可能会执行失败，但是Redis仍然会执行事务中余下的其他命令，而不会执行回滚操作，你可能会觉得这种行为很奇怪。

然而，这种行为也有其合理之处：

> 只有当被调用的Redis命令有语法错误时，这条命令才会执行失败（在将这个命令放入事务队列期间，Redis能够发现此类问题），或者对某个键执行不符合其数据类型的操作：实际上，这就意味着只有程序错误才会导致Redis命令执行失败，这种错误很有可能在程序开发期间发现，一般很少在生产环境发现。
> Redis已经在系统内部进行功能简化，这样可以确保更快的运行速度，因为Redis不需要事务回滚的能力。

对于Redis事务的这种行为，有一个普遍的反对观点，那就是程序有可能会有缺陷（bug）。但是，你应当注意到：事务回滚并不能解决任何程序错误。例如，如果某个查询会将一个键的值递增2，而不是1，或者递增错误的键，那么事务回滚机制是没有办法解决这些程序问题的。请注意，没有人能解决程序员自己的错误，这种错误可能会导致Redis命令执行失败。正因为这些程序错误不大可能会进入生产环境，所以我们在开发Redis时选用更加简单和快速的方法，没有实现错误回滚的功能。

#### 五、丢弃命令队列

DISCARD命令可以用来中止事务运行。在这种情况下，不会执行事务中的任何命令，并且会将Redis连接恢复为正常状态。示例如下所示：



![<img>](https://img-blog.csdn.net/20161013225047326)



#### 六、通过CAS操作实现乐观锁

Redis使用WATCH命令实现事务的“检查再设置”（CAS）行为。

作为WATCH命令的参数的键会受到Redis的监控，Redis能够检测到它们的变化。在执行EXEC命令之前，如果Redis检测到至少有一个键被修改了，那么整个事务便会中止运行，然后EXEC命令会返回一个Null值，提醒用户事务运行失败。

例如，设想我们需要将某个键的值自动递增1（假设Redis没有INCR命令）。

首次尝试的伪码可能如下所示：

```
val = GET mykey
val = val + 1
SET mykey $val
```

如果我们只有一个Redis客户端在一段指定的时间之内执行上述伪码的操作，那么这段伪码将能够可靠的工作。如果有多个客户端大约在同一时间尝试递增这个键的值，那么将会产生竞争状态。例如，客户端-A和客户端-B都会读取这个键的旧值（例如：10）。这两个客户端都会将这个键的值递增至11，最后使用SET命令将这个键的新值设置为11。因此，这个键的最终值是11，而不是12。

现在，我们可以使用WATCH命令完美地解决上述的问题，伪码如下所示：

```
WATCH mykey
val = GET mykey
val = val + 1
MULTI
SET mykey $val
EXEC
```

由上述伪码可知，如果存在竞争状态，并且有另一个客户端在我们调用WATCH命令和EXEC命令之间的时间内修改了val变量的结果，那么事务将会运行失败。

我们只需要重复执行上述伪码的操作，希望此次运行不会再出现竞争状态。这种形式的锁就被称为乐观锁，它是一种非常强大的锁。在许多用例中，多个客户端可能会访问不同的键，因此不太可能发生冲突 —— 也就是说，通常没有必要重复执行上述伪码的操作。

#### 七、WATCH命令详解

那么WATCH命令实际做了些什么呢？这个命令会使得EXEC命令在满足某些条件时才会运行事务：我们要求Redis只有在所有受监控的键都没有被修改时，才会执行事务。（但是，相同的客户端可能会在事务内部修改这些键，此时这个事务不会中止运行。）否则，Redis根本就不会进入事务。（注意，如果你使用WATCH命令监控一个易失性的键，然后在你监控这个键之后，Redis再使这个键过期，那么EXEC命令仍然可以正常工作。）

WATCH命令可以被调用多次。简单说来，所有的WATCH命令都会在被调用之时立刻对相应的键进行监控，直到EXEC命令被调用之时为止。你可以在单条的WATCH命令之中，使用任意数量的键作为命令参数。

当调用EXEC命令时，所有的键都会变为未受监控的状态，Redis不会管事务是否被中止。当一个客户单连接被关闭时，所有的键也都会变为未受监控的状态。

你还可以使用UNWATCH命令（不需要任何参数），这样便能清除所有的受监控键。当我们对某些键施加乐观锁之后，这个命令有时会非常有用。因为，我们可能需要运行一个用来修改这些键的事务，但是在读取这些键的当前内容之后，我们可能不打算继续进行操作，此时便可以使用UNWATCH命令，清除所有受监控的键。在运行UNWATCH命令之后，Redis连接便可以再次自由地用于运行新事务。

如何使用WATCH命令实现ZPOP操作呢？

本文将通过一个示例，说明如何使用WATCH命令创建一个新的原子化操作（Redis并不原生支持这个原子化操作），此处会以实现ZPOP操作为例。这个命令会以一种原子化的方式，从一个有序集合中弹出分数最低的元素。以下源码是最简单的实现方式：

```
WATCH zset
element = ZRANGE zset 0 0
MULTI
ZREM zset element
EXEC
```

如果伪码中的EXEC命令执行失败（例如，返回Null值），那么我们只需要重复运行这个操作即可。

#### 八、Redis脚本和事务

根据定义，Redis脚本也是事务型的。因此，你可以通过Redis事务实现的功能，同样也可以通过Redis脚本来实现，而且通常脚本更简单、更快速。

由于Redis从2.6版本才开始引入脚本特性，而事务特性是很久以前就已经存在的，所以目前的版本才有两个看起来重复的特性。但是，我们不太可能在短时间内移除对事务特性的支持。因为，即使不用求助于Redis脚本，用户仍然能够规避竞争状态，这从语义上来看是适宜的。还有另一个更重要的原因，Redis事务特性的实现复杂度是最小的。

但是，在相当长的一段时间之内，我们不大可能看到整个用户群体都只使用Redis脚本。如果发生这种情况，那么我们可能会废弃，甚至最终移除Redis事务。



### 71.Redis 的管道如何实现？

###### 1.1 为什么要有redis管道？

redis本身处理速度很快，但是如果你连续调用10条redis命令，它们要有10个网络来回，这速度就会降下来了，那么有没有办法把这10条命令一起发送到服务端呢？有，它就是redis管道

###### 1.2 redis管道的本质是什么？

redis管道的本质是将要发往redis服务端执行的命令在客户端缓存起来，比如说缓存100条，然后你可以将这100条命令一起发送到redis服务端，从而将100个网络来回降低到1个来回，大大降低了网络开销，提升了性能。

###### 1.3 redis管道优点是什么？

优点：

- 多个指令之间没有依赖关系，一个命令出问题，不影响其他命令；
- 可以使用 pipeline 一次性执行多个指令，减少 IO，缩减时间。

特点：

- redis的管道，是客户端实现的技术，服务端稍微配合一下即可（读取批量命令执行，每条命令执行完后进行缓存，全部执行完后再一次性返回）。
- 优点是大大减少了网络请求次数，提高了性能
- 注意：由于执行结果是批量返回的，所以管道中的命令不宜太多，否则redis服务端的缓存压力将会变大，进而影响性能。
- 注意：管道中的命令适合彼此没有关联的命令，如果一个命令的执行依赖上次执行的结果，那就不要用管道了。



##### 二、Redis管道 vs Redis事务

从下方的流程图，可以看出区别：

###### **1.命令在哪里缓存：**

- 事务里面的命令是在服务端缓存，当发出exec命令的时候，服务端就会判断并执行事务命令。
- 管道里面的命令是在客户端缓存，当客户端结束管道后一次发送到服务端，服务端读取后按照先后顺序先后执行。
- 但不管是事务还是管道，服务端都需要缓存单个命令的执行结果，等全部执行完后再返回给客户端

###### **2.命令中出现语法错误，是否影响其他命令：**

- 事务里的命令如果有语法错误（比如：getset name，注意不是执行错误），会导致事务被丢弃，里面的命令都不会执行
- 而管道里的命令如果出现语法错误，依然不影响其他的命令执行

###### **3.命令执行过程：**

- 事务和管道里的命令执行过程中都不能被其他的命令插入（事务的肯定不会打断，管道的暂时认为不会打断吧）
- 事务的命令指向前需要判断watch指定的值是否改变，如果改变了就不执行，而管道不会判断

 

事务流程图：

![在这里插入图片描述](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0NzY3Mzk=,size_16,color_FFFFFF,t_70)

管道流程图：
![在这里插入图片描述](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA0NzY3Mvcvzk=,size_16,color_FFFFFF,t_70)

 

### 72.关系数据库和NoSQL区别？为什么要出现非关系数据库？

关系型数据库的不足

关系型数据库的性能非常高，但是它毕竟是一个通用型的数据库，并不能完全适应所有的用途，具体来说它并不擅长以下处理:
\- 大量数据的写入处理
\- 为有数据更新的表做索引或表结构变更
\- 字段不固定时应用
\- 对简单查询需要快速返回结果的处理

这里逐一进行说明：

1. 大量数据的写入处理
   在数据读入方面，由复制产生的主从模式（数据的写入由主数据库负责，数据的读入由从数据库负责），可以比较简单的通过增加从数据库来实现规模化，但是在数据库的写入方面却不是这么简单，例如，考虑把主数据库从一台增加到俩台，做为互相关联复制的二元主数据库来使用，确实这样似乎可以把每台主数据库的负荷减少一半，但是更新处理会发生冲突（同样的数据在俩台服务器同时更新成其他值），可能会造成数据的不一致，为了避免这样的问题，就需要把对某个表的请求分别分配给合适的的主数据库来处理。
    　　另外也可以考虑把数据库分割开来，分别放在不同的数据库服务器上。数据库分割可以减少每台数据库服务器上的数据量，以便减少磁盘I/O处理，实现内存上的高速处理。但是这样做存储在不同服务器上的表之间就无法进行join处理。

2. 为有数据更新的表做索引或表结构变更
   在使用关系型数据库时，为了加快查询速度需要创建索引，为了增加必要的字段就一定需要改变表结构。为了进行这些处理，需要对表进行共享锁定，这期间数据变更（更新，插入，删除）是无法进行的。如果为数据量比较大的表创建索引或者是变更其表结构，就可能会导致长时间内数据无法进行更新。

3. 字段不固定时的应用
   如果字段不固定，在实际运用中每次都进行反复的表结构变更时非常痛苦的，也可以预先设定大量的预备字段，但这样的话很容易弄不清楚字段和数据的对应状态。

4. 对简单查询需要快速返回结果的处理
   关系型数据库并不擅长对简单的查询快速返回结果，因为关系型数据库是使用SQL进行读取的，它需要对SQL语言进行解析，同时还有对表的的锁定和解锁这样的额外开销。若希望对简单查询进行高速处理，没有必要非用关系型数据库不可。

![image-20211218115924430](.\img\最高级多方面面试题\image-20211218115924430-1642418807162.png)

### 73.缓存如何监控和优化热点 key？

Redis的热点key出现主要有以下几种情况
1、用户消费的数据远大于生产的数据（热卖商品、热点新闻、热点评论、明星直播）
2、请求分片集中，超过单Server的性能极限。

热点key可能造成如下问题：
1、流量集中，达到物理网卡上限
2、请求过多，缓存分片服务被打垮
3、DB击穿，引起业务雪崩

如何发现热点key：
1、通过tcpdump抓包，可以分析抓取到网络包分析key的频率
2、redis客户端抓取，例如请求key的时候记录日志，分析日志得到key的访问频率
3、redis的monitor可以记录redis的所有操作，记录并分析monitor日志得到key的访问频率（注意：monitor可能会造成性能问题，慎重使用）
4、Redis 4.0提供了—hot-keys配合maxmemory-policy可以统计热点key
5、第三方开源项目，如facebook开源项目redis-faina，原理同3

解决方案如下：
1、对于”get”类型的热点key，通常可以为redis添加slave，通过slave承担读压力来缓解
2、服务端本地缓存，服务端先请求本地缓存，缓解redis压力
3、多级缓存方案，通过多级请求，层层过滤解决热点key问题
4、proxy方案，有些方案会探测分片热点key，缓存在proxy上缓解redis压力
5、同解决big方案类似，将一个key通过hash分解为多个key，value值一样，将这些key分散到集群多个分片中，需要访问时先根据hash算出对应的key，然后访问的具体的分片

### 74.redis计算距离

解析地址：https://blog.csdn.net/Tank_666/article/details/79980603

### 75、redis 是 cpu密集型和还是内存密集型的 ？

内存密集型

### 76.试阐述Memcache的key多节点分布的算法？当任一节点出现故障时PHP的Memcache客户端将如何处置？如何确保Memcache数据读写操作的原子性？

答：原理：一致性hash

原子性：
原子性会导致的问题：简单的说就是A，B都想操作key1，然后都在key1上增加自己的信息，就会有问题
		memcached是原子的吗？宏观上所有的被发送到memcached的单个命令是完全原子的。如果您针对同一份数据同时发送了一个set命令和一个get命令，它们不会影响对方。它们将被串行化、先后执行。即使在多线程模式，所有的命令都是原子的；命令序列不是原子的。如果您通过get命令获取了一个item，修改了它，然后想把它set回memcached，我们不保证这个item没有被其他进程（process，未必是操作系统中的进程）操作过。在并发的情况下，您也可能覆写了一个被其他进程set的item。
		memcached 1.2.5以及更高版本，提供了gets和cas命令，它们可以解决上面的问题。如果您使用gets命令查询某个key的item，memcached会 给您返回该item当前值的唯一标识。如果您覆写了这个item并想把它写回到memcached中，您可以通过cas命令把那个唯一标识一起发送给 memcached。如果该item存放在memcached中的唯一标识与您提供的一致，您的写操作将会成功。如果另一个进程在这期间也修改了这个 item，那么该item存放在memcached中的唯一标识将会改变，您的写操作就会失败。

![image-20211217231211920](.\img\最高级多方面面试题\image-20211217231211920.png)

**什么是CAS协议**

Memcached于1.2.4版本新增CAS(Check and Set)协议类同于Java并发的CAS(Compare and Swap)原子操作，处理同一item被多个线程更改过程的并发问题。

在Memcached中，每个key关联有一个64-bit长度的long型惟一数值，表示该key对应value的版本号。这个数值由Memcached server产生，从1开始，且同一Memcached server不会重复。在两种情况下这个版本数值会加1：1、新增一个key-value对；2、对某已有key对应的value值更新成功。删除item版本值不会减小。

**php使用**

Memcached::cas()执行一个“检查并设置”的操作，因此，它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。检查是通过`cas_token`参数进行的， 这个参数是Memcach指定给已经存在的元素的一个唯一的64位值， 怎样获取这个值请查看Memcached::get*() 系列方法的文档。注意：这个值作为double类型是因为PHP的整型空间限制。

译注：这是Memcached扩展比Memcache扩展一个非常重要的优势， 在这样一个系统级（Memcache自身提供）的冲突检测机制（乐观锁）下， 我们才能保证高并发下的数据安全。

```
<?php
$m = new Memcached();
$m->addServer('localhost', 11211);
 
do {
    /* 获取ip列表以及它的标记 */
    $ips = $m->get('ip_block', null, $cas);
    /* 如果列表不存在， 创建并进行一个原子添加（如果其他客户端已经添加， 这里就返回false）*/
    if ($m->getResultCode() == Memcached::RES_NOTFOUND) {
        $ips = array($_SERVER['REMOTE_ADDR']);
        $m->add('ip_block', $ips);
    /* 其他情况下，添加ip到列表中， 并以cas方式去存储， 这样当其他客户端修改过， 则返回false */
    } else {
        $ips[] = $_SERVER['REMOTE_ADDR'];
        $m->cas($cas, 'ip_block', $ips);
    }  
} while ($m->getResultCode() != Memcached::RES_SUCCESS);
 
?>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>


### 77.redis与memcached如何实现分布式搭建.

### 79.redis实现互斥锁？

### 80.分布式环境下常见的应用场景（分布式锁、分布式自增 ID）

### 81.Redis集群方案应该怎么做？都有哪些方案？

### 82.Redis 集群的主从复制模型是怎样的？

### 83.如何解决 Redis 的并发竞争 Key 问题？

### 84.redis 的 zset 的使用场景？底层实现？为什么要用跳表？

### 85.Redis 的 key 是如何寻址的？

### 86.Redis 的持久化底层如何实现？

### 87.使用 Redis 如何实现异步队列？

### 88.Redis分布式锁 + 队列 + crontab 实现高并发下的抢购流程

https://blog.csdn.net/weixin_40325128/article/details/89378834

### 78.一致性hash原理是什么.

![图片](https://mmbiz.qpic.cn/mmbiz_png/TLH3CicPVibrcibBRsaoibV3E7BYf2icUQlicTZBgicicElZluMRx6m8yOAKjSa2mI481zz6SPSwEa0STqK8TekMcesiavQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)











### 79.redis面试知识点：

![image-20211209095223519](.\img\最高级多方面面试题\image-20211209095223519.png)



![image-20211209095421565](.\img\最高级多方面面试题\image-20211209095421565.png)

![image-20211209102021691](.\img\最高级多方面面试题\image-20211209102021691.png)

![image-20211209103612050](.\img\最高级多方面面试题\image-20211209103612050.png)

![image-20211209103629873](.\img\最高级多方面面试题\image-20211209103629873.png)

![image-20211209103813066](.\img\最高级多方面面试题\image-20211209103813066.png)



![image-20211209112600879](.\img\最高级多方面面试题\image-20211209112600879.png)

![image-20211209113213998](.\img\最高级多方面面试题\image-20211209113213998.png)

![image-20211209115320954](.\img\最高级多方面面试题\image-20211209115320954.png)

![image-20211209115547703](.\img\最高级多方面面试题\image-20211209115547703.png)

![image-20211209115908897](.\img\最高级多方面面试题\image-20211209115908897.png)



![image-20211209133007833](.\img\最高级多方面面试题\image-20211209133007833.png)

![image-20211209133725534](.\img\最高级多方面面试题\image-20211209133725534.png)

为什么不用多线程？

![image-20211209133749757](.\img\最高级多方面面试题\image-20211209133749757.png)

IO多路复用：

![image-20211209133848400](.\img\最高级多方面面试题\image-20211209133848400.png)

![image-20211209134903626](.\img\最高级多方面面试题\image-20211209134903626.png)

1.在server中处理的耗时操作：

![image-20211209135111560](.\img\最高级多方面面试题\image-20211209135111560.png)

2.并发量非常大时，单线程读与客户端IO数据存在瓶颈：

![image-20211209135159730](.\img\最高级多方面面试题\image-20211209135159730.png)

![image-20211209141827563](.\img\最高级多方面面试题\image-20211209141827563.png)

1.主从同步：

![image-20211209141945633](.\img\最高级多方面面试题\image-20211209141945633.png)

2.主从级联模式：

![image-20211209142012945](.\img\最高级多方面面试题\image-20211209142012945.png)

3.主从网络断开怎么处理？

![image-20211209142050487](.\img\最高级多方面面试题\image-20211209142050487.png)

4.实例与哈希槽的关系变化：

![image-20211209142141073](.\img\最高级多方面面试题\image-20211209142141073.png)

![image-20211209142458714](.\img\最高级多方面面试题\image-20211209142458714.png)

![image-20211209144957632](.\img\最高级多方面面试题\image-20211209144957632.png)

![image-20211209163221736](.\img\最高级多方面面试题\image-20211209163221736.png)












# 十三.nginx面试题

### 1.Nginx 是如何实现并发的？为什么 Nginx 不使用[多线程](https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=多线程)？Nginx常见的优化手段有哪些？502错误可能原因有哪些？

#### （1）Nginx 是如何实现高并发的？

异步，非阻塞，使用了epoll 和大量的底层代码优化。

如果一个server采用一个进程负责一个request的方式，那么进程数就是并发数。正常情况下，会有很多进程一直在等待中。

而nginx采用一个master进程，多个woker进程的模式。

master进程主要负责收集、分发请求。每当一个请求过来时，master就拉起一个worker进程负责处理这个请求。
同时master进程也负责监控woker的状态，保证高可靠性
woker进程一般设置为跟cpu核心数一致。nginx的woker进程在同一时间可以处理的请求数只受内存限制，可以处理多个请求。
Nginx 的异步非阻塞工作方式正把当中的等待时间利用起来了。在需要等待的时候，这些进程就空闲出来待命了，因此表现为少数几个进程就解决了大量的并发问题。

​		每进来一个request，会有一个worker进程去处理。但不是全程的处理，处理到什么程度呢？处理到可能发生阻塞的地方，比如向上游（后端）服务器转发request，并等待请求返回。那么，这个处理的worker很聪明，他会在发送完请求后，注册一个事件：“如果upstream返回了，告诉我一声，我再接着干”。于是他就休息去了。此时，如果再有request 进来，他就可以很快再按这种方式处理。而一旦上游服务器返回了，就会触发这个事件，worker才会来接手，这个request才会接着往下走。

#### （2）为什么 Nginx 不使用多线程？

Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以worker支持比perfork高的并发），并发过大会耗光服务器资源。

Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置Nginx主进程的工作进程的数量）(epoll)，不会为每个请求分配cpu和内存资源，节省了大量资源，同时也减少了大量的CPU的上下文切换。所以才使得Nginx支持更高的并发。

#### （3）Nginx常见的优化配置有哪些？

##### 1）调整worker_processes

指Nginx要生成的worker数量,最佳实践是每个CPU运行1个工作进程。

了解系统中的CPU核心数，输入

$ grep processor / proc / cpuinfo | wc -l

##### 2)  最大化worker_connections

Nginx Web服务器可以同时提供服务的客户端数。与worker_processes结合使用时，获得每秒可以服务的最大客户端数

最大客户端数/秒=工作进程*工作者连接数

为了最大化Nginx的全部潜力，应将工作者连接设置为核心一次可以运行的允许的最大进程数1024。

##### 3)  启用Gzip压缩

压缩文件大小，减少了客户端http的传输带宽，因此提高了页面加载速度

建议的gzip配置示例如下:( 在http部分内）
![image-20211217152120435](.\img\最高级多方面面试题\image-20211217152120435.png)

##### 4)为静态文件启用缓存

为静态文件启用缓存，以减少带宽并提高性能，可以添加下面的命令，限定计算机缓存网页的静态文件：

location ~* .(jpg|jpeg|png|gif|ico|css|js)$ {

​		expires 365d;

}

##### 5）Timeouts

keepalive连接减少了打开和关闭连接所需的CPU和网络开销，获得最佳性能需要调整的变量可参考：
![image-20211217152230208](.\img\最高级多方面面试题\image-20211217152230208.png)

##### 6)禁用access_logs

访问日志记录，它记录每个nginx请求，因此消耗了大量CPU资源，从而降低了nginx性能。

完全禁用访问日志记录

access_log off;

如果必须具有访问日志记录，则启用访问日志缓冲

access_log /var/log/nginx/access.log主缓冲区= 16k

#### （4）502报错可能原因有哪些？

1）FastCGI进程是否已经启动

2）FastCGI worker进程数是否不够

3）FastCGI执行时间过长

4）FastCGI Buffer不够

​		nginx和apache一样，有前端缓冲限制，可以调整缓冲参数

​		fastcgi_buffer_size 32k;

​		fastcgi_buffers 8 32k;

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Nginx 的 buffer 机制
对于来自 FastCGI Server 的 Response，Nginx 将其缓冲到内存中，然后依次发送到客户端浏览器。缓冲区的大小由 fastcgi_buffers 和 fastcgi_buffer_size 两个值控制。</p>
<p>比如如下配置：
fastcgi_buffers      8 4K;
fastcgi_buffer_size  4K;</p>
<p>fastcgi_buffers 控制 nginx 最多创建 8 个大小为 4K 的缓冲区，而 fastcgi_buffer_size 则是处理 Response 时第一个缓冲区的大小，不包含在前者中。所以总计能创建的最大内存缓冲区大小是 8<em>4K+4K = 36k。而这些缓冲区是根据实际的 Response 大小动态生成的，并不是一次性创建的。比如一个 8K 的页面，Nginx 会创建 2</em>4K 共 2 个 buffers。</p>
<p>当 Response 小于等于 36k 时，所有数据当然全部在内存中处理。如果 Response 大于 36k 呢？fastcgi_temp 的作用就在于此。多出来的数据会被临时写入到文件中，放在这个目录下面。</p>
<p>Buffer Size 优化
buffer的大小是你需要调优最重要参数。如果buffer size太小就会到导致nginx使用临时文件存储response，这会引起磁盘读写IO，流量越大问题越明显。</p>
<p>client_body_buffer_size 处理客户端请求体buffer大小。用来处理POST提交数据，上传文件等。client_body_buffer_size 需要足够大以容纳如果需要上传POST数据。</p>
<p>fastcgi_buffers，proxy_buffers 处理后端响应。如果这个buffer不够大，同样会引起磁盘都系IO。需要注意的是它们有一个上限值，这个上限值受 fastcgi_max_temp_file_size 、 proxy_max_temp_file_size控制。</p>
<p>FastCGI缓冲设置主要参数
fastcgi_buffers 4 64k
这个参数指定了从FastCGI进程到来的应答，本地将用多少和多大的缓冲区读取，假设一个PHP或JAVA脚本所产生页面大小为256kb，那么会为其分配4个64kb的缓冲来缓存；若页面大于256kb，那么大于256kb的部分会缓存到fastcgi_temp指定路径中，这并非是个好办法，内存数据处理快于硬盘，一般该值应该为站点中PHP或JAVA脚本所产生页面大小中间值，如果站点大部分脚本所产生的页面大小为256kb，那么可把值设置为16 16k,4 64k等。</p>
<p>fastcgi_buffer_size=64k
读取fastcgi应答第一部分需要多大缓冲区，该值表示使用1个64kb的缓冲区读取应答第一部分(应答头),可以设置为fastcgi_buffers选项缓冲区大小。</p>
<p>fastcgi_connect_timeout=300
连接到后端fastcgi超时时间，单位秒，下同。</p>
<p>fastcgi_send_timeout=300
向fastcgi请求超时时间(这个指定值已经完成两次握手后向fastcgi传送请求的超时时间)</p>
<p>fastcgi_reAd_timeout=300
接收fastcgi应答超时时间，同理也是2次握手后。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
5）Proxy Buffer不够

​		如果你用了Proxying，调整

​		proxy_buffer_size 16k;

​		proxy_buffers 4 16k;

6）php脚本执行时间过长

​		将php-fpm.conf的0s改成一个时间

### 2.缺省安装的Nginx+php-fpm环境，假设用户浏览一个耗时的网页，但是却在服务端渲染页面的中途中关闭了浏览器，那么请问服务端的PHP脚本是继续执行还是退出执行？

答：正常情况下，如果client异常退出了，Server端的程序还是会继续执行，直到与IO进行了两次交互操作。Server端发现client端已经断开连接，这个时候会出发一个User_abort，如果这个没有设置ignore_user_abort，那么这个php-fpm的程序才会被中断。


### 3.nginx是如何实现高并发的？

答：nginx之所以可以实现高并发，与它采用的epoll模型有很大的关系。epoll模型采用异步非阻塞的事件处理机制。这种机制可让nginx进程同时监控多个事件。

简单来说，就是异步非阻塞，使用了epoll模型和大量的底层代码优化。如果深入一点的话，就是nginx的特殊进程模型和事件模型的设计，才使其可以实现高并发。

### 4.nginx的进程模型？

它是采用一个master进程和多个worker进程的工作模式。
1、master进程主要负责收集、分发请求。当一个请求过来时，master拉起一个worker进程负责处理这个请求。；
2、master进程也要负责监控worker的状态，保证高可靠性；
3、worker进程议案设置为和CPU核心数一致或者其二倍。nginx的worker进程和Apache的不一样。apache的进程在同一时间只能处理一个请求，所以它会开启很多个进程，几百甚至几千个。而nginx的worker进程在同一时间可以处理的请求数只受内存限制，因此可以处理更多请求。



master进程主要用来管理worker进程，具体包括如下4个主要功能：
1、接收来自外界的信号。
2、向各worker进程发送信号。
3、监控woker进程的运行状态。
4、当woker进程退出后（异常情况下），会自动重新启动新的woker进程。



woker进程主要用来处理基本的网络事件：
1、多个worker进程之间是对等且相互独立的，他们同等竞争来自客户端的请求。
2、一个请求，只可能在一个worker进程中处理，一个worker进程，不可能处理其它进程的请求。
3、worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致。同时，nginx为了更好的利用多核特性，具有cpu绑定选项，我们可以将某一个进程绑定在某一个核上，这样就不会因为进程的切换带来cache的失效。

### 5.nginx的调度算法有哪些？

​		sticky：通过nginx-sticky模块，来实现cookie黏贴的方式将来自同一个客户端的请求发送到同一个后端服务器上处理，这样一定程度上可以解决多个后端服务器的session会话同步的问题；
​		round-robin（RR）：轮询，每个请求按时间顺序依次分配到不同的后端服务器，如果后端某台服务器死机，自动剔除故障系统，使用户访问不受影响；
​		weight：轮询权重，weight的值越大分配到的访问概率就越高，主要用于后端每台服务器性能不均衡的情况下，或者仅仅为在主从的情况下设置不同的权重，达到合理有效的利用主机资源。
​		least_conn：请求被发送到当前活跃连接最少的realserver上，会考虑到weight的值；
​		ip_hash：每个请求按照IP的哈希结果分配，使来自同一个IP的访客固定访问后端服务器，可以有效的解决动态网页存在的session共享问题。
​		fair：比weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面的大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，相应时间短的优先分配。nginx本身不支持fair，如果需要使用这种调度算法，则必须安装upstream_fair模块。
​		url_hash：按访问的URL的哈希结果来分配请求，使每个URL定向到后端服务器，可以进一步提高后端缓存服务器的效率。同样，nginx本身不支持url_hash，如果需要这种调度算法，则必须安装nginx的hash软件包。

### 6.nginx负载均衡调度状态

在nginx upstream模块中，可以设定每台后端服务器在负载均衡调度中的状态。

![image-20211217153802141](.\img\最高级多方面面试题\image-20211217153802141.png)

### 7、如何查看nginx已添加的模块？如果需要添加某个模块，应该如何实现？

查看已添加的模块：nginx -V；
如果需要添加某个模块，需要将工作目录切换至nginx的源码包中，执行“nginx -V”命令查看之前配置时的选项进行复制，然后增加需要添加的模块配置项，进行配置并编译，将新生成的nginx命令覆盖掉原有的nginx命令，然后重载nginx服务，即可实现在线添加模块。

### 8、可以从哪些方面来优化nginx服务？

![image-20211217154139972](.\img\最高级多方面面试题\image-20211217154139972.png)

### 9.使用Nginx的优势点

Nginx 由于使用了epoll和kqueue网路I/O模型，在实际生产环境能够支撑3万左右并发连接。

Nginx 内存消耗低。

Nginx 跨平台，而且配置相对来说难度较低。

Nginx 内置健康检查功能，如果负载均衡其中一个服务器宕机了，则接受到的请求会发送给其他服务器去处理。

支持Gzip压缩，可以添加浏览器本地缓存的Header头。

Nginx 支持热部署，可以在不间断服务的情况下平滑进行配置的更改。

Nginx 异步接收用户请求，减轻了Web服务器的压力。

### 10.**Nginx如何处理请求？**

​			Nginx启动后，首先进行配置文件的解析，解析成功会得到虚拟服务器的ip和端口号，在主进程master进程中创建socket，对addrreuse选项进行设置，并将socket绑定到对应的ip地址和端口并进行监听。然后创建子进程worker进程，当客户端和Nginx进行三次握手，则可以创建成功与Nginx的连接。当有新的请求进入时，空闲的worker进程会竞争，当某一个worker进程竞争成功，则会得到这个已经成功建立连接的socket，然后创建ngx_connection_t结构体，接下来设置读写事件处理函数并添加读写事件用来与客户端进行数据交换。当请求结束Nginx或者客户端主动关闭连接，此时一个请求处理完毕。

### 11.Session不同步如何处理？

上面其实提过了解决方案，nginx负载均衡方式使用ip_hash方式，如果用户已经访问过某个后端器，则再次访问时会将这个请求的ip地址进行哈希算法转换，自动定位到该服务器。当然也可以通过redis缓存用户session，一样可以处理session不同步的问题。



### **13.Nginx中正向代理与反向代理的区别**

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在正向代理中，隐藏了请求来源的客户端信息；
在反向代理中，隐藏了请求具体处理的服务端信息；</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
![image-20211217155202459](.\img\最高级多方面面试题\image-20211217155202459.png)

### 14.nginx是如何处理HTTP请求？

![image-20211217155218471](.\img\最高级多方面面试题\image-20211217155218471.png)

### 15.nginx中，如何使用未定义的服务器名称来阻止处理请求？

![image-20211217155337666](.\img\最高级多方面面试题\image-20211217155337666.png)

### 16.解释Nginx服务器的Master和worker进程分别是什么？

​		worker进程：处理请求

​		master进程：读取及评估配置和维持

### 17.解释你如何通过不同于80的端口开启nginx?

![image-20211217155710134](.\img\最高级多方面面试题\image-20211217155710134.png)



### 18.解释是否有可能将Nginx的错误替换为502错误，503？

![image-20211217160342648](.\img\最高级多方面面试题\image-20211217160342648.png)

### 19.在Nginx中，解释如何在url中保留双斜线？

![image-20211217160450785](.\img\最高级多方面面试题\image-20211217160450785.png)

### 20.解释ngx_http_upsteam_module的作用是什么？

![image-20211217160657409](.\img\最高级多方面面试题\image-20211217160657409.png)

### 21.请解释什么是C10K问题？

C10K问题是指无法同时处理大量客户端(10,000)的网络套接字。

10k就是10千，也就是10240，c可能就是client吧，c10k意思是10000并发客户端连接到单个服务器，导致服务器连接数过多崩溃的问题。

解决c10k意思是采用一系列改进之后让单机服务器能接受10k客户端并发连接。



#### C10K问题由来

随着互联网的普及，应用的用户群体几何倍增长，此时服务器性能问题就出现。最初的服务器是基于进程/线程模型。新到来一个TCP连接，就需要分配一个进程。假如有C10K，就需要创建1W个进程，可想而知单机是无法承受的。那么如何突破单机性能是高性能网络编程必须要面对的问题，进而这些局限和问题就统称为C10K问题，最早是由Dan Kegel进行归纳和总结的，并且他也系统的分析和提出解决方案。

#### C10K问题的本质

C10K问题的本质上是操作系统的问题。对于Web 1.0/2.0时代的操作系统，传统的同步阻塞I/O模型处理方式都是requests per second。当创建的进程或线程多了，数据拷贝频繁（缓存I/O、内核将数据拷贝到用户进程空间、阻塞，进程/线程上下文切换消耗大， 导致操作系统崩溃，这就是C10K问题的本质。

可见, 解决C10K问题的关键就是尽可能减少这些CPU资源消耗。

#### C10K问题的解决方案

从网络编程技术的角度来说，主要思路：

1. 每个连接分配一个独立的线程/进程
2. 同一个线程/进程同时处理多个连接

#### 每个进程/线程处理一个连接

该思路最为直接，但是申请进程/线程是需要系统资源的，且系统需要管理这些进程/线程，所以会使资源占用过多，可扩展性差

#### 每个进程/线程同时处理 多个连接(I/O多路复用)

1. select方式：使用fd_set结构体告诉内核同时监控那些文件句柄，使用逐个排查方式去检查是否有文件句柄就绪或者超时。该方式有以下缺点：文件句柄数量是有上线的，逐个检查吞吐量低，每次调用都要重复初始化fd_set。
2. poll方式：该方式主要解决了select方式的2个缺点，文件句柄上限问题(链表方式存储)以及重复初始化问题(不同字段标注关注事件和发生事件)，但是逐个去检查文件句柄是否就绪的问题仍然没有解决。
3. epoll方式：该方式可以说是C10K问题的killer，他不去轮询监听所有文件句柄是否已经就绪。epoll只对发生变化的文件句柄感兴趣。其工作机制是，使用"事件"的就绪通知方式，通过epoll_ctl注册文件描述符fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd, epoll_wait便可以收到通知, 并通知应用程序。而且epoll使用一个文件描述符管理多个描述符,将用户进程的文件描述符的事件存放到内核的一个事件表中, 这样数据只需要从内核缓存空间拷贝一次到用户进程地址空间。而且epoll是通过内核与用户空间共享内存方式来实现事件就绪消息传递的，其效率非常高。但是epoll是依赖系统的(Linux)。
4. 异步I/O以及Windows，该方式在windows上支持很好，这里就不具体介绍啦。



### 22.请陈述stub_status和 sub_filter指令的作用是什么?

Stub_status指令：用于了解Nginx当前状态，如当前的活动连接，接受和处理当前读/写/等待连接的总数
Sub_filter指令：用于搜索和替换响应中的内容，并快速修复陈旧的数据

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>nginx学习sub_filter模块
用户替换html中的字符
location / {
root   /opt/app/code/;
random_index on;
index  index.html index.htm;
sub_filter '<h1>Admin' '<h1>ggggg';  //第一个参数是要被替换的，第二个参数是替换后的
sub_filter_once off;   //替换所有的，默认是on，替换第一个
}
改完保存下，使用命令检查nginx语法是否正确</p>
<p>nginx -tc /etc/nginx/nginx.conf
平滑重启nginx
nginx -s reload -c /etc/nginx/nginx.conf</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
### 23.解释Nginx是否支持将请求压缩到上游?

可以使用 Nginx模块 gunzip将请求压缩到上游。gunzip模块是一个过滤器，它可以对不支持“gzip”编码方法的客户机或服务器使用“内容编码:gzip”来解压缩响应。

### 24.HTTP压缩的使用场景和流程？

从上面对于HTTP压缩的介绍可以看出，这种技术是一种优化技术，常常用于压缩服务器端返回的报文以达到节省带宽加速响应的目的。

下面简单介绍一个HTTP使用Gzip压缩的过程。

- 浏览器发送Http request 给Web服务器, request 中有Accept-Encoding: gzip, deflate, br。 (告诉服务器，浏览器支持gzip压缩)

- Web服务器接到request后， 先生成原始的Response, 其中有原始的Content-Type和Content-Length。

- Web服务器通过Gzip，来对Response进行编码， 编码后header中有Content-Type和Content-Length(压缩后的大小)， 并且增加了Content-Encoding:gzip. 然后把Response发送给浏览器。

- 浏览器接到Response后，根据Content-Encoding:gzip来对Response进行解码。 获取到原始response后， 然后显示出网页。

  ​	客户端也可以发送压缩数据给服务端，通过代码将请求数据解压即可，规范起见同样要在请求中加入Content-Encoding:gzip

### 25.如何在Nginx中获得当前的时间?

要获得 Nginx的当前时间，必须使用SSl模块、$date_gmt和date_local的变量。
Proxy_set_header THE-TIME $date_gmt;

### 26.nginx的配置案例：

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>upstream product_server{
    server www.product.com:8080;
}
upstream order_server{
    server www.image.com:8081;
}
</code></pre>
<p>#HTTP服务器
server {
#监听80端口，80端口是知名端口号，用于HTTP协议
listen       80;</p>
<pre><code>    #定义使用www.xx.com访问
    server_name  www.nginx.com;    
  
    #编码格式
    charset utf-8;
    
    #代理配置参数
    proxy_connect_timeout 180;
    proxy_send_timeout 180;
    proxy_read_timeout 180;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarder-For $remote_addr;
    
    #默认指向product的server
    location / {
        proxy_pass http://product_server;
    }

	#使用location对不同请求做相应处理
    location /product/{
        proxy_pass http://product_server;
    }

    location /image/ {
        proxy_pass http://image_server;
    }
    
}
</code></pre>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
### 27.多进程机制，使用多进程的好处有两点：

进程之间不共享资源，不需要加锁，减少了使用锁对性能造成的影响，同时降低编程的复杂度，降低开发成本。
采用独立的进程，可以让进程互相之间不会影响，如果一个进程发生异常退出时，其它进程正常工作，master 进程则很快启动新的worker 进程，确保服务不会中断，从而将风险降到最低。



### 28.内存池

为了避免出现内存碎片，减少向操作系统申请内存的次数、降低各个模块的开发复杂度，Nginx 设计了简单的内存池，它的作用主要是把多次向系统申请内存的操作整合成一次，这大大减少了 CPU 资源的消耗，同时减少了内存碎片。



### 29.什么是nginx,它的优势和功能？

Nginx是一个高性能的 HTTP 和 反向代理 服务器，也是一个 IMAP/POP3/SMTP 代理服务器。因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。
优点：
（1）更快
这表现在两个方面：一方面，在正常情况下，单次请求会得到更快的响应；另一方面，在高峰期（如有数以万计的并发请求），Nginx可以比其他Web服务器更快地响应请求。

（2）高扩展性，跨平台
Nginx的设计极具扩展性，它完全是由多个不同功能、不同层次、不同类型且耦合度极低的模块组成。因此，当对某一个模块修复Bug或进行升级时，可以专注于模块自身，无须在意其他。而且在HTTP模块中，还设计了HTTP过滤器模块：一个正常的HTTP模块在处理完请求后，会有一串HTTP过滤器模块对请求的结果进行再处理。这样，当我们开发一个新的HTTP模块时，不但可以使用诸如HTTP核心模块、events模块、log模块等不同层次或者不同类型的模块，还可以原封不动地复用大量已有的HTTP过滤器模块。这种低耦合度的优秀设计，造就了Nginx庞大的第三方模块，当然，公开的第三方模块也如官方发布的模块一样容易使用。
Nginx的模块都是嵌入到二进制文件中执行的，无论官方发布的模块还是第三方模块都是如此。这使得第三方模块一样具备极其优秀的性能，充分利用Nginx的高并发特性，因此，许多高流量的网站都倾向于开发符合自己业务特性的定制模块。

（3）高可靠性：用于反向代理，宕机的概率微乎其微
高可靠性是我们选择Nginx的最基本条件，因为Nginx的可靠性是大家有目共睹的，很多家高流量网站都在核心服务器上大规模使用Nginx。Nginx的高可靠性来自于其核心框架代码的优秀设计、模块设计的简单性；另外，官方提供的常用模块都非常稳定，每个worker进程相对独立，master进程在1个worker进程出错时可以快速“拉起”新的worker子进程提供服务。

（4）低内存消耗
一般情况下，10 000个非活跃的HTTP Keep-Alive连接在Nginx中仅消耗2.5MB的内存，这是Nginx支持高并发连接的基础。

（5）单机支持10万以上的并发连接
这是一个非常重要的特性！随着互联网的迅猛发展和互联网用户数量的成倍增长，各大公司、网站都需要应付海量并发请求，一个能够在峰值期顶住10万以上并发请求的Server，无疑会得到大家的青睐。理论上，Nginx支持的并发连接上限取决于内存，10万远未封顶。当然，能够及时地处理更多的并发请求，是与业务特点紧密相关的。

（6）热部署
master管理进程与worker工作进程的分离设计，使得Nginx能够提供热部署功能，即可以在7×24小时不间断服务的前提下，升级Nginx的可执行文件。当然，它也支持不停止服务就更新配置项、更换日志文件等功能。

（7）最自由的BSD许可协议
这是Nginx可以快速发展的强大动力。BSD许可协议不只是允许用户免费使用Nginx，它还允许用户在自己的项目中直接使用或修改Nginx源码，然后发布。这吸引了无数开发者继续为Nginx贡献自己的智慧。
以上7个特点当然不是Nginx的全部，拥有无数个官方功能模块、第三方功能模块使得Nginx能够满足绝大部分应用场景，这些功能模块间可以叠加以实现更加强大、复杂的功能，有些模块还支持Nginx与Perl、Lua等脚本语言集成工作，大大提高了开发效率。这些特点促使用户在寻找一个Web服务器时更多考虑Nginx。
选择Nginx的核心理由还是它能在支持高并发请求的同时保持高效的服务

### 30.nginx的常用算法实现？

1、round-robin
round-robin的意思是循环轮询。Nginx最简单的负载均衡配置如下：

    http {
        upstream app1 {
            server 10.10.10.1;
    
            server 10.10.10.2;
        }
        server {
            listen 80;
            location / {
    
                proxy_pass http://app1;
    
            }
        }
        }



     upstream app1用来指定一个服务器组，该组的名字是app1，包含两台服务器。在指定服务器组里面包含的服务器时以形式“server ip/domain：port”的形式指定，其中80端口可以忽略。然后在接收到请求时通过“proxy_pass http://app1”把对应的请求转发到组app1上。Nginx默认的负载均衡算法就是循环轮询，如上配置我们采用的就是循环轮询，其会把接收到的请求循环的分发给其包含的（当前可用的）服务器。使用如上配置时，Nginx会把第1个请求给10.10.10.1，把第2个请求给10.10.10.2，第3个请求给10.10.10.1，以此类推。


2、least-connected
least-connected算法的中文翻译是最少连接，即每次都找连接数最少的服务器来转发请求。例如Nginx负载中有两台服务器，A和B，当Nginx接收到一个请求时，A正在处理的请求数是10，B正在处理的请求数是20，则Nginx会把当前请求交给A来处理。要启用最少连接负载算法只需要在定义服务器组时加上“least_conn”，如：

    upstream app1 {
    	least_conn;
    
    	server 10.10.10.1;
    
    	server 10.10.10.2;
    }

3、ip-hash

ip-hash算法会根据请求的客户端IP地址来决定当前请求应该交给谁。使用ip-hash算法时Nginx会确保来自同一客户端的请求都分发到同一服务器。要使用ip-hash算法时只需要在定义服务器组时加上“ip-hash ”指令，如：

    upstream app1 {
               ip_hash;
    
    		server 10.10.10.1;
    
    		server 10.10.10.2;
    	}

4、weighted
weighted算法也就是权重算法，会根据每个服务的权重来分发请求，权重大的请求相对会多分发一点，权重小的会少分发一点。这通常应用于多个服务器的性能不一致时。需要使用权重算法时只需要在定义服务器组时在服务器后面指定参数weight，如：

    upstream app1 {
    	server 10.10.10.1 weight=3;
    
    	server 10.10.10.2;
    	}



### 31.动态资源、静态资源分离的原因

动态资源、静态资源分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路
动态资源、静态资源分离简单的概括是：动态文件与静态文件的分离
**二者分离的原因**
在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件）这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗，当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决，动、静分离将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问，这里我们将静态资源放到nginx中，动态资源转发到tomcat服务器中

### 32.什么是DNS解析域名

DNS域名解析就是讲域名转化为不需要显示端口（二级域名的端口一般为80）的IP地址，域名解析的一般先去本地环境的host文件读取配置，解析成对应的IP地址，根据IP地址访问对应的服务器。若host文件未配置，则会去网络运营商获取对应的IP地址和域名.

### 33.什么是Nginx

Nginx是一个高级的轻量级的web服务器,由俄罗斯科学家开发的，具有如下优点:

     1.占用内存少，并发量强，支持多种并发连接，效率高.
     2.能够作为负载均衡服务器和(内部直接支持 Rails 和 PHP)代理服务器。Nginx用C编写开销和CPU占有小.
     3.安装启动简单，配置简洁，bug少，一般几个月不需要重新启动且不会宕机，稳定性和安全性好.

 Nginx是一款轻量级的web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在
 一个BSD-like协议下发行。由俄罗斯的程序设计师Igor Sysoev所开发，供俄国大型的入口网站及搜索引擎Rambler（漫步者）使用。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：新浪、网易、腾讯等。

######  （1）优点：

 1、可运行linux，并有windows移植版
 2、在高连接并发的情况下，Nginx是Apache服务器不错的替代品,Nginx在美国是做虚拟主机生意的老板们经常选择的软件平台之一。能够支持高达50000个并发连接数的响应调度器的实现技术中,IP负载均衡技术是效率最高的，IP虚拟服务器软件（IPVS）实在linux内核中实现的。

FastCGI的动态程序进行缓存，配合着第三方的ngx_cache_purge，对制定的URL缓存内容可以进行增删管理。

######  （2）Nginx配置：

1、全局块：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进行pid存放路径，
 日志存放路径，配置文件引入，允许生成worker process数等。 

2、events块：配置影响nginx服务器或与用户的网络连接。
 有每个进程的最大连接数，选取哪种时间驱动模型处理连接请求，是否允许同时接受多个忘了连接，开启多个网络连接序列化等

3、http块：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，
 日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。

4、server块：配置虚拟主机的相关参数，一个http中可以有多个server。

5、location块：配置请求的路由，以及各种页面的处理情况。
 还要注意以下几点：

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>1、$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；
2.$remote_user：用来记录客户端用户名称
3、$time_local:用来记录访问时间与时区
4、$request:用来记录请求的url与http协议
5.$status:用来记录请求状态，成功200</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
6.$body_bytes_s ent:记录发送给客户端文件主题内容大小；

7.$http_user_agent:记录客户端浏览器的相关信息

######  （3）惊群现象：

一个网络连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得连接，这样会影响系统系能。

每个指令必须有分号结束。

nginx是工作在网络7层的





###  34.反向代理的作用

隐藏真实服务器，使真实服务器只能通过内网访问，保护了真实服务器不被攻击。配置负载均衡，减轻单台真实服务器的压力。配置主备服务器，保持服务稳定运行。

###  35.Nginx如何配置反向代理

首先到DNS服务器做域名解析，如果是局域网在hosts文件中配置IP和域名对应关系。编辑nginx的nginx.conf文件，配置server_name为指向nginx服务器的域名，location拦截请求，如果是访问nginx本地资源则配置root，如果是反向代理到真实服务器则配置proxy_pass为服务器地址。

### 36.说说常用Nginx的相关配置

upstream 负载均衡配置

server [IP] [weight] [backup] 配置tomcat集群

proxy_connect_timeout、proxy_read_timeout、proxy_send_timeout 连接时间、真实服务器响应时间、返回结果时间

location 匹配用户请求的url

root 配置本地资源路径

proxy_pass    配置真实服务器地址

 

请画图展示反向代理流程

![img](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ExNTEwMjc4MDcwNQ==,size_16,color_FFFFFF,t_7011111-1642418807163)

### 37.LVS与Nginx区别

LVS是四层反向代理，基于TCP和UDP协议，可用于管理Nginx集群，抗负载能力强。Nginx是七层反向代理，基于HTTP协议，用于管理真实服务器集群。

### 38.location的作用

匹配用户请求url，根据不同请求转发到不同的服务器。

### 39.Nginx中如何配置负载均衡

在upstream中配置多个server，在location的proxy_pass配置为http://+upstream名称

### 40.四层负载均衡与七层负载均衡区别

四层负载均衡基于TCP和UDP协议，通过IP+端口号接受请求并转发到服务器。七层负载均衡基于HTTP协议，通过url或主机名接收请求并转发到服务器。

### 41.四层负载均衡有那些实现方案

LVS、F5

### 42.负载均衡有那些算法

轮询算法:按照时间顺序分配到不同的服务器，当其中一台服务器宕机则被自动剔除，切换到正常的服务器。

权重算法:按照分配给服务器的权重比例来分发到不同服务器，权重比例越高，则访问几率越大。

IP绑定(ip_hash):根据访问的IP的哈希结果来判定，使同一个IP访问一台固定的后端服务器，同时解决动态页面的session问题.

 

### 43.服务器分布式后，会产生了那些问题

分布式锁

分布式全局ID

分布式Session一致性问题

分布式事务

分布式任务调度

分布式日志收集

分布式配置中心

### 44.什么是动态负载均衡

一般情况下，使用nginx搭建服务器集群，每次修改nginx.conf配置文件都需要重启nginx服务器。动态负载均衡就是修改nginx.conf配置文件后不必重启nginx而使配置生效。

### 45.Nginx如何实现动态负载均衡

搭建Nginx+Consul+Upsycn环境。Nginx实现服务的反向代理和负载均衡。Consul是一个开源的注册中心和服务发现的框架，通过HTTP API来发现服务，注册服务。同时支持故障发现，K/V存储，多数据中心，Raft算法等多种高可用特性。Consul在Nginx动态负载均衡作用是通过Http api注册和发现服务.Upsycn是新浪微博的开源框架，在Nginx动态负载均衡的作用是Consul的后端的server列表，即获取Nginx的上游服务器(Upstream server）信息,并动态更新Nginx的路由信息.



### 46.Nginx如何实现TCP四层负载均衡

在nginx.conf文件中配置tcp模块，在upstream块中定义socket服务器负载均衡，其余与nginx配置七层负载均衡相同。

    tcp {
       ### 定义多个上游服务器
       upstream  itmayeidu{
          ### 定义TCP模块上游服务器
    		server 192.168.5.165:80001;
    		server 192.168.5.165:80002;
       }
       server {
        	listen       9999;
        	server_name  192.168.212.137;
       		proxy_pass itmayeidu;
    
    	}
    	//反向代理upstream
    }

### 47.lvs 与Nginx做负载均衡的区别

lvs工作在网络第四层，nginx工作在网络第七层；lvs比nginx抗负载能力强；lvs对网络依赖性强，nginx对网络依赖性弱；lvs几乎可以对所有应用做负载均衡，比如数据库

##### lvs与keepalived区别

Lvs可以实现负载均衡，但是无法实现健康检查。Keepalived可以进行健康检查实现高可用。

##### keepalived 作用

keepalive 软件可以进行健康检查，而且能同时实现 LVS 的高可用性，解决 LVS 单点故障的问题

##### 如何实现双机主从热备

Nginx+Tomcat：在upstream中配置多台服务器，从服务器后加backup

Keepalived+Nginx：在多台nginx服务器上安装keepalived，将主服务器的state设置为MASTER，从服务器设置为BACKUP，主服务器的优先级要高于从服务器

 

##### lvs+Keepalived+Nginx架构流程图

![img](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3ExNTEwMjc4MDcwNQ==,size_16,color_FFFFFF,t_70-1642418807163)

### 48.项目发布如何不影响到正常用户访问，实现7*24小时访问

可以两台机子互为热备，平时各自负责各自的服务。在做上线更新的时候，关闭一台服务器的tomcat后，nginx自动把流量切换到另外一台服务的后备机子上，从而实现无痛更新，保持服务的持续性，提高服务的可靠性，从而保证服务器7*24小时运行。

### 49.项目如何发生故障宕机了，如何处理。

使用lvs+keepalived+Nginx做主从热备，lvs管理nginx集群，nginx管理服务器集群，在服务器宕机的情况下keepalived启动健康检测，多次重启无果可以短信通知运维人员及时维护。

### 50.动态网站与静态网站区别

在浏览器中打开一个网站，点击鼠标右键查看源码，多次请求后如果源码不产生变化就是静态网站，变化就是动态网站。

 

###### 动态页面静态化的作用

便于搜索引擎抓取和排名

 

###### 什么是动静分离架构模式

静态页面与动态页面分开不同系统访问的架构设计方法，静态页面与动态页面以不同域名区分。

 

###### 如何搭建动静分离

以nginx服务器作为静态资源服务器，静态资源和动态资源访问分开配置，静态资源在location中使用本地文件路径配置方式，动态资源使用proxy_pass配置到后台服务器。

如：

    ###静态资源访问
    
    server {
      listen       80;
      server_name  static.itmayiedu.com;
      location /static/imgs {
           root F:/;
           index  index.html index.htm;
       }
    }



     ###动态资源访问
     server {
         listen       80;
         server_name  www.itmayiedu.com;
         location / {
             proxy_pass http://127.0.0.1:8080;
             index  index.html index.htm;
         }
    }

###### 动静分离与前后分离区别

​		动静分离是将静态资源和动态资源存放在不同服务器中，前后分离是将前端和后台分离，前端通过api调用后台接口

###### 如何控制浏览器静态资源缓存

​		静态资源存在缓存的原因是项目上线时，浏览器缓存中的静态资源导致与服务器将淘汰资源的代码发生冲突(或者是页面访问频繁访问同一资源，导致一些浏览器如IE(本人开发亲身经历过)返回默认的响应结果，与实际响应结果不符合)，一般的服务器是强制F5进行刷新或者是清除缓存，最有效的解决方法就是在请求资源后面加上变量(如时间戳,随机数)

 

### 51.nginx为什么可以替代apache

1、作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。在高连接并发的情况下，Nginx 是 Apache 服务器不错的替代品；Nginx 在美国是做虚拟主机生意的老板们经常选择的软件平台之一。能够支持高达 50000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型。

Nginx 作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP 代理服务器对外进行服务。Nginx 采用 C 进行编写，不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好很多。

2、Nginx 配置简洁,Apache 复杂，Nginx 启动特别容易,并且几乎可以做到 7*24 不间断运行，即使运行数个月也不需要重新启动。你还能够不间断服务的情况下进行软件版本的升级。Nginx 静态处理性能比 Apache 高 3 倍以上，Apache 对 PHP 支持比较简单，Nginx 需要配合其他后端来使用，Apache 的组件比 Nginx 多。

3、最核心的区别在于 Apache 是同步多进程模型，一个连接对应一个进程；Nginx 是异步的，多个连接（万级别）可以对应一个进程。

4、Nginx 的优势是处理静态请求，cpu 内存使用率低，Apache 适合处理动态请求，所以现在一般前端用 Nginx 作为反向代理抗住压力，Apache 作为后端处理动态请求。

总结内容来自于：https://www.imydl.com/linux/8252.html 是我想要的结果

这里有详细介绍：https://www.cnblogs.com/zm-0713/p/5064168.html
————————————————



### 52.php如何与nginx关联，以及端口如何管理

这里有详细的说明来自于：https://www.cnblogs.com/zhouguowei/p/9720108.html

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>nginx和php之间是怎样通信的呢？
　　FastCGI原理</p>
<p>FastCGI是一个运用于Http Server和动态脚本语言间通信的接口，多数流行的Http Server都支持FastCGI，包括Apache、Nginx和lighttpd等。同时，FastCGI也被许多脚本语言支持，其中就有PHP。 FastCGI接口方式采用C/S结构，可以将HttP服务器和脚本解析服务器分开，同时在脚本解析服务器上启动一个或者多个脚本解析守护进程。当HttP服务器每次遇到动态程序时，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给客户端。这种方式可以让HttP服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p>
<p>Nginx+php-fpm实现原理</p>
<p>Nginx本身不会对PHP进行解析，终端对PHP页面的请求将会被Nginx交给FastCGI进程监听的IP地址及端口，由php-fpm作为动态解析服务器处理，最后将处理结果再返回给nginx。其实，Nginx就是一个反向代理服务器。Nginx通过反向代理功能将动态请求转向后端php-fpm，从而实现对PHP的解析支持，这就是Nginx实现PHP动态解析的原理。</p>
<p>Nginx不支持对外部程序的直接调用或者解析，所有的外部程序（包括PHP）必须通过FastCGI接口来调用。FastCGI接口在Linux下是socket（这个socket可以是文件socket，也可以是ip socket）。为了调用CGI程序，还需要一个FastCGI的wrapper（wrapper可以理解为用于启动另一个程序的程序），这个wrapper绑定在某个固定socket上，如端口或者文件socket。当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接收到请求，然后派生出一个新的线程，这个线程调用解释器或者外部程序处理脚本并读取返回数据；接着，wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx；最后，Nginx将返回的数据发送给客户端。</p>
<p>Nginx 简单配置</p>
<p>location ~ .php$ {
root /home/admin/web/nginx/html/;
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
fastcgi_param SCRIPT_FILENAME /home/admin/web/nginx/html/$fastcgi_script_name;
include fastcgi_params;
}
　　当nginx接收到一个http请求时，通过配置文件找到对应的server。然后匹配server中的所有location，找到最匹配的。而在location中的命令会启动不同的模块去完成工作，比如rewrite模块、index模块。因此在nginx中模块可以看作真正的劳动工作者。nginx的模块是被编译到nginx中的，属于静态方式。启动nginx时，模块被自动加载。不像apache，把模块单独编译成so文件，在配置文件中指定是否加载。所以，单比模块加载方面，nginx也比apache速度上有提升。</p>
<p>那nginx是怎么调用php的呢？先看下面的nginx中关于php的配置</p>
<p>location ~ .php$ {
root /webpath;
fastcgi_pass 127.0.0.1:9000;
...
...<br>
}
　　这个location指令把以php为文件后缀的请求，交给127.0.0.1:9000处理。我想你看到这个应该猜到了，这是一个C/S架构东西。 而这里的IP地址和端口（127.0.0.1:9000）就是fastcgi进程监听的IP地址和端口。fastcgi是一个可伸缩地、高速地在http server和动态脚本语言间通信的接口。多数流行的http server都支持fastcgi，包括apache、nginx和lighttpd等。同时，fastcgi也被许多脚本语言支持，其中就有php。</p>
<p>那这个fastcgi的配置IP和端口从何而来呢？在php-fpm.conf中可以看到如下：</p>
<p>listen = 127.0.0.1:9000  #这个表示php的fastcgi进程监听的ip地址以及端口
pm.start_servers = 2
　　php-fpm作为fastcgi的进程管理器，可以有效控制内存和进程，并且平滑重载php配置。php5.3以后，php-fpm被集成到php的core中，默认安装，无须配置。</p>
<p>fastcgi进程管理器php-fpm自身初始化，启动主进程php-fpm和启动start_servers个fastcgi子进程。主进程php-fpm主要是管理fastcgi子进程，监听9000端口，fastcgi子进程等待请求。当客户端请求到达nginx时，nginx通过location指令，将所有以php为后缀的文件都交给 127.0.0.1:9000 来处理。php-fpm选择并连接到一个fastcgi子进程，并将环境变量和标准输入发送到fastcgi子进程。fastcgi子进程完成处理后将标准输出和错误信息返回。当fastcgi子进程关闭连接时，请求便告处理完成，等待下次处理。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>




### 53.nginx解析PHP的原理：

Nginx 是没法解析动态脚本的,下面看一张原理解析图片,说白了Nginx解析php是通过fast-cig + php-fpm配合完成的.
用户通过浏览器访问PHP页面时候，流程是首先请求到了Nginx服务器，服务器发现是动态请求，Nginx通过Fast-cgi接口来跟动态脚本PHP通信，Fast-cig在Linux下是socket（文件或者Ip类型）,通信过程中由FastCGI的wrapper（wrapper可理解为用于启动另外一个线程的程序）进而启动一个CIG的解析器.Web server将CGI环境变量和标准输入发送到FastCGI子进程php-cgi
FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server再返回给用户。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，php-cgi在此便退出了，在php-cgi启动的过程中，会有守护者或者说管理者（PHP-fpm）,防止php-cgi的崩溃.
这样整流程也算完成了.

### 54.什么是CGI、什么是FastCGI，什么是PHP-Fpm，什么是PHP-cgi

CGI ：是一个可伸缩地、高速地在HTTP server和动态脚本语言间通信的接口
FastCGI : 是CGI的fast版本（哈哈，急速版）多数流行的HTTP server都支持FastCGI，包括Apache、Nginx和lighttpd等，这一带Fast可了不得了:
1.性能提升.他老爹处理请求时遇到动态脚本解析器。
2.升级附带了支持高迸发性
3.安全上做了升级
说道性能提升了，肯定有性能提升之道，那提升的原理是啥呢？
1.1 接口处理方式采用了 C/S 结构. 在处理机制上就使得HTTP服务和脚本解析器剥离开来,使得部署变得可分离,这样脚本解析服务器可以分出来多个守护进程，遇到动态脚本则分发给FastCIG，将得到结果反给浏览器。HTTP服务器呢则一心一意的干静态资源解析方面的活。这就相当于是多线程的概念啦，当然会快呀。
PHP－Fpm : 这个就是咱们上面提到的脚本解析守护进程.
PHP-Cgi : 是PHP自带的FastCGI管理器。

### 55.apache和nginx的区别？

nginx：

      轻量级，采用 C 进行编写，同样的 web 服务，会占用更少的内存及资源
      抗并发，nginx 以 epoll and kqueue 作为开发模型，处理请求是异步非阻塞的，负载能力比 apache 高很多，而 apache 则是阻塞型的。在高并发下 nginx 能保持低资源低消耗高性能 ，而 apache 在 PHP 处理慢或者前端压力很大的情况下，很容易出现进程数飙升，从而拒绝服务的现象。
     nginx 处理静态文件能力较好
     nginx 的设计高度模块化，编写模块相对简单
     nginx 配置简洁，正则配置让很多事情变得简单，而且改完配置能使用 -t 测试配置有没有问题，apache 配置复杂 ，重启的时候发现配置出错了，会很崩溃（这一点确实是深受其害啊...........）
    nginx 作为负载均衡服务器，支持 7 层负载均衡 
    nginx 本身就是一个反向代理服务器，而且可以作为非常优秀的邮件代理服务器

apache:

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>apache 的 rewrite 比 nginx 强大，在 rewrite 频繁的情况下，考虑用 apache
apache 模块超多，基本想到的都可以找到
apache 更为成熟，少 bug ，nginx 的 bug 相对较多
apache 稳定性特别好
apache 对 PHP 支持比较简单，nginx 需要配合其他后端用
apache 在处理动态请求有优势，nginx 在这方面是鸡肋，一般动态请求要 apache 去做，nginx 适合静态和反向。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
总结：
两者最核心的区别在于 apache 是同步多进程模型，一个连接对应一个进程，而 nginx 是异步的，多个连接（万级别）可以对应一个进程
一般来说，需要性能的 web 服务，用 nginx 。如果不需要性能只求稳定，更考虑 apache ，后者的各种功能模块实现得比前者，例如 ssl 的模块就比前者好，可配置项多。epoll(freebsd 上是 kqueue ) 网络 IO 模型是 nginx 处理性能高的根本理由，但并不是所有的情况下都是 epoll 大获全胜的，如果本身提供静态服务的就只有寥寥几个文件，apache 的 select 模型或许比 epoll 更高性能。当然，这只是根据网络 IO 模型的原理作的一个假设，真正的应用还是需要实测了再说的。
更为通用的方案是，前端 nginx 抗并发，后端 apache 集群，配合起来会更好。

### 





# 十四.rabbitmq面试题：

#### 1、什么是rabbitmq

采用AMQP高级消息队列协议的一种消息队列技术,最大的特点就是消费并不需要确保提供方存在,实现了服务之间的高度解耦

#### 2、为什么要使用rabbitmq

1)在分布式系统下具备异步,削峰,负载均衡等一系列高级功能;

2)拥有持久化的机制，进程消息，队列中的信息也可以保存下来。

3)实现消费者和生产者之间的解耦。

4)对于并发场景下，利用消息队列可以使得同步访问变为串行访问达到一定量的限流，利于数据库的操作。

可以使用消息队列达到异步下单的效果，排队中，后台进行逻辑下单

#### 3、使用rabbitmq的场景

1)服务间异步通信

2)顺序消费

3)定时任务

4)请求削峰

#### 4、如何确保消息正确地发送至RabbitMQ？ 如何确保消息接收方消费了消息？

发送方确认模式

将信道设置成confirm模式(发送方确认模式)，则所有在信道上发布的消息都会被指派一个唯一的ID。

一旦消息被投递到目的队列后，或者消息被写入磁盘后(可持久化的消息)，信道会发送一个确认给生产者(包含消息唯一ID)。

如果RabbitMQ发生内部错误从而导致消息丢失，会发送一条nack(not acknowledged，未确认)消息。

发送方确认模式是异步的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。

接收方确认机制

接收方消息确认机制

消费者接收每一条消息后都必须进行确认(消息接收和消息确认是两个不同操作)。只有消费者确认了消息，RabbitMQ才能安全地把消息从队列中删除。

这里并没有用到超时机制，RabbitMQ仅通过Consumer的连接中断来确认是否需要重新发送消息。也就是说，只要连接不中断，RabbitMQ给了Consumer足够长的时间来处理消息。保证数据的最终一致性；

下面罗列几种特殊情况

如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ会认为消息没有被分发，然后重新分发给下一个订阅的消费者。(可能存在消息重复消费的隐患，需要去重)

如果消费者接收到消息却没有确认消息，连接也未断开，则RabbitMQ认为该消费者繁忙，将不会给该消费者分发更多的消息。

#### 5、如何避免消息重复投递或重复消费？

在消息生产时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重的依据(消息投递失败并重传)，避免重复的消息进入队列；

在消息消费时，要求消息体中必须要有一个bizId(对于同一业务全局唯一，如支付ID、订单ID、帖子ID等)作为去重的依据，避免同一条消息被重复消费。

#### 6、消息基于什么传输？

由于TCP连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ使用信道的方式来传输数据。信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。

#### 7、消息如何分发？

若该队列至少有一个消费者订阅，消息将以循环(round-robin)的方式发送给消费者。每条消息只会分发给一个订阅的消费者(前提是消费者能够正常处理消息并进行确认)。 通过路由可实现多消费的功能

#### 8、消息怎么路由？

消息提供方->路由->一至多个队列 消息发布到交换器时，消息将拥有一个路由键(routing key)，在消息创建时设定。 通过队列路由键，可以把队列绑定到交换器上。

消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配(针对不同的交换器有不同的路由规则)；

常用的交换器主要分为一下三种

fanout：如果交换器收到消息，将会广播到所有绑定的队列上

direct：如果路由键完全匹配，消息就被投递到相应的队列

topic：可以使来自不同源头的消息能够到达同一个队列。 使用topic交换器时，可以使用通配符

#### 9、如何确保消息不丢失？

消息持久化，当然前提是队列必须持久化 RabbitMQ确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换器上时，Rabbit会在消息提交到日志文件后才发送响应。

一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费之前RabbitMQ重启，那么Rabbit会自动重建交换器和队列(以及绑定)，并重新发布持久化日志文件中的消息到合适的队列。

#### 10、使用RabbitMQ有什么好处？

1)服务间高度解耦

2)异步通信性能高

3)流量削峰

#### 11、rabbitmq的集群

镜像集群模式

你创建的queue，无论元数据还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。

好处在于，你任何一个机器宕机了，没事儿，别的机器都可以用。坏处在于，第一，这个性能开销也太大了吧，消息同步所有机器，导致网络带宽压力和消耗很重！第二，这么玩儿，就没有扩展性可言了，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue



镜像队列
功能和原理
RabbitMQ的Cluster集群模式一般分为两种，普通模式和镜像模式。

普通模式：默认的集群模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么得等rabbit01节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。

镜像模式：将需要消费的队列变为镜像队列，存在于多个节点，这样就可以实现RabbitMQ的HA高可用性。作用就是消息实体会主动在镜像节点之间实现同步，而不是像普通模式那样，在consumer消费数据时临时读取。缺点就是，集群内部的同步通讯会占用大量的网络带宽。
————————————————

#### 12、mq的缺点

系统可用性降低

系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。

系统复杂性提高

硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已

#### 13、一致性问题

A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。

所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的

##### 分布式场景下如何保证消息队列实现最终一致性

考虑一个分布式场景中一个常见的场景：服务A执行某个数据库操作成功后，会发送一条消息到消息队列，现在希望只有数据库操作执行成功才发送这条消息。下面是一些常见的作法：

**1. 先执行数据库操作，再发送消息**

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>public void purchaseOrder() {
orderDao.save(order);
messageQueue.send(message);
}</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
 

有可能order新增成功，发送消息失败。最终形成不一致状态。

**2. 先发送消息，再执行数据库操作**

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>public void purchaseOrder() {
messageQueue.send(message);
orderDao.save(order);
}</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
 

有可能消息发送成功，而order新增失败，从而形成不一致状态。

**3. 在数据库事务中，先发送消息，再执行数据库操作**

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@Transactional
public void purchaseOrder() {
messageQueue.send(message);
orderDao.save(order);
}</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
 

这里同样无法保证一致性。如果数据库操作成功，然而消息已经发送了，无法进行回滚。

**4. 在数据库事务中，先执行数据库操作，再发送消息**

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@Transactional
public void purchaseOrder() {
orderDao.save(order);
messageQueue.send(message);
}</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
 

这种方案成功与否，取决于消息队列是否拥有应答机制和事务机制。

**应答机制表示producer发送消息后，消息队列能够返回response从而证明消息是否插入成功。**

如果消息队列拥有应答机制，将上面的代码改写为：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@Transactional
public void purchaseOrder() {
orderDao.save(order);
try{
kafkaProducer.send(message).get();
} catch(Exception e)
throw new RuntimeException(&quot;Fail to send message&quot;);
}</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

 

这段代码表示如果发送发收到消息队列错误的response，就抛出一个RuntimeException。那么消息发送失败，能够造成数据库操作的回滚。这个方案看似可行，然而存在这样一种情况，如果消息发送成功，而消息队列由于网络原因没有即时返回response，此时消息发送方由于没有及时收到应答从而认为消息发送失败了，因此消息发送方的数据库事务回滚了，然而消息的确已经插入成功，从而造成了最终不一致性。

上面的不一致性可以通过消息的事务机制解决。

**事务机制表示消息队列中的消息是否拥有状态，从而决定消费者是否消费该条消息。**

> Alibaba旗下的开源消息队列RocketMQ以高可用性闻名，它是最早支持事务消息的消息队列。Kafka从版本0.11开始也支持了事务机制。

RoketMQ的事务机制是将消息标记为Prepared状态或者Confirmed状态。处于Prepared状态的消息对consumer不可见。

而Kafka通过Transaction Marker将消息标记为Uncommited或Commited状态。Consumer通过配置`isolation-level`为`read_committed`或`read_uncommitted`来决定对哪种类型的消息可见。

**5. 消息队列不支持事务消息**

如果消息队列不支持事务消息，那么我们的解决方案是，新增一张message表，并开启一个定时任务扫描这张message表，将所有状态为prepared的message发送给消息队列，发送成功后，将message状态置为confirmed。

代码如下：

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>@Transactional
public void purchaseOrder() {
orderDao.save(order);
messageService.save(message);
}</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
 

此时插入order和插入message的逻辑处于同一个数据库事务，通过后台的定时程序不断扫描message表，因此一定能够保证消息被成功投递到消息消费方。

这个方案存在的一个问题是，有可能后台任务发送消息成功后宕机了，从而没有来得及将已发送的message状态置为confirmed。因此下一次扫描message表时，会重复发送该条消息。这就是[at least once delivery](https://links.jianshu.com/go?to=http%3A%2F%2Fblog.jonathanoliver.com%2Fmessaging-at-least-once-delivery%2F)。

由于at least once delivery的特性，consumer有可能收到重复的数据。此时可以在consumer端建立一张message_consume表，来判断消息是否已经消费过，如果已经消费过，那么就直接丢弃该消息。

#### 13.rabbitmq 怎么保证幂等性，数据一致性问题

mq的作用主要是用来解耦，削峰，异步，

增加MQ,系统的复杂性也会增加很多，

也会带来其他的问题，比如MQ挂了怎么办，怎么保持数据的幂等性

幂等性问题通俗点讲就是保证数据不被重复消费，同时数据也不能少，

也就是数据一致性问题。

下面是MQ丢失的3种情况
![在这里插入图片描述](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTA3MTk1,size_16,color_FFFFFF,t_70)

1，生产者发送消息至MQ的数据丢失

解决方法:在生产者端开启comfirm 确认模式，你每次写的消息都会分配一个唯一的 id，

然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了

2，MQ收到消息，暂存内存中，还没消费，自己挂掉，数据会都丢失

解决方式：MQ设置为持久化。将内存数据持久化到磁盘中

3，消费者刚拿到消息，还没处理，挂掉了，MQ又以为消费者处理完

解决方式：用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。

![在这里插入图片描述](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyOTA3MTk1,size_16,colsssor_FFFFFF,t_70)

数据重复的问题简单的多，就是在消费端判断数据是否已经被消费过

比如你拿个数据要写库，你先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。
比如你是写 Redis，那没问题了，反正每次都是 set，天然幂等性。
比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。
比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。

#### 14、分布式事务

分段提交。会有一个仲裁者，然后给所有节点来发消息。当所有节点都ack之后，才会成功。否则就得等待重发。

#### 15、针对直播这种突然大流量的情况，该怎么设计。

1)NGINX加机器

2)cdn缓存静态页面

3)redis队列，让用户慢点进来。

4)加缓存。缓存用户数据，比如用户信息。

5)数据库使用主从

6)弹性扩容

7)限流熔断



## 1.RabbitMQ是什么？

RabbitMQ是实现了高级消息队列协议（`AMQP`）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用Erlang语言编写的，而群集和故障转移是构建在开放电信平台框架上的。所有主要的编程语言均有与代理接口通讯的客户端库。

PS:也可能直接问什么是消息队列？消息队列就是一个使用队列来通信的组件

## 2.RabbitMQ特点?

**可靠性**: RabbitMQ使用一些机制来保证可靠性， 如持久化、传输确认及发布确认等。

**灵活的路由** : 在消息进入队列之前，通过交换器来路由消息。对于典型的路由功能， RabbitMQ 己经提供了一些内置的交换器来实现。针对更复杂的路由功能，可以将多个 交换器绑定在一起， 也可以通过插件机制来实现自己的交换器。

**扩展性**: 多个RabbitMQ节点可以组成一个集群，也可以根据实际业务情况动态地扩展 集群中节点。

**高可用性** : 队列可以在集群中的机器上设置镜像，使得在部分节点出现问题的情况下队 列仍然可用。

**多种协议**: RabbitMQ除了原生支持AMQP协议，还支持STOMP， MQTT等多种消息 中间件协议。

**多语言客户端** :RabbitMQ 几乎支持所有常用语言，比如 Java、 Python、 Ruby、 PHP、 C#、 JavaScript 等。

**管理界面** : RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息、集 群中的节点等。

**令插件机制** : RabbitMQ 提供了许多插件 ， 以实现从多方面进行扩展，当然也可以编写自 己的插件。

## 3.AMQP是什么?

RabbitMQ就是 AMQP 协议的 `Erlang` 的实现(当然 RabbitMQ 还支持 `STOMP2`、 `MQTT3` 等协议 ) AMQP 的模型架构 和 RabbitMQ 的模型架构是一样的，生产者将消息发送给交换器，交换器和队列绑定 。

RabbitMQ 中的交换器、交换器类型、队列、绑定、路由键等都是遵循的 AMQP 协议中相 应的概念。目前 RabbitMQ 最新版本默认支持的是 AMQP 0-9-1。

## 4.AMQP协议3层？

**Module Layer**:协议最高层，主要定义了一些客户端调用的命令，客户端可以用这些命令实现自己的业务逻辑。

**Session Layer**:中间层，主要负责客户端命令发送给服务器，再将服务端应答返回客户端，提供可靠性同步机制和错误处理。

**TransportLayer**:最底层，主要传输二进制数据流，提供帧的处理、信道服用、错误检测和数据表示等。

## 5.AMQP模型的几大组件？

- 交换器 (Exchange)：消息代理服务器中用于把消息路由到队列的组件。
- 队列 (Queue)：用来存储消息的数据结构，位于硬盘或内存中。
- 绑定 (Binding)：一套规则，告知交换器消息应该将消息投递给哪个队列。

## 6.说说生产者Producer和消费者Consumer?

生产者

- 消息生产者，就是投递消息的一方。
- 消息一般包含两个部分：消息体（`payload`)和标签(`Label`)。

消费者

- 消费消息，也就是接收消息的一方。
- 消费者连接到RabbitMQ服务器，并订阅到队列上。消费消息时只消费消息体，丢弃标签。

## 7.为什么需要消息队列？

从本质上来说是因为互联网的快速发展，业务不断扩张，促使技术架构需要不断的演进。

从以前的单体架构到现在的微服务架构，成百上千的服务之间相互调用和依赖。从互联网初期一个服务器上有 100 个在线用户已经很了不得，到现在坐拥10亿日活的微信。此时，我们需要有一个「工具」来解耦服务之间的关系、控制资源合理合时的使用以及缓冲流量洪峰等等。因此，消息队列就应运而生了。

它常用来实现：`异步处理`、`服务解耦`、`流量控制（削峰）`。

## 8.说说Broker服务节点、Queue队列、Exchange交换器？

- Broker可以看做RabbitMQ的服务节点。一般请下一个Broker可以看做一个RabbitMQ服务器。
- Queue:RabbitMQ的内部对象，用于存储消息。多个消费者可以订阅同一队列，这时队列中的消息会被平摊（轮询）给多个消费者进行处理。
- Exchange:生产者将消息发送到交换器，由交换器将消息路由到一个或者多个队列中。当路由不到时，或返回给生产者或直接丢弃。

## 9.消息队列有什么优缺点

优点上面已经说了，就是在特殊场景下有其对应的好处，解耦、异步、削峰。缺点有以下几个：

- 系统可用性降低 系统引入的外部依赖越多，越容易挂掉。万一 MQ 挂了，MQ 一挂，整套系统崩 溃，你不就完了？
- 系统复杂度提高 硬生生加个 MQ 进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？
- 怎么保证消息传递的顺序性？问题一大堆。
- 一致性问题 A 系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是 BCD 三个系统那里，BD 两个系统写库成功了，结果 C 系统写库失败了，咋整？你这数据就不一致 了。

## 10.如何保证消息的可靠性？

消息到MQ的过程中搞丢，MQ自己搞丢，MQ到消费过程中搞丢。

`生产者到RabbitMQ`：事务机制和Confirm机制，注意：事务机制和 Confirm 机制是互斥的，两者不能共存，会导致 RabbitMQ 报错。

`RabbitMQ自身`：持久化、集群、普通模式、镜像模式。

`RabbitMQ到消费者`：basicAck机制、死信队列、消息补偿机制。

## 11.什么是RoutingKey路由键？

生产者将消息发送给交换器的时候，会指定一个`RoutingKey`,用来指定这个消息的路由规则，这个`RoutingKey`需要与交换器类型和绑定键(`BindingKey`)联合使用才能最终生效。

## 12.Binding绑定？

通过绑定将交换器和队列关联起来，一般会指定一个`BindingKey`,这样RabbitMq就知道如何正确路由消息到队列了。

## 13.交换器4种类型？

主要有以下4种。

- fanout:把所有发送到该交换器的消息路由到所有与该交换器绑定的队列中。

- direct:把消息路由到BindingKey和RoutingKey完全匹配的队列中。

- topic:

- 匹配规则：

- RoutingKey` 为一个 点号'.': 分隔的字符串。比如: `java.xiaoka.show

- `BindingKey`和`RoutingKey`一样也是点号“.“分隔的字符串。

  `BindingKey`可使用 * 和 # 用于做模糊匹配，*匹配一个单词，#匹配多个或者0个

`headers`:不依赖路由键匹配规则路由消息。是根据发送消息内容中的`headers`属性进行匹配。性能差，基本用不到。

## 14.生产者消息运转？

1.`Producer`先连接到Broker,建立连接Connection,开启一个信道(Channel)。

2.`Producer`声明一个交换器并设置好相关属性。

3.`Producer`声明一个队列并设置好相关属性。

4.`Producer`通过路由键将交换器和队列绑定起来。

5.`Producer`发送消息到`Broker`,其中包含路由键、交换器等信息。

6.相应的交换器根据接收到的路由键查找匹配的队列。

7.如果找到，将消息存入对应的队列，如果没有找到，会根据生产者的配置丢弃或者退回给生产者。

8.关闭信道。

9.管理连接。

## 15.消费者接收消息过程？

1.`Producer`先连接到`Broker`,建立连接`Connection`,开启一个信道(`Channel`)。

2.向`Broker`请求消费响应的队列中消息，可能会设置响应的回调函数。

3.等待`Broker`回应并投递相应队列中的消息，接收消息。

4.消费者确认收到的消息,`ack`。

5.`RabbitMq`从队列中删除已经确定的消息。

6.关闭信道。

7.关闭连接。

### 16.交换器无法根据自身类型和路由键找到符合条件队列时，有哪些处理？

- mandatory ：true 返回消息给生产者。
- mandatory: false 直接丢弃。

## 17.死信队列？

DLX，全称为 `Dead-Letter-Exchange`，死信交换器，死信邮箱。当消息在一个队列中变成死信 (`dead message`) 之后，它能被重新被发送到另一个交换器中，这个交换器就是 DLX，绑定 DLX 的队列就称之为死信队列。

## 18.导致的死信的几种原因？

- 消息被拒（`Basic.Reject /Basic.Nack`) 且 `requeue = false`。
- 消息TTL过期。
- 队列满了，无法再添加。

## 19.延迟队列？

存储对应的延迟消息，指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。

## 20.优先级队列？

- 优先级高的队列会先被消费。
- 可以通过`x-max-priority`参数来实现。
- 当消费速度大于生产速度且Broker没有堆积的情况下，优先级显得没有意义。

## 21.事务机制？

RabbitMQ 客户端中与事务机制相关的方法有三个:

`channel.txSelect` 用于将当前的信道设置成事务模式。

`channel . txCommit` 用于提交事务 。

`channel . txRollback` 用于事务回滚,如果在事务提交执行之前由于 RabbitMQ 异常崩溃或者其他原因抛出异常,通过txRollback来回滚。

## 22.发送确认机制？

生产者把信道设置为`confirm`确认模式,设置后，所有再改信道发布的消息都会被指定一个唯一的ID，一旦消息被投递到所有匹配的队列之后，RabbitMQ就会发送一个确认（`Basic.Ack`)给生产者（包含消息的唯一ID)，这样生产者就知道消息到达对应的目的地了。

## 23.消费者获取消息的方式？

- 推
- 拉

## 24.消费者某些原因无法处理当前接受的消息如何来拒绝？

channel .basicNack channel .basicReject

## 25.消息传输保证层级？

`At most once`:最多一次。消息可能会丢失，但不会重复传输。

`At least once`：最少一次。消息绝不会丢失，但可能会重复传输。

`Exactly once`:  恰好一次，每条消息肯定仅传输一次。

## 26.了解Virtual Host吗?

每一个RabbitMQ服务器都能创建虚拟的消息服务器，也叫虚拟主机(virtual host)，简称vhost。

默认为“/”。

## 27.集群中的节点类型？

内存节点：ram,将变更写入内存。

磁盘节点：disc,磁盘写入操作。

RabbitMQ要求最少有一个磁盘节点。

## 28.队列结构？

通常由以下两部分组成？

`rabbit_amqqueue_process`:负责协议相关的消息处理，即接收生产者发布的消息、向消费者交付消息、处理消息的确认(包括生产端的 confirm 和消费端的 ack) 等。

`backing_queue`:是消息存储的具体形式和引擎，并向 rabbit a`mqqueue process`提供相关的接口以供调用。

## 29.RabbitMQ中消息可能有的几种状态?

`alpha`: 消息内容(包括消息体、属性和 headers) 和消息索引都存储在内存中 。

`beta`: 消息内容保存在磁盘中，消息索引保存在内存中。

`gamma`: 消息内容保存在磁盘中，消息索引在磁盘和内存中都有 。

`delta`: 消息内容和索引都在磁盘中 。

## 30.在何种场景下使用了消息中间件？

- 接口之间耦合比较严重
- 面对大流量并发时，容易被冲垮
- 存在性能问题

## 31.生产者如何将消息可靠投递到MQ？

1.Client发送消息给MQ

2.MQ将消息持久化后，发送Ack消息给Client，此处有可能因为网络问题导致Ack消息无法发送到Client，那么Client在等待超时后，会重传消息；

3.Client收到Ack消息后，认为消息已经投递成功。

## 32 . MQ如何将消息可靠投递到消费者？

1.MQ将消息push给Client（或Client来pull消息）

2.Client得到消息并做完业务逻辑

3.Client发送Ack消息给MQ，通知MQ删除该消息，此处有可能因为网络问题导致Ack失败，那么Client会重复消息，这里就引出消费幂等的问题；

4.MQ将已消费的消息删除

## 33.如何保证RabbitMQ消息队列的高可用?

RabbitMQ 有三种模式：`单机模式`，`普通集群模式`，`镜像集群模式`。

**单机模式**：就是demo级别的，一般就是你本地启动了玩玩儿的，没人生产用单机模式

**普通集群模式**：意思就是在多台机器上启动多个RabbitMQ实例，每个机器启动一个。

**镜像集群模式**：这种模式，才是所谓的RabbitMQ的高可用模式，跟普通集群模式不一样的是，你创建的queue，无论元数据(元数据指RabbitMQ的配置数据)还是queue里的消息都会存在于多个实例上，然后每次你写消息到queue的时候，都会自动把消息到多个实例的queue里进行消息同步。



### 11.RabbitMQ怎么使用的？应用场景有哪些？怎么确保消息不重复消费？死信队列了解吗？怎么处理队列的死信？

#### 1. 死信队列&amp;死信交换器：

DLX 全称（Dead-Letter-Exchange）,称之为死信交换器，当消息变成一个死信之后，如果这个消息所在的队列存在**x-dead-letter-exchange**参数，那么它会被发送到x-dead-letter-exchange对应值的交换器上，这个交换器就称之为死信交换器，与这个死信交换器绑定的队列就是死信队列。

说实在的，死信队列和普通队列没啥区别，都需要自己创建Queue、Exchange，然后通过RoutingKey绑定到Exchange上。只不过死信队列的RoutingKey和Exchange要作为参数，绑定到正常的队列上。

#### 2. 死信消息：

- （1）消息被拒绝（Basic.Reject或Basic.Nack）并且设置 requeue 参数的值为 false
- （2）消息过期了
- （3）队列达到最大的长度

#### 3. 过期消息：

在 rabbitmq 中存在2种方法可设置消息的过期时间:

- 第一种通过**对队列进行设置**，这种设置后，该队列中所有的消息都存在相同的过期时间;
- 第二种通过**对消息本身进行设置**，那么每条消息的过期时间都不一样。

如果**同时使用这2种方法，那么以过期时间小的那个数值为准。**当消息达到过期时间还没有被消费，那么那个消息就成为了一个 **死信** 消息。

- （1）

  队列设置

  ：在队列申明的时候使用** x-message-ttl **参数，单位为 毫秒；

  - 队列中这个属性的设置要在第一次声明队列的时候设置才有效，如果队列一开始已存在且没有这个属性，则要删掉队列再重新声明才可以。
  - 队列的 ttl 只能被设置为某个固定的值，一旦设置后则不能更改，否则会抛出异常。

- （2）**单个消息设置**：是设置消息属性的 expiration 参数的值，单位为 毫秒。

**说明：**

对于第一种设置队列属性的方法，一旦消息过期，就会从队列中抹去；而在第二种方法中，即使消息过期，也不会马上从队列中抹去，因为每条消息是否过期是在即将投递到消费者之前判定的。

**为什么这两种方法处理的方式不一样?**

因为第一种方法里，队列中己过期的消息肯定在队列头部，RabbitMQ只要定期从队头开始扫描是否有过期的消息即可。而第二种方法里，每条消息的过期时间不同，如果要删除所有过期消息势必要扫描整个队列，所以不如等到此消息即将被消费时再判定是否过期,如果过期再进行删除即可。这样只判断队列头是否过期的方法的优势是，不用时刻扫描整个队列的所有消息去判断哪个过期，这样会非常耗资源。

另外，还需要注意的一点是，如果不设置TTL，表示消息永远不会过期，如果将TTL设置为0，则表示除非此时可以直接投递该消息到消费者，否则该消息将会被丢弃。

#### 4. 延时队列

延时队列，顾名思义，不是及时的队列，也就是发送者发出的消息要延迟一段时间，消费者才能接受到。有一个很典型的应用场景就是订单30分钟内未支付就关闭订单，还有一种场景，账单24小时未确认，就发送提醒消息。

在rabbitmq中是不存在延时队列，如果需要使用的话，就需要安装延时队列插件。另外，我们也可以通过过期队列消息和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列，就可以模拟出延时队列了。

使用延时队列插件，可以参考文章（[https://www.cnblogs.com/geekdc/p/13550620.html](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2Fgeekdc%2Fp%2F13550620.html)），使用过期队列消息和死信队列模拟延时队列，实现流程如下图，具体代码实现可自行搜索，这个资料也比较多。

![img](https:////upload-images.jianshu.io/upload_images/150505-8008c94c4d14ca7e.png?imageMogr2/auto-orient/strip|imageView2/2/w/932/format/webp)

使用过期消息和死信队列模拟延时队列

**通过过期消息和死信队列来模拟出延时队列：**

前面讲了过期消息有两种实现方法，第一种是通过对队列进行设置，第二种是通过对消息本身进行设置。

第一种方法通过队列设置，需要在队列声明的时候设置才有效。而如果使用这种方法，那么每增加一个新的时间需求，就要增加一个队列，显然这种方法不够灵活。

既然第一种方法不够灵活，那么咱通过第二种方法就可以实现灵活性。然而事情并没有那么简单，因为前面已经讲了，如果使用在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查队列头部的消息是否过期，如果过期则丢到死信队列，所以如果队列中第一个消息的延时时长很长，而第二个消息的延时时长很短，则第二个消息并不会优先得到执行。

所以总结一下，可以看得出来，通过过期消息和死信队列虽然可以模拟延时队列，并无法达到一个灵活通用的延迟队列。



作者：GuangHui
链接：https://www.jianshu.com/p/256d2eaf1786
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 12.kafka、activemq、rabbitmq、rocketmq都有什么优点和缺点啊？

常见的MQ其实就这几种，别的还有很多其他MQ，但是比较冷门的，那么就别多说了

作为一个码农，你起码得知道各种mq的优点和缺点吧，咱们来画个表格看看

| 特性                    | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                     | Kafka                                                        |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量              | 万级，吞吐量比RocketMQ和Kafka要低了一个数量级                | 万级，吞吐量比RocketMQ和Kafka要低了一个数量级                | 10万级，RocketMQ也是可以支撑高吞吐的一种MQ                   | 10万级别，这是kafka最大的优点，就是吞吐量高。 一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |
| topic数量对吞吐量的影响 |                                                              |                                                              | topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降 这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic | topic从几十个到几百个的时候，吞吐量会大幅度下降 所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源 |
| 时效性                  | ms级                                                         | 微秒级，这是rabbitmq的一大特点，延迟是最低的                 | ms级                                                         | 延迟在ms级以内                                               |
| 可用性                  | 高，基于主从架构实现高可用性                                 | 高，基于主从架构实现高可用性                                 | 非常高，分布式架构                                           | 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |
| 消息可靠性              | 有较低的概率丢失数据                                         |                                                              | 经过参数优化配置，可以做到0丢失                              | 经过参数优化配置，消息可以做到0丢失                          |
| 功能支持                | MQ领域的功能极其完备                                         | 基于erlang开发，所以并发能力很强，性能极其好，延时很低       | MQ功能较为完善，还是分布式的，扩展性好                       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准 |
| 优劣势总结              | 非常成熟，功能强大，在业内大量的公司以及项目中都有应用 偶尔会有较低概率丢失消息 而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本 而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用 | erlang语言开发，性能极其好，延时很低； 吞吐量到万级，MQ功能比较完备 而且开源提供的管理界面非常棒，用起来很好用 社区相对比较活跃，几乎每个月都发布几个版本分 在国内一些互联网公司近几年用rabbitmq也比较多一些 但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。 而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。 而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。 | 接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障 日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景 而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码 还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的 | kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展 同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量 而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略 这个特性天然适合大数据实时计算以及日志收集 |


综上所述，各种对比之后，我个人倾向于是：

一般的业务系统要引入MQ，最早大家都用ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；

后来大家开始用RabbitMQ，但是确实erlang语言阻止了大量的java工程师去深入研究和掌控他，对公司而言，几乎处于不可控的状态，但是确实人是开源的，比较稳定的支持，活跃度也高；

不过现在确实越来越多的公司，会去用RocketMQ，确实很不错，但是我提醒一下自己想好社区万一突然黄掉的风险，对自己公司技术实力有绝对自信的，我推荐用RocketMQ，否则回去老老实实用RabbitMQ吧，人是活跃开源社区，绝对不会黄

所以中小型公司，技术实力较为一般，技术挑战不是特别高，用RabbitMQ是不错的选择；大型公司，基础架构研发实力较强，用RocketMQ是很好的选择

如果是大数据领域的实时计算、日志采集等场景，用Kafka是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范



### 13.如何保证消息队列的高可用？

#### 1.RabbitMQ的高可用

RabbitMQ基于主从模式实现高可用。RabbitMQ有三种模式：单机模式，普通集群模式，镜像集群模式。
 （1）单机模式：
 单机模式就是demo级别的，生产中不会有人使用。
 （2）普通集群模式
 普通集群模式就是在多台机器上启动多个rabbitmq实例，每个机器启动一个。但是创建的queue只会放在一个rabbitmq实例上面，但是其他的实例都同步了这个queue的元数据。在你消费的时候，如果连接到了另一个实例，他会从拥有queue的那个实例获取消息然后再返回给你。

![img](.\img\最高级多方面面试题\webpfdsf)

这种方式并没有做到所谓消息的高可用，就是个普通的集群，这样还会导致要么消费者每次随机连接一个实例然后拉取数据，这样的话在实例之间会产生网络传输，增加系统开销，要么固定连接那个queue所在的实例消费，这样会导致单实例的性能瓶颈。

而且如果那个方queue的实例宕机了，会导致接下来其他实例都无法拉取数据；如果没有开启消息的持久化会丢失消息；就算开启了消息的持久化，消息不一定会丢，但是也要等这个实例恢复了，才可以继续拉取数据。
 所以这个并没有提供高可用，这种方案只是提高了吞吐量，也就是让集群中多个节点来服务某个queue的读写操作。

（3）镜像集群模式
 这种模式，才是rabbitmq提供是真正的高可用模式，跟普通集群不一样的是，你创建的queue，无论元数据还是queue里面是消息数据都存在多个实例当中，然后每次写消息到queue的时候，都会自动把消息到多个queue里进行消息同步。

![img](.\img\最高级多方面面试题\webpdssss)

这种模式的好处在于，任何一台机器宕机了，其他的机器还可以使用。
 **坏处在于：**1、性能消耗太大，所有机器都要进行消息的同步，导致网络压力和消耗很大。2、没有扩展性可言，如果有一个queue负载很重，就算加了机器，新增的机器还是包含了这个queue的所有数据，并没有办法扩展queue。
 **如何开启镜像集群模式：**在控制台新增一个镜像集群模式的策略，指定的时候可以要求数据同步到所有节点，也可以要求同步到指定节点，然后在创建queue的时候，应用这个策略，就会自动将数据同步到其他的节点上面去了。

#### 2.kafka的高可用

（1）kafka的一个基本架构：多个broker组成，一个broker是一个节点；你创建一个topic，这个topic可以划分成多个partition，每个partition可以存在于不同的broker上面，每个partition存放一部分数据。这是天然的分布式消息队列。

实际上rabbitmq并不是分布式消息队列，他就是传统的消息队列，只不过提供了一些集群、HA的机制而已，因为无论如何配置，rabbitmq一个queue的数据就存放在一个节点里面，镜像集群下，也是每个节点都放这个queue的全部数据。

kafka在0.8以前是没有HA机制的，也就是说任何一个broker宕机了，那个broker上的partition就丢了，没法读也没法写，没有什么高可用可言。

kafka在0.8之后，提过了HA机制，也就是replica副本机制。每个partition的数据都会同步到其他机器上，形成自己的replica副本。然后所有的replica副本会选举一个leader出来，那么生产者消费者都和这个leader打交道，其他的replica就是follower。写的时候，leader会把数据同步到所有follower上面去，读的时候直接从leader上面读取即可。

**为什么只能读写leader：**因为要是你可以随意去读写每个follower，那么就要关心数据一致性问题，系统复杂度太高，容易出问题。kafka会均匀度讲一个partition的所有数据replica分布在不同的机器上，这样就可以提高容错性。
 这样就是高可用了，因为如果某个broker宕机 了，没事儿，那个broker的partition在其他机器上有副本，如果这上面有某个partition的leader，那么此时会重新选举出一个现代leader出来，继续读写这个新的leader即可。

![image-20211225164304980](.\img\最高级多方面面试题\image-20211225164304980.png)

**写消息：** 写数据的时候，生产者就写leader，然后leader将数据落到磁盘上之后，接着其他follower自己主动从leader来pull数据。一旦所有follower同步好了数据，就会发送ack个leader，leader收到了所有的follower的ack之后，就会返回写成功的消息给消息生产者。（这只是一种模式，可以调整）。
 **读数据:**消费数据的时候，只会从leader进行消费。但是只有一个消息已经被所有follower都同步成功返回ack的时候，这个消息才会被消费者读到。



### 14.如何保证消息不被重复消费？

#### 1.幂等性

> 幂等（idempotent、idempotence）是一个数学与计算机学概念，常见于抽象代数中。
> 在编程中一个幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。这些[函数](https://links.jianshu.com/go?to=https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%E5%87%BD%E6%95%B0%2F301912)不会影响系统状态，也不用担心重复执行会对系统造成改变。例如，“setTrue()”函数就是一个幂等函数,无论多次执行，其结果都是一样的.更复杂的操作幂等保证是利用唯一交易号(流水号)实现.

简单来说，幂等性就是一个数据或者一个请求，给你重复来了多次，你得确保对应的数据是不会改变的，不能出错。

#### 2.出现重复消费场景

（1）首先，比如rabbitmq、rocketmq、kafka，都有可能会出现消息重复消费的问题。因为这个问题通常不是由mq来保证的，而是消费方自己来保证的。
 （2）举例kafka来说明重复消费问题
 kafka有一个叫做offset的概念，就是每个消息写进去，都有一个offset代表他的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表我已经消费过了，下次就算重启，kafka就会让消费者从上次消费到的offset来继续消费。

但是万事总有例外，如果consumer消费了数据，还没来得及发送自己已经消费的消息的offset就挂了，那么重启之后就会收到重复的数据。

![img](.\img\最高级多方面面试题\webpffff)

#### 3.保证幂等性(重复消费)

要保证消息的幂等性，这个要结合业务的类型来进行处理。下面提供几个思路供参考：
 （1）、可在内存中维护一个set，只要从消息队列里面获取到一个消息，先查询这个消息在不在set里面，如果在表示已消费过，直接丢弃；如果不在，则在消费后将其加入set当中。
 （2）、如何要写数据库，可以拿唯一键先去数据库查询一下，如果不存在在写，如果存在直接更新或者丢弃消息。
 （3）、如果是写redis那没有问题，每次都是set，天然的幂等性。
 （4）、让生产者发送消息时，每条消息加一个全局的唯一id，然后消费时，将该id保存到redis里面。消费时先去redis里面查一下有么有，没有再消费。
 （5）、数据库操作可以设置唯一键，防止重复数据的插入，这样插入只会报错而不会插入重复数据。



### 15.如何保证消费的时候是幂等？

### 16.如何保证消息的可靠性传输？

数据的丢失问题，可能出现在生产者、MQ、消费者中，我们从 RabbitMQ 和 Kafka 分别来分析一下吧。

#### RabbitMQ

![在这里插入图片描述](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbjE5OTU=,size_16,color_FFFFFF,t_70)

##### 生产者弄丢了数据

  生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题什么的，都有可能。
  此时可以选择用 RabbitMQ 提供的事务功能，就是生产者发送数据之前开启 RabbitMQ 事务channel.txSelect，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>// 开启事务
channel.txSelect
try {
// 这里发送消息
} catch (Exception e) {
channel.txRollback
// 这里再次重发这条消息
}
// 提交事务
channel.txCommit</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
但问题是，RabbitMQ 事务机制(同步)一搞，基本上吞吐量会降下来，因为太耗性能。
  所以一般来说，如果要确保写 RabbitMQ 的消息别丢，可以开启 confirm 模式，在生产者那里设置开启 confirm 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。
  事务机制和 confirm 机制最大的不同在于，事务机制是同步的，你提交一个事务之后会阻塞在那儿，但是 confirm 机制是异步的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。
  所以一般在生产者这块避免数据丢失，都是用 confirm 机制的。

##### RabbitMQ 弄丢了数据

  就是 RabbitMQ 自己弄丢了数据，这个你必须开启 RabbitMQ 的持久化，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，可能导致少量数据丢失，但是这个概率较小。
**设置持久化有两个步骤：**

第一个是创建 queue 的时候将其设置为持久化，这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化
queue 里的数据的。
第二个是发送消息的时候将消息的 deliveryMode 设置为 2，就是将消息设置为持久化的，此时 RabbitMQ
就会将消息持久化到磁盘上去。
必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。
注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。
所以，持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的。

##### 消费端弄丢了数据

  RabbitMQ 如果丢失了数据，主要是因为你消费的时候，刚消费到，还没处理，结果进程挂了，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。
  这个时候得用 RabbitMQ 提供的 ack 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 ack，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 ack 一把。这样的话，如果你还没处理完，不就没有 ack 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。

![在这里插入图片描述](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lqbjE5OTU=,size_16,color_FFFF3333FF,t_70)

#### Kafka

##### 消费端弄丢了数据

  唯一可能导致消费者弄丢数据的情况，就是你消费到了这个消息，然后消费者那边自动提交了 offset，让 Kafka 以为你已经消费好了这个消息，但其实你才刚准备处理这个消息，你还没处理，你自己就挂了，此时这条消息就丢咯。
  这不是跟 RabbitMQ 差不多吗，大家都知道 Kafka 会自动提交 offset，那么只要关闭自动提交 offset，在处理完之后自己手动提交 offset，就可以保证数据不会丢。但是此时确实还是可能会有重复消费，比如你刚处理完，还没提交 offset，结果自己挂了，此时肯定会重复消费一次，自己保证幂等性就好了。
  生产环境碰到的一个问题，就是说我们的 Kafka 消费者消费到了数据之后是写到一个内存的 queue 里先缓冲一下，结果有的时候，你刚把消息写入内存 queue，然后消费者会自动提交 offset。然后此时我们重启了系统，就会导致内存 queue 里还没来得及处理的数据就丢失了。
————————————————

##### Kafka 弄丢了数据

  这块比较常见的一个场景，就是 Kafka 某个 broker 宕机，然后重新选举 partition 的 leader。大家想想，要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后选举某个 follower 成 leader 之后，不就少了一些数据？这就丢了一些数据啊。
  生产环境也遇到过，我们也是，之前 Kafka 的 leader 机器宕机了，将 follower 切换为 leader 之后，就会发现说这个数据就丢了。
所以此时一般是要求起码设置如下 4 个参数：

给 topic 设置 replication.factor 参数：这个值必须大于 1，要求每个 partition 必须有至少 2
个副本。
在 Kafka 服务端设置 min.insync.replicas 参数：这个值必须大于 1，这个是要求一个 leader
至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower 吧。
在 producer 端设置 acks=all：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。
在 producer 端设置 retries=MAX（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里了。
这样配置之后，至少在 Kafka broker 端就可以保证在 leader 所在 broker 发生故障，进行 leader 切换时，数据不会丢失。

##### 生产者会不会弄丢数据？

如果按照上述的思路设置了 acks=all，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。


### 17.传输过程出现消息丢失了怎么办？

和上面一洋

### 18.如何保证消息的顺序性？

我举个例子，我们以前做过一个 mysql `binlog` 同步的系统，压力还是非常大的，日同步数据要达到上亿，就是说数据从一个 mysql 库原封不动地同步到另一个 mysql 库里面去（mysql -> mysql）。常见的一点在于说比如大数据 team，就需要同步一个 mysql 库过来，对公司的业务系统的数据做各种复杂的操作。

你在 mysql 里增删改一条数据，对应出来了增删改 3 条 `binlog` 日志，接着这三条 `binlog` 发送到 MQ 里面，再消费出来依次执行，起码得保证人家是按照顺序来的吧？不然本来是：增加、修改、删除；你楞是换了顺序给执行成删除、修改、增加，不全错了么。

本来这个数据同步过来，应该最后这个数据被删除了；结果你搞错了这个顺序，最后这个数据保留下来了，数据同步就出错了。

先看看顺序会错乱的俩场景：

- **RabbitMQ**：一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者2先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。

![img](.\img\最高级多方面面试题\webp443432423)

**Kafka**：比如说我们建了一个 topic，有三个 partition。生产者在写的时候，其实可以指定一个 key，比如说我们指定了某个订单 id 作为 key，那么这个订单相关的数据，一定会被分发到同一个 partition 中去，而且这个 partition 中的数据一定是有顺序的。
消费者从 partition 中取出来数据的时候，也一定是有顺序的。到这里，顺序还是 ok 的，没有错乱。接着，我们在消费者里可能会搞**多个线程来并发处理消息**。因为如果消费者是单线程消费处理，而处理比较耗时的话，比如处理一条消息耗时几十 ms，那么 1 秒钟只能处理几十条消息，这吞吐量太低了。而多个线程并发跑的话，顺序可能就乱掉了。

![img](.\img\最高级多方面面试题\webpffzvvcbdg)

#### 解决方案

#### RabbitMQ

拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。

![img](.\img\最高级多方面面试题\webpgfdhdfh)

#### Kafka

- 一个 topic，一个 partition，一个 consumer，内部单线程消费，单线程吞吐量太低，一般不会用这个。
- 写 N 个内存 queue，具有相同 key 的数据都到同一个内存 queue；然后对于 N 个线程，每个线程分别消费一个内存 queue 即可，这样就能保证顺序性。

![img](.\img\最高级多方面面试题\webpvcvcbb)





### 19.如何解决消息队列的延时问题？如何解决消息队列的过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，应该怎么解决？

你看这问法，其实本质针对的场景，都是说，可能你的消费端出了问题，不消费了；或者消费的速度极其慢。接着就坑爹了，可能你的消息队列集群的磁盘都快写满了，都没人消费，这个时候怎么办？或者是这整个就积压了几个小时，你这个时候怎么办？或者是你积压的时间太长了，导致比如 RabbitMQ 设置了消息过期时间后就没了怎么办？

所以就这事儿，其实线上挺常见的，一般不出，一出就是大 case。一般常见于，举个例子，消费端每次消费之后要写 mysql，结果 mysql 挂了，消费端 hang 那儿了，不动了；或者是消费端出了个什么岔子，导致消费速度极其慢。
 关于这个事儿，我们一个一个来梳理吧，先假设一个场景，我们现在消费端出故障了，然后大量消息在 mq 里积压，现在出事故了，慌了。

##### 大量消息在 mq 里积压了几个小时了还没解决

几千万条数据在 MQ 里积压了七八个小时，从下午 4 点多，积压到了晚上 11 点多。这个是我们真实遇到过的一个场景，确实是线上故障了，这个时候要不然就是修复 consumer 的问题，让它恢复消费速度，然后傻傻的等待几个小时消费完毕。这个肯定不能在面试的时候说吧。

一个消费者一秒是 1000 条，一秒 3 个消费者是 3000 条，一分钟就是 18 万条。所以如果你积压了几百万到上千万的数据，即使消费者恢复了，也需要大概 1 小时的时间才能恢复过来。

一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：

- 先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉。
- 新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量。
- 然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，**消费之后不做耗时的处理**，直接均匀轮询写入临时建立好的 10 倍数量的 queue。
- 接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据。
- 等快速消费完积压数据之后，**得恢复原先部署的架构**，**重新**用原先的 consumer 机器来消费消息。

##### mq 中的消息过期失效了

假设你用的是 RabbitMQ，RabbtiMQ 是可以设置过期时间的，也就是 TTL。如果消息在 queue 中积压超过一定的时间就会被 RabbitMQ 给清理掉，这个数据就没了。那这就是第二个坑了。这就不是说数据会大量积压在 mq 里，而是**大量的数据会直接搞丢**。

这个情况下，就不是说要增加 consumer 消费积压的消息，因为实际上没啥积压，而是丢了大量的消息。我们可以采取一个方案，就是**批量重导**，这个我们之前线上也有类似的场景干过。就是大量积压的时候，我们当时就直接丢弃数据了，然后等过了高峰期以后，比如大家一起喝咖啡熬夜到晚上12点以后，用户都睡觉了。这个时候我们就开始写程序，将丢失的那批数据，写个临时程序，一点一点的查出来，然后重新灌入 mq 里面去，把白天丢的数据给他补回来。也只能是这样了。

假设 1 万个订单积压在 mq 里面，没有处理，其中 1000 个订单都丢了，你只能手动写程序把那 1000 个订单给查出来，手动发到 mq 里去再补一次。

##### mq 都快写满了

如果消息积压在 mq 里，你很长时间都没有处理掉，此时导致 mq 都快写满了，咋办？这个还有别的办法吗？没有，谁让你第一个方案执行的太慢了，你临时写程序，接入数据来消费，**消费一个丢弃一个，都不要了**，快速消费掉所有的消息。然后走第二个方案，到了晚上再补数据吧。





### 9.为什么要使用消息队列？

在实际的项目实践中，消息队列有的使用还是比较常用的，有时在想消息队列的好处是什么，使用MQ能带来什么好处。在说之前，目前市场主流的几种MQ(activeMQ，RabbitMQ，RocketMQ,Kafka)，关于MQ的入门就不说了，可以找下教程，写个demo测试一下就好了，还是比较简单的。先上张图了解下每个MQ的区别

![img](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nyb3Nzcm9hZHMxMA==,size_16,color_FFFFFF,t_70)

使用消息队列主要起到解耦，异步，削峰的目的。

#### 1、解耦：

就是一个系统或者一个模块，调用了多个系统或者模块，互相之间的调用很复杂，维护起来很麻烦。其实这个调用是不需要直接同步调用接口的，皆可以用MQ给他异步化解耦。

#### 2、异步：

一个系统接收一个请求，需要在本地写库，还需要在另外几个相关的系统写库都需要一定的时长。最终请求总延时是就是三者的总时长，而当使用MQ异步请求，也就是两个时长，第一个是创建MQ，第二个是将消息放入MQ中，这样会大大提高效率。

#### 3、削峰

可能每个系统的早高峰不一样，有些系统是上班期间访问量很大，有些系统是下班时间访问量大，所以，我们需要用MQ来降低并发请求到数据库的数据，给数据库一定的时间去处理，不然一起拥进到数据库，系统就会崩了。

通过几张图片可以清楚的了解到MQ的好处在什么地方，使用前：

![img](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nyb3Nfdfzcm9hZHMxMA==,size_16,color_FFFFFF,t_70)

 这张图很容易去理解，每次都需要A系统接需求去完成功能，而且A系统和其他系统之间耦合性太强了，这种情况下系统之间很容易存在问题。

使用MQ进行解耦：

![img](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nyb3Nzcm9hZHMxMA==,size_16,codddlor_FFFFFF,t_70)

 我在实际的项目工作当中，也在使用消息队列，使用消息队列的好处以及优势很明显，上面这张图也已经描述的非常清楚了。

通过图分析，可以得出如何去解耦。

异步：

未使用队列之前的业务流程：

![img](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nyb3Nzcm9hZHMxMA==,size_16,color_FFFFFF,t_dd70)

使用后： 

![img](.\img\最高级多方面面试题\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Nyb3Nzcm9hZHMxMA==,size_16,color_FFFFfffFF,t_70)

如果A系统和其他几个系统进行直接调用，则每个系统进行业务进行，每个系统业务执行结束才可以归结为一次调用结束，但是这样的性能很低，响应时间很长，通过使用MQ的可以达到异步通知其他系统，A系统结束可以直接调用结束，响应时间变短，用户体验好。



### 10.消息队列有什么缺点？

优点上面已经说了，就是在特殊场景下有其对应的好处，*解耦、异步、削峰*

缺点呢？显而易见的

![img](.\img\最高级多方面面试题\201805141317498dsd)

**系统可用性降低**：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统的接口就好了，人ABCD四个系统好好的，没啥问题，你偏加个MQ进来，万一MQ挂了咋整？MQ挂了，整套系统崩溃了，你不就完了么。

**系统复杂性提高**：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？头大头大，问题一大堆，痛苦不已

**一致性问题**：A系统处理完了直接返回成功了，人都以为你这个请求就成功了；但是问题是，要是BCD三个系统那里，BD两个系统写库成功了，结果C系统写库失败了，咋整？你这数据就不一致了。

所以消息队列实际是一种非常复杂的架构，你引入它有很多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最好之后，你会发现，妈呀，系统复杂度提升了一个数量级，也许是复杂了10倍。但是关键时刻，用，还是得用的。。。







### 20.如果让你写一个消息队列，该如何进行架构设计？

其实聊到这个问题，一般面试官要考察两块：

- 你有没有对某一个消息队列做过较为深入的原理的了解，或者从整体了解把握住一个消息队列的架构原理。
- 看看你的设计能力，给你一个常见的系统，就是消息队列系统，看看你能不能从全局把握一下整体架构设计，给出一些关键点出来。

说实话，问类似问题的时候，大部分人基本都会蒙，因为平时从来没有思考过类似的问题，大多数人就是平时埋头用，从来不去思考背后的一些东西。类似的问题，比如，如果让你来设计一个 Spring 框架你会怎么做？如果让你来设计一个 Dubbo 框架你会怎么做？如果让你来设计一个 MyBatis 框架你会怎么做？

##### 回答

其实回答这类问题，说白了，不求你看过那技术的源码，起码你要大概知道那个技术的基本原理、核心组成部分、基本架构构成，然后参照一些开源的技术把一个系统设计出来的思路说一下就好。

比如说这个消息队列系统，我们从以下几个角度来考虑一下：

- 首先这个 mq 得支持可伸缩性吧，就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -> topic -> partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？
- 其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。
- 其次你考虑一下你的 mq 的可用性啊？这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -> leader &amp; follower -> broker 挂了重新选举 leader 即可对外服务。
- 能不能支持数据 0 丢失啊？可以的，参考我们之前说的那个 kafka 数据零丢失方案。

mq 肯定是很复杂的，面试官问你这个问题，其实是个开放题，他就是看看你有没有从架构角度整体构思和设计的思维以及能力。确实这个问题可以刷掉一大批人，因为大部分人平时不思考这些东西。



## Kafka

### 21.描述一下 Kafka 的设计架构？

### 22.Kafka 消费端是否可能出现重复消费问题？

### 23.Kafka 为什么会分区？

### 24.Kafka 如何保证数据一致性？

### 25.Kafka 中 ISR、OSR、AR 是什么？

### 26.Kafka 在什么情况下会出现消息丢失？

### 27.Kafka 消息是采用 Pull 模式，还是 Push 模式？

### 28.Kafka 如何和 ZooKeeper 进行交互？

### 29.Kafka 是如何实现高吞吐率的？

#### 生产者和消费者的命令行是什么？

#### Kafka 怎么保证数据可靠性？

#### 讲讲 kafka 维护消费状态跟踪的方法

#### 为什么需要消息系统，mysql 不能满足需求吗？

#### Kafka 判断一个节点是否还活着有那两个条件？

#### Kafka 与传统 MQ 消息系统之间有三个关键区别？

#### kafka 分布式（不是单机）的情况下，如何保证消息的顺序消费？

#### kafka 如何不消费重复数据？比如扣款，我们不能重复的扣

## RocketMQ

### 30.RocketMQ 和 ActiveMQ 有哪些区别？

|                | ActiveMQ                                                     | RabbitMQ                                                     | RocketMq                                                     | ZeroMQ                              |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------- |
| 关注度         | 高                                                           | 高                                                           | 中                                                           | 中                                  |
| 成熟度         | 成熟                                                         | 成熟                                                         | 比较成熟                                                     | 不成熟                              |
| 所属社区/公司  | Apache                                                       | Mozilla Public License                                       | Alibaba                                                      |                                     |
| 社区活跃度     | 高                                                           | 高                                                           | 中                                                           | 低                                  |
| 文档           | 多                                                           | 多                                                           | 中                                                           | 中                                  |
| 特点           | 功能齐全，被大量开源项目使用                                 | 由于Erlang 语言的并发能力，性能很好                          | 各个环节分布式扩展设计，主从 HA；支持上万个队列；多种消费模式；性能很好 | 低延时，高性能，最高 43万条消息每秒 |
| 授权方式       | 开源                                                         | 开源                                                         | 开源                                                         | 开源                                |
| 开发语言       | Java                                                         | Erlang                                                       | Java                                                         | C                                   |
| 支持的协议     | OpenWire、 STOMP、 REST、XMPP、 AMQP                         | AMQP                                                         | 自己定义的一 套(社区提供 JMS--不成熟)                        | TCP、UDP                            |
| 客户端支持语言 | Java、C、 C++、 Python、 PHP、 Perl、.net 等                 | Java、C、 C++、 Python、 PHP、Perl 等                        | Java  C++（不成熟）                                          | python、 java、 php、.net 等        |
| 持久化         | 内存、文件、数据库                                           | 内存、文件                                                   | 磁盘文件                                                     | 在消息发送端保存                    |
| 事务           | 支持                                                         | 不支持                                                       | 支持                                                         | 不支持                              |
| 集群           | 支持                                                         | 支持                                                         | 支持                                                         | 不支持                              |
| 负载均衡       | 支持                                                         | 支持                                                         | 支持                                                         | 不支持                              |
| 管理界面       | 一般                                                         | 好                                                           | 无社区有 web console  实现                                   | 无                                  |
| 部署方式       | 独立、嵌入                                                   | 独立                                                         | 独立                                                         | 独立                                |
| 评价           | 优点：   成熟的产品，已经在很多公司得到应用（非大规模场景）。有较多的文档。各种协议支持较好，有多重语言的成熟的客户端； 缺点： 根据其他用户反馈，会出莫名其妙的问题，切会丢失消息。 其重心放到activemq6.0 产品—apollo 上去了，目前社区不活跃，且对 5.x 维护较少； Activemq 不适合用于上千个队列的应用场景 | 优点：  由于erlang语言的特性，mq 性能较好；管理界面较丰富，在互联网公司也有较大规模的应用；支持amqp系诶，有多中语言且支持 amqp 的客户端可用   缺点：  erlang语言难度较 大。集群不支持动态扩展。 | 优点：   模型简单，接口易用（JMS  的接口很多场合并不太实用）。在阿里大规模应用。目前支付宝中的余额宝等新兴产 品均使用rocketmq。集群规模大概在50 台左右，单日处理消息上百亿；性能非常好，可以大量堆 积消息在broker  中；支持多种消费，包括集群消费、广播消费等。开发度较活跃，版本更新很快。  缺点：  没有在 mq 核心中去实现JMS 等接口， |                                     |

##### 几种MQ产品说明：

ZeroMQ : 扩展性好，开发比较灵活，采用C语言实现，实际上他只是一个socket库的重新封装，如果我们做为消息队列使用，需要开发大量的代码

RabbitMQ :结合erlang语言本身的并发优势，性能较好，但是不利于做二次开发和维护

ActiveMQ: 历史悠久的开源项目，已经在很多产品中得到应用，实现了JMS1.1规范，可以和spring-jms轻松融合，实现了多种协议，不够轻巧（源代码比RocketMQ多）.，支持持久化到数据库，对队列数较多的情况支持不好，不过我们的项目中并不会建很多的队列.

Redis 做为一个基于内存的K-V数据库，其提供了消息订阅的服务，可以当作MQ来使用，目前应用案例较少，且不方便扩展

RocketMQ: 阿里巴巴的MQ中间件，在其多个产品下使用，并能够撑住双十一的大流量，他并没有实现JMS规范，使用起来很简单。部署由一个 命名服务（nameserver）和一个代理（broker）组成，nameserver和broker以及producer都支持集群，队列的容量受机器硬盘的限制，队列满后可以支持持久化到硬盘（也可以自己适配代码，将其持久化到NOSQL数据库中），队列满后会影响吞吐量，可以采用主备来保证稳定性，支持回溯消费，可以在broker端进行消息过滤.



##### 针对消息中间件的选择可以从以下方面进行考虑：(主要对比ActiveMQ和RocketMQ)

> 优先级：我们的项目对此需求不是特别明显，RocketMQ需要新建一个特殊队列来接收优先级高的队列，无法实现从0-65535这种细粒度的控制，ActiveMQ可以精细控制

> 顺序：我们的消息总线中的消息应该都是无状态的，所以对消息的处理顺序没有严格的要求，如果有特殊要求的话可以在业务层进行控制，activeMQ无法保证严格的顺序，RocketMQ可以保证严格的消费顺序

> 持久化：都支持

> 稳定性：RoketMQ在稳定性上可能更值得信赖，支持多种集群方案，毕竟已经撑过几个双十一

> 消息过滤：ActiveMQ仅支持在客户端消费的时候进行判断是否是自己需要的消息，RocketMQ可以在broker端进行过滤，对于我们的消息总线，这里可以节省大量的网络传输是否会有消息重发造成的重复消费：RocketMQ可以保证，ActiveMQ无法保证

> 回溯消费：即重新将某一个时刻之前的消息重新消费一遍，我们对于这种需求应该很少，RocketMQ支持，ActiveMQ不支持（RocketMQ的队列是持久化到硬盘的，定期进行清除

> 事务：都支持

> 定时消费：RocketMQ支持

> 消息堆积：就是当缓存消息的内存满了之后的解决方案，一种是丢弃策略，这种不会影响吞吐量，还有一种就是将消息持久化到磁盘，这种会影响吞吐量，在评估影响程度上，RocketMQ的成绩稍微好一点

> 客户端不在线：RocketMQ可以在客户端上线后继续将未消费的消息推送到客户端

### 31.为什么 RocketMQ 不会丢失消息？

分别从Producer发送机制、Broker的持久化机制，以及消费者的offSet机制来最大程度保证消息不易丢失

1. 从Producer的视角来看：如果消息未能正确的存储在MQ中，或者消费者未能正确的消费到这条消息，都是消息丢失。
2. 从Broker的视角来看：如果消息已经存在Broker里面了，如何保证不会丢失呢（宕机、磁盘崩溃）
3. 从Consumer的视角来看：如果消息已经完成持久化了，但是Consumer取了，但是未消费成功且没有反馈，就是消息丢失

从Producer分析：如何确保消息正确的发送到了Broker?

1. 默认情况下，可以通过同步的方式阻塞式的发送，check SendStatus，状态是OK，表示消息一定成功的投递到了Broker，状态超时或者失败，则会触发默认的2次重试。此方法的发送结果，可能Broker存储成功了，也可能没成功
2. 采取事务消息的投递方式，并不能保证消息100%投递成功到了Broker，但是如果消息发送Ack失败的话，此消息会存储在CommitLog当中，但是对ConsumerQueue是不可见的。可以在日志中查看到这条异常的消息，严格意义上来讲，也并没有完全丢失
3. RocketMQ支持 日志的索引，如果一条消息发送之后超时，也可以通过查询日志的API，来check是否在Broker存储成功

从Broker分析：如果确保接收到的消息不会丢失?

1. 消息支持持久化到Commitlog里面，即使宕机后重启，未消费的消息也是可以加载出来的
2. Broker自身支持同步刷盘、异步刷盘的策略，可以保证接收到的消息一定存储在本地的内存中
3. Broker集群支持 1主N从的策略，支持同步复制和异步复制的方式，同步复制可以保证即使Master 磁盘崩溃，消息仍然不会丢失

从Cunmser分析：如何确保拉取到的消息被成功消费？

1. 消费者可以根据自身的策略批量Pull消息

2. Consumer自身维护一个持久化的offset（对应MessageQueue里面的min offset），标记已经成功消费或者已经成功发回到broker的消息下标

3. 如果Consumer消费失败，那么它会把这个消息发回给Broker，发回成功后，再更新自己的offset

4. 如果Consumer消费失败，发回给broker时，broker挂掉了，那么Consumer会定时重试这个操作

5. 如果Consumer和broker一起挂了，消息也不会丢失，因为consumer 里面的offset是定时持久化的，重启之后，继续拉取offset之前的消息到本地

   

### 32.RocketMQ 的事务消息都有哪些应用？

**概述**
事务消息解决的问题是：Provider本地事务 + 消息投递 一起执行。解决应用端 和 MQ端两个独立的应用的操作，在一个事务里面完成
因为传统的模式无法保证这一点，比如MQ宕机，或者网络丢失，而事务消息有一个两阶段确认的这一操作，可以大大降低这种丢失的概率。
但是这个功能和消费者无关，并不能确保该消息能被消费者成功消费。
消费端同样也存在这个分布式的问题：成功的从MQ中取出消息到本地 + 消费端成功业务上消费这个消息

**思考题**
RocketMQ有发送同步消息的功能，只有Broker Ack Send_OK状态码时才代表消息发送成功，否则阻塞重试，重试2次还失败就报错。
既然同步消息可以保证消息成功的写入到MQ中，为什么还要有事务消息呢？
事务消息解决的问题是：Provider本地事务 + 消息投递 一起执行。
而同步消息解决的问题是：消息一定投递成功。

**应用场景：**
比如工行用户A向建行用户B转账1万元。
使用同步消息：
①:工行系统发送一个同步消息给MQ，给B增款1万元
②:MQ ack反馈发送成功了
③:工行系统给用户A扣款1万元
可能的问题，ack Send_OK之后，工行系统抛出异常，没有给用户A扣款，但是消息已经发送出去了，B赠款成功了。

使用事务消息：
①:工行系统发一个事务消息给MQ，给B增款1万元
②:Broker precommit成功，executeLocalTransaction，真正执行工行用户A扣款1万元
③:扣款成功ACK Commit给MQ
④:MQ收到Commit ACK时，commit消息，建行系统可以消费这个消息
⑤:如果工行系统扣款异常，则消息虽然prepareCommit在MQ中，但是对建行不可见。另外如果ACK网络丢失或者延时，MQ如果超时未接收到ACK，会发起重试确认到工行。
最终确保：扣款 + 消息成功投递 在一个事务里面执行

**实现原理**
投递消息：Producer向Broker投递一个事务消息，并且带有唯一的key作为参数（幂等性)
①:Broker预提交消息（在Broker本地做了存储，但是该消息的状态对Consumer不可见）
②:Broker预提交成功后回调Producer的executeLocalTransaction方法
④:Producer提交业务(比如记录最终成功投递的日志），并根据业务提交的执行情况，向Broker反馈Commit 或者回滚
⑤:Broker最终处理
Broker监听到Producer发来的Commit反馈时，会最终提交这个消息到本地，此时该事务消息对Consumer可见，事务消息最终投递成功，事务结束
Broker监听到Producer发来的RollBack反馈时，会最终回滚掉本地的预提交的消息，事务消息最终投递失败，事务结束
Broker超时未接受到Producer的反馈，会定时重试调用Producer.checkLocalTransaction，Producer会根据自己的执行情况Ack给Broker

**Ack消息的3种状态**
Broker是根据Producer发送过来的状态码，来决定下一步的操作（提交、回滚、重试）
①:TransactionStatus.CommitTransaction: commit transaction，it means that allow consumers to consume this message.
②:TransactionStatus.RollbackTransaction: rollback transaction，it means that the message will be deleted and not allowed to consume.
③:TransactionStatus.Unknown: intermediate state，it means that MQ is needed to check back to determine the status.

**Producer实现2个接口方法：**
实际上官方的这种模式，重试指的是check的重试而不是execute的重试，因为execute方法只会执行一次，要特别注意。
executeLocalTransaction：最终执行本地事务,并Ack执行状态给Broker
checkLocalTransaction：检查Producer是否成功执行了事务,并Ack执行状态给Broker
实际上是可以写在一个方法里面的，execute的时候先根据key进行check，已经执行了就Ack OK，没有的话就执行。执行成功Ack Ok，执行失败就Ack RollBack。
但是这里官方把这个功能拆分的更细了，降低单一方法的复杂度

**事务消息的优点:**
①:消息的投递失败时(比如MQ宕机或者网络丢失),Producer是可以感知到的，因为最终的业务提交是在回调的execute方法里面执行的
②:如果消息成功发送到Broker，但是没有Producer最终Commit Ack时（比如Producer宕机了），该事务消息仍然处于预提交的状态，不会被消费者读取到，这保证了消息在P和C端的状态一致性

总结：其实rocketmq事务消息是在回调里面做的本地事务的提交，以及check本地事务执行情况。保证本地事务的正常提交，以及mq消息正常发送成功。

第一步也就是先发送一个半消息，这个消息对consumer是不可见的，在回调里面做本地事务的正常提交。

源码地址demo:https://gitee.com/gd1234/springboot-rocketmq

**补一下图：**

**图一：rocketmq事务消息设计思路图：**

![img](.\img\最高级多方面面试题\816762-20210131105335889-115436698.png)

①:应用模块遇到要发送事务消息的场景时，先发送prepare消息给MQ。
②:prepare消息发送成功后，应用模块执行数据库事务（本地事务）。
③:根据数据库事务执行的结果，再返回Commit或Rollback给MQ。
④:如果是Commit，MQ把消息下发给Consumer端，如果是Rollback，直接删掉prepare消息。
⑤:第3步的执行结果如果没响应，或是超时的，启动定时任务回查事务状态（最多重试15次，超过了默认丢弃此消息），处理结果同第4步。
⑥:MQ消费的成功机制由MQ自己保证。

 **图二：RocketMQ事务消息实现流程图**

以RocketMQ 4.5.2版本为例，事务消息有专门的一个队列RMQ_SYS_TRANS_HALF_TOPIC，所有的prepare消息都先往这里放，当消息收到Commit请求后，就把消息再塞到真实的Topic队列里，供Consumer消费，同时向RMQ_SYS_TRANS_OP_HALF_TOPIC塞一条消息。简易流程图如下：

![img](.\img\最高级多方面面试题\816762-20210131105750460-895371602.png)

 **图三：rocketmq回查本地事务图**

![img](.\img\最高级多方面面试题\816762-20210131105848294-155355372.png)

### 33.RocketMQ 是怎么保证系统高可用的？

##### **一、什么是高可用**

高可用即通过系统设计，尽可能减少系统不可用时间。

单点系统是不具备高可用特征的，因此高可用一般在分布式系统中才能体现。

##### **二、常见的高可用策略**

高可用的核心策略是：冗余 + 故障处理

冗余策略：

- 多个反向代理
- 多个服务
- 多个数据库
- 多个缓存

故障处理：

- keepalived + virtual IP自动故障转移
- service-connection-pool来保证自动故障转移
- db-connection-pool来保证自动故障转移

##### **三、RocketMQ中的策略**

3.1 消息存储高可用（对应冗余）

RocketMQ具有主从Broker。分别为master和slave，数据存储时需要将master的消息复制到slave，复制方式有两种：

1. 同步刷盘

master和slave均写成功，才返回客户端成功。master挂了之后，可保证数据不丢失，但是同步复制会增加数据写入延迟，降低吞吐率。

2. 异步刷盘

只要master写成功，则返回成功，拥有较低的延迟和较高的吞吐率，但是master出现故障，可能造成数据丢失。异步刷盘主要利用的是OS的PageCache的优势，只要消息写入了PageCache，则返回成功。

3.2 消息发送高可用（对应故障处理）

RocketMQ的topic创建机制，使得topic对应多个消息队列。如：topicA在broker1的队列为queue-1和queue-2，在broker2的队列为queue-3和queue-4。

在选择消息队列时，难免遇到宕机的broker，或者因为网络原因发送失败，因此RocketMQ采用了重试机制 + broker规避的策略，来保证消息发送的高可用。

1. 重试机制（源码见底部）

不同消息发送方式，对应不同的重试次数，同步3次，异步和单向为1次。重试机制可以提高消息发送成功的几率。

2. Broker故障延迟机制 (源码见底部)

Rocket提供了一个故障延迟开关（sendLatencyFaultEnable），用以选择消息队列的选择，对应两种状态：

1）关闭（默认）

如果当前选择的broker与上次失败的broker相同，则跳过重选。

2）开启

对发送失败的消息做规避处理，延迟发送时间，并且维护Broker。比如上次请求的等待时间超过500ms，就退避为3000ms。

3.3 消息消费高可用（对应故障处理）

消息消费第一次是从master获取，之后读取路径有以下几种情况：

- slave同步未完成，依旧从master读取；
- slave同步完成，master写负载很高，从slave读；
- master宕机，RocketMQ会从slave中选举新的master，4.5版本之前需要手动修改，4.5版本之后引入了Dledger技术（基于Raft协议实现）。DLedger引入之后，可以让一个Master对应多个Slave，也就是存在多个副本，一旦Master宕机了。多个Slave之间就会通过DLedger技术和Raft协议算法进行选举，选出来的Slave节点将作为新的Master继续提供服务。



附：

- 重试机制

```java
int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;

for (; times &lt; timesTotal; times++) {
	// ...
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul>
<li>故障延迟机制</li>
</ul>
<div class="language-java line-numbers-mode" data-ext="java"><pre v-pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">MessageQueue</span> <span class="token function">selectOneMessageQueue</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token class-name">TopicPublishInfo</span> tpInfo<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">String</span> lastBrokerName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// Broker故障延迟机制</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sendLatencyFaultEnable<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token comment">// 自增取值</span>
      <span class="token keyword">int</span> index <span class="token operator">=</span> tpInfo<span class="token punctuation">.</span><span class="token function">getSendWhichQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> tpInfo<span class="token punctuation">.</span><span class="token function">getMessageQueueList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 队列位置值取模</span>
        <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">%</span> tpInfo<span class="token punctuation">.</span><span class="token function">getMessageQueueList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pos <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
          pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token class-name">MessageQueue</span> mq <span class="token operator">=</span> tpInfo<span class="token punctuation">.</span><span class="token function">getMessageQueueList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 校验队列是否可用</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>latencyFaultTolerance<span class="token punctuation">.</span><span class="token function">isAvailable</span><span class="token punctuation">(</span>mq<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">null</span> <span class="token operator">==</span> lastBrokerName <span class="token operator">||</span> mq<span class="token punctuation">.</span><span class="token function">getBrokerName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>lastBrokerName<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">return</span> mq<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>

      <span class="token comment">// 尝试从失败的broker列表中选择一个可用的broker</span>
      <span class="token keyword">final</span> <span class="token class-name">String</span> notBestBroker <span class="token operator">=</span> latencyFaultTolerance<span class="token punctuation">.</span><span class="token function">pickOneAtLeast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">int</span> writeQueueNums <span class="token operator">=</span> tpInfo<span class="token punctuation">.</span><span class="token function">getQueueIdByBroker</span><span class="token punctuation">(</span>notBestBroker<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>writeQueueNums <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">MessageQueue</span> mq <span class="token operator">=</span> tpInfo<span class="token punctuation">.</span><span class="token function">selectOneMessageQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>notBestBroker <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          mq<span class="token punctuation">.</span><span class="token function">setBrokerName</span><span class="token punctuation">(</span>notBestBroker<span class="token punctuation">)</span><span class="token punctuation">;</span>
          mq<span class="token punctuation">.</span><span class="token function">setQueueId</span><span class="token punctuation">(</span>tpInfo<span class="token punctuation">.</span><span class="token function">getSendWhichQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> writeQueueNums<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> mq<span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// 从失败条目中移除已经恢复的broker</span>
        latencyFaultTolerance<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>notBestBroker<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Error occurred when selecting message queue"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> tpInfo<span class="token punctuation">.</span><span class="token function">selectOneMessageQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 默认机制</span>
  <span class="token keyword">return</span> tpInfo<span class="token punctuation">.</span><span class="token function">selectOneMessageQueue</span><span class="token punctuation">(</span>lastBrokerName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="-2" tabindex="-1"><a class="header-anchor" href="#-2" aria-hidden="true">#</a> </h2>
<h1 id="十五-swoole面试题" tabindex="-1"><a class="header-anchor" href="#十五-swoole面试题" aria-hidden="true">#</a> 十五.swoole面试题</h1>
<h3 id="_1-对swoole、workerman和php自带的socket的理解-为什么php自带的socket不怎么听说-基本都是用swoole-workerman去实现" tabindex="-1"><a class="header-anchor" href="#_1-对swoole、workerman和php自带的socket的理解-为什么php自带的socket不怎么听说-基本都是用swoole-workerman去实现" aria-hidden="true">#</a> 1.对Swoole、Workerman和php自带的socket的理解,为什么php自带的socket不怎么听说，基本都是用swoole,workerman去实现？</h3>
<h5 id="_1、php的socket扩展是一套socket-api-仅此而已。" tabindex="-1"><a class="header-anchor" href="#_1、php的socket扩展是一套socket-api-仅此而已。" aria-hidden="true">#</a> 1、PHP的socket扩展是一套socket api，仅此而已。</h5>
<p>swoole，用C实现，它的socket是C 库的socket，更加底层可控。</p>
<p>workerman，如题主所说，使用PHP实现，那它的socket就是用PHP socket扩展啊。只是对其进行工程化开发，成了一个框架。</p>
<h5 id="_2、swoole-框架和-swoole-扩展是不一样的。" tabindex="-1"><a class="header-anchor" href="#_2、swoole-框架和-swoole-扩展是不一样的。" aria-hidden="true">#</a> 2、swoole 框架和 swoole 扩展是不一样的。</h5>
<p>swoole 框架也可以脱离 swoole 扩展来使用。</p>
<p>swoole 扩展将进程管理，tcp 监听这些工作在 C 里面做了，以扩展的形式提供给 PHP 一些接口来调用。</p>
<p>workerman 就是原生的使用 php stream 相关的函数来监听 tcp，进行进程管理。</p>
<p>如果你想学习 PHP 开发 tcp 的原理建议看 workerman 的源码，如果你只是想使用，用 swoole 就 OK 了。</p>
<h5 id="_3、就是一个底层通信框架-基于socket通信的" tabindex="-1"><a class="header-anchor" href="#_3、就是一个底层通信框架-基于socket通信的" aria-hidden="true">#</a> 3、就是一个底层通信框架，基于socket通信的，</h5>
<p>其实PHP 也能做多进程编程（扩展支持，workerman是这方面NO.1），swoole使用C 实现的一套PHP扩展，基于它也是做这方面的功能，因为这两个底层框架的存在，大大扩展了PHP的应用范围，和不错的未来期望</p>
<h5 id="_4、php现有的应用方式都是基于http的" tabindex="-1"><a class="header-anchor" href="#_4、php现有的应用方式都是基于http的" aria-hidden="true">#</a> 4、php现有的应用方式都是基于http的，</h5>
<p>对于需要快速实时响应的情况比较乏力，比如网络游戏或者推送服务一般都需要与用户长期保持一个tcp连接以便实时响应和推送信息。</p>
<p>swoole就是解决这样应用场景的。</p>
<p>这个是让<a href="http://www.codexueyuan.com/php" target="_blank" rel="noopener noreferrer">php<ExternalLinkIcon/></a>自身建立一个服务，不需要nginx之类的代理，直接监听端口实现通信。</p>
<p>一种应用方式也可以代替掉nginx做http服务，但一般不会这么用。</p>
<h5 id="_5、实际上作为一名php程序员-我很清楚php的确有很多局限性" tabindex="-1"><a class="header-anchor" href="#_5、实际上作为一名php程序员-我很清楚php的确有很多局限性" aria-hidden="true">#</a> 5、实际上作为一名PHP程序员，我很清楚PHP的确有很多局限性，</h5>
<p>比如Unix系统编程、网络通信编程、异步io，大部分PHPer不懂。PHP界也确实没有这样的东西。Swoole开源项目就是为了弥补PHP在这些方面的缺陷诞生的。与WordPress这些产品不同，swoole实际上是一个网络通信和异步io的引擎，一个基础库。PHPer可以基于swoole去实现过去PHP无法实现的功能。swoole为PHPer打开了通往另一个世界的大门。</p>
<h5 id="_6、这2个框架都很出名-它们的出现大大的提高了php的应用范围及知名度" tabindex="-1"><a class="header-anchor" href="#_6、这2个框架都很出名-它们的出现大大的提高了php的应用范围及知名度" aria-hidden="true">#</a> 6、这2个框架都很出名，它们的出现大大的提高了php的应用范围及知名度</h5>
<p>workerman和swoole都是php socket 服务器框架，都支持长连接、tcp和udp、websocket、异步、分布式部署等</p>
<p>workerman纯php写的，swoole是php的c扩展，性能肯定更高，百度、腾讯不少产品的server就是基于swoole的</p>
<p>workerman上手更快，文档更丰富，社区活跃，社区基本做到有问必答，一般的中小型项目也够了，所以初学者最好还是使用workerman，熟了后再根据具体业务权衡（官方网站都有压测数据）</p>
<h3 id="_2、看你项目里说到使用过swoole-也写点go-你可以说说他们协程上的区别吗" tabindex="-1"><a class="header-anchor" href="#_2、看你项目里说到使用过swoole-也写点go-你可以说说他们协程上的区别吗" aria-hidden="true">#</a> 2、看你项目里说到使用过swoole，也写点go，你可以说说他们协程上的区别吗？</h3>
<p>答:设计上他们是一样的，主要区别在于，协程调度器模式。swoole 的协程调度器是单线程，go 的协程调度器是多线程。这就意味着，同一时刻 swoole 只有一个协程在运行，而 go 同一时刻可以多个协程在运行。所以在 swoole 协程中不需要对全局变量进行加锁。而且 swoole 本质是单线程多进程的，意味着它没有超全局的变量，仅仅是进程级别变量。而 go 多线程，多线程必然会存在临界变量锁的问题。当然，go 也提供了开箱即用的 sync 读写锁，或者你也可以直接使用通道来代替。</p>
<h3 id="_3、你可以说说-go-的-gmp-调度模型吗-暂无答案" tabindex="-1"><a class="header-anchor" href="#_3、你可以说说-go-的-gmp-调度模型吗-暂无答案" aria-hidden="true">#</a> 3、你可以说说 go 的 gmp 调度模型吗？（暂无答案）</h3>
<h3 id="_4、websocket-连接步骤" tabindex="-1"><a class="header-anchor" href="#_4、websocket-连接步骤" aria-hidden="true">#</a> 4、websocket 连接步骤 ？</h3>
<h3 id="_5、是否了解-go" tabindex="-1"><a class="header-anchor" href="#_5、是否了解-go" aria-hidden="true">#</a> 5、是否了解 Go ？</h3>
<h3 id="_6-为什么用swoole-swoole的优势是什么" tabindex="-1"><a class="header-anchor" href="#_6-为什么用swoole-swoole的优势是什么" aria-hidden="true">#</a> 6.为什么用swoole？swoole的优势是什么？</h3>
<h4 id="_1-swoole搭建图文直播课和聊天室的业务逻辑" tabindex="-1"><a class="header-anchor" href="#_1-swoole搭建图文直播课和聊天室的业务逻辑" aria-hidden="true">#</a> 1.<a href="http://www.phpxs.com/" target="_blank" rel="noopener noreferrer">swoole<ExternalLinkIcon/></a>搭建图文直播课和聊天室的业务逻辑</h4>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211216143324608.png" alt="image-20211216143324608"></p>
<h4 id="_2-使用swoole遇到了哪些问题" tabindex="-1"><a class="header-anchor" href="#_2-使用swoole遇到了哪些问题" aria-hidden="true">#</a> 2.使用swoole遇到了哪些问题</h4>
<p>​		a.进程隔离：
​			多进程之间会产生进程隔离,global无效,不能共用一个mysql,redis连接,所以每个进程单独开一个数据库连接
​			如何解决进程间通信：redis 、swoole_table
​		b.是否可以共用1个redis或mysql连接
​				不可以，无法确定返回处理的reactor的id
​		d.为什么onReceive收到的数据这么大
​				客户端发送的多次请求，服务端是可以一次性接收的。并不是客户端发送一次，服务端接收一次</p>
<h4 id="_3-如何理解swoole" tabindex="-1"><a class="header-anchor" href="#_3-如何理解swoole" aria-hidden="true">#</a> 3.如何理解swoole</h4>
<p>swoole就是PHP外衣的c程序：其实就是c、java那些语言里面的高阶功能：
比如持久连接、异步通信、websocket，多线程。</p>
<h4 id="_4-进程、线程、协程" tabindex="-1"><a class="header-anchor" href="#_4-进程、线程、协程" aria-hidden="true">#</a> 4.进程、线程、协程</h4>
<p>进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。
线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程也由操作系统调度。
协程和线程一样共享堆，不共享栈，协程由程序员在代码里调度。</p>
<h4 id="_5-swoole出现的意义是什么" tabindex="-1"><a class="header-anchor" href="#_5-swoole出现的意义是什么" aria-hidden="true">#</a> 5.swoole出现的意义是什么？</h4>
<p>解決php缺失的功能：swoole做为一种网络通信框架，解决php缺失的功能：比如多线程、异步通信、持久连接等</p>
<h4 id="_6-php-swoole能做什么" tabindex="-1"><a class="header-anchor" href="#_6-php-swoole能做什么" aria-hidden="true">#</a> 6.php+swoole能做什么？</h4>
<p>c能做的，php+swoole都能做：比如 游戏服务器、在线聊天系统等</p>
<h4 id="_7-关于phper常用的全局变量-global-为什么在onrequest函数中不能使用。" tabindex="-1"><a class="header-anchor" href="#_7-关于phper常用的全局变量-global-为什么在onrequest函数中不能使用。" aria-hidden="true">#</a> 7.关于phper常用的全局变量（global）为什么在onRequest函数中不能使用。</h4>
<p>因为swoole是多线程编程，global是不能在多个进程间共享的。例如</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211216145745354.png" alt="image-20211216145745354"></p>
<p>如果在swoole中写一个上面的程序，并不会每次访问输出一个递增的数字。如果要实现预期的效果，需要使用swoole_table的相关函数。</p>
<h4 id="_8-自制httpserve" tabindex="-1"><a class="header-anchor" href="#_8-自制httpserve" aria-hidden="true">#</a> 8.自制httpserve</h4>
<p>写一个http服务端，然后通过浏览器访问这个自制的服务器，刷新一次浏览器，服务端为什么为接收到两次请求？这个问题估计困饶了好多初次用swoole写httpserver的朋友。因为浏览器会多发一个favicon.ico请求。
<strong>原因</strong>
出现这种情况的原因其实很简 单，大部分phper都只会php这一种语言，主要用途就是做web，写业务逻辑。很少去了解服务器程序的开发。有一次一个朋友用swoole写了一个简 单的服务端，一个客户端，跑过来问我为什么都启动了却都收不到数据，我简单看了下代码，所有连接确实都成功了，两端都设置了onReceive回调，代码 没问题，看到最后才发现他的服务端、客户端都设置了接到消息的回调函数，但是两端都没有向对方发消息，两端处于僵持状态。然后swoole官方对于这种常 识问题没有给出说明，只是说如何设置回调、如何发消息，如何这样，如何那样。对于有服务端开发经验的同学来说，肯定不会遇到这种问题，swoole文档也 不需要指明需要这样做，因为这是常识。但对于phper来说，指明这一点是非常重要的，因为如上面所说phper是没有这方面认知的，只有服务端开发经验 的程序员有才会有。</p>
<p><strong>swoole的特色：</strong>
网络通信 框架、异步、多线程。这些特性正是php所不完善的功能（虽然官方提供很多基础函数可以实现这些功能，然后缺少中文文档，很少有人用php来实现这部分功 能），普通的phper也不具备这些特性的基础认知，所以贸然使用swoole难免会遇到一些根本在swoole官方查不到的常识问题。</p>
<h4 id="_9-workman和swoole区别和异同" tabindex="-1"><a class="header-anchor" href="#_9-workman和swoole区别和异同" aria-hidden="true">#</a> 9.workman和swoole区别和异同</h4>
<p>workerman和swoole在现阶段很受争议，有时间你得认识认识，不然你就不是混php圈子的。swoole是使用C语言实现的socket通信框架，workerman则是使用纯php实现的socket框架，二者进程模型上也存在很多的不同。</p>
<h5 id="先说下swoole的进程模型-看一下以下解析图。" tabindex="-1"><a class="header-anchor" href="#先说下swoole的进程模型-看一下以下解析图。" aria-hidden="true">#</a> 先说下swoole的进程模型，看一下以下解析图。</h5>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211216150739067.png" alt="image-20211216150739067"></p>
<p><strong>master进程</strong>
这个进程比较复杂，也是我认为最核心的进程，这是一个包含多线程的进程，分别是一个主线程和n个reactor线程（数量可以配置）。</p>
<p>其中，主线程用于accept新的连接，然后评估一下每个reactor线程负责维护的连接数，然后分配给数量最少的那个reactor线程，最大程度保证每个reactor线程的负载量是均衡的。</p>
<p>本质上讲，一旦一个socket可读或者可写了，就由reactor线程发送给worker进程或者发送会客户端。除此之外，主线程还负责对所有信号的接管，避免reactor线程收到信号的打扰中断。</p>
<p>总的来说就是：master进程负责了连接的accept、托管、socket的可读可写（数据的发送和接受），本质上讲，master进程负责了IO。还需要注意一点儿的是reactor线程是彻底的全异步非阻塞工作方式。</p>
<p><strong>manager进程</strong>
manager进程是worker进程和taskworker进程的妈，说的洋气点儿就是manager进程fork出来了worker进程和taskworker进程，生出来了就得管，所以，manager进程得负责对worker进程和taskworker进程的抚养义务，具体包括监控它们的状态、当它们意外挂了后重新拉起一个新的进程（避免了僵尸进程）、平滑重启（就是传说中的reload）。
————————————————
<strong>worker进程</strong>
worker进程是manager进程fork出来的，这个进程说白了就是搬砖干活（官方文档中屡次提到的业务代码），其实就是平时码的那些curd业务逻辑代码，懂了吧？只不过worker进程比较diao的是，这个进程可以用异步方式去工作，也可以用同步方式去工作。</p>
<p><strong>taskworker进程</strong>
taskworker进程（后文中称tasker进程）实际本质上也是worker进程，只不过是一种特殊的worker进程。如果你的worker进程中存在一些耗时耗力的操作，那么可以先抛给tasker进程，自己先去干别的，等tasker干完了，再由worker进程取回，非常diao。但是tasker进程只能工作在同步方式下，并不能使用异步。这就是为什么tasker进程不可以使用定时器，而worker进程可以使用定时器的原因。</p>
<p>总的来说，就是master进程就是接活儿的销售，但是具体干活则由worker进程来做，如果worker进程感觉到某些流程太繁忙复杂就可以让tasker进程来做。而manager进程就是后勤worker进程和takser进程的人力资源保障部，负责他们的生死存亡。</p>
<h5 id="workerman的进程模型" tabindex="-1"><a class="header-anchor" href="#workerman的进程模型" aria-hidden="true">#</a> workerman的进程模型：</h5>
<p>相对于swoole来说，workerman没有swoole中的reator线程，其次workerman没有用于处理普通业务的worker进程以及tasker进程。而workerman的话，socket是由worker进程负责的，swoole中则是由主进程中的reactor线程来负责的。而swoole在接受到数据后，可以通过自己的worker进程来处理业务（有点儿类似于fpm进程）。</p>
<p>workerman是一个高性能的PHP socket 服务器框架，workerman基于PHP多进程以及libevent事件轮询库，PHP开发者只要实现一两个接口，便可以开发出自己的网络应用，例如Rpc服务、聊天室服务器、手机游戏服务器等。</p>
<p>workerman的目标是让PHP开发者更容易的开发出基于socket的高性能的应用服务，而不用去了解PHP socket以及PHP多进程细节。 workerman本身是一个PHP多进程服务器框架，具有PHP进程管理以及socket通信的模块，所以不依赖php-fpm、nginx或者apache等这些容器便可以独立运行
————————————————</p>
<p>workerman有两种进程模型</p>
<p>1、基本的master worker模型</p>
<p>2、master gateway worker模型</p>
<p>master worker模型工作流程及进程间关系如下：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211216151840201.png" alt="image-20211216151840201"></p>
<p><strong>master worker模型说明：</strong></p>
<p>master进程为主进程，启动过程中读取conf配置，根据每个应用配置中的ip和端口创建监听socket，然后再根据配置中的进程数创建对应数量的子进程即worker进程，worker进程会自动继承master进程创建的监听socket，使得worker进程能够独立的接受并处理客户端的连接。</p>
<p>而后master进程进入监听信号的逻辑中，监听worker进程退出信号（worker进程退出后，系统会自动向master进程发送一个SIGHCLD信号，mater进程会重新创建子进程，将缺失的子进程补上），master进程还会监听workermand脚本发来的停止信号（SIGINT）和平滑重启服务信号（SIGHUP）</p>
<p>worker进程为master进程派生出来的子进程，自动继承了master进程的监听socket，每个worker进程独立的接受并处理客户端的连接。</p>
<p>master worker模型比较适合业务简单的应用或者短连接应用
————————————————
<img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211216152244782.png" alt="image-20211216152244782"></p>
<p>master gateway worker 模型说明：</p>
<p>这种模型多了一个gateway进程组，工作流程与master worker模型基本相同，区别是worker进程不再直接与客户端打交道，客户端与worker进程之间多了一个gateway进程，gateway专职处理网络IO，并维护客户端的长连接。</p>
<p>master gateway worker 模型非常适合长连接应用
————————————————
当我们业务代码以同步阻塞方式来使用swoole和workerman的时候，swoole则很想nginx+fpm的二合一体，而workerman则只相当于nginx，这就是区别啦！</p>
<h1 id="十六-高并发和大流量解决方法" tabindex="-1"><a class="header-anchor" href="#十六-高并发和大流量解决方法" aria-hidden="true">#</a> 十六.高并发和大流量解决方法</h1>
<h3 id="_1-php-高并发和大流量的解决方案" tabindex="-1"><a class="header-anchor" href="#_1-php-高并发和大流量的解决方案" aria-hidden="true">#</a> 1.PHP-高并发和大流量的解决方案</h3>
<h5 id="一-高并发的概念" tabindex="-1"><a class="header-anchor" href="#一-高并发的概念" aria-hidden="true">#</a> 一  高并发的概念</h5>
<p>在互联网时代，并发，高并发通常是指并发访问。也就是在某个时间点，有多少个访问同时到来。</p>
<h5 id="二-高并发架构相关概念" tabindex="-1"><a class="header-anchor" href="#二-高并发架构相关概念" aria-hidden="true">#</a> 二  高并发架构相关概念</h5>
<p>1、QPS (每秒查询率) : 每秒钟请求或者查询的数量，在互联网领域，指每秒响应请求数(指HTTP请求)</p>
<p>2、PV（Page View）：综合浏览量，即页面浏览量或者点击量，一个访客在24小时内访问的页面数量</p>
<ul>
<li>-注：同一个人浏览你的网站的同一页面，只记做一次pv</li>
</ul>
<p>3、吞吐量（fetches/sec） ：单位时间内处理的请求数量 （通常由QPS和并发数决定）</p>
<p>4、响应时间：从请求发出到收到响应花费的时间</p>
<p>5、独立访客（UV）：一定时间范围内，相同访客多次访问网站，只计算为1个独立访客</p>
<p>6、带宽：计算带宽需关注两个指标，峰值流量和页面的平均大小</p>
<p>7、日网站带宽： PV/统计时间（换算到秒） * 平均页面大小（kb）* 8</p>
<h5 id="三-需要注意点" tabindex="-1"><a class="header-anchor" href="#三-需要注意点" aria-hidden="true">#</a> 三 需要注意点：</h5>
<p>1、QPS不等于并发连接数（QPS是每秒HTTP请求数量，并发连接数是系统同时处理的请求数量）</p>
<p>2、峰值每秒请求数（QPS）= （总PV数<em>80%）/ （六小时秒数</em>20%）【代表80%的访问量都集中在20%的时间内】</p>
<p>3、压力测试： 测试能承受的最大并发数 以及测试最大承受的QPS值</p>
<p>4、常用的性能测试工具【ab，wrk，httpload，Web Bench，Siege，Apache JMeter】</p>
<h5 id="四-优化" tabindex="-1"><a class="header-anchor" href="#四-优化" aria-hidden="true">#</a> 四 优化</h5>
<p>1、当QPS小于50时</p>
<p>优化方案:为一般小型网站,不用考虑优化</p>
<p>2、当QPS达到100时,遇到数据查询瓶颈</p>
<p>优化方案: 数据库缓存层,数据库的负载均衡</p>
<p>3、当QPS达到800时, 遇到带宽瓶颈</p>
<p>优化方案:CDN加速,负载均衡</p>
<p>4、当QPS达到1000时</p>
<p>优化方案: 做html静态缓存</p>
<p>5、当QPS达到2000时</p>
<p>优化方案: 做业务分离,分布式存储</p>
<h5 id="五、高并发解决方案案例" tabindex="-1"><a class="header-anchor" href="#五、高并发解决方案案例" aria-hidden="true">#</a> 五、高并发解决方案案例:</h5>
<h6 id="_1、流量优化" tabindex="-1"><a class="header-anchor" href="#_1、流量优化" aria-hidden="true">#</a> 1、流量优化</h6>
<p>防盗链处理(去除恶意请求)</p>
<h6 id="_2、前端优化" tabindex="-1"><a class="header-anchor" href="#_2、前端优化" aria-hidden="true">#</a> 2、前端优化</h6>
<p>(1) 减少HTTP请求[将css,js等合并]</p>
<p>(2) 添加异步请求(先不将所有数据都展示给用户,用户触发某个事件,才会异步请求数据)</p>
<p>(3) 启用浏览器缓存和文件压缩</p>
<p>(4) CDN加速</p>
<p>(5) 建立独立的图片服务器(减少I/O)</p>
<h6 id="_3、服务端优化" tabindex="-1"><a class="header-anchor" href="#_3、服务端优化" aria-hidden="true">#</a> 3、服务端优化</h6>
<p>(1) 页面静态化</p>
<p>(2) 并发处理</p>
<p>(3) 队列处理</p>
<h6 id="_4、数据库优化" tabindex="-1"><a class="header-anchor" href="#_4、数据库优化" aria-hidden="true">#</a> 4、数据库优化</h6>
<p>(1) 数据库缓存</p>
<p>(2) 分库分表,分区</p>
<p>(3) 读写分离</p>
<p>(4) 负载均衡</p>
<h6 id="_5、web服务器优化" tabindex="-1"><a class="header-anchor" href="#_5、web服务器优化" aria-hidden="true">#</a> 5、web服务器优化</h6>
<p>(1) nginx反向代理实现负载均衡</p>
<p>(2) lvs实现负载均衡
————————————————</p>
<h3 id="_2-web资源防盗链" tabindex="-1"><a class="header-anchor" href="#_2-web资源防盗链" aria-hidden="true">#</a> 2.web资源防盗链</h3>
<p>相关概念：</p>
<p>什么是防盗链：盗链就是在自己的服务器上展示一些不是自己服务器上的内容</p>
<p>防盗链工作原理 ： 通过refer 或者签名，网站可以检测到目标网页访问的来源网页，如果是资源文件，则可以跟踪到显示他的网页地址，一旦检测到来源不是本站即进行阻止或者返回指定页面。 通过签名方式  通过计算签名的方式，计算签名是否合法，合法则显示，否则返回错误信息。</p>
<p>实现方法：通过referer方法 使用nginx 模块ngx_http_referer_module 用于阻挡来源非法的域名请求，nginx指令valid_referers,全局变量$invalid_referer.</p>
<p>问题 可以伪装referer。 使用加密签名， 使用第三方模块httpAccessModule实现反盗链，</p>
<h3 id="_3-高并发下优化" tabindex="-1"><a class="header-anchor" href="#_3-高并发下优化" aria-hidden="true">#</a> 3.高并发下优化：</h3>
<h5 id="_1-减少http请求" tabindex="-1"><a class="header-anchor" href="#_1-减少http请求" aria-hidden="true">#</a> 1.减少http请求</h5>
<p>相关概念</p>
<p>为什么减少http请求次数： 性能黄金法则：只有10%-20%的最终用户响应时间花在接受请求的http文档上，剩下的80%-90%时间花在html文档引用的所有组件（图片，js，css ，flash等）。如何改善：减少组件数量，从而减少http请求。http连接产生的开销：域名解析-tcp连接-发送请求-等待-下载资源-解析时间</p>
<p>减少http请求的方式：css精灵、合并脚本和样式表适</p>
<h5 id="_2-浏览器缓存和压缩优化技术" tabindex="-1"><a class="header-anchor" href="#_2-浏览器缓存和压缩优化技术" aria-hidden="true">#</a> 2.浏览器缓存和压缩优化技术</h5>
<h5 id="_5-cdn加速" tabindex="-1"><a class="header-anchor" href="#_5-cdn加速" aria-hidden="true">#</a> 5.CDN加速</h5>
<h5 id="_6-建立独立的图片服务器" tabindex="-1"><a class="header-anchor" href="#_6-建立独立的图片服务器" aria-hidden="true">#</a> 6.建立独立的图片服务器</h5>
<h5 id="_7-动态语言静态化" tabindex="-1"><a class="header-anchor" href="#_7-动态语言静态化" aria-hidden="true">#</a> 7.动态语言静态化</h5>
<h5 id="_8-数据缓存层的优化" tabindex="-1"><a class="header-anchor" href="#_8-数据缓存层的优化" aria-hidden="true">#</a> 8.数据缓存层的优化</h5>
<h5 id="_9-数据库缓存层的优化" tabindex="-1"><a class="header-anchor" href="#_9-数据库缓存层的优化" aria-hidden="true">#</a> 9.数据库缓存层的优化</h5>
<h5 id="_10-mysql数据层的优化" tabindex="-1"><a class="header-anchor" href="#_10-mysql数据层的优化" aria-hidden="true">#</a> 10.mysql数据层的优化</h5>
<h5 id="_11-web服务器负载均衡" tabindex="-1"><a class="header-anchor" href="#_11-web服务器负载均衡" aria-hidden="true">#</a> 11.web服务器负载均衡</h5>
<h5 id="相关概念" tabindex="-1"><a class="header-anchor" href="#相关概念" aria-hidden="true">#</a> 相关概念：</h5>
<p>七层负载均衡实现： 基于url等应用层信息的负载均衡；代表 nginx的proxy是他一个很强大的功能，实现了7层负载均衡。功能强大、性能卓越、运行稳定， 配置灵活简单、能自动剔除工作不正常的后端服务器、上传文件使用异步模式、支持多种分配策略。nginx负载均衡策略：内置策略：iphash、加权轮询， 扩展策略：fair策略：根据后端服务器的响应时间判断负载情况，从中选出负载最轻的机器进行分流。通用hash：通用hash比较简单，可以以nginx内置变量为key进行hash、一致性hash：采用nginx内置的一致性hash环，支持memcache。</p>
<p>nginx配置：</p>
<p>四层负载均衡实现： 通过报文中的目标地址和端口，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。lvs实现服务器负载均衡有三种方式NAT、DR、和TUN。</p>
<h3 id="_6-高并发下如何保证数据的一致性-重点" tabindex="-1"><a class="header-anchor" href="#_6-高并发下如何保证数据的一致性-重点" aria-hidden="true">#</a> 6.高并发下如何保证数据的一致性（重点）</h3>
<p>1.通过悲观锁实现 for update</p>
<p>2.通过乐观锁实现，加字段</p>
<p>3.针对秒杀系统，可以采取将并发请求串行化。放在一个队列中，处理对数据库的写操作</p>
<p>4.通过redis实现，读和写都操作redis。写redis数据时，同时产生一条业务相关联的日志数据。单独开个任务或者消息队列来对日志数据进行读取，获取里面的对数据库的操作。然后进行写数据库。</p>
<p>5.因为redis支持事务，所有写操作可以通过lua脚本来支持对数据库的操作。</p>
<p>6.写update语句时，还可以这样写。update produce p set p.num=$SumNum-$num where p.num=$sumNum and $sumNum-$num&gt;0;</p>
<p>更新某个库存值时，首先获取当前库存量。更新时传入查询到的数量。减出此次要操作的数量。加上两个限制条件：</p>
<p>1.业务层面乐观锁CAS，使用版本号解决ABA问题，实际使用中使用时间戳，更新的时候把查出来的时间戳带上，如果更新失败可以自旋，获取最近值和时间戳，直到更新成功。
2.DB层面开启一个事务，然后select一行for update给这一行加上排它锁，再去更新行，然后提交，其他事务就会阻塞在select for update。
3.分布式锁适合竞争不激烈的情况保证一致性，因为性能比较差，按CAP理论来讲应该是保证了CP放弃了A，zk或者redis保证一致性P，只有拿到锁的线程才能执行，保证一致性C。
4.采用redis方式的分布式锁，如果有集群，当主挂了之后，还未同步到从，那么另外的线程会到从库拿锁，引起超卖问题。根本原因是，分布式锁要求的是CP，redis集群是AP，用AP去实现CP是不现实的。
5.redis方式还有一个问题，setnx超时时间如果小于接口超时时间，当接口缓慢时达到redis超时时间会释放锁，再来请求就会拿到锁，会出现多个用户同时拿到锁。
6.用redis本身的原子性操作库存是一种常见做法。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>// redis会返回操作之后的结果，这个过程是原子性的
Long currStock = redisTemplate.opsForHash().increment("key", "stock", -1);
if (currStock &lt; 0) { // 说明库存已经扣减完了。
	// 业务异常。
	log.error("[抢购下单] 无库存");
} else {
// 生成订单
// 发布订单创建成功事件
// 构建响应
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_7-mysql的并发控制" tabindex="-1"><a class="header-anchor" href="#_7-mysql的并发控制" aria-hidden="true">#</a> 7.mysql的并发控制</h3>
<p>并发即指在同一时刻，多个操作并行执行。MySQL对并发的处理主要应用了两种机制——是&quot;锁&quot;和&quot;多版本控制&quot;。</p>
<h5 id="_1、并发控制" tabindex="-1"><a class="header-anchor" href="#_1、并发控制" aria-hidden="true">#</a> 1、并发控制</h5>
<p>MySQL提供两个级别的并发控制：服务器级(the server level)和存储引擎级(the storage engine level)。加锁是实现并发控制的基本方法，MySQL中锁的粒度：</p>
<p>(1) 表级锁：MySQL独立于存储引擎提供表锁，例如，对于ALTER TABLE语句，服务器提供表锁(table-level lock)。</p>
<p>(2) 行级锁：InnoDB和Falcon存储引擎提供行级锁，此外，BDB支持页级锁。</p>
<p>另外，值得一提的是，MySQL的一些存储引擎（如InnoDB、BDB）除了使用封锁机制外，还同时结合MVCC机制，即多版本并发控制(Multi-Version Concurrent Control)，来实现事务的并发控制，从而使得只读事务不用等待锁，提高了事务的并发性。</p>
<p>锁的分类</p>
<p>共享锁：也称为读锁，读锁允许多个连接可以同一时刻并发的读取同一资源,互不干扰；
排他锁：也称为写锁，一个写锁会阻塞其他的写锁或读锁，保证同一时刻只有一个连接可以写入数据，同时防止其他用户对这个数据的读写。</p>
<h5 id="_2、事务处理" tabindex="-1"><a class="header-anchor" href="#_2、事务处理" aria-hidden="true">#</a> 2、事务处理</h5>
<p>2.1 事务的ACID特性</p>
<p>数据库的事务处理的原则是保证ACID的正确性。</p>
<p>事务是由一组SQL语句组成的逻辑处理单元，事务具有以下4个属性：</p>
<p>(1) 原子性（Atomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行，不可能只执行其中的一部分。（不可分割）</p>
<p>(2) 一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。（状态更改一致性）</p>
<p>(3) 隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的。（执行过程隔离不可见）</p>
<p>(4) 持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。（持久生效）</p>
<p>2.2 事务处理带来的问题</p>
<p>由于事务的并发执行，带来以下一些著名的问题：</p>
<p>(1) 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。</p>
<p>(2) 脏读（Dirty Reads）：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些&quot;脏&quot;数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做&quot;脏读&quot;。</p>
<p>(3) 不可重复读（Non-Repeatable Reads）：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做&quot;不可重复读&quot;。</p>
<p>(4) 幻读（Phantom Reads）：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为&quot;幻读&quot;。</p>
<p>2.3 Mysql隔离级别</p>
<p>READ UNCOMMITTED ：事务可以看到其他事务没有被提交的数据（脏数据）。
READ COMMITTED ：事务可以看到其他事务已经提交的数据。
REPEATABLE READ ：保证事务中多次查询的结果相同（Innodb默认级别），会出现幻读。
SERIALIZABLE ：所有事务顺序执行，对所有read操作加锁。保证一致性。</p>
<p><img src="https://img2018.cnblogs.com/blog/1279026/201810/1279026-20181013152937250-755169707.png" alt="img"></p>
<p>3、多版本并发控制</p>
<p>MVCC的实现：通过保存数据资源在不同时间点的快照实现的。根据事务开始的时间不同，每个事务看到的数据快照版本是不一样的。</p>
<p>InnoDB中的MVCC实现：通过在每行记录后面保存两个隐藏的列来实现，一个保存了行的创建时间，一个保存了行的过期时间。</p>
<p>SELECT</p>
<p>当读取记录时，存储引擎会选取满足下面两个条件的行作为读取结果。</p>
<p>读取记录行的开始版本号必须早于当前事务的版本号。也就是说，在当前事务开始之前，这条记录已经存在。在事务开始之后才插入的行，事务不会看到。</p>
<p>读取记录行的过期版本号必须晚于当前事务的版本号。也就是说，当前事务开始的时候，这条记录还没有过期。在事务开始之前就已经过期的数据行，该事务也不会看到。</p>
<p>INSERT</p>
<p>存储引擎为新插入的每一行保存当前的系统版本号作为这一行的开始版本号。</p>
<p>UPDATE</p>
<p>存储引擎会新插入一行记录，当前的系统版本号就是新记录行的开始版本号。同时会将原来行的过期版本号设为当前的系统版本号。</p>
<p>DELETE</p>
<p>存储引擎将删除的记录行的过期版本号设置为当前的系统版本号。</p>
<p>MVCC只在 REPEATABLE READ 和 READ COMMITTED 两个隔离级别下工作。</p>
<h3 id="_8-mysql并发写原理" tabindex="-1"><a class="header-anchor" href="#_8-mysql并发写原理" aria-hidden="true">#</a> 8.mysql并发写原理</h3>
<h4 id="资深程序员经典总结-mysql的并发控制原理" tabindex="-1"><a class="header-anchor" href="#资深程序员经典总结-mysql的并发控制原理" aria-hidden="true">#</a> 资深程序员经典总结：MySQL的并发控制原理</h4>
<p>MySQL是主流的开源关系型数据库，提供高性能的数据存储服务。我们在做后端开发时，性能瓶颈往往不是应用本身，而是数据库层面。所以掌握MySQL的一些底层原理有助于我们更好地理解MySQL，对MySQL进行性能调优，从而开发高性能的后端服务。</p>
<p>MySQL的逻辑架构</p>
<p>MySQL的逻辑架构如下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/de563481c74654a01dc3fbca872a8452.png" alt="de563481c74654a01dc3fbca872a8452.png"></p>
<p>最上层是处理客户端过来的连接的。主要做连接处理、授权认证、安全等。MySQL在这一层维护了一个线程池，用于处理来自客户端的连接。MySQL可以使用用户名密码认证，也可以使用SSL基于X.509证书认证。</p>
<p>第二层由三部分组成：查询缓存、解析器、优化器。解析器用来解析SQL语句，优化器会对解析之后的语句进行优化。在解析查询前，服务器会先检查查询缓存，如果能在其中找到对应的查询结果，则无需再进行查询解析、优化等过程，直接返回查询结果。存储过程、触发器、视图等都在这一层实现。</p>
<p>第三层是存储引擎，存储引擎负责在MySQL中存储数据、提取数据、开启一个事务等等。存储引擎通过API与上层进行通信，这些API屏蔽了不同存储引擎之间的差异，使得这些差异对上层查询过程透明。存储引擎不会去解析SQL。</p>
<p>Mysql最常用的存储引擎是InnoDB</p>
<h6 id="mysql的并发控制" tabindex="-1"><a class="header-anchor" href="#mysql的并发控制" aria-hidden="true">#</a> Mysql的并发控制</h6>
<p>如果多个线程同时操作数据，就有可能引发并发控制的问题。本文接下来将介绍MySQL是如何控制并发读写的。</p>
<h6 id="读写锁" tabindex="-1"><a class="header-anchor" href="#读写锁" aria-hidden="true">#</a> 读写锁</h6>
<p>如果多个线程都只是读数据，其实可以一起读，不会互相影响，这个时候应该使用“读锁”，也称为共享锁。获取读锁的线程之间互相不会阻塞，可以同时读取一个资源。</p>
<p>如果有一个线程需要写数据，则应该使用“写锁”，也成为排它锁。写锁会阻塞其它的写锁和读锁，直至写操作完成。</p>
<h6 id="锁粒度" tabindex="-1"><a class="header-anchor" href="#锁粒度" aria-hidden="true">#</a> 锁粒度</h6>
<p>首先明确一个概念：在给定的资源上，需要加锁的数据越少，系统能够承载的并发量就越高。但加锁也是需要消耗资源的，如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受影响。</p>
<p>所以一个好的“锁策略”就是要在锁的开销和数据的安全性之间寻求平衡，Mysql支持多个存储引擎的架构，每种存储引擎都可以实现自己的锁策略和锁粒度。</p>
<h6 id="表锁和行锁" tabindex="-1"><a class="header-anchor" href="#表锁和行锁" aria-hidden="true">#</a> 表锁和行锁</h6>
<p>表锁顾名思义就是锁住整张表。表锁开销比较小。对表加写锁后，其它用户对这张表的所有读写操作都会被阻塞。在MySQL中，尽管存储引擎可以提供自己的锁，但MySQL有时候也会使用表锁，比如 ALTER TABLE 之类的语句。</p>
<p>写锁比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面。</p>
<p>行级锁即锁住整行，可以最大程度地支持并发处理，但加解锁的开销也会比较大。行级锁只在储存引擎层实现，所有的存储引擎都以自己的方式实现了行级锁。</p>
<h6 id="mvcc" tabindex="-1"><a class="header-anchor" href="#mvcc" aria-hidden="true">#</a> MVCC</h6>
<p>MVCC即“多版本并发控制”，可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。</p>
<p>主流的关系型数据库都实现了MVCC，但实现机制各有不同。实际上MVCC也没有一个统一的标准。但大都实现了非阻塞的读操作，写操作也只是锁定必要的行。</p>
<p>MVCC保证的是每个事务里面在执行期间看到的数据都是一致的。但不同的事务由于开始的时间不同，所以可能对同一张表，同一时刻看到的数据是不一样的。</p>
<p>在MySQL的InnoDB引擎，是通过给每行记录后面保存两个隐藏的列来实现的。一个是保存行的创建时间，另一个保存了行的过期时间(或删除时间)。</p>
<p>实际上存储的并不是实际的一个时间戳，而是“系统版本号”。</p>
<p>每次开启一个事务，系统版本号都会递增。事务开始时，系统版本号会作为事务的版本号，用来和查询到的行的版本号进行比较。下面分别介绍常见的CRUD操作中版本号是怎么工作的：</p>
<p>INSERT</p>
<p>保存当前系统版本号作为行版本号</p>
<p>DELETE</p>
<p>保存当前的系统版本号到这行数据的“删除版本”。</p>
<p>UPDATE</p>
<p>插入一行新纪录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行的“删除版本”。</p>
<p>SELECT</p>
<p>只查找版本早于当前事务版本的行。这样可以保证事务读取都的行，要么之前就存在，要么是这个事务本身自己插入或者修改的。</p>
<p>行的“删除版本”要么未定义，要么大于当前事务版本号。这样可以确保事务读取到的行，在事务之前没有被删除。</p>
<p>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作，其它两个隔离级别不能工作。因为READ UNCOMMITTED总是读取最新的数据防，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。</p>
<h3 id="_9-mysql-写-并发能力-高性能" tabindex="-1"><a class="header-anchor" href="#_9-mysql-写-并发能力-高性能" aria-hidden="true">#</a> 9.mysql 写 并发能力_高性能</h3>
<h4 id="mysql-二-并发控制" tabindex="-1"><a class="header-anchor" href="#mysql-二-并发控制" aria-hidden="true">#</a> MySQL（二）：并发控制</h4>
<p>无论何时，只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。</p>
<h6 id="读写锁-1" tabindex="-1"><a class="header-anchor" href="#读写锁-1" aria-hidden="true">#</a> 读写锁</h6>
<p>在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁(shared lock)和排他锁(exclusive lock)，也叫读锁(read lock)和写锁(write lock)。</p>
<p>锁的概念如下：</p>
<p>读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。</p>
<p>写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，这是出于安全策略的考虑，只有这样，才能确保在给定的时间里，只有一个用户能执行写入，并防止其他用户读取正在写入的同一资源。</p>
<p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL会通过锁定防止其他用户读取同一数据。大多数时候，MySQL锁的内部管理都是透明的(自动加锁)。</p>
<p>锁粒度</p>
<p>一种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。更理想的方式是，只对会修改的数据片进行精确的锁定。任何时候，在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。</p>
<p>MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。</p>
<h6 id="表锁-table-lock" tabindex="-1"><a class="header-anchor" href="#表锁-table-lock" aria-hidden="true">#</a> 表锁(table lock)</h6>
<p>表锁是MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表，一个用户在对表进行写操作(插入、删除、更新等)前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获得读锁，读锁之间是不相互阻塞的。</p>
<p>在特定的场景中，表锁也可能有良好的性能。例如，READ LOCAL表锁支持某些类型的并发写操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面(写锁可以插入到锁队列中读锁的前面，反之读锁则不能插入到写锁的前面)。</p>
<p>尽管存储引擎可以管理自己的锁，MySQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。</p>
<p>表锁的优势：开销小；加锁快；无死锁</p>
<p>表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低</p>
<p>加锁的方式：自动加锁。查询操作(SELECT)，会自动给涉及的所有表加读锁，更新操作(UPDATE、DELETE、INSERT)，会自动给涉及的表加写锁。也可以显示加锁：</p>
<p>共享读锁：lock table tableName read;</p>
<p>独占写锁：lock table tableName write;</p>
<p>批量解锁：unlock tables;</p>
<h6 id="行级锁-row-lock" tabindex="-1"><a class="header-anchor" href="#行级锁-row-lock" aria-hidden="true">#</a> 行级锁(row lock)</h6>
<p>行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销)。在InnoDB和XtraDB，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而MySQL服务器层没有实现。服务器层完全不了解存储引擎中的锁实现，所有的存储引擎都以自己的方式显现了锁机制。</p>
<p>行锁的劣势：开销大；加锁慢；会出现死锁</p>
<p>行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强</p>
<p>加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：</p>
<p>共享锁：select * from tableName where ... + lock in share mode</p>
<p>排他锁：select * from tableName where ... + for update</p>
<p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。</p>
<h6 id="间隙锁" tabindex="-1"><a class="header-anchor" href="#间隙锁" aria-hidden="true">#</a> 间隙锁</h6>
<p>在行级锁的基础上，当用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做&quot;间隙(GAP)&quot;。InnoDB也会对这个&quot;间隙&quot;加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p>
<p>事务1mysql&gt; update innodb_lock set k=66 where id &gt;=6;</p>
<p>Query OK,1 row affected (0.33sec)</p>
<p>mysql&gt;commit;</p>
<p>事务2mysql&gt; insert into innodb_lock (id,k,v) values(8,'8','8000');</p>
<p>Query OK,1 row affected (12.99 sec)</p>
<p>第一个事务锁住了不存在的id，导致第二个事务执行插入时阻塞。</p>
<p>危害(坑)：若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响。</p>
<h3 id="_10-mysql是自动表锁定吗-mysql数据库表怎么锁定" tabindex="-1"><a class="header-anchor" href="#_10-mysql是自动表锁定吗-mysql数据库表怎么锁定" aria-hidden="true">#</a> 10.mysql是自动表锁定吗_MySQL数据库表怎么锁定</h3>
<p>如果你同时运行表的检查/修复程序时，你或许不想让MySQL服务器和实用程序同时访问一个表。如果两个程序都向表中写数据显然会造成很大的麻烦，甚至会有意外情况发生。如果表正由一个程序写入，同时进行读取的另一个程序也会产生混乱的结果。本文主要讲述如何对MySQL数据库表进行锁定。锁定表的方法</p>
<p>防止客户机的请求互相干扰或者服务器与维护程序相互干扰的方法主要有多种。如果你关闭数据库，就可以保证服务器和myisamchk和 isamchk之间没有交互作用。但是停止服务器的运行并不是一个好注意，因为这样做会使得没有故障的数据库和表也不可用。本节主要讨论的过程，是避免服务器和myisamchk或isamchk之间的交互作用。实现这种功能的方法是对表进行锁定。</p>
<p>服务器由两种表的锁定方法：</p>
<p>1.内部锁定</p>
<p>内部锁定可以避免客户机的请求相互干扰——例如，避免客户机的SELECT查询被另一个客户机的UPDATE查询所干扰。也可以利用内部锁定机制防止服务器在利用myisamchk或isamchk检查或修复表时对表的访问。</p>
<p>语法：</p>
<p>锁定表：LOCK TABLES tbl_name {READ | WRITE},[ tbl_name {READ | WRITE},…]</p>
<p>解锁表：UNLOCK TABLES</p>
<p>LOCK TABLES为当前线程锁定表。UNLOCK TABLES释放被当前线程持有的任何锁。当线程发出另外一个LOCK TABLES时，或当服务器的连接被关闭时，当前线程锁定的所有表自动被解锁。</p>
<p>如果一个线程获得在一个表上的一个READ锁，该线程(和所有其他线程)只能从表中读。如果一个线程获得一个表上的一个WRITE锁，那么只有持锁的线程READ或WRITE表，其他线程被阻止。</p>
<p>每个线程等待(没有超时)直到它获得它请求的所有锁。</p>
<p>WRITE锁通常比READ锁有更高的优先级，以确保更改尽快被处理。这意味着，如果一个线程获得READ锁，并且然后另外一个线程请求一个WRITE锁, 随后的READ锁请求将等待直到WRITE线程得到了锁并且释放了它。</p>
<p>显然对于检查，你只需要获得读锁。再者钟情跨下，只能读取表，但不能修改它，因此他也允许其它客户机读取表。对于修复，你必须获得些所以防止任何客户机在你对表进行操作时修改它。</p>
<p>2.外部锁定</p>
<p>服务器还可以使用外部锁定(文件级锁)来防止其它程序在服务器使用表时修改文件。通常，在表的检查操作中服务器将外部锁定与myisamchk或 isamchk作合使用。但是，外部锁定在某些系统中是禁用的，因为他不能可靠的进行工作。对运行myisamchk或isamchk所选择的过程取决于服务器是否能使用外部锁定。如果不使用，则必修使用内部锁定协议。</p>
<p>如果服务器用--skip-locking选项运行，则外部锁定禁用。该选项在某些系统中是缺省的，如Linux。可以通过运行mysqladmin variables命令确定服务器是否能够使用外部锁定。检查skip_locking变量的值并按以下方法进行：如果skip_locking为off，则外部锁定有效您可以继续并运行人和一个实用程序来检查表。服务器和实用程序将合作对表进行访问。但是，运行任何一个实用程序之前，应该使用mysqladmin flush-tables。为了修复表，应该使用表的修复锁定协议。</p>
<p>如果skip_locaking为on，则禁用外部锁定，所以在myisamchk或isamchk检查修复表示服务器并不知道，最好关闭服务器。如果坚持是服务器保持开启状态，月确保在您使用此表示没有客户机来访问它。必须使用卡党的锁定协议告诉服务器是该表不被其他客户机访问。</p>
<p>检查表的锁定协议</p>
<p>本节只介绍如果使用表的内部锁定。对于检查表的锁定协议，此过程只针对表的检查，不针对表的修复。</p>
<p>1.调用mysql发布下列语句：$mysql –u root –p db_namemysql&gt;LOCK TABLE tbl_name READ;mysql&gt;FLUSH TABLES;</p>
<p>该锁防止其它客户机在检查时写入该表和修改该表。FLUSH语句导致服务器关闭表的文件，它将刷新仍在告诉缓存中的任何为写入的改变。</p>
<p>2.执行检查过程$myisamchk tbl_name$ isamchk tbl_name</p>
<p>3.释放表锁mysql&gt;UNLOCK TABLES;</p>
<p>如果myisamchk或isamchk指出发现该表的问题，将需要执行表的修复。
————————————————
版权声明：本文为CSDN博主「不贪吃」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_27102543/article/details/113333289</p>
<h3 id="_11-mysql-表锁-自动关闭-mysql表锁-总以为自己懂了" tabindex="-1"><a class="header-anchor" href="#_11-mysql-表锁-自动关闭-mysql表锁-总以为自己懂了" aria-hidden="true">#</a> 11.mysql 表锁 自动关闭_MySQL表锁，总以为自己懂了</h3>
<p>关于 MySQL 的如下问题，你能准确的答出来么？</p>
<p>(1)和行锁相比，表锁有什么优势？</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>（1）表锁占用内存少很多，行锁的数量与行记录数相关，非常耗内存；

（2）如果业务经常读写表中很大一部分数据时，表锁会更快，因为此时只涉及一个锁，而不是同时管理N多个锁；

（3）如果业务经常使用group by，表锁会更快，原因同（2）；

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(2)频繁 group by 的业务，用 MyISAM 更好，还是 InnoDB 更好，为什么？</p>
<p>(3)某个 session 占有了表写锁，有另外 N 个 session 又要对表进行写操作，MySQL 是如何处理的？</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>表锁是怎么运作的？

和其他临界资源的读写锁类似。

写时，要加写锁：

（1）如果表没有锁，对表加写锁；

（2）否则，入写锁队列；

读时，要加读锁：

（1）如果表没有写锁，对表加读锁；

（2）否则，入读锁队列；

表锁释放时：
如果写锁队列和读锁队列里都有锁，写有更高的优先级，即写锁队列先出列。这么做的原因是，如果有“大查询”，可能会导致写锁被批量“饿死”，而写锁往往释放很快。

画外音：潜台词是，如果有大量并发update请求，select会等所有update请求执行完才执行。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>(4)某个 session 释放了表写锁，有另外 N 个 session 要对表进行写操作，同时还有 M 个 session 要对表进行读操作，谁先抢到锁，为什么？</p>
<p>(5)如何判断表锁是不是主要冲突点？</p>
<p>如果要分析表锁冲突情况，可查看：</p>
<p>Table_locks_immediate：立刻获得表锁的次数；</p>
<p>Table_locks_waited：需要等待表锁的次数；</p>
<p>这两个变量。</p>
<p>使用以下命令查看：</p>
<p>show status like 'Table%';</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/form111at,png" alt="img"></p>
<p>如果等待表锁的次数占比较大，说明表锁可能是潜在瓶颈。</p>
<p>(6)如何高效的实现并发插入与查询，如何互斥？</p>
<p>(7)MyISAM 什么情况下，数据文件会出现空洞？</p>
<p>(8)MyISAM，假如数据文件有空洞，新插入的数据是先补上空洞，还是插入在文件尾部？</p>
<h5 id="为什么在并发插入量比较大的时候-比较适合使用myisam呢-不会因为表锁频繁冲突而导致吞吐量降低吗" tabindex="-1"><a class="header-anchor" href="#为什么在并发插入量比较大的时候-比较适合使用myisam呢-不会因为表锁频繁冲突而导致吞吐量降低吗" aria-hidden="true">#</a> 为什么在并发插入量比较大的时候，比较适合使用MyISAM呢？不会因为表锁频繁冲突而导致吞吐量降低吗？</h5>
<p>**知识点一：**MyISAM的索引与记录存储分离，有单独的区域存储行记录，PK是非聚集索引。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/827744-20200109172553620-521491159.png" alt="img"></p>
<p>**知识点二：**MyISAM表，如果数据文件(data file)紧密存储，中间没有空闲块(free blocks)，数据总是插入到数据文件的尾部(end)，就如同追加日志一样，性能很高，此时的并发insert与select是不加锁的(lock free)。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/827744-20200109172604732-167867055.png" alt="img"></p>
<p>如上图所示：</p>
<p>（1）数据文件连续且紧密的存储着；</p>
<p>（2）并发insert无表锁争抢（只需插入队列互斥）；</p>
<p>（3）insert只在数据文件的尾部进行；</p>
<p>（4）并发select也能够同时进行（共享读锁）；</p>
<p>**知识点三：**MyISAM表，如果数据文件(data file)中间有空洞(hole)，上述机制会失效，直到空洞被新数据填满，又会启用不加锁机制。 **空洞是怎么导致的？**删除或者修改数据，都可能导致空洞。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/827744-20200109172612233-1847283865.png" alt="img"></p>
<p>如上图所示：</p>
<p>（1）中间删除了一些数据，导致中间出现空闲块(free blocks)；</p>
<p>（2）此时，select和insert会有表锁冲突，无法并发；</p>
<p><img src="https://img2018.cnblogs.com/blog/827744/202001/827744-20200109172621297-297847862.png" alt="img"></p>
<p>再如上图所示：</p>
<p>（1）随着插入的进行，中间的空闲块又被填满了；</p>
<p>（2）此时，并发select和insert又恢复了；</p>
<p><strong>结论</strong>：虽然MyISAM只支持表锁，但高并发select与insert的业务场景，上述机制使得MyISAM的<strong>表锁</strong>依然有非常强劲的性能。</p>
<p>但如果你花 1 分钟认真阅读了《频繁插入 (insert) 的业务，用什么存储引擎更合适？》，上述问题都是小 case。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/f2867daa78bc0506415a79da60479644.png" alt="f2867daa78bc0506415a79da60479644.png"></p>
<h3 id="_12-mysql事务中update是否会锁表" tabindex="-1"><a class="header-anchor" href="#_12-mysql事务中update是否会锁表" aria-hidden="true">#</a> 12.Mysql事务中Update是否会锁表？</h3>
<h4 id="两种情况" tabindex="-1"><a class="header-anchor" href="#两种情况" aria-hidden="true">#</a> 两种情况：</h4>
<p>1.带索引 2.不带索引</p>
<h4 id="前提介绍" tabindex="-1"><a class="header-anchor" href="#前提介绍" aria-hidden="true">#</a> 前提介绍：</h4>
<p>方式：采用命令行的方式来模拟</p>
<p>1.mysq由于默认是开启自动提交事务，所以首先得查看自己当前的数据库是否开启了自动提交事务。</p>
<p>命令：select @@autocommit;</p>
<p>结果如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>+``--------------+``| @@autocommit |``+``--------------+``| 0 |``+``--------------+
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>如果是1，那么运行命令：set autocommit = 0;设置为不开启自动提交</p>
<p>2.当前的数据库表格式如下</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>tb_user | ``CREATE` `TABLE` ``tb_user` (`` ```id` ``bigint``(20) ``NOT` `NULL` `AUTO_INCREMENT,`` `````name``` ``varchar``(32) ``DEFAULT` `NULL``,`` ```phone` ``varchar``(11) ``DEFAULT` `NULL``,`` ```operator` ``varchar``(32) ``DEFAULT` `NULL``,`` ```gmt_create` datetime ``DEFAULT` `NULL``,`` ```gmt_modified` datetime ``DEFAULT` `NULL``,`` ``PRIMARY` `KEY` `(`id`)``) ENGINE=InnoDB AUTO_INCREMENT=3 ``DEFAULT` `CHARSET=utf8
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>显然除了主键，我没有加任何索引</p>
<h4 id="实际例子" tabindex="-1"><a class="header-anchor" href="#实际例子" aria-hidden="true">#</a> 实际例子：</h4>
<h5 id="_1-没有索引" tabindex="-1"><a class="header-anchor" href="#_1-没有索引" aria-hidden="true">#</a> <strong>1.没有索引</strong></h5>
<p>运行命令：begin;开启事务，然后运行命令：update tb_user set phone=11 where name=&quot;c1&quot;;修改，先别commit事务。</p>
<p>再开一个窗口，直接运行命令：update tb_user set phone=22 where name=“c2”;会发现命令卡住了，但是当前面一个事务通过commit提交了，命令就会正常运行结束，说明是被锁表了。</p>
<h5 id="_2-给name字段加索引" tabindex="-1"><a class="header-anchor" href="#_2-给name字段加索引" aria-hidden="true">#</a> <strong>2.给name字段加索引</strong></h5>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>create` `index` `index_name ``on` `tb_user(``name``);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后继续如1里面的操作，也就是一个开启事务，运行update tb_user set phone=11 where name=&quot;c1&quot;；先不提交</p>
<p>然后另一个运行update tb_user set phone=22 where name=&quot;c2&quot;;发现命令不会卡住，说明没有锁表</p>
<p>但是如果另一个也是update tb_user set phone=22 where name=&quot;c1&quot;;更新同一行，说明是锁行了</p>
<p><strong>3.总结</strong></p>
<p><strong>如果没有索引，update会锁表，如果加了索引，就会锁行</strong></p>
<h3 id="_13-mysql-表锁和行锁机制" tabindex="-1"><a class="header-anchor" href="#_13-mysql-表锁和行锁机制" aria-hidden="true">#</a> 13.MySQL 表锁和行锁机制</h3>
<p>行锁变表锁，是福还是坑？如果你不清楚MySQL加锁的原理，你会被它整的很惨！不知坑在何方？没事，我来给你们标记几个坑。遇到了可别乱踩。通过本章内容，带你学习MySQL的行锁，表锁，两种锁的优缺点，行锁变表锁的原因，以及开发中需要注意的事项。还在等啥？经验等你来拿！</p>
<p>MySQL的存储引擎是从MyISAM到InnoDB，锁从表锁到行锁。后者的出现从某种程度上是弥补前者的不足。比如：MyISAM不支持事务，InnoDB支持事务。表锁虽然开销小，锁表快，但高并发下性能低。行锁虽然开销大，锁表慢，但高并发下相比之下性能更高。事务和行锁都是在确保数据准确的基础上提高并发的处理能力。本章重点介绍InnoDB的行锁。</p>
<h4 id="案例分析" tabindex="-1"><a class="header-anchor" href="#案例分析" aria-hidden="true">#</a> 案例分析</h4>
<p>目前，MySQL常用的存储引擎是InnoDB，相对于MyISAM而言。InnoDB更适合高并发场景，同时也支持事务处理。我们通过下面这个案例(坑)，来了解行锁和表锁。
业务：因为订单重复导入，需要用脚本将订单状态为&quot;待客服确认&quot;且平台是&quot;xxx&quot;的数据批量修改为&quot;已关闭&quot;。
说明：避免直接修改订单表造成数据异常。这里用innodb_lock 表演示InnoDB的行锁。表中有三个字段：id，k(key值)，v(value值)。
步骤：
第一步：连接数据库，这里为了方便区分命名为Transaction-A，设置autocommit为零，表示需手动提交事务。
第二步：Transaction-A，执行update修改id为1的命令。
第三步：新增一个连接，命名为Transaction-B，能正常修改id为2的数据。再执行修改id为1的数据命令时，却发现该命令一直处理阻塞等待中。
第四步：Transaction-A，执行commit命令。Transaction-B，修改id为1的命令自动执行，等待37.51秒。</p>
<p>总结：<strong>多个事务操作同一行数据时，后来的事务处于阻塞等待状态。这样可以避免了脏读等数据一致性的问题。后来的事务可以操作其他行数据，解决了表锁高并发性能低的问题</strong>。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code><span class="token comment"># Transaction-A</span>
mysql<span class="token operator">></span> <span class="token keyword">set</span> autocommit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'1001'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> <span class="token keyword">commit</span><span class="token punctuation">;</span>

<span class="token comment"># Transaction-B</span>
mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'2001'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.37</span> sec<span class="token punctuation">)</span>
mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'1002'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">37.51</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>有了上面的模拟操作，结果和理论又惊奇的一致，似乎可以放心大胆的实战。。。。。。但现实真的很残酷。
现实：当执行批量修改数据脚本的时候，行锁升级为表锁。其他对订单的操作都处于等待中，，，
原因：InnoDB只有在通过索引条件检索数据时使用行级锁，否则使用表锁！而模拟操作正是通过id去作为检索条件，而id又是MySQL自动创建的唯一索引，所以才忽略了行锁变表锁的情况。
步骤：
第一步：还原问题，Transaction-A，通过k=1更新v。Transaction-B，通过k=2更新v，命令处于阻塞等待状态。
第二步：处理问题，给需要作为查询条件的字段添加索引。用完后可以删掉。</p>
<p>总结：<strong>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁</strong>。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code><span class="token keyword">Transaction</span><span class="token operator">-</span>A
mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'1002'</span> <span class="token keyword">where</span> k<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> <span class="token keyword">commit</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> <span class="token keyword">create</span> <span class="token keyword">index</span> idx_k <span class="token keyword">on</span> innodb_lock<span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">Transaction</span><span class="token operator">-</span>B
mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'2002'</span> <span class="token keyword">where</span> k<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">19.82</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>从上面的案例看出，行锁变表锁似乎是一个坑，可MySQL没有这么无聊给你挖坑。这是因为MySQL有自己的执行计划。
当你需要更新一张较大表的大部分甚至全表的数据时。而你又傻乎乎地用索引作为检索条件。一不小心开启了行锁(没毛病啊！保证数据的一致性！)。可MySQL却认为大量对一张表使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突问题，性能严重下降。所以MySQL会将行锁升级为表锁，即实际上并没有使用索引。
我们仔细想想也能理解，既然整张表的大部分数据都要更新数据，在一行一行地加锁效率则更低。其实我们可以通过explain命令查看MySQL的执行计划，你会发现key为null。表明MySQL实际上并没有使用索引，行锁升级为表锁也和上面的结论一致。</p>
<h4 id="行锁" tabindex="-1"><a class="header-anchor" href="#行锁" aria-hidden="true">#</a> 行锁</h4>
<p>行锁的劣势：开销大；加锁慢；会出现死锁
行锁的优势：锁的粒度小，发生锁冲突的概率低；处理并发的能力强
加锁的方式：自动加锁。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁；对于普通SELECT语句，InnoDB不会加任何锁；当然我们也可以显示的加锁：
共享锁：select * from tableName where ... + lock in share more
排他锁：select * from tableName where ... + for update
InnoDB和MyISAM的最大不同点有两个：一，InnoDB支持事务(transaction)；二，默认采用行级锁。加锁可以保证事务的一致性，可谓是有人(锁)的地方，就有江湖(事务)；我们先简单了解一下事务知识。</p>
<h4 id="mysql-事务属性" tabindex="-1"><a class="header-anchor" href="#mysql-事务属性" aria-hidden="true">#</a> MySQL 事务属性</h4>
<p>事务是由一组SQL语句组成的逻辑处理单元，事务具有ACID属性。
<strong>原子性</strong>（Atomicity）：事务是一个原子操作单元。在当时原子是不可分割的最小元素，其对数据的修改，要么全部成功，要么全部都不成功。
<strong>一致性</strong>（Consistent）：事务开始到结束的时间段内，数据都必须保持一致状态。
<strong>隔离性</strong>（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的&quot;独立&quot;环境执行。
<strong>持久性</strong>（Durable）：事务完成后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。</p>
<h4 id="事务常见问题" tabindex="-1"><a class="header-anchor" href="#事务常见问题" aria-hidden="true">#</a> 事务常见问题</h4>
<p><strong>更新丢失</strong>（Lost Update）
原因：当多个事务选择同一行操作，并且都是基于最初选定的值，由于每个事务都不知道其他事务的存在，就会发生更新覆盖的问题。类比github提交冲突。</p>
<p><strong>脏读</strong>（Dirty Reads）
原因：事务A读取了事务B已经修改但尚未提交的数据。若事务B回滚数据，事务A的数据存在不一致性的问题。</p>
<p><strong>不可重复读</strong>（Non-Repeatable Reads）
原因：事务A第一次读取最初数据，第二次读取事务B已经提交的修改或删除数据。导致两次读取数据不一致。不符合事务的隔离性。</p>
<p><strong>幻读</strong>（Phantom Reads）
原因：事务A根据相同条件第二次查询到事务B提交的新增数据，两次数据结果集不一致。不符合事务的隔离性。</p>
<p>幻读和脏读有点类似
脏读是事务B里面修改了数据，
幻读是事务B里面新增了数据。</p>
<h4 id="事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#事务的隔离级别" aria-hidden="true">#</a> 事务的隔离级别</h4>
<p>数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大。这是因为事务隔离实质上是将事务在一定程度上&quot;串行&quot;进行，这显然与&quot;并发&quot;是矛盾的。根据自己的业务逻辑，权衡能接受的最大副作用。从而平衡了&quot;隔离&quot; 和 &quot;并发&quot;的问题。MySQL默认隔离级别是可重复读。
脏读，不可重复读，幻读，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code><span class="token operator">+</span><span class="token comment">------------------------------+---------------------+--------------+--------------+--------------+</span>
<span class="token operator">|</span> 隔离级别                      <span class="token operator">|</span> 读数据一致性         <span class="token operator">|</span> 脏读         <span class="token operator">|</span> 不可重复 读   <span class="token operator">|</span> 幻读         <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------------------+---------------------+--------------+--------------+--------------+</span>
<span class="token operator">|</span> 未提交读<span class="token punctuation">(</span><span class="token keyword">Read</span> <span class="token keyword">uncommitted</span><span class="token punctuation">)</span>    <span class="token operator">|</span> 最低级别            <span class="token operator">|</span> 是            <span class="token operator">|</span> 是           <span class="token operator">|</span> 是           <span class="token operator">|</span> 
<span class="token operator">+</span><span class="token comment">------------------------------+---------------------+--------------+--------------+--------------+</span>
<span class="token operator">|</span> 已提交读<span class="token punctuation">(</span><span class="token keyword">Read</span> <span class="token keyword">committed</span><span class="token punctuation">)</span>      <span class="token operator">|</span> 语句级              <span class="token operator">|</span> 否           <span class="token operator">|</span> 是           <span class="token operator">|</span> 是           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------------------+---------------------+--------------+--------------+--------------+</span>
<span class="token operator">|</span> 可重复读<span class="token punctuation">(</span><span class="token keyword">Repeatable</span> <span class="token keyword">read</span><span class="token punctuation">)</span>     <span class="token operator">|</span> 事务级              <span class="token operator">|</span> 否           <span class="token operator">|</span> 否           <span class="token operator">|</span> 是           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------------------+---------------------+--------------+--------------+--------------+</span>
<span class="token operator">|</span> 可序列化<span class="token punctuation">(</span><span class="token keyword">Serializable</span><span class="token punctuation">)</span>        <span class="token operator">|</span> 最高级别，事务级     <span class="token operator">|</span> 否           <span class="token operator">|</span> 否           <span class="token operator">|</span> 否           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">------------------------------+---------------------+--------------+--------------+--------------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>查看当前数据库的事务隔离级别：show variables like 'tx_isolation';</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code>mysql<span class="token operator">></span> <span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'tx_isolation'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">---------------+-----------------+</span>
<span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span>           <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-----------------+</span>
<span class="token operator">|</span> tx_isolation  <span class="token operator">|</span> <span class="token keyword">REPEATABLE</span><span class="token operator">-</span><span class="token keyword">READ</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">---------------+-----------------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="间隙锁-1" tabindex="-1"><a class="header-anchor" href="#间隙锁-1" aria-hidden="true">#</a> 间隙锁</h4>
<p>当我们用范围条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做&quot;间隙(GAP)&quot;。InnoDB也会对这个&quot;间隙&quot;加锁，这种锁机制就是所谓的间隙锁(Next-Key锁)。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code><span class="token keyword">Transaction</span><span class="token operator">-</span>A
mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> k<span class="token operator">=</span><span class="token number">66</span> <span class="token keyword">where</span> id <span class="token operator">>=</span><span class="token number">6</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.63</span> sec<span class="token punctuation">)</span>
mysql<span class="token operator">></span> <span class="token keyword">commit</span><span class="token punctuation">;</span>

<span class="token keyword">Transaction</span><span class="token operator">-</span>B
mysql<span class="token operator">></span> <span class="token keyword">insert</span> <span class="token keyword">into</span> innodb_lock <span class="token punctuation">(</span>id<span class="token punctuation">,</span>k<span class="token punctuation">,</span>v<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">'7'</span><span class="token punctuation">,</span><span class="token string">'7000'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">18.99</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>危害(坑)：<strong>若执行的条件是范围过大，则InnoDB会将整个范围内所有的索引键值全部锁定，很容易对性能造成影响</strong>。</p>
<h4 id="排他锁" tabindex="-1"><a class="header-anchor" href="#排他锁" aria-hidden="true">#</a> 排他锁</h4>
<p>排他锁，也称写锁，独占锁，当前写操作没有完成前，它会阻断其他写锁和读锁。
<img src="https://segmentfault.com/img/remote/1460000012773162?w=630&amp;h=513" alt="排他锁"></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code><span class="token comment"># Transaction_A</span>
mysql<span class="token operator">></span> <span class="token keyword">set</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> innodb_lock <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">4</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> k    <span class="token operator">|</span> v    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">4</span>    <span class="token operator">|</span> <span class="token number">4000</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'4001'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>

mysql<span class="token operator">></span> <span class="token keyword">commit</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.04</span> sec<span class="token punctuation">)</span>
<span class="token comment"># Transaction_B</span>
mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> innodb_lock <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">4</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> k    <span class="token operator">|</span> v    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">4</span>    <span class="token operator">|</span> <span class="token number">4001</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">9.53</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="共享锁" tabindex="-1"><a class="header-anchor" href="#共享锁" aria-hidden="true">#</a> 共享锁</h4>
<p>共享锁，也称读锁，多用于判断数据是否存在，多个读操作可以同时进行而不会互相影响。当如果事务对读锁进行修改操作，很可能会造成死锁。如下图所示。
<img src="https://segmentfault.com/img/remote/1460000012773163?w=629&amp;h=465" alt="共享锁"></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code><span class="token comment"># Transaction_A</span>
mysql<span class="token operator">></span> <span class="token keyword">set</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> innodb_lock <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">4</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> k    <span class="token operator">|</span> v    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">4</span>    <span class="token operator">|</span> <span class="token number">4001</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'4002'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">31.29</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Rows</span> <span class="token keyword">matched</span>: <span class="token number">1</span>  Changed: <span class="token number">1</span>  <span class="token keyword">Warnings</span>: <span class="token number">0</span>
<span class="token comment"># Transaction_B</span>
mysql<span class="token operator">></span> <span class="token keyword">set</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> innodb_lock <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">4</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token operator">|</span> id <span class="token operator">|</span> k    <span class="token operator">|</span> v    <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token operator">|</span>  <span class="token number">4</span> <span class="token operator">|</span> <span class="token number">4</span>    <span class="token operator">|</span> <span class="token number">4001</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----+------+------+</span>
<span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'4002'</span> <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
ERROR <span class="token number">1213</span> <span class="token punctuation">(</span><span class="token number">40001</span><span class="token punctuation">)</span>: Deadlock found <span class="token keyword">when</span> trying <span class="token keyword">to</span> get <span class="token keyword">lock</span><span class="token punctuation">;</span> try restarting <span class="token keyword">transaction</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="分析行锁定" tabindex="-1"><a class="header-anchor" href="#分析行锁定" aria-hidden="true">#</a> 分析行锁定</h4>
<p>通过检查InnoDB_row_lock 状态变量分析系统上的行锁的争夺情况 show status like 'innodb_row_lock%'</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'innodb_row_lock%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">-------------------------------+-------+</span>
<span class="token operator">|</span> Variable_name                 <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------------------------------+-------+</span>
<span class="token operator">|</span> Innodb_row_lock_current_waits <span class="token operator">|</span> <span class="token number">0</span>     <span class="token operator">|</span>
<span class="token operator">|</span> Innodb_row_lock_time          <span class="token operator">|</span> <span class="token number">0</span>     <span class="token operator">|</span>
<span class="token operator">|</span> Innodb_row_lock_time_avg      <span class="token operator">|</span> <span class="token number">0</span>     <span class="token operator">|</span>
<span class="token operator">|</span> Innodb_row_lock_time_max      <span class="token operator">|</span> <span class="token number">0</span>     <span class="token operator">|</span>
<span class="token operator">|</span> Innodb_row_lock_waits         <span class="token operator">|</span> <span class="token number">0</span>     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">-------------------------------+-------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>innodb_row_lock_current_waits: 当前正在等待锁定的数量
innodb_row_lock_time: 从系统启动到现在锁定总时间长度；非常重要的参数，
innodb_row_lock_time_avg: 每次等待所花平均时间；非常重要的参数，
innodb_row_lock_time_max: 从系统启动到现在等待最常的一次所花的时间；
innodb_row_lock_waits: 系统启动后到现在总共等待的次数；非常重要的参数。直接决定优化的方向和策略。</p>
<h4 id="行锁优化" tabindex="-1"><a class="header-anchor" href="#行锁优化" aria-hidden="true">#</a> 行锁优化</h4>
<p>1 尽可能让所有数据检索都通过索引来完成，避免无索引行或索引失效导致行锁升级为表锁。
2 尽可能避免间隙锁带来的性能下降，减少或使用合理的检索范围。
3 尽可能减少事务的粒度，比如控制事务大小，而从减少锁定资源量和时间长度，从而减少锁的竞争等，提供性能。
4 尽可能低级别事务隔离，隔离级别越高，并发的处理能力越低。</p>
<h4 id="表锁" tabindex="-1"><a class="header-anchor" href="#表锁" aria-hidden="true">#</a> 表锁</h4>
<p>表锁的优势：开销小；加锁快；无死锁
表锁的劣势：锁粒度大，发生锁冲突的概率高，并发处理能力低
加锁的方式：自动加锁。查询操作（SELECT），会自动给涉及的所有表加读锁，更新操作（UPDATE、DELETE、INSERT），会自动给涉及的表加写锁。也可以显示加锁：
共享读锁：lock table tableName read;
独占写锁：lock table tableName write;
批量解锁：unlock tables;</p>
<h4 id="共享读锁" tabindex="-1"><a class="header-anchor" href="#共享读锁" aria-hidden="true">#</a> 共享读锁</h4>
<p>对MyISAM表的读操作（加读锁），不会阻塞其他进程对同一表的读操作，但会阻塞对同一表的写操作。只有当读锁释放后，才能执行其他进程的写操作。在锁释放前不能取其他表。
<img src="https://segmentfault.com/img/remote/1460000012773164?w=645&amp;h=461" alt="读锁"></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code><span class="token keyword">Transaction</span><span class="token operator">-</span>A
mysql<span class="token operator">></span> <span class="token keyword">lock</span> <span class="token keyword">table</span> myisam_lock <span class="token keyword">read</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myisam_lock<span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> innodb_lock<span class="token punctuation">;</span>
ERROR <span class="token number">1100</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: <span class="token keyword">Table</span> <span class="token string">'innodb_lock'</span> was <span class="token operator">not</span> locked <span class="token keyword">with</span> <span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span>

mysql<span class="token operator">></span> <span class="token keyword">update</span> myisam_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'1001'</span> <span class="token keyword">where</span> k<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">;</span>
ERROR <span class="token number">1099</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: <span class="token keyword">Table</span> <span class="token string">'myisam_lock'</span> was locked <span class="token keyword">with</span> a <span class="token keyword">READ</span> <span class="token keyword">lock</span> <span class="token operator">and</span> can<span class="token string">'t be updated

mysql> unlock tables;
Query OK, 0 rows affected (0.00 sec)
Transaction-B
mysql> select * from myisam_lock;
9 rows in set (0.00 sec)

mysql> select * from innodb_lock;
8 rows in set (0.01 sec)

mysql> update myisam_lock set v='</span><span class="token number">1001</span><span class="token string">' where k='</span><span class="token number">1</span>'<span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">18.67</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="独占写锁" tabindex="-1"><a class="header-anchor" href="#独占写锁" aria-hidden="true">#</a> 独占写锁</h4>
<p>对MyISAM表的写操作（加写锁），会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作。在锁释放前不能写其他表。
<img src="https://segmentfault.com/img/remote/1460000012773165" alt="写锁"></p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code><span class="token keyword">Transaction</span><span class="token operator">-</span>A
mysql<span class="token operator">></span> <span class="token keyword">set</span> autocommit<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.05</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">lock</span> <span class="token keyword">table</span> myisam_lock <span class="token keyword">write</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.03</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">update</span> myisam_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'2001'</span> <span class="token keyword">where</span> k<span class="token operator">=</span><span class="token string">'2'</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">1</span> <span class="token keyword">row</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myisam_lock<span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>

mysql<span class="token operator">></span> <span class="token keyword">update</span> innodb_lock <span class="token keyword">set</span> v<span class="token operator">=</span><span class="token string">'1001'</span> <span class="token keyword">where</span> k<span class="token operator">=</span><span class="token string">'1'</span><span class="token punctuation">;</span>
ERROR <span class="token number">1100</span> <span class="token punctuation">(</span>HY000<span class="token punctuation">)</span>: <span class="token keyword">Table</span> <span class="token string">'innodb_lock'</span> was <span class="token operator">not</span> locked <span class="token keyword">with</span> <span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span>

mysql<span class="token operator">></span> <span class="token keyword">unlock</span> <span class="token keyword">tables</span><span class="token punctuation">;</span>
Query OK<span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">rows</span> affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>
<span class="token keyword">Transaction</span><span class="token operator">-</span>B
mysql<span class="token operator">></span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> myisam_lock<span class="token punctuation">;</span>
<span class="token number">9</span> <span class="token keyword">rows</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">42.83</span> sec<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>总结：<strong>表锁，读锁会阻塞写，不会阻塞读。而写锁则会把读写都阻塞</strong>。</p>
<h4 id="查看加锁情况" tabindex="-1"><a class="header-anchor" href="#查看加锁情况" aria-hidden="true">#</a> 查看加锁情况</h4>
<p>show open tables; 1表示加锁，0表示未加锁。</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">open</span> <span class="token keyword">tables</span> <span class="token keyword">where</span> in_use <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----------+-------------+--------+-------------+</span>
<span class="token operator">|</span> <span class="token keyword">Database</span> <span class="token operator">|</span> <span class="token keyword">Table</span>       <span class="token operator">|</span> In_use <span class="token operator">|</span> Name_locked <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------+-------------+--------+-------------+</span>
<span class="token operator">|</span> <span class="token keyword">lock</span>     <span class="token operator">|</span> myisam_lock <span class="token operator">|</span>      <span class="token number">1</span> <span class="token operator">|</span>           <span class="token number">0</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------+-------------+--------+-------------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="分析表锁定" tabindex="-1"><a class="header-anchor" href="#分析表锁定" aria-hidden="true">#</a> 分析表锁定</h4>
<p>可以通过检查table_locks_waited 和 table_locks_immediate 状态变量分析系统上的表锁定：show status like 'table_locks%'</p>
<div class="language-sql line-numbers-mode" data-ext="sql"><pre v-pre class="language-sql"><code>mysql<span class="token operator">></span> <span class="token keyword">show</span> <span class="token keyword">status</span> <span class="token operator">like</span> <span class="token string">'table_locks%'</span><span class="token punctuation">;</span>
<span class="token operator">+</span><span class="token comment">----------------------------+-------+</span>
<span class="token operator">|</span> Variable_name              <span class="token operator">|</span> <span class="token keyword">Value</span> <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------------------------+-------+</span>
<span class="token operator">|</span> Table_locks_immediate      <span class="token operator">|</span> <span class="token number">104</span>   <span class="token operator">|</span>
<span class="token operator">|</span> Table_locks_waited         <span class="token operator">|</span> <span class="token number">0</span>     <span class="token operator">|</span>
<span class="token operator">+</span><span class="token comment">----------------------------+-------+</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>table_locks_immediate: 表示立即释放表锁数。
table_locks_waited: 表示需要等待的表锁数。此值越高则说明存在着越严重的表级锁争用情况。</p>
<p>此外，MyISAM的读写锁调度是写优先，这也是MyISAM不适合做写为主表的存储引擎。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永久阻塞。</p>
<h4 id="什么场景下用表锁" tabindex="-1"><a class="header-anchor" href="#什么场景下用表锁" aria-hidden="true">#</a> 什么场景下用表锁</h4>
<p>InnoDB默认采用行锁，在未使用索引字段查询时升级为表锁。MySQL这样设计并不是给你挖坑。它有自己的设计目的。
即便你在条件中使用了索引字段，MySQL会根据自身的执行计划，考虑是否使用索引(所以explain命令中会有possible_key 和 key)。如果MySQL认为全表扫描效率更高，它就不会使用索引，这种情况下InnoDB将使用表锁，而不是行锁。因此，在分析锁冲突时，别忘了检查SQL的执行计划，以确认是否真正使用了索引。</p>
<p>第一种情况：<strong>全表更新</strong>。事务需要更新大部分或全部数据，且表又比较大。若使用行锁，会导致事务执行效率低，从而可能造成其他事务长时间锁等待和更多的锁冲突。</p>
<p>第二种情况：<strong>多表查询</strong>。事务涉及多个表，比较复杂的关联查询，很可能引起死锁，造成大量事务回滚。这种情况若能一次性锁定事务涉及的表，从而可以避免死锁、减少数据库因事务回滚带来的开销。</p>
<h4 id="页锁" tabindex="-1"><a class="header-anchor" href="#页锁" aria-hidden="true">#</a> 页锁</h4>
<p>开销和加锁时间介于表锁和行锁之间；会出现死锁；锁定粒度介于表锁和行锁之间，并发处理能力一般。只需了解一下。</p>
<h4 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h4>
<p>1 InnoDB 支持表锁和行锁，使用索引作为检索条件修改数据时采用行锁，否则采用表锁。
2 InnoDB 自动给修改操作加锁，给查询操作不自动加锁
3 行锁可能因为未使用索引而升级为表锁，所以除了检查索引是否创建的同时，也需要通过explain执行计划查询索引是否被实际使用。
4 行锁相对于表锁来说，优势在于高并发场景下表现更突出，毕竟锁的粒度小。
5 当表的大部分数据需要被修改，或者是多表复杂关联查询时，建议使用表锁优于行锁。
6 为了保证数据的一致完整性，任何一个数据库都存在锁定机制。锁定机制的优劣直接影响到一个数据库的并发处理能力和性能。</p>
<p>到这里，Mysql的表锁和行锁机制就介绍完了，若你不清楚InnoDB的行锁会升级为表锁，那以后会吃大亏的。若有打什么不对的地方请指正。若觉得文章不错，麻烦点个赞！来都来了，留下你的痕迹吧！</p>
<h3 id="_14-mysql数据库查询记录时是否每次只能使用一个索引" tabindex="-1"><a class="header-anchor" href="#_14-mysql数据库查询记录时是否每次只能使用一个索引" aria-hidden="true">#</a> 14.MySQL数据库查询记录时是否每次只能使用一个索引</h3>
<h4 id="起因" tabindex="-1"><a class="header-anchor" href="#起因" aria-hidden="true">#</a> 起因</h4>
<p>以下是一个不完整的课程表，我只把我需要的字段保留下来了，创建了两个单独的索引 idx_city_id 和idx_start_course_time</p>
<div class="language-c line-numbers-mode" data-ext="c"><pre v-pre class="language-c"><code>CREATE TABLE `t_lesson` <span class="token punctuation">(</span>
    `id` <span class="token function">BIGINT</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> NOT <span class="token constant">NULL</span> AUTO_INCREMENT<span class="token punctuation">,</span>
    `start_course_time` DATETIME NOT <span class="token constant">NULL</span> COMMENT <span class="token char">'预计直播课上课时间'</span><span class="token punctuation">,</span>
    `end_course_time` DATETIME NOT <span class="token constant">NULL</span> COMMENT <span class="token char">'预计直播课下课时间'</span><span class="token punctuation">,</span>
    `city_id` <span class="token function">INT</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> NOT <span class="token constant">NULL</span><span class="token punctuation">,</span>
    PRIMARY <span class="token function">KEY</span> <span class="token punctuation">(</span>`id`<span class="token punctuation">)</span><span class="token punctuation">,</span>
    INDEX `idx_city_id` <span class="token punctuation">(</span>`city_id`<span class="token punctuation">)</span><span class="token punctuation">,</span>
    INDEX `idx_start_course_time` <span class="token punctuation">(</span>`start_course_time`<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token number">123456789</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行以下语句：</p>
<div class="language-c line-numbers-mode" data-ext="c"><pre v-pre class="language-c"><code>explain select <span class="token operator">*</span> from t_lesson where start_course_time <span class="token operator">=</span> <span class="token char">'2019-08-25 06:00:00'</span> and city_id<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
<span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>key 代表 MySQL 实际会使用的索引，是idx_start_course_time
<img src="https://img-blog.csdnimg.cn/20191024162347680.png" alt="在这里插入图片描述">
当时脑子出现了以下几个问题：</p>
<ul>
<li>MySQL 同时只能使用一个索引吗？</li>
<li>什么情况下能使用两个索引呢？</li>
<li>为什么存在两个索引的情况下却只使用了一个索引呢？</li>
</ul>
<h3 id="_15-mysql-同时只能使用一个索引吗" tabindex="-1"><a class="header-anchor" href="#_15-mysql-同时只能使用一个索引吗" aria-hidden="true">#</a> <strong>15.MySQL 同时只能使用一个索引吗？</strong></h3>
<p>网上随处可见，MySQL5.0之后是有索引合并这个概念的，所以第一个问题解决了，MySQL可以同时使用多个索引</p>
<h3 id="_16-什么情况下能使用两个索引呢" tabindex="-1"><a class="header-anchor" href="#_16-什么情况下能使用两个索引呢" aria-hidden="true">#</a> <strong>16.什么情况下能使用两个索引呢？</strong></h3>
<p>以下只做个例子，具体情况可以具体看下索引合并文档</p>
<div class="language-c line-numbers-mode" data-ext="c"><pre v-pre class="language-c"><code>explain select <span class="token operator">*</span> from t_lesson where start_course_time <span class="token operator">=</span> <span class="token char">'2019-08-25 06:00:00'</span> or city_id<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>

<span class="token number">12</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><img src="https://img-blog.csdnimg.cn/20191024162619319.png" alt="在这里插入图片描述" style="zoom:200%;" />
<h3 id="_17-为什么存在两个索引的情况下却只使用了一个索引呢" tabindex="-1"><a class="header-anchor" href="#_17-为什么存在两个索引的情况下却只使用了一个索引呢" aria-hidden="true">#</a> <strong>17.为什么存在两个索引的情况下却只使用了一个索引呢？</strong></h3>
<p>这是我觉得写的比较好的回答：https://segmentfault.com/q/1010000003880137
引用其中的一句话：“与其说是数据库只支持一条查询语句只使用一个索引，倒不如说N条独立索引同时在一条语句使用的消耗比只使用一个索引还要慢。”</p>
<h3 id="_18-l1缓存和l2缓存" tabindex="-1"><a class="header-anchor" href="#_18-l1缓存和l2缓存" aria-hidden="true">#</a> 18.  L1缓存和L2缓存</h3>
<p>缓存大小也是CPU的重要指标之一，而且缓存的结构和大小对CPU速度的影响非常大，CPU内缓存的运行频率极高，一般是和处理器同频运作，工作效率远远大于系统内存和硬盘。实际工作时，CPU往往需要重复读取同样的数据块，而缓存容量的增大，可以大幅度提升CPU内部读取数据的命中率，而不用再到内存或者硬盘上寻找，以此提高系统性能。但是由于CPU芯片面积和成本的因素来考虑，缓存都很小。</p>
<p>L1 Cache(一级缓存)是CPU第一层高速缓存，分为数据缓存和指令缓存。内置的L1高速缓存的容量和结构对CPU的性能影响较大，不过高速缓冲存储器均由静态RAM组成，结构较复杂，在CPU管芯面积不能太大的情况下，L1级高速缓存的容量不可能做得太大。一般服务器CPU的L1缓存的容量通常在32—256KB。</p>
<p>L2 Cache(二级缓存)是CPU的第二层高速缓存，分内部和外部两种芯片。内部的芯片二级缓存运行速度与主频相同，而外部的二级缓存则只有主频的一半。L2高速缓存容量也会影响CPU的性能，原则是越大越好，现在家庭用CPU容量最大的是512KB，而服务器和工作站上用CPU的L2高速缓存更高达256-1MB，有的高达2MB或者3MB。</p>
<p>所以下面2级缓存大的好一点</p>
<h3 id="_19-多个进程去读取redis消息队列是否会发生冲突" tabindex="-1"><a class="header-anchor" href="#_19-多个进程去读取redis消息队列是否会发生冲突" aria-hidden="true">#</a> 19.多个进程去读取redis消息队列是否会发生冲突？</h3>
<p>redis自己保证队列读写的互斥。redis是单线程，工作方式大概是这样的。你的多进程读取其实是可以并行发多个读取请求包，这些请求包到达redis的socket buffer中，redis的处理是串行响应你的请求，无锁。如果哪天redis改成多线程的方式，同样可以通过加锁互斥保证队列的读取不会出事情。</p>
<h3 id="_20-socket-两种连接方式" tabindex="-1"><a class="header-anchor" href="#_20-socket-两种连接方式" aria-hidden="true">#</a> 20.Socket 两种连接方式</h3>
<h4 id="长连接与短连接" tabindex="-1"><a class="header-anchor" href="#长连接与短连接" aria-hidden="true">#</a> <strong>长连接与短连接</strong></h4>
<p>所谓长连接，指在一个TCP连接上可以连续发送多个数据包，在TCP连接保持期间，如果没有数据包发送，需要双方发检测包以维持此连接，一般需要自己做在线维持。</p>
<p>短连接是指通信双方有数据交互时，就建立一个TCP连接，数据发送完成后，则断开此TCP连接，一般银行都使用短连接。</p>
<p>比如http的，只是连接、请求、关闭，过程时间较短,服务器若是一段时间内没有收到请求即可关闭连接。</p>
<p>其实长连接是相对于通常的短连接而说的，也就是长时间保持客户端与服务端的连接状态。</p>
<p>长连接与短连接的操作过程:</p>
<p>通常的短连接操作步骤是：</p>
<p>连接→数据传输→关闭连接；</p>
<p>而长连接通常就是：</p>
<p>连接→数据传输→保持连接(心跳)→数据传输→保持连接(心跳)→……→关闭连接；</p>
<p>这就要求长连接在没有数据通信时，定时发送数据包(心跳)，以维持连接状态，短连接在没有数据传输时直接关闭就行了.</p>
<p><strong>在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接</strong>。</p>
<p>第一次握手：建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；</p>
<p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p>
<p>第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</p>
<p>完成三次握手，客户端与服务器开始传送数据.</p>
<h3 id="_21-什么是高并发" tabindex="-1"><a class="header-anchor" href="#_21-什么是高并发" aria-hidden="true">#</a> 21.什么是高并发？</h3>
<p>多个进程或线程同时（或者说在同一段时间内）访问同一资源会产生并发问题。</p>
<h5 id="初期解决方案" tabindex="-1"><a class="header-anchor" href="#初期解决方案" aria-hidden="true">#</a> 初期解决方案</h5>
<h6 id="高并发时系统或服务器级别的解决方案" tabindex="-1"><a class="header-anchor" href="#高并发时系统或服务器级别的解决方案" aria-hidden="true">#</a> 高并发时系统或服务器级别的解决方案</h6>
<p>增大服务器的CPU
增大内存条
增加硬盘个数，对硬盘做Raid5
换掉免费哦的Tomcat，使用商用weblogic（美国Oracle公司出品的）
增加到二块网卡
聘请系统架构师优化Linux内核
甚至花高价直接购买高性能服务器</p>
<h6 id="应用级别的解决方案" tabindex="-1"><a class="header-anchor" href="#应用级别的解决方案" aria-hidden="true">#</a> 应用级别的解决方案</h6>
<p>网页HTML静态化（需要CMS项目支持）
图片服务期分离（常用解决方案）
缓存（常用解决方案）上上策为分布式缓存
镜像（下载较多）</p>
<h6 id="采用负载均衡技术" tabindex="-1"><a class="header-anchor" href="#采用负载均衡技术" aria-hidden="true">#</a> 采用负载均衡技术</h6>
<p>为了满足业务量增长的需求，衍生出来的一种脸颊有效透明的方法以扩展现有网络设备
和服务器的带宽，增加吞吐量、加强网络数据处理能力，提高网络的灵活性和可用性的技术
就是负载均衡（Load Balance）
三负载均衡
负载均衡有三大作用：1、转发请求 2、故障移除 3、恢复添加
负载均衡种类
1、一种是通过硬件来进行解决，常见的硬件有NetScaler、F5、Radware和Array等商用的
负载均衡器，但是它们是比较昂贵。
2、一种是通过软件来进行解决的，常见的软件有LVS、Nginx、apache等，它们是基于Linux
系统并且开元的负载均衡策略</p>
<p>负载均衡-然间解决
主流软件：1.apache+JK 2、nginx 3、lvs+keepalived</p>
<h3 id="_22-面试介绍" tabindex="-1"><a class="header-anchor" href="#_22-面试介绍" aria-hidden="true">#</a> 22.面试介绍</h3>
<p>您好，很高兴能来本公司面试，我叫牛建军，毕业于郑州轻工业学院，之后在郑州的一家公司做了2年的
java开发。在工作期间大概参与了三个项目的开发。
第一个项目是二手车竞拍管理系统，由于刚到公司所以负责的内容难度不大。第二个项目是一个电器设备公司的资源管理
系统，在这个项目中，我主要负责了系统管理模块、系统技术资料图纸管理模块以及登录模块的开发。系统管理模块又分为用户管理
角色管理、运行监控、数据字典四个子模块，在技术资料图纸管理模块用了lucene搜索，并且有高亮效果。
还负责了权限系统的开发，使用hibernate缓存和sql优化来提高网站性能。
整个负责的模块使用了大量的js和jquery组件，比如fck，jxl，jfreechart，Z-tree等等
第三个项目是一个服装的电商项目。在这个项目中主要负责后台商品管理页面，前台商品列表页面，以及商品详情页和购物车模块。
在前台商品列表页面用页面缓OSCache存来提高性能，商品详情页是后台商品上架时Freemarker自动生成的
网站存在大量的图片读写操作，使用了jersey技术搭建图片服务器集群，这些都缓解了服务器的压力，另外还是用了分布式缓存redis来
提高网站性能，把session存储到redis达到集群下session共享
为了解决网站高并发的问题，在数据库端使用mysql的读写分离和主从复制，在服务器端使用了负载均衡。
我非常热爱java，通过这几年了学习掌握了基本的java开发，但在我面前未知的依然是一片大海，我会努力也希望能够在这个行业更长远的发展。</p>
<h3 id="_23-工具" tabindex="-1"><a class="header-anchor" href="#_23-工具" aria-hidden="true">#</a> 23.工具</h3>
<p>visio是微软的 可以画业务流程图、网络图、工作流图、数据库模型图和软件图
Rational Rose是Rational公司出品的一种面向对象的统一建模语言的可视化建模工具
powerDesigner是设计数据库模型的，包括面向对象模型、业务流程模型、概念数据模型、物理数据模型等</p>
<h3 id="_24-对于大流量的网站-您采用什么样的方法来解决访问量问题" tabindex="-1"><a class="header-anchor" href="#_24-对于大流量的网站-您采用什么样的方法来解决访问量问题" aria-hidden="true">#</a> 24.对于大流量的网站,您采用什么样的方法来解决访问量问题?</h3>
<p>①确认服务器硬件是否足够支持当前的流量
②优化数据库访问
③禁止外部的盗链
④控制大文件的下载
⑤使用不同主机分流主要流量、集群
⑥使用流量分析统计软件</p>
<h3 id="_25-如何实现用户的安全登录" tabindex="-1"><a class="header-anchor" href="#_25-如何实现用户的安全登录" aria-hidden="true">#</a> 25.如何实现用户的安全登录？</h3>
<p>①防止 Sql 注入，对特殊字符进行转义、过滤或者使用预编译的 sql 语句绑定变量。最小权限原则，特别是不要用 root 账户，为不同的类型的动作或者组建使用不同的账户。
②当 sql 运行出错时，不要把数据库返回的错误信息全部显示给用户，以防止泄露服务器和数据库相关信息
③XSS 攻击
④暴力破解</p>
<h1 id="十七-企业级lnmp环境面试必备" tabindex="-1"><a class="header-anchor" href="#十七-企业级lnmp环境面试必备" aria-hidden="true">#</a> 十七.企业级LNMP环境面试必备</h1>
<h3 id="_1-lnmp的工作流程" tabindex="-1"><a class="header-anchor" href="#_1-lnmp的工作流程" aria-hidden="true">#</a> 1.LNMP的工作流程：</h3>
<p>当LNMP工作的时候，首先是用户通过浏览器输入域名请求Nginx Web服务，如果是请求的是静态的资源，则由Nginx解析返回给用户。</p>
<p>如果是动态的资源，那么久通过Fast CGI接口发送给PHP引擎服务(Fast CGI进程php-fpm)进行解析。</p>
<p>如果这个动态的请求要读取数据库，那么PHP就会继续向后请求MySQL数据库，读取需要的数据。</p>
<p>最终通过Nginx服务把获取的数据返回给用户，这就是LNMP的基本流程。</p>
<h3 id="_2-企业选用mysql作为数据库的优点" tabindex="-1"><a class="header-anchor" href="#_2-企业选用mysql作为数据库的优点" aria-hidden="true">#</a> 2.企业选用MySQL作为数据库的优点：</h3>
<p>1.性能卓越，服务稳定，很少出现异常宕机。</p>
<p>2.开放源代码并且没有版权的限制，自主传播，使用成本低。</p>
<p>3.历史悠久，社区及用户非常活跃，遇到问题很快可以获取帮助。</p>
<p>4.软件体积小安装简单，并且易于维护，安装及维护的成本低。</p>
<p>5.支持多种操作系统，提供API接口。</p>
<p>6.品牌效应，使得企业无需考虑就直接使用。</p>
<h3 id="_3-lnmp环境搭建问题" tabindex="-1"><a class="header-anchor" href="#_3-lnmp环境搭建问题" aria-hidden="true">#</a> 3.LNMP环境搭建问题：</h3>
<p>当安装LNMP一体化环境的时候MySQL数据库要装在Nginx所在的服务器上，</p>
<p>如果MySQL和Nginx不在同一台机器上，那么Nginx服务器上的MySQL数据库软件只要解压移动安装目录中就行。</p>
<p>不需要对MySQL进行初始化配置。</p>
<p>在PHP5.3以上的版本中，Nginx服务器上安装了MySQL软件，只需要在编译PHP的时候指定相关参数即可。</p>
<p>编译参数：--with-mysql=mysqlnd</p>
<p>表示在编译的时候会调用内置的MySQL的库。</p>
<h3 id="_4-什么是fcgi" tabindex="-1"><a class="header-anchor" href="#_4-什么是fcgi" aria-hidden="true">#</a> 4.什么是FCGI：</h3>
<p>FastCGI是一个可伸缩的、高速的在HTTP服务器的动态脚本语言间通信的接口(在Linux下，FastCGI就是socket，这个socket可以是文件socket或IPsocket)。</p>
<p>FastCGI采用C/S架构，它可以将HTTP服务器和脚本服务器分开，同时还可以在脚本解析服务器上启动一个或多个服务器来解析守护进程。</p>
<p>当HTTP服务器遇到动态程序的时候，可以将其直接交付给FastCGI进程来执行，然后将得到的结果返回给浏览器。这种方式可以让HTTP服务器专一的处理静态的请求。</p>
<p>这会很高的提高整个应用系统的性能。</p>
<h3 id="_5-fastcgi的重要特点" tabindex="-1"><a class="header-anchor" href="#_5-fastcgi的重要特点" aria-hidden="true">#</a> 5.FastCGI的重要特点：</h3>
<p>1.HTTP服务器和动态脚本语言间通信的接口或工具。</p>
<p>2.可以把动态语言解析或HTTP服务器分离开。</p>
<p>3.Nginx、Apache、Lighttpd，以及多数动态语言都支持FastCGI。</p>
<p>4.PHP动态语言方式采用C/S结构，分为客户端(HTTP服务器)和服务器端(动态语言解析服务器)。</p>
<p>5.PHP动态语言服务器端可以启动多个FastCGI的守护进程。</p>
<p>6.HTTP服务器通过FastCGI客户端和动态语言FastCGI服务器端通信。</p>
<h3 id="_6-nginx-fcgi运行原理" tabindex="-1"><a class="header-anchor" href="#_6-nginx-fcgi运行原理" aria-hidden="true">#</a> 6.Nginx FCGI运行原理：</h3>
<p>Nginx不支持对外部动态程序的直接调用或者解析。所有的外部程序(包括PHP)必须通过FastCGI接口来调用。</p>
<p>FastCGI接口在Linux下是一个socket，为了调用CGI程序，还需要一个FastCGI的wrapper(可以理解为用户启动另一个程序的程序)，这个wrapper绑定在某个固定的socket上。</p>
<p>当Nginx将CGI请求发送给这个socket的时候，通过FastCGI接口，wrapper接受到请求，然后派生出一个新的线程，这个线程调用解释器或外部的程序处理脚本来读取返回的数据。</p>
<p>然后wrapper再将返回的数据通过FastCGI接口，沿着固定的socket传递给Nginx，最后Nginx将返回的数据发送给客户端。</p>
<p>FastCGI的主要优点就是把动态的语言和HTTP服务器分离开来，使Nginx专门处理静态的请求，动态的请求直接使用PHP/PHP-FPM服务器专门处理。</p>
<h3 id="_7-关于cgi和fastcgi的理解" tabindex="-1"><a class="header-anchor" href="#_7-关于cgi和fastcgi的理解" aria-hidden="true">#</a> 7.关于CGI和FastCGI的理解？</h3>
<p>在搭建 LAMP/LNMP 服务器时，会经常遇到 PHP-FPM、FastCGI和CGI 这几个概念。如果对它们一知半解，很难搭建出高性能的服务器。</p>
<p><a href="https://www.cnblogs.com/tssc/p/10255590.html#_labelTop" target="_blank" rel="noopener noreferrer">回到顶部<ExternalLinkIcon/></a></p>
<h2 id="_0-cgi的引入" tabindex="-1"><a class="header-anchor" href="#_0-cgi的引入" aria-hidden="true">#</a> 0.CGI的引入</h2>
<p>在网站的整体架构中，Web Server（如nginx，apache）只是内容的分发者，对客户端的请求进行应答。</p>
<p>如果客户端请求的是index.html这类静态页面，那么Web Server就去文件系统中找对应的文件，找到返回给客户端（一般是浏览器），在这里Web Server分发的就是是静态数据。</p>
<p>整个过程如下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/1211667-20190114110548267-1086537722.png" alt="img"></p>
<p>对于像index.php这类的动态页面请求，Web Server根据配置文件知道这个不是静态文件，则会调用PHP 解析器进行处理然后将返回的数据转发给客户端（浏览器）。</p>
<p>整个过程如下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/1211667-20190114112158766-480550737.png" alt="img"></p>
<p>在这个过程中，Web Server并不能直接处理静态或者动态请求，对于静态请求是直接查找然后返回数据或者报错信息，对于动态数据也是交付给其他的工具（这里的PHP解析器）进行处理。</p>
<p>那么Web Server和处理工具（这里的php-fpm）是怎样进行交互的呢？传输的是那些数据呢？这些数据的格式又是怎样的呢？</p>
<p>由此便引出了今天的主角：<strong>CGI</strong></p>
<h2 id="_1-关于cgi" tabindex="-1"><a class="header-anchor" href="#_1-关于cgi" aria-hidden="true">#</a> <strong>1.关于CGI</strong></h2>
<h3 id="_1-1-什么是cgi" tabindex="-1"><a class="header-anchor" href="#_1-1-什么是cgi" aria-hidden="true">#</a> 1.1.什么是CGI？</h3>
<p>1）CGI（Common Gateway Interface）全称是“通用网关接口”，是一种让客户端（web浏览器）与Web服务器（nginx等）程序进行通信（数据传输）的协议。</p>
<p>用来规范web服务器传输到php解释器中的数据类型以及数据格式，包括URL、查询字符串、POST数据、HTTP header等，也就是为了保证web server传递过来的数据是标准格式的。</p>
<p>2）CGI可以用任何一种具有标准输入、输出和环境变量的语言编写，如php、perl、tcl等。</p>
<p>不同类型语言写的程序只要符合cgi标准，就能作为一个cgi程序与web服务器交互，早期的cgi大多都是c或c++编写的。</p>
<p>3）一般说的CGI指的是用各种语言编写的能实现该功能的程序。</p>
<h3 id="_1-2-cgi程序的工作原理" tabindex="-1"><a class="header-anchor" href="#_1-2-cgi程序的工作原理" aria-hidden="true">#</a> 1.2.CGI程序的工作原理</h3>
<p>1）每次当web server收到index.php这种类型的动态请求后，会启动对应的CGI程序（PHP的解析器）；
2）PHP解析器会解析php.ini配置文件，初始化运行环境，然后处理请求，处理完成后将数据按照CGI规定的格式返回给web server然后退出进程；
3）最后web server再把结果返回给浏览器。</p>
<h3 id="_1-3-cgi程序的特点" tabindex="-1"><a class="header-anchor" href="#_1-3-cgi程序的特点" aria-hidden="true">#</a> 1.3.CGI程序的特点</h3>
<p>1）高并发时的性能较差：
CGI程序的每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式（每次HTTP服务器遇到动态请求时都需要重新启动脚本解析器来解析php.ini，重新载入全部DLL扩展并重初始化全部数据结构，然后把结果返回给HTTP服务器），很明显，这样的接口方式会导致php的性能很差，在处理高并发访问时，几乎是不可用的。
2）传统的CGI接口方式安全性较差</p>
<p>3）CGI对php.ini的配置很敏感，在开发和调试的时候相当方便</p>
<h3 id="_1-4-cgi程序的应用领域" tabindex="-1"><a class="header-anchor" href="#_1-4-cgi程序的应用领域" aria-hidden="true">#</a> 1.4.CGI程序的应用领域</h3>
<p>因为CGI为每一次请求增加一个进程，效率很低，所以基本已经不在生产部署时采用。但由于CGI对php配置的敏感性，通常被用在开发和调试阶段</p>
<p><a href="https://www.cnblogs.com/tssc/p/10255590.html#_labelTop" target="_blank" rel="noopener noreferrer">回到顶部<ExternalLinkIcon/></a></p>
<h2 id="_2-关于fastcgi" tabindex="-1"><a class="header-anchor" href="#_2-关于fastcgi" aria-hidden="true">#</a> 2.关于FastCGI</h2>
<h3 id="_2-1-什么是fastcgi" tabindex="-1"><a class="header-anchor" href="#_2-1-什么是fastcgi" aria-hidden="true">#</a> 2.1.什么是FastCGI？</h3>
<p>通过CGI程序的工作原理可以看出：CGI程序性能较差，安全性较低，为了解决这些问题产生了FastCGI。</p>
<p>1）FastCGI（Fast Common Gateway Interface）全称是“快速通用网关接口”
是通用网关接口（CGI）的增强版本，由CGI发展改进而来，主要用来提高CGI程序性能，
类似于CGI，FastCGI也是一种让交互程序与Web服务器通信的协议
2）FastCGI致力于减少网页服务器与CGI程序之间互动的开销，从而使服务器可以同时处理更多的网页请求（提高并发访问）。</p>
<p>3）同样的，一般说的FastCGI指的也是用各种语言编写的能实现该功能的程序。</p>
<h3 id="_2-2-fastcgi程序的工作原理" tabindex="-1"><a class="header-anchor" href="#_2-2-fastcgi程序的工作原理" aria-hidden="true">#</a> 2.2.FastCGI程序的工作原理</h3>
<p>1）Web Server启动同时，加载FastCGI进程管理器（nginx的php-fpm或者IIS的ISAPI或Apache的Module)
2）FastCGI进程管理器读取php.ini配置文件，对自身进行初始化，启动多个CGI解释器进程(php-cgi)，等待来自Web Server的连接。
3）当Web Server接收到客户端请求时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server会将相关环境变量和标准输入发送到FastCGI子进程php-cgi进行处理
4）FastCGI子进程完成处理后将数据按照CGI规定的格式返回给Web Server，然后关闭FastCGI子进程或者等待下一次请求。</p>
<h3 id="_2-3-fastcgi对进程的管理方式" tabindex="-1"><a class="header-anchor" href="#_2-3-fastcgi对进程的管理方式" aria-hidden="true">#</a> 2.3.FastCGI对进程的管理方式</h3>
<p>Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然提高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。</p>
<h3 id="_2-4-fastcgi的特点" tabindex="-1"><a class="header-anchor" href="#_2-4-fastcgi的特点" aria-hidden="true">#</a> 2.4.FastCGI的特点：</h3>
<p>1）FastCGI具有语言无关性，支持用大多数语言进行编写，对应的程序也支持大多数主流的web服务器
FastCGI技术目前支持语言有：C/C++，Java，PHP，Perl，Tcl，Python，SmallTalk，Ruby等。
支持FastCGI技术的主流web服务器有：Apache，Nginx，lighttpd等</p>
<p>2）FastCGI程序的接口方式采用C/S结构，可以将web服务器和脚本解析服务器分开，独立于web服务器运行，提高web服务器的并发性能和安全性：</p>
<p>提高性能：这种方式支持多个web分发服务器和多个脚本解析服务器的分布式架构，同时可以在脚本解析服务器上启动一个或者多个脚本解析守护进程来处理动态请求，可以让web服务器专一地处理静态请求或者将动态脚本服务器的结果返回给客户端，这在很大程度上提高了整个应用系统的性能。</p>
<p>提高安全性：API方式把应用程序的代码与核心的web服务器链接在一起，这时一个错误的API的应用程序可能会损坏其他应用程序或核心服务器，恶意的API的应用程序代码甚至可以窃取另一个应用程序或核心服务器的密钥，采用这种方式可以在很大程度上避免这个问题</p>
<p>3）FastCGI的不依赖于任何Web服务器的内部架构，因此即使服务器技术的变化, FastCGI依然稳定不变</p>
<p>4）FastCGI程序在修改php.ini配置时可以进行平滑重启加载新配置</p>
<p>所有的配置加载都只在FastCGI进程启动时发生一次，每次修改php.ini配置文件，只需要重启FastCGI程序（php-fpm等）即可完成平滑加载新配置，已有的动态请求会继续处理，处理完成关闭进程，新来的请求使用新加载的配置和变量进行处理</p>
<p>5）FAST-CGI是较新的标准，架构上和CGI大为不同，是用一个驻留内存的服务进程向网站服务器提供脚本服务。像是一个常驻(long-live)型的CGI，维护的是一个进程池，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次（这是CGI最为人诟病的fork-and-execute 模式），速度和效率比CGI大为提高，是目前的主流部署方式。</p>
<p>6）FastCGI的不足：</p>
<p>因为是在内存中同时运行多进程，所以会比CGI方式消耗更多的服务器内存，每个PHP-CGI进程消耗7至25兆内存，在进行优化配置php-cgi进程池的数量时要注意系统内存，防止过量</p>
<h3 id="_2-5-fastcgi程序的应用领域" tabindex="-1"><a class="header-anchor" href="#_2-5-fastcgi程序的应用领域" aria-hidden="true">#</a> 2.5.FastCGI程序的应用领域</h3>
<p>生产环境的主流部署方式</p>
<h3 id="_2-6-关于cgi和fastcgi的总结" tabindex="-1"><a class="header-anchor" href="#_2-6-关于cgi和fastcgi的总结" aria-hidden="true">#</a> 2.6.关于CGI和FastCGI的总结</h3>
<p>1）CGI 和 FastCGI 都只是一种通信协议规范，不是一个实体，一般说的CGI指的是用各种语言编写的能实现该功能的程序
2）CGI 程序和FastCGI程序，是指实现这两个协议的程序，可以是任何语言实现这个协议的。（PHP-CGI 和 PHP-FPM就是实现FastCGI的程序）
3）CGI程序和FastCGI程序的区别：
<strong>关于CGI程序：</strong>
CGI使外部程序与Web服务器之间交互成为可能。CGI程序运行在独立的进程中，并对每个Web请求建立一个进程，这种方法非常容易实现，但效率很差，难以扩展。面对大量请求，进程的大量建立和消亡使操作系统性能大大下降。此外，由于地址空间无法共享，也限制了资源重用。</p>
<p><strong>关于FastCGI程序：</strong>
与CGI程序为每个请求创建一个新的进程不同，FastCGI使用持续的进程（master）来处理一连串的请求。这些进程由FastCGI服务器管理，而不是web服务器。 当进来一个请求时，web服务器把环境变量和这个页面请求通过一个socket或者一个TCP connection传递给FastCGI进程。</p>
<p><a href="https://www.cnblogs.com/tssc/p/10255590.html#_labelTop" target="_blank" rel="noopener noreferrer">回到顶部<ExternalLinkIcon/></a></p>
<h2 id="_3-关于php-cgi-php-fpm和spawn-fcgi" tabindex="-1"><a class="header-anchor" href="#_3-关于php-cgi-php-fpm和spawn-fcgi" aria-hidden="true">#</a> 3.关于PHP-CGI，PHP-FPM和Spawn-FCGI</h2>
<h3 id="_3-1-php-cgi是什么" tabindex="-1"><a class="header-anchor" href="#_3-1-php-cgi是什么" aria-hidden="true">#</a> 3.1.PHP-CGI是什么？</h3>
<p>很多地方说：PHP-CGI是PHP自带的FastCGI管理器，目前还没找到最原始的出处，以我的理解和经验来看这话有点毛病，我认为应该是：使用php实现CGI协议的CGI程序，可以用来管理php解释器，如果有异议可以和我探讨下。。。</p>
<p>使用如下命令可以启动PHP-CGI：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>php-cgi -b 127.0.0.1:9000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>php-cgi的特点：</p>
<p>1）php-cgi变更php.ini配置后需重启php-cgi才能让新的配置生效，不可以平滑重启</p>
<p>2）直接杀死php-cgi进程php就不能运行了</p>
<h3 id="_3-2-关于php-fpm" tabindex="-1"><a class="header-anchor" href="#_3-2-关于php-fpm" aria-hidden="true">#</a> 3.2.关于php-fpm</h3>
<p>PHP-FPM(FastCGI Process Manager)</p>
<p>针对PHP-CGI的不足，PHP-FPM和Spawn-FCGI应运而生，它们的守护进程会平滑从新生成新的子进程。</p>
<p>1）PHP-FPM使用PHP编写的PHP-FastCGI管理器，管理对象是PHP-CGI程序，不能说php-fpm是fastcgi进程的管理器，因为前面说了fastcgi是个协议</p>
<p>下载地址：http://php-fpm.org/download</p>
<p>早期的PHP-FPM是作为PHP源码的补丁而使用的，在PHP的5.3.2版本中直接整合到了PHP-FPM分支，目前主流的PHP5.5，PHP5.6，PHP5.7已经集成了该功能（被官方收录）</p>
<p>在配置时使用--enable-fpm参数即可开启PHP-FPM</p>
<p>2）修改php.ini之后，php-cgi进程的确是没办法平滑重启的。php-fpm对此的处理机制是新的worker用新的配置，已经存在的worker处理完手上的活就可以歇着了，通过这种机制来平滑过度。</p>
<h3 id="_3-3-关于spawn-fcgi" tabindex="-1"><a class="header-anchor" href="#_3-3-关于spawn-fcgi" aria-hidden="true">#</a> 3.3.关于Spawn-FCGI</h3>
<p>1）Spawn-FCGI是一个通用的FastCGI管理服务器，它是lighttpd中的一部份，很多人都用Lighttpd的Spawn-FCGI进行FastCGI模式下的管理工作</p>
<p>2）Spawn-FCGI目前已经独成为一个项目，更加稳定一些，也给很多Web 站点的配置带来便利。已经有不少站点将它与nginx搭配来解决动态网页。</p>
<p>Spawn-FCGI的下载地址是http://redmine.lighttpd.net/projects/spawn-fcgi，目前（20190114）最新版本为1.6.4，在4年前更新的，有点凉凉的意思。。。</p>
<h3 id="_3-4-php-fpm与spawn-cgi对比" tabindex="-1"><a class="header-anchor" href="#_3-4-php-fpm与spawn-cgi对比" aria-hidden="true">#</a> 3.4.PHP-FPM与spawn-CGI对比</h3>
<p>1）PHP-FPM的配置都是在php-fpm.ini的文件内，早些时候重启可以通过/usr/local/php/sbin/php-fpm reload进行，无需杀掉进程就可以完成php.ini的修改加载，被php官方收录以后需要指定参数进行重载配置，可以自己创建脚本进行管理
2）PHP-FPM控制的进程cpu回收的速度比较慢,内存分配的很均匀，比Spawn-FCGI要好，可以有效控制内存和进程，且不容易崩溃，很优秀
3）Spawn-FCGI控制的进程CPU下降的很快，而内存分配的比较不均匀。有很多进程似乎未分配到，而另外一些却占用很高。可能是由于进程任务分配的不均匀导致的。而这也导致了总体响应速度的下降。而PHP-FPM合理的分配，导致总体响应的提到以及任务的平均。</p>
<p>（摘录的，暂未实际验证）</p>
<p><a href="https://www.cnblogs.com/tssc/p/10255590.html#_labelTop" target="_blank" rel="noopener noreferrer">回到顶部<ExternalLinkIcon/></a></p>
<h2 id="_4-php运行的5种模式" tabindex="-1"><a class="header-anchor" href="#_4-php运行的5种模式" aria-hidden="true">#</a> 4.PHP运行的5种模式</h2>
<p>php目前比较常见的五大运行模式：包括cli、cgi 、fast-cgi、isapi、apache模块的DLL</p>
<h3 id="_4-1-cli模式" tabindex="-1"><a class="header-anchor" href="#_4-1-cli模式" aria-hidden="true">#</a> 4.1.cli模式</h3>
<p>cli模式就是php的命令行运行模式，</p>
<p>例如：在linux下经常使用 “php -m”查找PHP安装了那些扩展就是PHP命令行运行模式</p>
<p>其他的可以输入php -h查看下</p>
<h3 id="_4-2-cgi模式" tabindex="-1"><a class="header-anchor" href="#_4-2-cgi模式" aria-hidden="true">#</a> 4.2.CGI模式</h3>
<p>比较经典的使用方法，使用CGI程序将浏览器，web服务器，php解释器连接起来进行数据交换的工具，目前主要用来做开发或调试</p>
<p>CGI方式在遇到连接请求（用户 请求）先要创建cgi的子进程，激活一个CGI进程，然后处理请求，处理完后结束这个子进程。这就是fork-and-execute模式。所以用cgi方式的服务器有多少连接请求就会有多少cgi子进程，子进程反复加载是cgi性能低下的主要原因。都会当用户请求数量非常多时，会大量挤占系统的资源如内 存，CPU时间等，造成效能低下。</p>
<h3 id="_4-3-fastcgi模式" tabindex="-1"><a class="header-anchor" href="#_4-3-fastcgi模式" aria-hidden="true">#</a> 4.3.FastCGI模式</h3>
<p>目前主流的使用方式，比CGI模式的工具效率高很多，大量用于分布式高并发的环境中</p>
<p>在Linux中，nginx加php-fpm是最主流的使用方式</p>
<h3 id="_4-4-isapi运行模式" tabindex="-1"><a class="header-anchor" href="#_4-4-isapi运行模式" aria-hidden="true">#</a> 4.4.<strong>ISAPI运行模式</strong></h3>
<p>ISAPI即Internet Server Application Program Interface，是微软提供的一套面向Internet服务的API接口，一个ISAPI的DLL，可以在被用户请求激活后长驻内存，等待用户的另一个请求，还可以在一个DLL里设置多个用户请求处理函数，此外，ISAPI的DLL应用程序和WWW服务器处于同一个进程中，效率要显著高于CGI。（由于微软的排他性，只能运行于windows环境)</p>
<h3 id="_4-5-apache模块运行模式" tabindex="-1"><a class="header-anchor" href="#_4-5-apache模块运行模式" aria-hidden="true">#</a> 4.5.<strong>apache模块运行模式</strong></h3>
<p>此运行模式可以在Linux和windows环境下使用Apache，他们的共同点都是用 LoadModule 来加载相关模块，有两种类型</p>
<h4 id="_4-5-1-mod-php模块" tabindex="-1"><a class="header-anchor" href="#_4-5-1-mod-php模块" aria-hidden="true">#</a> 4.5.1.mod_php模块</h4>
<p>Apache调用php的相关模块（php5_module），也就是把php作为apache的一个子模块来运行</p>
<p>当通过web访问php文件时，apache就会调用php5_module通过sapi将数据传给php解析器来解析php代码，整个过程如下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/1211667-20190115144956366-1888035801.png" alt="img"></p>
<p>从上面图中，可以看出：</p>
<p>1）sapi就是这样的一个中间过程，SAPI提供了一个和外部通信的接口，有点类似于socket，使得PHP可以和其他应用进行交互数据（apache，nginx等）。</p>
<p>php默认提供了很多种SAPI，常见的提供给apache和nginx的php5_module、CGI、FastCGI，给IIS的ISAPI，以及Shell的CLI。</p>
<p>所以，以上的apache调用php执行的过程如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>apache -> httpd -> php5_module -> sapi -> php
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2）apache每接收一个请求，都会产生一个进程来连接php通过sapi来完成请求，如果用户过多，并发数过多，服务器就会承受不住了。</p>
<p>3）把mod_php编进apache时，出问题时很难定位是php的问题还是apache的问题，而且PHP是与Web服务器一起启动并运行的，当php模块出现问题可能会导致Apache一同挂掉</p>
<h4 id="_4-5-2-mod-cgi模块" tabindex="-1"><a class="header-anchor" href="#_4-5-2-mod-cgi模块" aria-hidden="true">#</a> 4.5.2.mod_cgi模块</h4>
<p>在此种模式中Apache启动加载mod_cgi模块，使用CGI调用管理动态的php请求</p>
<p>更高级的是mod_fcgid模块，是apache的fastcgi实现，性能提高，在apache的2.4以后的版本中得到支持。</p>
<p>总结：</p>
<p>1）mod_php是apache的内置php解释模块，使用prefork方式，不需要额外的进程来做通讯和应用解释，显然mod_php比mod_cgi这样方式性能要好得多</p>
<p>2）缺点是把应用和HTTP服务器绑定在了一起，当php模块出现问题可能会导致Apache一同挂掉</p>
<p>3）另外每个Apache进程都需要加载mod_php而不论这个请求是处理静态内容还是动态内容，这样导致浪费内存，效率下降，</p>
<p>4）php.ini文件的变更需要重新启动apache服务器才能生效，这使得无法进行平滑配置变更。</p>
<h3 id="_4-6-总结一下" tabindex="-1"><a class="header-anchor" href="#_4-6-总结一下" aria-hidden="true">#</a> 4.6.总结一下</h3>
<p>随着技术的不断升级，单纯的Apache加php模块的方式已不再主流，而是替换为Apache加php_cgi，以及后来的php_fcgi和nginx加php-fpm的方法，可以看下图：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/1211667-20190115145942380-1500445422.png" alt="img"></p>
<h1 id="十八-分布式面试题" tabindex="-1"><a class="header-anchor" href="#十八-分布式面试题" aria-hidden="true">#</a> 十八.分布式面试题</h1>
<p>最近整理了分布式面试题，一共有<strong>121</strong>道，后面会不断增加，争取做到全网最全的分布式面试题。大部分题目都是来自小伙伴们在面试中被问到后，反馈到我这里的。也由此可知，下一个被问到的估计就是你。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/81e3481113a3283e33d61ca1d9c1c100.png" alt="img"></p>
<h3 id="_1-分布式事务" tabindex="-1"><a class="header-anchor" href="#_1-分布式事务" aria-hidden="true">#</a> 1.分布式事务</h3>
<h3 id="_2-请说说你对分布式系统-cap-理论的理解-cap-分别代表什么含义-什么是cap定理-cap-theorem" tabindex="-1"><a class="header-anchor" href="#_2-请说说你对分布式系统-cap-理论的理解-cap-分别代表什么含义-什么是cap定理-cap-theorem" aria-hidden="true">#</a> 2.请说说你对分布式系统 CAP 理论的理解，CAP 分别代表什么含义？什么是CAP定理（CAP theorem）</h3>
<p>在理论计算机科学中，CAP定理（CAP theorem），又被称作布鲁尔定理（Brewer’s theorem），它指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p>
<p>一致性（Consistency） （等同于所有节点访问同一份最新的数据副本）
可用性（Availability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）
分区容错性（Partition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）</p>
<p>一个分布式系统最多同时满足一致性 (Consistency)，可用性 (Availability) 和分区容忍性 (Partition Tolerance) 这三项中的两项。</p>
<p>同时满足一致性（C）和可用性（A）就要牺牲掉容错性（P）
同时满足可用性（A）和分区容错性（P）就要牺牲掉一致性（C）
同时满足一致性（C）和分区容错性（P）就要牺牲掉可用性（A）</p>
<p>举例深入分析
用 Redis Cluster 高可用架构举例：Redis 就能会将数据分片到多个实例 (按照 slot 存储) 中，即一个机房分担一部分数据。Master 负责写，Master 会自动同步到 Slave。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/form2223at,png" alt="图片描述"></p>
<h5 id="redis-去中心集群架构优点" tabindex="-1"><a class="header-anchor" href="#redis-去中心集群架构优点" aria-hidden="true">#</a> Redis 去中心集群架构优点：</h5>
<ol>
<li>无中心架构：三机房部署，其中一主一从构成一个分片，之间通过异步复制同步数据，异步复制存在数据不一致的时间窗口，保证高性能的同时牺牲了部分一致性。一旦某个机房掉线，则分片上位于另一个机房的 slave 会被提升为 master 从而可以继续提供服务。</li>
<li>可扩展性：可线性扩展到 1000 多个节点，节点可动态添加或删除。</li>
<li>降低运维成本，提高系统的扩展性和可用性。</li>
</ol>
<p>分析，这个分布式架构中满足了 CAP 中哪个两个定理？</p>
<p>优点 1 中讲到，三机房部署，每个机房有一主一从，即一个 Master 对应一个 Slave ，但是你会发现，机房 1 中的 Master 1 连接的 Slave 在机房 2，机房 2 中的 Master 2 连接的 Slave 在机房 3，机房 3 中的 Master 3 连接的 Slave 在机房 1，这样构成一个环，为什么要这样设计？</p>
<p>假设：机房断电 or 火灾 or 其他各种原因，反正就是机房 1 所有机器都不能用了。</p>
<p>这个时候那机房 1 的全部数据都不能访问了吗？这显然是我们不希望的。前面已经说了 Master 负责写，Master 会自动同步到 Slave，如果 Master 写服务宕机，Slave 读服务会被提升为 Master ，也就是说机房 1 的数据在机房 2 的 Slave2 上还有备份，数据还在，在宕机的 Master 没有恢复前 Slave 要同时承担读写服务，虽然累一点，但是还能用，这样设计是为了提高可用性（A），和容错性（P）。系统准许你一台机器或者整个机房都宕机，系统仍然能用。</p>
<p>但是你会发现，单个机房如果距离很远， Master 1 的数据同步到 Slave2 上是跨机房，跨机房同步肯定不如同机房块，这样一来 Slave2 负责的读就会有延迟，Master1 要更新的数据还没有同步到他在另一个机房的备份前，读操作就是不一致的，这样设计显然是牺牲掉一致性（C）。相信这样分析应该能理解 CAP 定理了。</p>
<p>进一步分析：</p>
<p>让同一组 Master - Slave 放在一个机房，同机房复制数据不是更快？这样能不能解决数据一致（C）问题，答案是能，还有更好的解决一致性的办法就是不要 Master - Slave 组合，就一台机器，一台机器同时担任读写请求，没有延迟不存在数据一致性问题。这是时候如果宕机了怎么办？这样的架构下，那就真的是不可用了，解决了一致性（C）却牺牲了可用性（A）和容错性（P），太不划算了。</p>
<p>总之，分布式系统下，CAP 确实无法同时满足，在 Redis 去中心集群架构中，最优的解决方案还是满足可用性（A）和分区容错性（P）就要牺牲掉一致性（C），即使跨机房同步数据，延迟也不过 1s，数据不一致的问题只出现在 1s 内，日常开发中，很少遇到要求强一致性的场景。例如订单系统，用户更新了订单支付状态，读订单状态是在从库，有什么读场景等不来这一秒？</p>
<p>如果真的必须要求强一致性，那可能就必须调整分布式架构方案来。</p>
<p>总结
本文主要讲解了 CAP 定理的概念，为什么要学习这个概念，设计高可用分布式系统时，你必须知道系统的短处，懂得 CAP 能让你根据实际情况有舍有得。面试会被经常问到，比如，你说你使用了消息队列，解决了系统耦合问题，提高了响应速度，那面试官问题：使用消息队列有啥缺点？如果你知道 CAP 定理这个问题还难吗？</p>
<p>显然消息的延迟会带来数据不一致问题。理想情况下消息不丢失那数据会最终一致，你能保证消息不丢失吗？如何解决机问题，如果是我，我会选择 “最终一致性”，就是说不管消息延迟多久甚至丢失，设计一个离线定时任务，定期去扫描两个系统的数据，有不一致的情况就主动刷新同步，这样保证最终一致。
————————————————P指的是分区容错性，分区现象产生后需要容错，容错是指在A与C之间选择。如果分布式系统没有分区现象（没有出现不一致不可用情况） 本身就没有分区 ，既然没有分区则就更没有分区容错性P。
无论我设计的系统是AP还是CP 系统如果没有出现不一致不可用。 则该系统就处于CA状态
P的体现前提是得有分区情况存在</p>
<h3 id="_4-什么是二阶段提交" tabindex="-1"><a class="header-anchor" href="#_4-什么是二阶段提交" aria-hidden="true">#</a> 4.什么是二阶段提交？</h3>
<p>2PC Two-Phase Commit  ,即二阶段提交，是计算机网络尤其是在数据库领域内，为了使基于分布式系统架构下的所有节点在进行事务处理过程中保持原子性和一致性的算法。</p>
<p>二阶段提交协议也被认为是一种一致性协议，用来保证分布式提醒数据库的一致性。目前，绝大多数的关系型数据库都是采用二阶段提交协议来完成分布式事务处理的，利用该协议能够非常方便地完成所有分布式事务参与者的协调，统一决定事务的提交或者回滚，从而能够有效地保证分布式数据一致性，因此，二阶段提交协议被广泛地应用在许多分布式系统中。</p>
<p>**优点：**原理简单，实现方便
**缺点：**同步阻塞（执行中，所有参与该事务操作的逻辑都处于阻塞状态，无法进行其他操作）</p>
<p>单点问题（协调者挂了，整个二阶提交无法运转）
数据不一致（执行成功是，协调者commit,部分参与者没有收到。所以部分执行，部分未执行，出现数据    不一致）。
太过保守（参与者故障，协调者只能依靠自身的超时机制判断是否需要事务中断，策略保守。二阶提交    没有设计较为完善的容错机制，任意一个节点的失败都会导致整个事务的失败）</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table>
<thead>
<tr>
<th>阶段一：<br/>1，事务询问<br/>协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。<br/>2，执行事务<br/>各参与者节点执行事务操作，并将Undo和Redo信息记入事务日志中。<br/>3，各参与者向协调者反馈事务询问的响应<br/>如果参与者成功执行了事务操作，那么就反馈给协调者Yes响应，表示事务可以执行；如果参与者没有成功执行事务，那么就反馈给协调者No响应，表示事务不可以执行。<br/><br/>阶段二：<br/>完成事务（反馈都是Yes）,执行：<br/>1，发送提交请求<br/>   协调者向所有参与者节点发出Commit请求。<br/>2，事务提交<br/>  参与者接收到Commit请求后，会正式地执行事务提交操作，并在完成提交之后释放在整个   事务执行期间占用的资源。<br/>3，反馈事务提交结果<br/> 参与者在完成事务提交后，向协调者发送Ack消息。<br/>4，完成事务<br/>协调者接收到所有参与者反馈的Ack消息后，完成事务。<br/>中断事务（有至少一个反馈No,或者等待超时），执行：<br/>1，发送回滚请求。<br/>协调者向所有参与者节点发送Rollback请求。<br/>2，事务回滚<br/>参与者接收到Rollback请求后，会利用其在阶段一中记录的Undo信息来执行事务的回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。<br/>3，反馈事务回滚结果<br/>参与者在完成事务回滚之后，向协调者发送Ack消息<br/>4，中断事务<br/>协调者接收所有参与者反馈的Ack消息后，完成事务中断。<br/>————————————————<br/></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
<h5 id="分布式一致性" tabindex="-1"><a class="header-anchor" href="#分布式一致性" aria-hidden="true">#</a> 分布式一致性</h5>
<p>还好我们之前专门给女朋友介绍过什么是分布式，要不然这个话题说来就话长了。</p>
<p>在之前介绍分布式的时候，我们以饭店的后厨为例，今天继续之前的例子来说说什么是分布式一致性。</p>
<p>随着饭店的发展，慢慢的从只有一个厨师演变成有多个厨师，进而演变成有洗菜工、配菜师、厨师等多个职位。</p>
<p>当有了多种分工之后，就势必需要协调这些人之间的合作。</p>
<p>比如餐厅客人点了一份番茄炒蛋，然后后厨开始准备起来，洗菜工开始洗西红柿，配菜师开始准备鸡蛋，厨师开始向锅内加油准备炒菜。这是一种很正常的情况。</p>
<p>但是，如果消息传达的不到位，或者洗菜师傅临时不在厨房等，就会导致有的人已经开始准备起来，但是有的人并没有准备。</p>
<p>这就像是一个分布式系统一样的，当我们在电商网站下单的时候，需要有多个分布式服务同时服务，如支付系统进行支付、红包系统进行红包扣减、库存系统扣减库存、物流系统更新物流信息等。</p>
<p>但是，如果其中某一个系统在执行过程中失败了，或者由于网络原因没有收到请求，那么，整个系统可能就有不一致的现象了，即：付了钱，扣了红包，但是库存没有扣减。</p>
<p>这就是所谓的分布式系统的数据一致性问题。
————————————————</p>
<h5 id="二阶段提交" tabindex="-1"><a class="header-anchor" href="#二阶段提交" aria-hidden="true">#</a> 二阶段提交</h5>
<p>之所以刚刚的例子中会出现一致性问题，就是因为每一个员工都只关注自己所做的事情，无法关注到其他人，那么，要想保证整体的一致性，就需要在后厨中引入一个新的角色，负责统筹，这个角色来进行协调和调配所有人。</p>
<p>那么，引入一个协调者负责协调所有参与者的工作，这个在分布式系统中其实就是X/Open组织定义的分布式事务处理模型，而二阶段提交就是根据这一模型衍生出来的。
————————————————
在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败（只知道自己有时间可以玩王者荣耀，不知道其他人有没有）。</p>
<p>当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有参与者的操作结果并最终指示这些节点是否要把操作结果进行真正的提交（组织者通知各位参与者一起进入游戏房间）。</p>
<p>因此，二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p>
<p>所谓的两个阶段是指：第一阶段：准备阶段(投票阶段)和第二阶段：提交阶段（执行阶段）
————————————————
准备阶段</p>
<p>事务协调者给每个参与者发送Prepare消息，每个参与者要么直接返回失败（告知组织者自己没时间，不能一起玩游戏），要么在本地执行事务（登录王者荣耀），但不提交（先不开始游戏）。</p>
<p>可以进一步将准备阶段分为以下三个步骤：</p>
<p>1）协调者节点向所有参与者节点询问是否可以执行提交操作，并开始等待各参与者节点的响应。（询问是否可以一起玩游戏）</p>
<p>2）参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（登录王者荣耀游戏）</p>
<p>3）各参与者节点响应协调者节点发起的询问。如果参与者节点的事务操作实际执行成功，则它返回一个”同意”消息；（告知组织者自己已经登录成功）如果参与者节点的事务操作实际执行失败，则它返回一个”中止”消息。（告知组织者自己暂时无法一起玩游戏，如自己的账号被限制无法打排位）
————————————————
<img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224172031326.png" alt="image-20211224172031326"></p>
<p>提交阶段</p>
<p>如果协调者收到了参与者的失败消息或者超时（有人不能一起玩游戏，或者一直没有回复），直接给每个参与者发送回滚消息（告知其他人，暂时取消游戏）；否则，发送提交消息（邀请大家进入游戏房间）；参与者根据协调者的指令执行提交或者回滚操作（进入房间一起玩游戏或者退出游戏去做别的事情）。</p>
<p>接下来分两种情况分别讨论提交阶段的过程。</p>
<p>当协调者节点从所有参与者节点获得的相应消息都为”同意”时:</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224172116531.png" alt="image-20211224172116531"></p>
<p>1）协调者节点向所有参与者节点发出”正式提交”的请求（要求所有已登录的朋友加入游戏房间）。</p>
<p>2）参与者节点正式完成操作，并释放在整个事务期间内占用的资源（接受邀请，进入房间）。</p>
<p>3）参与者节点向协调者节点发送”完成”消息（点击&quot;准备&quot;，进入准备状态）。</p>
<p>4）协调者节点受到所有参与者节点反馈的”完成”消息后，完成事务（进入王者峡谷）。</p>
<p>如果任一参与者节点在第一阶段返回的响应消息为”中止”，或者 协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224172711757.png" alt="image-20211224172711757"></p>
<p>1）协调者节点向所有参与者节点发出”回滚操作”的请求（告知所有人取消游戏）。</p>
<p>2）参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源（退出游戏，去做自己的事情）。</p>
<p>3）参与者节点向协调者节点发送”回滚完成”消息（告诉组织者自己知道了，后面有机会再玩）。</p>
<p>4）协调者节点受到所有参与者节点反馈的”回滚完成”消息后，取消事务（取消本次游戏活动）</p>
<p>2PC的缺点</p>
<p>以上过程其实是有一些缺点的，如</p>
<p>1、当参与者收到组织者的消息之后，需要登录游戏，在游戏中等待组织者的再次邀请，这个过程比较浪费时间。</p>
<p>2、如果在这个过程中，组织者突然有什么事情被打断了，那么那些已经进入游戏的参与者就可能一直等下去。</p>
<p>3、在所有人都登录游戏之后，组织者通过邀请要求所有人加入他的房间，这时候如果有一些网络异常、或者参与者没在手机前面等情况，可能会有一部分用户加入了房间，有一部分没加入。</p>
<p>4、如果组织者在游戏中开始邀请所有参与者的时候，他邀请了第一个人之后，他和这个被他邀请的人都掉线了。这时候另外三个人就不知道到底应该怎么办了。</p>
<p>以上问题，分布式系统的2PC阶段一样存在，分别对应以下问题：</p>
<p>1、同步阻塞问题。执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p>
<p>2、单点故障。由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p>
<p>3、数据不一致。在二阶段提交的阶段二中，当协调者向参与者发送commit请求之后，发生了局部网络异常或者在发送commit请求过程中协调者发生了故障，这回导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据不一致性的现象。</p>
<p>4、二阶段无法解决的问题：协调者在发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，没人知道事务是否被已经提交。</p>
<p>总结一下，就是说2PC并不是完美的，他存在着同步阻塞问题、单点故障问题、无法100%保证数据一致性等问题。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224174402002.png" alt="image-20211224174402002"></p>
<p>二阶段提交的算法思路可以概括为: 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。</p>
<p>二阶段是指: 第一阶段 - 请求阶段(表决阶段) 第二阶段 - 提交阶段(执行阶段)</p>
<p>(1) 请求阶段(表决)：</p>
<p>事务协调者通知每个参与者准备提交或取消事务，然后进入表决过程，参与者要么在本地执行事务，写本地的redo和undo日志，但不提交，到达一种&quot;万事俱备，只欠东风&quot;的状态。请求阶段，参与者将告知协调者自己的决策: 同意(事务参与者本地作业执行成功)或取消（本地作业执行故障）</p>
<p>(2) 提交阶段(执行):</p>
<p>在该阶段，写调整将基于第一个阶段的投票结果进行决策: 提交或取消</p>
<p>当且仅当所有的参与者同意提交事务，协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务</p>
<p>jta+<a href="https://so.csdn.net/so/search?from=pc_blog_highlight&amp;q=atom" target="_blank" rel="noopener noreferrer">atom<ExternalLinkIcon/></a>ikos分包管理分布式事务，不适用微服项目</p>
<h3 id="_5-什么是三阶段提交" tabindex="-1"><a class="header-anchor" href="#_5-什么是三阶段提交" aria-hidden="true">#</a> 5.什么是三阶段提交？</h3>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224174558005.png" alt="image-20211224174558005"></p>
<p>三阶段提交协议在协调者和参与者中都引入超时机制，并且把两阶段提交协议的第一个阶段分成了两步: 询问，然后再锁资源，最后真正提交。</p>
<p>(1) canCommit阶段</p>
<p>3PC的canCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回yes响应，否则返回no响应</p>
<p>(2) preCommit阶段</p>
<p>协调者根据参与者canCommit阶段的响应来决定是否可以继续事务的preCommit操作。根据响应情况，有下面两种可能:</p>
<p>a) 协调者从所有参与者得到的反馈都是yes:</p>
<p>那么进行事务的预执行，协调者向所有参与者发送preCommit请求，并进入prepared阶段。参与泽和接收到preCommit请求后会执行事务操作，并将undo和redo信息记录到事务日志中。如果一个参与者成功地执行了事务操作，则返回ACK响应，同时开始等待最终指令</p>
<p>b) 协调者从所有参与者得到的反馈有一个是No或是等待超时之后协调者都没收到响应:</p>
<p>那么就要中断事务，协调者向所有的参与者发送abort请求。参与者在收到来自协调者的abort请求，或超时后仍未收到协调者请求，执行事务中断。</p>
<p>(3) doCommit阶段</p>
<p>协调者根据参与者preCommit阶段的响应来决定是否可以继续事务的doCommit操作。根据响应情况，有下面两种可能:</p>
<p>a) 协调者从参与者得到了ACK的反馈:</p>
<p>协调者接收到参与者发送的ACK响应，那么它将从预提交状态进入到提交状态，并向所有参与者发送doCommit请求。参与者接收到doCommit请求后，执行正式的事务提交，并在完成事务提交之后释放所有事务资源，并向协调者发送haveCommitted的ACK响应。那么协调者收到这个ACK响应之后，完成任务。</p>
<p>b) 协调者从参与者没有得到ACK的反馈, 也可能是接收者发送的不是ACK响应，也可能是响应超时:</p>
<p>执行事务中断。</p>
<h3 id="_6-分布式事务-两阶段提交和三阶提交" tabindex="-1"><a class="header-anchor" href="#_6-分布式事务-两阶段提交和三阶提交" aria-hidden="true">#</a> 6.分布式事务，两阶段提交和三阶提交</h3>
<p>一、什么是分布式事务</p>
<p>在分布式系统中，为了保证数据的高可用，通常我们会将数据保留多个副本，同时这些副本会存储到不同的物理机器上，这就是分布式。</p>
<p>为了保证数据的一致性，需要用到分布式事务</p>
<p>1.1 什么是事务？</p>
<p>事务是指对数据的一系列操作要么全部执行要么全部不执行</p>
<p>1.2事务的实现步骤</p>
<p>1.数据库将一系列要执行的操作全部记录成日志</p>
<p>2.逐条执行这一系列操作</p>
<p>3.如果这一系列操作全部执行成功，那么提交事务，事务也就执行成功，若这一系列操作有某一个失败，则会回滚，将所有的操作全部清除，从而达到要么全部执行要么全部不执行的效果。</p>
<p>分布式事务可以理解为设计多个数据库的事务可以同时根据几个不同的数据库</p>
<p>数据库在物理机器上是相互独立的，一个数据库在执行本地事务时，不知道其他数据库事务的执行情况，为了保持所有的执行一致，引入协调者，由协调者来统一管理多个参与者数据库的执行情况。</p>
<p>1.3 分布式事务 实现：</p>
<p>1.在开启事务之后，本地事务会将所有的操作记录成日志，并且执行事务操作，若执行成功，则向协调者发执行成功的通知，如果所有参与者数据库全部发完了执行成功的通知，那么协调者知道，所有的参与者准备好了，返回提交的消息，数据库会将事务提交，从而分布式事务就能执行成功。</p>
<p>若某一个实例在执行一系列操作失败，则会发送失败的消息，则要求所有的数据库实例操作全部回滚，不论是操作成功还是操作失败，协调者在收到操作失败的通知，就会返回回滚的通知，并且回滚通知是发送给每一个参与者，参与者收到回滚通知后，会根据日志，将刚才所执行的事务操作全部回滚，回到事务启动之前的状态，这就是分布式事务执行失败的状况。</p>
<p>根据协调者的思想，在具体的实现分布式事务上，实现的二阶段提交协议和三阶段提交协议。</p>
<p>二、二阶段提交</p>
<p>一个协调者和多个参与者 参与者1,2,3   二阶段提交时协调者方式的一种实现</p>
<p>1.准备阶段</p>
<p>协调者开启事务，向参与者发出事务执行的请求，参与者收到事务操作后，会将事务操作先记录成日志，然后逐条执行事务，执行完事务之后并不提交，如果一系列操作全部执行成功就会向协调者返回一个同意到的消息，如果有操作执行失败，那么就返回一个终止的消息，在协调者收到所有参与者返回的消息之后，就进入了第二个阶段，提交阶段。</p>
<p>2.提交阶段</p>
<p>协调者会根据所有参与者返回的情况决定下一步操作</p>
<p>1.理想情况，若所有的参与者都返回同意的消息，那么，协调者就知道所有的参与者已经准备好，协调者就会向所有的参与者发回一个提交的消息，参与者在收到提交消息之后，会将本地事务进行提交，并且释放占用的资源，在处理完成之后，会返回一个完成的消息，分布式事务也就完成。</p>
<p>2.异常情况，加入某一个参与者进行一系列操作的过程中，出现了异常，那么返回的不是同意消息，而是终止消息，这个时候为了保证所有参与者数据的一致性，需要协调者将所有参与者已经执行的操作全部撤回，协调者在收到中止消息之后，会向所有的参与者发出回滚的请求，参与者收到回滚请求后，会根据之前记录的日志，将所有的操作进行撤销，所有参与者回到事务启动之前的状态，分布式事务执行失败。</p>
<p>缺点：</p>
<p>1.协调者存在单点故障</p>
<p>在分布式事务中，由于协调者太重要了，一旦协调者出现故障，整个分布式就没办法继续执行。</p>
<p>2.可能出现数据不一致
当所有参与者操作执行完成，并且向协调者发回同意的消息之后，协调者就会向所有的参与者发出提交的请求，假设者提交请求发到了参与者1，参与者2，但当发送给参与者3时，发生了网络异常，提交请求并没有到达参与者3，就会出现参与者1，参与者2都提交了，参与者3却没有提交，这个时候，整个分布式系统中就会出现数据不一致的情况。</p>
<p>三、三阶段提交</p>
<p>因为二阶段提交出现了问题，所以在二阶段的基础上，提出了三阶段提交。</p>
<p>三阶段提交时二阶段提交的改进版本，三个阶段如下：</p>
<p>预备阶段、准备阶段、提交阶段</p>
<p>预备阶段、准备阶段是从二阶段准备阶段拆分出来的</p>
<p>在三阶段中，也是一个协调者和多个参与者 参与者1,2,3</p>
<p>具体逻辑实现：</p>
<p>1.预备阶段</p>
<p>协调者开启事务，向参与者发出询问的请求，询问参与者是否可以执行分布式事务的请求，可以执行就会返回一个同意的消息，如果不可以执行就会返回一个中止的消息，在协调者收到所有参与者的询问相应之后，分布式事务就进入了第二个阶段——准备阶段。</p>
<p>2.准备阶段</p>
<p>假设所有的参与者返回的是同意消息，那么分布式事务开始执行，协调者会向所有参与者发出执行分布式事务的请求，在所有参与者收到请求之后，会将所有的分布式事务记录成日志，然后逐条执行分布式事务操作，执行完之后，先不提交，如果执行成功，就返回一个同意的消息，如果执行本地事务的过程中，出现了异常，返回中止消息，在所有参与者返回本地执行结果之后，分布式事务进入第三个阶段，提交阶段。</p>
<p>3.提交阶段</p>
<p>协调者会根据所有参与者返回的结果来确定下一步的操作</p>
<p>假设所有参与者返回的都是同意的消息，那么协调者就知道所有的参与者准备好了，也就会开始执行提交请求，在参与者收到提交请求之后，就会执行本地事务的提交，并且释放相应的资源，执行完成之后，再返回一个完成的消息，在协调者收到所有的完成消息之后，分布式事务也就执行成功了。这是执行正常的情况。</p>
<p>异常处理</p>
<p>1.在预备阶段，协调者询问参与者是否进行分布式事务时，参与者并没有准备好，参与者会返回一个中止消息。</p>
<p>2.在准备阶段，参与者在执行本地事务时，执行异常，那么返回的不是同意，而是中止消息。</p>
<p>无论是第一种情况，还是第二种情况，一旦协调者收到参与者中止消息，就会中止分布式事务，向所有的参与者发出回滚的请求，参与者在收到回滚请求后，会根据日志，将所有的请求撤销，回到分布式事务开启之前的一致状态，这样，整个分布式事务就执行失败。</p>
<p>三阶段提交相对于二阶段提交的改进：</p>
<p>在三阶段提交增加了预备阶段，一旦进入预备阶段，表示所有参与者已经准备好分布式事务，即所有参与者的本地事务是可以执行成功的，这个时候，如果参与者记录完日志，并且执行完本地事务操作之后，就差提交了，这个时候不管发生协调者异常还是网络异常，协调者提交之后，请求没有到达参与者，参与者在等待超时之后，都会默认提交分布式事务，相对于二阶段提交，若二阶段异常，是没办法继续执行的，所以三阶段提交的改进是在二阶段提交没办法继续执行的情况下，可默认将事务提交。</p>
<p>缺点：</p>
<p>当参与者1执行本地事务异常时，给协调者回复中止信号，恰好协调者也异常，这个时候协调者无法中止整个分布式事务，参与者2，参与者3的事务会默认提交，但是参与者1又是执行异常的情况，整个分布式系统也会不一致，所以三阶段提交虽然改变了二阶段提交的问题，但并没有完美实现分布式事务，不过，理论上如此，在具体的实现中，我们会根据业务，对数据进行补偿和修正，以保证业务的数据最终一致。</p>
<h3 id="_7-什么是补偿事务" tabindex="-1"><a class="header-anchor" href="#_7-什么是补偿事务" aria-hidden="true">#</a> 7.什么是补偿事务？</h3>
<h5 id="_1-正文" tabindex="-1"><a class="header-anchor" href="#_1-正文" aria-hidden="true">#</a> （1）正文</h5>
<p><code v-pre>TCC</code>（Try Confirm Cancel）是服务化的二阶段编程模型，采用的补偿机制：</p>
<p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。如果您正在学习Spring Cloud，推荐一个连载多年还在继续更新的免费教程：https://blog.didispace.com/spring-cloud-learning/</p>
<p>它分为三个步骤：</p>
<ul>
<li>Try 阶段主要是对业务系统做检测及资源预留。</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ul>
<p>举个例子，假入你要向 张三 转账，思路大概是：</p>
<p>我们有一个本地方法，里面依次调用步骤：</p>
<p>1、首先在 Try 阶段，要先调用远程接口把 你 和 张三 的钱给冻结起来。</p>
<p>2、在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</p>
<p>3、如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程解冻接口对应的解冻方法 (Cancel)。</p>
<h5 id="_2-优点" tabindex="-1"><a class="header-anchor" href="#_2-优点" aria-hidden="true">#</a> （2）优点</h5>
<p>性能提升：具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。</p>
<p>数据最终一致性：基于 Confirm 和 Cancel 的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。</p>
<p>可靠性：解决了 XA 协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。</p>
<h5 id="_3-缺点" tabindex="-1"><a class="header-anchor" href="#_3-缺点" aria-hidden="true">#</a> （3）缺点</h5>
<p>TCC 的 Try、Confirm 和 Cancel 操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>TCC与2PC的思想很相似，事务处理流程也很相似，但2PC 是应用于在DB层面，TCC则可以理解为在应用层面的2PC，是需要我们编写业务逻辑来实现。
它的核心思想是："针对每个操作都要注册一个与其对应的确认（Confirm）和补偿（Cancel）"
对应两阶段流程为：阶段一为try阶段，阶段二为confirm阶段/cancel阶段
Try阶段：
是主业务服务请求(try)各个从业务服务预留资源。
Confirm阶段：
确认执行业务操作，在只预留的资源基础上，发起Confirm请求。
Cancel阶段：
只要涉及到的相关业务中，有一个业务方预留资源未成功，则取消所有业务资源的预留请求。
优点：
1、因为Try阶段检查并预留了资源，所以confirm阶段一般都可以执行成功
2、资源锁定都是在业务代码中完成，不会阻塞住DB，可以做到对db性能无影响。
缺点：
1、应用侵入性强：TCC由于基于在业务层面，至使每个操作都需要有 try、confirm、cancel三步。
2、开发难度大：代码开发量很大，要保证数据一致性 confirm 和 cancel 接口还必须实现幂等性。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_8-你知道哪些分布式事务解决方案" tabindex="-1"><a class="header-anchor" href="#_8-你知道哪些分布式事务解决方案" aria-hidden="true">#</a> 8.你知道哪些分布式事务解决方案？</h3>
<h4 id="_1-什么是分布式事务" tabindex="-1"><a class="header-anchor" href="#_1-什么是分布式事务" aria-hidden="true">#</a> （1）什么是分布式事务</h4>
<p>分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器**「分别位于不同的分布式系统的不同节点之上」**。</p>
<p>一个大的操作由N多的小的操作共同完成。而这些小的操作又分布在不同的服务上。针对于这些操作，<strong>「要么全部成功执行，要么全部不执行」</strong>。</p>
<h4 id="_2-为什么会有分布式事务" tabindex="-1"><a class="header-anchor" href="#_2-为什么会有分布式事务" aria-hidden="true">#</a> （2）为什么会有分布式事务？</h4>
<p>举个例子：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/32c84432e98522d44a7f38ca459f40c6.png" alt="img"></p>
<p>转账是最经典的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。</p>
<p>如果其中某个步骤失败，此时就有可能会出现 2 种**「异常」**情况：</p>
<ul>
<li>1.用户 A 的账户扣款成功，用户 B 账户余额增加失败</li>
<li>2.用户 A 账户扣款失败，用户 B 账户余额增加成功。</li>
</ul>
<p>对于银行系统来说，以上 2 种情况都是**「不允许发生」**，此时就需要事务来保证转账操作的成功。</p>
<p>在**「单体应用」<strong>中，我们只需要贴上@Transactional注解就可以开启事务来保证整个操作的</strong>「原子性」**。</p>
<p>但是看似以上简单的操作，在实际的应用架构中，不可能是单体的服务，我们会把这一系列操作交给**「N个服务」<strong>去完成，也就是拆分成为</strong>「分布式微服务架构」**。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224180116069.png" alt="image-20211224180116069"></p>
<p>比如下订单服务，扣库存服务等等，必须要**「保证不同服务状态结果的一致性」**，于是就出现了分布式事务。</p>
<h4 id="_3-分布式理论" tabindex="-1"><a class="header-anchor" href="#_3-分布式理论" aria-hidden="true">#</a> （3）分布式理论</h4>
<h5 id="cap定理" tabindex="-1"><a class="header-anchor" href="#cap定理" aria-hidden="true">#</a> CAP定理</h5>
<p>在一个分布式系统中，以下三点特性无法同时满足，<strong>「鱼与熊掌不可兼得」</strong></p>
<blockquote>
<p>一致性（C）：
在分布式系统中的所有数据备份，<strong>「在同一时刻是否拥有同样的值」</strong>。（等同于所有节点访问同一份最新的数据副本）</p>
</blockquote>
<blockquote>
<p>可用性（A）：
在集群中一部分节点**「故障」<strong>后，集群整体</strong>「是否还能响应」**客户端的读写请求。（对数据更新具备高可用性）</p>
</blockquote>
<blockquote>
<p>分区容错性（P）：
即使出现**「单个组件无法可用,操作依然可以完成」**。</p>
</blockquote>
<p>具体地讲在分布式系统中，在任何数据库设计中，一个Web应用**「至多只能同时支持上面的两个属性」**。显然，任何横向扩展策略都要依赖于数据分区。因此，设计人员必须在一致性与可用性之间做出选择。</p>
<h5 id="base理论" tabindex="-1"><a class="header-anchor" href="#base理论" aria-hidden="true">#</a> BASE理论</h5>
<p>在分布式系统中，我们往往追求的是可用性，它的重要程序比一致性要高，那么如何实现高可用性呢？</p>
<p>前人已经给我们提出来了另外一个理论，就是BASE理论，它是用来对CAP定理进行进一步扩充的。BASE理论指的是：</p>
<ul>
<li><strong>「Basically Available（基本可用）」</strong></li>
<li><strong>「Soft state（软状态）」</strong></li>
<li><strong>「Eventually consistent（最终一致性）」</strong></li>
</ul>
<p>BASE理论是对CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。</p>
<h4 id="_4-分布式事务解决方案" tabindex="-1"><a class="header-anchor" href="#_4-分布式事务解决方案" aria-hidden="true">#</a> （4）分布式事务解决方案</h4>
<h5 id="两阶段提交-2pc" tabindex="-1"><a class="header-anchor" href="#两阶段提交-2pc" aria-hidden="true">#</a> 两阶段提交（2PC）</h5>
<p>熟悉mysql的同学对两阶段提交应该颇为熟悉，mysql的事务就是通过**「日志系统」**来完成两阶段提交的。</p>
<p>两阶段协议可以用于单机集中式系统，由事务管理器协调多个资源管理器；也可以用于分布式系统，<strong>「由一个全局的事务管理器协调各个子系统的局部事务管理器完成两阶段提交」</strong>。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224180702752.png" alt="image-20211224180702752"></p>
<p>这个协议有**「两个角色」**，</p>
<p>A节点是事务的协调者，B和C是事务的参与者。</p>
<p>事务的提交分成两个阶段</p>
<p>第一个阶段是**「投票阶段」**</p>
<ul>
<li>1.协调者首先将命令**「写入日志」**</li>
<li>
<ol start="2">
<li>**「发一个prepare命令」**给B和C节点这两个参与者</li>
</ol>
</li>
<li>3.B和C收到消息后，根据自己的实际情况，<strong>「判断自己的实际情况是否可以提交」</strong></li>
<li>4.将处理结果**「记录到日志」**系统</li>
<li>5.将结果**「返回」**给协调者</li>
</ul>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224180733996.png" alt="image-20211224180733996"></p>
<p>第二个阶段是**「决定阶段」**</p>
<p>当A节点收到B和C参与者所有的确认消息后</p>
<ul>
<li><strong>「判断」<strong>所有协调者</strong>「是否都可以提交」</strong></li>
<li>
<ul>
<li>如果可以则**「写入日志」**并且发起commit命令</li>
<li>有一个不可以则**「写入日志」**并且发起abort命令</li>
</ul>
</li>
<li>参与者收到协调者发起的命令，<strong>「执行命令」</strong></li>
<li>将执行命令及结果**「写入日志」**</li>
<li>**「返回结果」**给协调者</li>
</ul>
<h6 id="可能会存在哪些问题" tabindex="-1"><a class="header-anchor" href="#可能会存在哪些问题" aria-hidden="true">#</a> 可能会存在哪些问题？</h6>
<ul>
<li><strong>「单点故障」</strong>：一旦事务管理器出现故障，整个系统不可用</li>
<li><strong>「数据不一致」</strong>：在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li>
<li><strong>「响应时间较长」</strong>：整个消息链路是串行的，要等待响应结果，不适合高并发的场景</li>
<li><strong>「不确定性」</strong>：当事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。</li>
</ul>
<h5 id="三阶段提交-3pc" tabindex="-1"><a class="header-anchor" href="#三阶段提交-3pc" aria-hidden="true">#</a> 三阶段提交（3PC）</h5>
<p>三阶段提交又称3PC，相对于2PC来说增加了CanCommit阶段和超时机制。如果段时间内没有收到协调者的commit请求，那么就会自动进行commit，解决了2PC单点故障的问题。</p>
<p>但是性能问题和不一致问题仍然没有根本解决。下面我们还是一起看下三阶段流程的是什么样的？</p>
<ul>
<li>第一阶段：**「CanCommit阶段」**这个阶段所做的事很简单，就是协调者询问事务参与者，你是否有能力完成此次事务。</li>
<li>
<ul>
<li>如果都返回yes，则进入第二阶段</li>
<li>有一个返回no或等待响应超时，则中断事务，并向所有参与者发送abort请求</li>
</ul>
</li>
<li>第二阶段：**「PreCommit阶段」**此时协调者会向所有的参与者发送PreCommit请求，参与者收到后开始执行事务操作，并将Undo和Redo信息记录到事务日志中。参与者执行完事务操作后（此时属于未提交事务的状态），就会向协调者反馈“Ack”表示我已经准备好提交了，并等待协调者的下一步指令。</li>
<li>第三阶段：**「DoCommit阶段」**在阶段二中如果所有的参与者节点都可以进行PreCommit提交，那么协调者就会从“预提交状态”转变为“提交状态”。然后向所有的参与者节点发送&quot;doCommit&quot;请求，参与者节点在收到提交请求后就会各自执行事务提交操作，并向协调者节点反馈“Ack”消息，协调者收到所有参与者的Ack消息后完成事务。相反，如果有一个参与者节点未完成PreCommit的反馈或者反馈超时，那么协调者都会向所有的参与者节点发送abort请求，从而中断事务。</li>
</ul>
<h5 id="补偿事务-tcc" tabindex="-1"><a class="header-anchor" href="#补偿事务-tcc" aria-hidden="true">#</a> 补偿事务（TCC）</h5>
<p>TCC其实就是采用的补偿机制，其核心思想是：<strong>「针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作」</strong>。它分为三个阶段：</p>
<p><strong>「Try,Confirm,Cancel」</strong></p>
<ul>
<li>Try阶段主要是对**「业务系统做检测及资源预留」**，其主要分为两个阶段</li>
<li>
<ul>
<li>Confirm 阶段主要是对**「业务系统做确认提交」**，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，<strong>「预留资源释放」</strong>。</li>
</ul>
</li>
</ul>
<p>比如下一个订单减一个库存：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8392c68c5b342c0382acf75cbe82cea5.png" alt="img"></p>
<p>执行流程：</p>
<ul>
<li>Try阶段：订单系统将当前订单状态设置为支付中，库存系统校验当前剩余库存数量是否大于1，然后将可用库存数量设置为库存剩余数量-1，</li>
<li>
<ul>
<li>如果Try阶段**「执行成功」**，执行Confirm阶段，将订单状态修改为支付成功，库存剩余数量修改为可用库存数量</li>
<li>如果Try阶段**「执行失败」**，执行Cancel阶段，将订单状态修改为支付失败，可用库存数量修改为库存剩余数量</li>
</ul>
</li>
</ul>
<p>TCC 事务机制相比于上面介绍的2PC，解决了其几个缺点：</p>
<ul>
<li>1.<strong>「解决了协调者单点」</strong>，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</li>
<li>2.<strong>「同步阻塞」</strong>：引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</li>
<li>3.<strong>「数据一致性」</strong>，有了补偿机制之后，由业务活动管理器控制一致性</li>
</ul>
<p>总之，TCC 就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，并且很大程度的**「增加」<strong>了业务代码的</strong>「复杂度」**，因此，这种模式并不能很好地被复用。</p>
<h5 id="本地消息表" tabindex="-1"><a class="header-anchor" href="#本地消息表" aria-hidden="true">#</a> 本地消息表</h5>
<p><img src="https://img-blog.csdnimg.cn/img_convert/347354cc33ca1d49f9b6065d93ba750b.png" alt="img"></p>
<p>执行流程：</p>
<ul>
<li>
<p>消息生产方，需要额外建一个消息表，并**「记录消息发送状态」**。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。</p>
</li>
<li>
<ul>
<li>如果消息发送失败，会进行重试发送。</li>
</ul>
</li>
<li>
<p>消息消费方，需要**「处理」<strong>这个</strong>「消息」**，并完成自己的业务逻辑。</p>
</li>
<li>
<ul>
<li>
<p>如果是**「业务上面的失败」<strong>，可以给生产方</strong>「发送一个业务补偿消息」**，通知生产方进行回滚等操作。</p>
</li>
<li>
<p>此时如果本地事务处理成功，表明已经处理成功了</p>
</li>
<li>
<p>如果处理失败，那么就会重试执行。</p>
</li>
</ul>
</li>
<li>
<p>生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。</p>
</li>
</ul>
<h5 id="消息事务" tabindex="-1"><a class="header-anchor" href="#消息事务" aria-hidden="true">#</a> 消息事务</h5>
<p>消息事务的原理是将两个事务**「通过消息中间件进行异步解耦」**，和上述的本地消息表有点类似，但是是通过消息中间件的机制去做的，其本质就是'将本地消息表封装到了消息中间件中'。</p>
<p>执行流程：</p>
<ul>
<li>发送prepare消息到消息中间件</li>
<li>发送成功后，执行本地事务</li>
<li>
<ul>
<li>如果事务执行成功，则commit，消息中间件将消息下发至消费端</li>
<li>如果事务执行失败，则回滚，消息中间件将这条prepare消息删除</li>
</ul>
</li>
<li>消费端接收到消息进行消费，如果消费失败，则不断重试</li>
</ul>
<p>这种方案也是实现了**「最终一致性」<strong>，对比本地消息表实现方案，不需要再建消息表，</strong>「不再依赖本地数据库事务」<strong>了，所以这种方案更适用于高并发的场景。目前市面上实现该方案的</strong>「只有阿里的 RocketMQ」**。</p>
<h5 id="最大努力通知" tabindex="-1"><a class="header-anchor" href="#最大努力通知" aria-hidden="true">#</a> 最大努力通知</h5>
<p>最大努力通知的方案实现比较简单，适用于一些最终一致性要求较低的业务。</p>
<p>执行流程：</p>
<ul>
<li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li>
<li>这里会有个专门消费 MQ 的服务，这个服务会消费 MQ 并调用系统 B 的接口；</li>
<li>要是系统 B 执行成功就 ok 了；要是系统 B 执行失败了，那么最大努力通知服务就定时尝试重新调用系统 B, 反复 N 次，最后还是不行就放弃。</li>
</ul>
<h5 id="sagas-事务模型" tabindex="-1"><a class="header-anchor" href="#sagas-事务模型" aria-hidden="true">#</a> Sagas 事务模型</h5>
<p>Saga事务模型又叫做长时间运行的事务</p>
<p>其核心思想是**「将长事务拆分为多个本地短事务」<strong>，由Saga事务协调器协调，如果正常结束那就正常完成，如果</strong>「某个步骤失败，则根据相反顺序一次调用补偿操作」**。</p>
<p>Seata框架中一个分布式事务包含3种角色：</p>
<p><strong>「Transaction Coordinator (TC)」</strong>：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚。<strong>「Transaction Manager (TM)」</strong>：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议。<strong>「Resource Manager (RM)」</strong>：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚。</p>
<p>seata框架**「为每一个RM维护了一张UNDO_LOG表」**，其中保存了每一次本地事务的回滚数据。</p>
<p>具体流程：1.首先TM 向 TC 申请**「开启一个全局事务」<strong>，全局事务</strong>「创建」<strong>成功并生成一个</strong>「全局唯一的 XID」**。</p>
<p>2.XID 在微服务调用链路的上下文中传播。</p>
<p>3.RM 开始执行这个分支事务，RM首先解析这条SQL语句，<strong>「生成对应的UNDO_LOG记录」</strong>。下面是一条UNDO_LOG中的记录，UNDO_LOG表中记录了分支ID，全局事务ID，以及事务执行的redo和undo数据以供二阶段恢复。</p>
<p>4.RM在同一个本地事务中**「执行业务SQL和UNDO_LOG数据的插入」<strong>。在提交这个本地事务前，RM会向TC</strong>「申请关于这条记录的全局锁」**。</p>
<p>如果申请不到，则说明有其他事务也在对这条记录进行操作，因此它会在一段时间内重试，重试失败则回滚本地事务，并向TC汇报本地事务执行失败。</p>
<p>6.RM在事务提交前，<strong>「申请到了相关记录的全局锁」</strong>，然后直接提交本地事务，并向TC**「汇报本地事务执行成功」**。此时全局锁并没有释放，全局锁的释放取决于二阶段是提交命令还是回滚命令。</p>
<p>7.TC根据所有的分支事务执行结果，向RM**「下发提交或回滚」**命令。</p>
<ul>
<li>RM如果**「收到TC的提交命令」<strong>，首先</strong>「立即释放」<strong>相关记录的全局</strong>「锁」**，然后把提交请求放入一个异步任务的队列中，马上返回提交成功的结果给 TC。异步队列中的提交请求真正执行时，只是删除相应 UNDO LOG 记录而已。</li>
<li>RM如果**「收到TC的回滚命令」**，则会开启一个本地事务，通过 XID 和 Branch ID 查找到相应的 UNDO LOG 记录。将 UNDO LOG 中的后镜与当前数据进行比较，</li>
<li>
<ul>
<li>如果不同，说明数据被当前全局事务之外的动作做了修改。这种情况，需要根据配置策略来做处理。</li>
<li>如果相同，根据 UNDO LOG 中的前镜像和业务 SQL 的相关信息生成并执行回滚的语句并执行，然后提交本地事务达到回滚的目的，最后释放相关记录的全局锁。</li>
</ul>
</li>
</ul>
<p>总结</p>
<p>本文介绍了分布式事务的一些基础理论，并对常用的分布式事务方案进行了讲解。</p>
<p>分布式事务本身就是一个技术难题，业务中具体使用哪种方案还是需要不同的业务特点自行选择，但是我们也会发现，分布式事务会大大的提高流程的复杂度，会带来很多额外的开销工作，<strong>「代码量上去了，业务复杂了，性能下跌了」</strong>。</p>
<h3 id="_9-为什么分布式系统的一致性和可用性不能同时满足" tabindex="-1"><a class="header-anchor" href="#_9-为什么分布式系统的一致性和可用性不能同时满足" aria-hidden="true">#</a> 9.为什么分布式系统的一致性和可用性不能同时满足？</h3>
<p>现在我们就来证明一下，为什么不能同时满足三个特性？</p>
<p>假设有两台服务器，一台放着应用A和数据库V，一台放着应用B和数据库V，他们之间的网络可以互通，也就相当于分布式系统的两个部分。</p>
<p>在满足一致性的时候，两台服务器 N1和N2，一开始两台服务器的数据是一样的，DB0=DB0。在满足可用性的时候，用户不管是请求N1或者N2，都会得到立即响应。在满足分区容错性的情况下，N1和N2有任何一方宕机，或者网络不通的时候，都不会影响N1和N2彼此之间的正常运作。</p>
<p>当用户通过N1中的A应用请求数据更新到服务器DB0后，这时N1中的服务器DB0变为DB1，通过分布式系统的数据同步更新操作，N2服务器中的数据库V0也更新为了DB1，这时，用户通过B向数据库发起请求得到的数据就是即时更新后的数据DB1。</p>
<p>上面是正常运作的情况，但分布式系统中，最大的问题就是网络传输问题，现在假设一种极端情况，N1和N2之间的网络断开了，但我们仍要支持这种网络异常，也就是满足分区容错性，那么这样能不能同时满足一致性和可用性呢？</p>
<p>假设N1和N2之间通信的时候网络突然出现故障，有用户向N1发送数据更新请求，那N1中的数据DB0将被更新为DB1，由于网络是断开的，N2中的数据库仍旧是DB0；</p>
<p>如果这个时候，有用户向N2发送数据读取请求，由于数据还没有进行同步，应用程序没办法立即给用户返回最新的数据DB1，怎么办呢？有二种选择，第一，牺牲数据一致性，响应旧的数据DB0给用户；第二，牺牲可用性，阻塞等待，直到网络连接恢复，数据更新操作完成之后，再给用户响应最新的数据DB1。</p>
<p>上面的过程比较简单，但也说明了要满足分区容错性的分布式系统，只能在一致性和可用性两者中，选择其中一个。也就是说分布式系统不可能同时满足三个特性。这就需要我们在搭建系统时进行取舍了，那么，怎么取舍才是更好的策略呢?</p>
<p>三、取舍策略
CAP三个特性只能满足其中两个，那么取舍的策略就共有三种：</p>
<p>CA without P：如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。但放弃P的同时也就意味着放弃了系统的扩展性，也就是分布式节点受限，没办法部署子节点，这是违背分布式系统设计的初衷的。</p>
<p>CP without A：如果不要求A（可用），相当于每个请求都需要在服务器之间保持强一致，而P（分区）会导致同步时间无限延长(也就是等待数据同步完才能正常访问服务)，一旦发生网络故障或者消息丢失等情况，就要牺牲用户的体验，等待所有数据全部一致了之后再让用户访问系统。设计成CP的系统其实不少，最典型的就是分布式数据库，如Redis、HBase等。对于这些分布式数据库来说，数据的一致性是最基本的要求，因为如果连这个标准都达不到，那么直接采用关系型数据库就好，没必要再浪费资源来部署分布式数据库。</p>
<p>AP wihtout C：要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性。典型的应用就如某米的抢购手机场景，可能前几秒你浏览商品的时候页面提示是有库存的，当你选择完商品准备下单的时候，系统提示你下单失败，商品已售完。这其实就是先在 A（可用性）方面保证系统可以正常的服务，然后在数据的一致性方面做了些牺牲，虽然多少会影响一些用户体验，但也不至于造成用户购物流程的严重阻塞。</p>
<p>三、总结
现如今，对于多数大型互联网应用的场景，主机众多、部署分散，而且现在的集群规模越来越大，节点只会越来越多，所以节点故障、网络故障是常态，因此分区容错性也就成为了一个分布式系统必然要面对的问题。那么就只能在C和A之间进行取舍。但对于传统的项目就可能有所不同，拿银行的转账系统来说，涉及到金钱的对于数据一致性不能做出一丝的让步，C必须保证，出现网络故障的话，宁可停止服务，可以在A和P之间做取舍。</p>
<p>总而言之，没有最好的策略，好的系统应该是根据业务场景来进行架构设计的，只有适合的才是最好的。</p>
<h3 id="_10-你是如何理解数据一致性的-数据一致性有哪几种模型" tabindex="-1"><a class="header-anchor" href="#_10-你是如何理解数据一致性的-数据一致性有哪几种模型" aria-hidden="true">#</a> 10.你是如何理解数据一致性的？数据一致性有哪几种模型？</h3>
<p>一般来说数据一致性我们可以分成三类，时间点一致性，事务一致性，应用一致性。</p>
<h5 id="时间点一致性-point-in-time-consistency" tabindex="-1"><a class="header-anchor" href="#时间点一致性-point-in-time-consistency" aria-hidden="true">#</a> 时间点一致性(Point in time Consistency)</h5>
<p>时间点一致性我觉得也可以叫做副本一致性，时间点一致性的定义为:</p>
<blockquote>
<p>如果所有相关的数据组件在任意时刻都是一致的，那么可以称作为时间点一致性。</p>
</blockquote>
<p>这个定义如果你了解过CAP理论的话，那么你应该不会太陌生。(如果不熟悉的同学可以看我这篇文章<a href="https://mp.weixin.qq.com/s/gg4q_53eiHCI3OUWzN7eWg" target="_blank" rel="noopener noreferrer">分布式事务<ExternalLinkIcon/></a>)</p>
<p>在CAP中的C的定义为对某个指定的客户端来说，读操作能返回最新的写操作。我们可以发现时间点并没有规定一致的需要保证是最新的，所以可能有同学会提出疑问时间点一致性的范围比CAP中的一致性范围要大一点。其实细想一下如果我们某个数据组件更新了数据，如果为了满足时间点一致性，那么我们所有相关的数据组件的数据都是一致的，所以其他的数据都会变为最新的，那么其实就和CAP是一样的，都需要满足如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据。</p>
<p>当然CAP和时间点一致性并不是完全的一致:时间点一致性的定义中要求所有数据组件的数据在任意时刻都是完全一致的，但是一般来说信息传播的速度最大是光速，其实并不能达到任意时刻一致，总有一定的时间不一致，对于我们CAP中的一致性来说只要达到读取到最新数据即可，达到这种情况并不需要严格的任意时间一致。</p>
<p>这里我们还需要注意的是这个并不总是用于分布式系统中的，在我们单个机器中如果有多核处理器，我们再任意时刻访问不同处理器对同一变量数据都需要是一致的也可以同样适用。</p>
<h5 id="事务一致性" tabindex="-1"><a class="header-anchor" href="#事务一致性" aria-hidden="true">#</a> 事务一致性</h5>
<p>一致性不仅仅可以表示数据的同时变更或相同性，还可以用来表示约束，而我们的事务一致性就是其中的一种。事务一致性就是我们平时所说的ACID中的C，其定义如下:</p>
<blockquote>
<p>事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</p>
</blockquote>
<p>事务一致性只能存在在事务开始前的和事务完成之后，在事务过程中数据有可能不一致。举个例子:比如A转100元给B，A扣减100，B加上100，在事务开始前和事务完成之后都能保证他们的帐是对上的，那么这就是事务一致性。但是在事务过程中有可能会出现A扣减了100元，B没有加上100元的情况，这就是不一致。</p>
<p>这里一般的初学者都会把CAP和ACID中的C都会误解成一样的含义，其实他们其中一个表示的数据的相同，而另一个是用来表示某种约束。</p>
<h5 id="应用一致性" tabindex="-1"><a class="header-anchor" href="#应用一致性" aria-hidden="true">#</a> 应用一致性</h5>
<p>应用一致性可以看做是约束一致性中的一种。上面的事务一致性代表的是单一数据源，如果数据源是多个，比如数据源有多个数据库，文件系统，缓存等。那么就需要我们应用一致性，这里也看做是分布式事务一致性。</p>
<p>在应用程序中涉及多个不同的单机事务，只有在所有的单机事务完成之前和完成之后，数据是完全一致的。比如给用户发送券和积分，券服务和积分服务是两个服务，他们各自有自己单机事务，这两个单机单机事务开始前和完成后都能保证用户的帐是对应上的。但是在这两个单机事务执行过程有可能会出现只送了券，没有送积分的情况，有可能状态不正确。</p>
<p>这三种一致性可以简单的看做两类，一个是数据副本一致，另一个是数据约束一致。接下来我更多的会介绍数据副本的一致的类型，而数据约束的一致，可以参考我之前写过的分布式事务的那篇文章。</p>
<h4 id="一致性的模型" tabindex="-1"><a class="header-anchor" href="#一致性的模型" aria-hidden="true">#</a> 一致性的模型</h4>
<p>再写这篇文章之前，我一直以为一致性就那么几个常听说的，强一致，弱一致，最终一致。再查询了一些文献资料之后发现一致性的类型真的是非常的多，这里我挑选一些比较重要的</p>
<p>如果有人问你你知道哪些一致性模型呢？很多人马上答出，强一致，最终一致。其实一致性的模型远远不止这么点，在《<a href="https://es.cs.uni-kl.de/publications/datarsg/Senf13.pdf" target="_blank" rel="noopener noreferrer">Operational Characterization of Weak Memory Consistency Models<ExternalLinkIcon/></a>》这篇论文当中描述了15种弱内存一致模型，而在维基百科对内存模型的描述还有更多。</p>
<p>很多一致性的模型最开始是用来描述内存是否一致的，也就是最开始并不是运用于分布式系统当中的。如果我们的机器是单核的话，那么他的内存一定是强一致的。如果我们的机器是多核的话，那么由于处理器并不是直接访问的内存而是访问的处理器独享的缓存，那么就有可能会出现不一致。再分布式中我们的每个节点其实就可以看成一个独立的处理器，而我们最初运用于内存一致性模型，也可以运用于我们分布式系统当中。下面我会从强到弱讲讲一些常见的一致性模型。</p>
<h5 id="线性一致性" tabindex="-1"><a class="header-anchor" href="#线性一致性" aria-hidden="true">#</a> 线性一致性</h5>
<p>线性一致性又叫做原子一致性，强一致性。线性一致性可以看做只有一个单核处理器，或者可以看做只有一个数据副本，并且所有操作都是原子的。在可线性化的分布式系统中，如果某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据。可以看见线性一致性和我们的CAP中的C是一致的。</p>
<p>举个非线性一致性的例子，比如有个秒杀活动，你和你的朋友同时去抢购一样东西，有可能他那里的库存已经没了，但是在你手机上显示还有几件，这个就违反了线性一致性，哪怕过了一会你的手机也显示库存没有，也依然是违反了。</p>
<p>线性一致性有什么作用呢？在《DDIA》这本书中描述了下面3个作用:</p>
<ul>
<li>加锁与主节点选举:主从复制系统需要确保只有一个主节点，否则会产生脑裂。选举新的主节点一般是使用锁:每个启动的节点都需要获得锁。而这个锁就需要满足可线性化，让所有的节点都同时同意哪个节点有锁。我们的ZooKeeper就可以用来提供分布式锁功能，那么我们就可以说ZooKeeper是满足线性一致性的吗？这个只能说说对了一部分，后面再顺序一致性的时候会对ZK是什么一致性再次说明。</li>
<li>约束与唯一性保证:比如同一个文件目录下不允许有两个相同的文件名，数据库主键不能重复，这些都需要线性化。其实这些本质和加锁类似，比如相同的文件名，那其实就是对这个文件名去做一个加锁操作，然后去保存，后保存的自然会出错。</li>
<li>跨通道的时间依赖:之前的那个抢购的那个例子为什么会被违反呢？原因是因为我们通过朋友告知这个通道，让我们提前知道了这个货物已经卖完。同样的如果我们计算机中出现了多个通道。举个例子，在用户交易的场景下，用户使用了50元，那么会在其余额中扣减50元，这个时候把这个事件作为一个消息队列给发送出去，然后短信服务会查询用户的余额然后进行发送短信，如果余额数据库的从库这个时候还没有更新数据，那么这个短信就有可能会取到用户旧的余额。这里出现不一致的原因就是因为多了一个通道，就和我们上面朋友告知我们卖完的通道一样。解决这个办法可以控制某一个通道，比如说将这个用户的余额作为参数给传进去，或者只读主库。秒杀的那个例子中，你可以不要自己的手机，去用朋友的手机。</li>
</ul>
<p><img src="https:////upload-images.jianshu.io/upload_images/1977282-0e3edaa6ac68a291?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>image</p>
<h5 id="顺序一致性" tabindex="-1"><a class="header-anchor" href="#顺序一致性" aria-hidden="true">#</a> 顺序一致性</h5>
<p>顺序一致性弱于严格一致性。对变量的写操作不一定要在瞬间看到，但是，不同处理器对变量的写操作必须在所有处理器上以相同的顺序看到，这里处理器再分布式系统中可以换成不同的节点。</p>
<p>这里我们又再回到Zookeeper到底是什么一致性？有很多面试题都会问到Zookeeper是CP还是AP呢？很多人都会回答到Zookeeper是CP，其实这个回答并不是很严谨的，我们从线性一致性中知道CAP中的一致性指的是线性一致性，那我们就可以说Zookeeper是线性一致性的吗？答案是否定的。当我们写入一个值的时候，会交由Leader去处理，Zab协议只需要保证半数从节点成功即可，那么就会有节点的数据是老的数据，这样客户端就有可能读出的数据并非是最新的从而破坏了线性一致性。</p>
<p>Zookeeper其实实现的是顺序一致性，在ZK中利用zxid(ZooKeeper Transaction Id),实现了整体顺序一致性，当然也可以认为Zookeeper的的写是线性一致性，读是顺序一致性。从节点通过zxid顺序的接收leader的广播，所以ZK不能保证所有的信息马上看到，但是最终都会看到。当然Zookeeper其实可以实现线性化，在ZK中有一个sync()命令，只要我们每次读的时候都去调用sync()强制同步数据，那么我们都能保证其是最新的。</p>
<p>顺序一致性是由Lamport(Paxos算法的作者)提出的，最开始只用来定义多处理内存的一致性，在Lamport的《How to Make a Multiprocessor Computer That Correctly Executes Multiprocess Programs》中其定义了什么是顺序一致性:</p>
<blockquote>
<p>the result of any execution is the same as if the operations of all the processors were executed in some sequential order, and the operations of each individual processor appear in this sequence in the order specified by its program.</p>
</blockquote>
<p>这句话的大致意思是多处理器的执行效果和单个处理器的执行效果是一样的,每个独立的处理器的操作都会按照指定的顺序出现在操作队列。这个最开始是用于并发编程的，但是让多处理器的执行变得和单处理器的确是没啥作用，后来就用于分布式系统当中。在ZK中所有的写操作都会交给Leader节点去做，并且所有操作的更新都会根据zxid的顺序进行更新，这里就是上面所说的指定的顺序，这个队列就是按照zxid的顺序。</p>
<h5 id="因果一致性" tabindex="-1"><a class="header-anchor" href="#因果一致性" aria-hidden="true">#</a> 因果一致性</h5>
<p>因果一致性是弱于顺序一致性的一致性模型，顺序一致性要求所有的操作的顺序都必须按照某个单个处理器(节点)的顺序，而因果一致性只需要满足有因果关系的操作是顺序一致性即可。</p>
<p>怎么理解因果关系呢？简单来说如果有人问你一个问题，那么你给出答案，这两个就是因果关系，但如果你给出答案再问题之前，那么这个就违反了因果关系。 举个简单的例子如果节点1更新了数据A，节点2读取数据A，并更新数据B，这里的数据B有可能是根据数据A计算出来的，所有具备因果关系，但是如果节点3看到的是先更新的B，再更新的A那么就破坏了因果一致性。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1977282-935104e60cee62fe?imageMogr2/auto-orient/strip|imageView2/2/w/806/format/webp" alt="img"></p>
<p>image</p>
<h5 id="处理器一致性" tabindex="-1"><a class="header-anchor" href="#处理器一致性" aria-hidden="true">#</a> 处理器一致性</h5>
<p>处理器一致性是更加弱的一致性模型，他只需要保证处理器看到某个处理器或者多个不同处理对相同位置的写入都是一致的。不需要考虑因果关系，而是对同一个内存或者同一个数据更新需要看到一致的顺序。</p>
<h5 id="fifo一致性" tabindex="-1"><a class="header-anchor" href="#fifo一致性" aria-hidden="true">#</a> FIFO一致性</h5>
<p>FIFO一致性是比处理器一致性还更加弱的一种，它不需要保证对相同位置的写入是一致的。 是指在一个处理器上完成的所有写操作，将会被以它实际发生的顺序通知给所有其它的处理器；但是在不同处理器上完成的写操作也许会被其它处理器以不同于实际执行的顺序所看到。这个在分布式系统中反映了网络中不同节点的延迟可能是不相同的。为了说明其和处理器一致性不同有如下例子:</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/1977282-a1a4a7cd54dee1ba?imageMogr2/auto-orient/strip|imageView2/2/w/930/format/webp" alt="img"></p>
<p>image</p>
<p>上面这个图中，可以发现是违反了处理器一致性的，为什么呢因为写入顺序是w(x)1,w(x)2而，p4应该是先R(x)1再R(x)2。但是这个符合FIFO一致性，FIFO只需要把自己的发生顺序通知给其他的处理器或者节点，不需要保证同一个值写入顺序是一致的。</p>
<h5 id="最终一致性" tabindex="-1"><a class="header-anchor" href="#最终一致性" aria-hidden="true">#</a> 最终一致性</h5>
<p>其实除了强一致以外，其他的一致性都可以看作为最终一致性，只是根据一致性不同模型的不同要求又衍生出了很多具体一致性模型。当然最简单的最终一致性，是不需要关注中间变化的顺序，只需要保证在某个时间点一致即可。只是这个某个时间点需要根据不同的系统，不同业务再去衡量。再最终一致性完成之前，有可能返回任何的值，不会对这些值做任何顺序保证。</p>
<blockquote>
<p>BASE理论中的E就是最终一致。</p>
</blockquote>
<h5 id="一致性模型有什么用" tabindex="-1"><a class="header-anchor" href="#一致性模型有什么用" aria-hidden="true">#</a> 一致性模型有什么用</h5>
<p>上面介绍了这么多一致性模型，我们了解到越强的一致性他的约束条件就越多，如果我们实现的话成本那么也就会越大。可以看见ZK如果想实现完全的线性一致性，那么他就需要随时都调用sync()去进行同步数据。</p>
<p>再我们真实的场景中我们数据库的主从复制模型(通过binlog复制也是顺序一致性)，从库的很大作用就是为了缓解主库的读压力，如果我们想盲目的达到线性化一致性，那么就必须去访问主库，这样我们的从库的意义就微乎其微了。</p>
<p>所以根据不同的系统的模型，不同的业务要求，我们对于一致性的要求是不同的，所以我们了解这些一致性的模型是有很多必要的。</p>
<h5 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1" aria-hidden="true">#</a> 总结</h5>
<p>这篇文章主要是介绍了什么是一致性，包括很多一致性模型，这里少讲了两个一致性事务一致性和应用一致性，有兴趣的可以阅读分布式事务。还有一个值得一提的是，谈到一致性其实就离不开共识，因为当数据副本有多个的时候，到底选择谁，如何选择才是正确的，这个有兴趣的同学可以自行查阅一些资料，比如Raft,Paxos和Zab等。</p>
<p>最后也再给大家几个问题:</p>
<ol>
<li>ZK到底是一致性模型？</li>
<li>Mysql主从是什么一致性模型?</li>
<li>Mysql主主是什么一致性模型？</li>
<li>你常用的一致性模型是什么？</li>
</ol>
<p>博客作者：咖啡拿铁的技术分享
每日一博栏目，每日为你推荐优秀博主的优质技术文章。同时欢迎用户投稿，文章一旦被官方账号收录，将获得网站首页推荐位置展示。关注开源中国简书号每日获取优质推送，点击下方链接，阅读原文章。↓↓↓
<a href="https://my.oschina.net/u/4072299/blog/3014290?from=jianshu" target="_blank" rel="noopener noreferrer">每日一博 | 你知道数据一致性有几种吗？谈谈数据一致性<ExternalLinkIcon/></a></p>
<h3 id="_11-你在做系统设计时-如何选择实现强一致性还是弱一致性" tabindex="-1"><a class="header-anchor" href="#_11-你在做系统设计时-如何选择实现强一致性还是弱一致性" aria-hidden="true">#</a> 11.你在做系统设计时，如何选择实现强一致性还是弱一致性？</h3>
<h5 id="cap原理与最终一致性-强一致性-弱一致性" tabindex="-1"><a class="header-anchor" href="#cap原理与最终一致性-强一致性-弱一致性" aria-hidden="true">#</a> CAP原理与最终一致性 强一致性 弱一致性</h5>
<p>介绍内容转载自：http://www.blogjava.net/hello-yun/archive/2012/04/27/376744.html</p>
<p>CAP原理中，有三个要素：</p>
<ul>
<li>一致性(<strong>C</strong>onsistency)</li>
<li>可用性(<strong>A</strong>vailability)</li>
<li>分区容忍性(<strong>P</strong>artition tolerance)</li>
</ul>
<p>CAP原理指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。因此在进行分布式架构设计时，必须做出取舍。而<strong>对于分布式数据系统，分区容忍性是基本要求</strong>，否则就失去了价值。因此设计分布式数据系统，就是在一致性和可用性之间取一个平衡。对于大多数web应用，其实并不需要强一致性，因此牺牲一致性而换取高可用性，是目前多数分布式数据库产品的方向。</p>
<p>当然，牺牲一致性，并不是完全不管数据的一致性，否则数据是混乱的，那么系统可用性再高分布式再好也没有了价值。牺牲一致性，只是不再要求关系型数据库中的强一致性，而是只要系统能达到<strong>最终一致性</strong>即可，考虑到客户体验，这个最终一致的时间窗口，要尽可能的对用户透明，也就是需要保障“用户感知到的一致性”。通常是通过数据的多份异步复制来实现系统的高可用和数据的最终一致性的，“用户感知到的一致性”的时间窗口则取决于数据复制到一致状态的时间。</p>
<p><strong>最终一致性(eventually consistent)</strong></p>
<p>对于一致性，可以分为从客户端和服务端两个不同的视角。从客户端来看，一致性主要指的是多并发访问时更新过的数据如何获取的问题。从服务端来看，则是更新如何复制分布到整个系统，以保证数据最终一致。一致性是因为有并发读写才有的问题，因此在理解一致性的问题时，一定要注意结合考虑并发读写的场景。</p>
<p>从客户端角度，多进程并发访问时，更新过的数据在不同进程如何获取的不同策略，决定了不同的一致性。对于关系型数据库，要求更新过的数据能被后续的访问都能看到，这是<em><strong>强一致性*</strong>。如果能容忍后续的部分或者全部访问不到，则是</em><em>弱一致性</em>*。如果经过一段时间后要求能访问到更新后的数据，则是最终一致性。</p>
<p>最终一致性根据更新数据后各进程访问到数据的时间和方式的不同，又可以区分为：</p>
<blockquote>
<ul>
<li><strong>因果一致性</strong>。如果进程A通知进程B它已更新了一个数据项，那么进程B的后续访问将返回更新后的值，且一次写入将保证取代前一次写入。与进程A无因果关系的进程C的访问遵守一般的最终一致性规则。</li>
<li><strong>“读己之所写（read-your-writes）”一致性</strong>。当进程A自己更新一个数据项之后，它总是访问到更新过的值，绝不会看到旧值。这是因果一致性模型的一个特例。</li>
<li><strong>会话（Session）一致性</strong>。这是上一个模型的实用版本，它把访问存储系统的进程放到会话的上下文中。只要会话还存在，系统就保证“读己之所写”一致性。如果由于某些失败情形令会话终止，就要建立新的会话，而且系统的保证不会延续到新的会话。</li>
<li><strong>单调（Monotonic）读一致性</strong>。如果进程已经看到过数据对象的某个值，那么任何后续访问都不会返回在那个值之前的值。</li>
<li><strong>单调写一致性</strong>。系统保证来自同一个进程的写操作顺序执行。要是系统不能保证这种程度的一致性，就非常难以编程了。</li>
</ul>
</blockquote>
<p>上述最终一致性的不同方式可以进行组合，例如单调读一致性和读己之所写一致性就可以组合实现。并且从实践的角度来看，这两者的组合，读取自己更新的数据，和一旦读取到最新的版本不会再读取旧版本，对于此架构上的程序开发来说，会少很多额外的烦恼。</p>
<p>从服务端角度，如何尽快将更新后的数据分布到整个系统，降低达到最终一致性的时间窗口，是提高系统的可用度和用户体验非常重要的方面。对于分布式数据系统：</p>
<ul>
<li>N — 数据复制的份数</li>
<li>W — 更新数据是需要保证写完成的节点数</li>
<li>R — 读取数据的时候需要读取的节点数</li>
</ul>
<p>如果W+R&gt;N，写的节点和读的节点重叠，则是强一致性。例如对于典型的一主一备同步复制的关系型数据库，N=2,W=2,R=1，则不管读的是主库还是备库的数据，都是一致的。</p>
<p>如果W+R&lt;=N，则是弱一致性。例如对于一主一备异步复制的关系型数据库，N=2,W=1,R=1，则如果读的是备库，就可能无法读取主库已经更新过的数据，所以是弱一致性。</p>
<p>对于分布式系统，为了保证高可用性，一般设置N&gt;=3。不同的N,W,R组合，是在可用性和一致性之间取一个平衡，以适应不同的应用场景。</p>
<ul>
<li>如果N=W,R=1，任何一个写节点失效，都会导致写失败，因此可用性会降低，但是由于数据分布的N个节点是同步写入的，因此可以保证强一致性。</li>
<li>如果N=R,W=1，只需要一个节点写入成功即可，写性能和可用性都比较高。但是读取其他节点的进程可能不能获取更新后的数据，因此是弱一致性。这种情况下，如果W&lt;(N+1)/2，并且写入的节点不重叠的话，则会存在写冲突</li>
</ul>
<h3 id="_12-在你的项目里-是如何设计分布式事务-实现最终一致性的" tabindex="-1"><a class="header-anchor" href="#_12-在你的项目里-是如何设计分布式事务-实现最终一致性的" aria-hidden="true">#</a> 12.在你的项目里，是如何设计分布式事务，实现最终一致性的？</h3>
<h3 id="_13-sagas事务模型是什么" tabindex="-1"><a class="header-anchor" href="#_13-sagas事务模型是什么" aria-hidden="true">#</a> 13.Sagas事务模型是什么？</h3>
<p>Saga是一个长活事务可被分解成可以交错运行的子事务集合。其中每个子事务都是一个保持数据库一致性的真实事务。</p>
<h5 id="saga的组成" tabindex="-1"><a class="header-anchor" href="#saga的组成" aria-hidden="true">#</a> Saga的组成</h5>
<ul>
<li>每个Saga由一系列sub-transaction Ti 组成</li>
<li>每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果</li>
</ul>
<p>可以看到，和TCC相比，Saga没有“预留”动作，它的Ti就是直接提交到库。</p>
<h5 id="saga的执行顺序有两种" tabindex="-1"><a class="header-anchor" href="#saga的执行顺序有两种" aria-hidden="true">#</a> <strong>Saga的执行顺序有两种：</strong></h5>
<ul>
<li>T1, T2, T3, ..., Tn</li>
<li>T1, T2, ..., Tj, Cj,..., C2, C1，其中0 &lt; j &lt; n</li>
</ul>
<h5 id="saga定义了两种恢复策略" tabindex="-1"><a class="header-anchor" href="#saga定义了两种恢复策略" aria-hidden="true">#</a> <strong>Saga定义了两种恢复策略：</strong></h5>
<ul>
<li>backward recovery，向后恢复，补偿所有已完成的事务，如果任一子事务失败。即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。</li>
<li>forward recovery，向前恢复，重试失败的事务，假设每个子事务最终都会成功。适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, ..., Tj(失败), Tj(重试),..., Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci。</li>
</ul>
<p>显然，向前恢复没有必要提供补偿事务，如果你的业务中，子事务（最终）总会成功，或补偿事务难以定义或不可能，向前恢复更符合你的需求。</p>
<p>理论上补偿事务永不失败，然而，在分布式世界中，服务器可能会宕机，网络可能会失败，甚至数据中心也可能会停电。在这种情况下我们能做些什么？ 最后的手段是提供回退措施，比如人工干预。</p>
<h3 id="_14-熟悉哪些分布式锁实现方案" tabindex="-1"><a class="header-anchor" href="#_14-熟悉哪些分布式锁实现方案" aria-hidden="true">#</a> 14.熟悉哪些分布式锁实现方案？</h3>
<h5 id="_1-为什么需要锁" tabindex="-1"><a class="header-anchor" href="#_1-为什么需要锁" aria-hidden="true">#</a> 1.为什么需要锁</h5>
<p>​       当我们要操作的一个资源存在中间态（资源在初始状态和结束状态之间还存在其他的状态），那我们在多线程下对此资源的访问就要小心了，因为状态的变迁需要时间，如果在此资源处于中间态的时，其他线程来获取此资源，那么获取到的结果则是这个资源的初始状态的值，这显然是不合理的。举个例子：</p>
<p>int a = 1;
a++;
在java中++不是原子操作，因为此操作分为了三步，第一步先将a变量所在内存的值加载到寄存器，第二步将寄存器的值自增1，第三步将寄存器中的值写回内存，那么a变量就可以被称为是存在中间态的资源。假如我们启了两个线程，A线程执行到了a++的第二步将寄存器的值自增1但还没有写回内存，这时候B线程读到a变量的值还是1，这种现象在业务代码中是不可以发生的，所以针对多线程访问具有中间态资源导致幻读的问题，我们需要用加锁的方式去解决。</p>
<h5 id="_2-锁要实现的思路是什么" tabindex="-1"><a class="header-anchor" href="#_2-锁要实现的思路是什么" aria-hidden="true">#</a> 2.锁要实现的思路是什么</h5>
<p>​       锁要实现的思路为，对具有中间态资源的访问进行排它处理，也就是在a++这个非原子操作执行结束之前，禁止让其他线程获取变量a的值，在宏观上的体现为，所有任务必须排队有序的执行，这里的有序不单指顺序，还可以为竞争得到锁的顺序。多线程获取锁的步骤：</p>
<pre><code>   （1）通过竞争获取锁（排队）
   （2）线程在对资源的操作中禁止其他线程对该资源的访问（占坑）
   （3）其他线程阻塞或者异步尝试获取锁（等待）
   （4）线程处理完任务释放锁，其他线程拿到锁（释放）
</code></pre>
<h5 id="_3-单体应用锁的局限性" tabindex="-1"><a class="header-anchor" href="#_3-单体应用锁的局限性" aria-hidden="true">#</a> 3.单体应用锁的局限性</h5>
<p>​       当项目部署方式为单体应用部署时，如果需要对某一个共享变量进行多线程同步访问，可以通过synchronize或者ReentranceLock实现。但如果我们的项目采用集群部署，前端请求采用Nginx转发的话，那么项目中业务方法上加的synchronize或者ReentranceLock就会失效，因为我们加的锁是JDK提供的锁，这种锁只能在一个JVM下起作用。这就是单体应用锁的局限性，只能在一个JVM内加锁，无法跨JVM在整个应用层面去加锁。</p>
<h5 id="_4-什么是分布式锁" tabindex="-1"><a class="header-anchor" href="#_4-什么是分布式锁" aria-hidden="true">#</a> 4.什么是分布式锁</h5>
<p>​       随着业务发展的需要，原单体单机部署的系统被演化成分布式集群系统后，由于分布式系统多线程、多进程且部署在不同的主机上的特点，将使原单机部署情况下的并发控制锁策略失效，单纯的Java API并不能提供分布式锁的能力。为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁。</p>
<h5 id="_5-分布式锁应该具备哪些条件" tabindex="-1"><a class="header-anchor" href="#_5-分布式锁应该具备哪些条件" aria-hidden="true">#</a> 5.分布式锁应该具备哪些条件</h5>
<p>​       我们要找到一个所有的JVM都能访问的第三方公共主键，并且其可以发出两个原子性操作的信号量，那么我们就可以把这两个信号量当做加锁和解锁的标识。分布式锁应该还具有以下条件：</p>
<pre><code>   （1）原子性：在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 
   （2）高可用：高可用的获取锁与释放锁，具备锁失效机制，防止死锁； 
   （3）高性能：高性能的获取锁与释放锁； 
   （4）可重入性：具备可重入特性； 
   （5）阻塞性：没有获得锁之前，其他任务既可以阻塞等待获取锁，也可以在没有获取到锁时直接返回获取锁失败。

   注：上述列举的是作为分布式锁应该满足的五种条件，非必须满足。如高可用和高性能本身就是互斥的，在实现高可用的同时或多或少会对性能产生一定的影响，再比如要不要实现锁的可重入性和阻塞性是根据实际业务来确定的，所以分布式锁的设计还需灵活配置。
</code></pre>
<h5 id="_6-实现分布式锁的五种方案" tabindex="-1"><a class="header-anchor" href="#_6-实现分布式锁的五种方案" aria-hidden="true">#</a> 6.实现分布式锁的五种方案</h5>
<h6 id="_6-1-基于数据库实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_6-1-基于数据库实现分布式锁" aria-hidden="true">#</a> 6.1 基于数据库实现分布式锁</h6>
<p>​              实现原理：把数据库select检索出的数据用for update加锁，其他事务不能修改这条数据，也不能再给这条数据加锁，解锁使用comit提交当前事务。</p>
<pre><code>          加锁信号量：select ...... for update
          解锁信号量：commit  
          实现流程：
</code></pre>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>sql：

DROP TABLE IF EXISTS `distribute_lock`;
CREATE TABLE `distribute_lock`  (
  `id` int(11) NOT NULL,
  `business_code` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `business_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;

INSERT INTO `distribute_lock` VALUES (1, 'demo', 'demo演示');

SET FOREIGN_KEY_CHECKS = 1;
dao：

DistributeLock selectDistributeLock(@Param("businessCode") String businessCode);
mapper：

&lt;select id="selectDistributeLock" resultType="com.example.distributelock.DistributeLock">
    select 
        * 
    from 
        distribute_lock
    where 
        business_code = #{businessCode,jdbcType=VARCHAR}
    for update
&lt;/select>

controller:

@RequestMapping("singleLock")
@Transactional(rollbackFor = Exception.class)
public void  singleLock() throws Exception {
    DistributeLock distributeLock = distributeLockMapper.selectDistributeLock("demo");
    if (distributeLock==null) {
        throw new Exception("分布式锁找不到");
    }
    try {
        //模拟业务代码执行
        Thread.sleep(20000);
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>​              上述代码都很简单，唯一要注意的就是controller层需要打上事务注解，如果不加的话查询sql会自动提交事务导致分布式锁失效。</p>
<h6 id="_6-2-基于redis实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_6-2-基于redis实现分布式锁" aria-hidden="true">#</a> 6.2 基于redis实现分布式锁</h6>
<pre><code>          实现原理：加锁时利用NX的原子性，多线程并发时，只有一个线程可以设置成功，从而获得锁。释放锁的时利用redis的delete命令配合LUA脚本实现，校验之前设置的随机数，相同才能释放，证明此时redis里面的值是当前线程设置的，避免释放了其他线程的锁

          加锁信号量：SET resource_name my_random_value NX PX 30000
             resource_name：redis里面的key，资源的名称，根据不同的业务设置不同的锁
             my_random_value：随机值，每个线程的随机值不同，用于释放锁时的校验
             NX：key不存在的时候设置成功，key存在的时候设置不成功，此操作为原子操作
             PX：自动失效时间，可以使锁过期失效，防止释放锁时出现异常，其他线程一直获取不到锁。
          解锁信号量：LUA脚本实现
          实现流程：
          引入redis依赖：

&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
&lt;/dependency&gt;
redis分布式锁工具类：

public class RedisLock implements AutoCloseable {
private RedisTemplate redisTemplate;
private String key;
private String value;
private int expireTime;
 
public RedisLock(RedisTemplate redisTemplate,String key,int expireTime){
    this.redisTemplate = redisTemplate;
    this.key = key;
    this.expireTime=expireTime;
    this.value = UUID.randomUUID().toString();
}
/**
 * 获取分布式锁
 */
public boolean getLock(){
    RedisCallback&lt;Boolean&gt; redisCallback = connection -&gt; {
        //设置NX
        RedisStringCommands.SetOption setOption = RedisStringCommands.SetOption.ifAbsent();
        //设置过期时间
        Expiration expiration = Expiration.seconds(expireTime);
        //序列化key
        byte[] redisKey = redisTemplate.getKeySerializer().serialize(key);
        //序列化value
        byte[] redisValue = redisTemplate.getValueSerializer().serialize(value);
        //执行setnx操作
        Boolean result = connection.set(redisKey, redisValue, expiration, setOption);
        return result;
    };
    //获取分布式锁
    Boolean lock = (Boolean)redisTemplate.execute(redisCallback);
    return lock;
}
 
/**
 * 解锁
 */
public boolean unLock() {
    String script = &quot;if redis.call(\&quot;get\&quot;,KEYS[1]) == ARGV[1] then\n&quot; +
            &quot;    return redis.call(\&quot;del\&quot;,KEYS[1])\n&quot; +
            &quot;else\n&quot; +
            &quot;    return 0\n&quot; +
            &quot;end&quot;;
    RedisScript&lt;Boolean&gt; redisScript = RedisScript.of(script,Boolean.class);
    List&lt;String&gt; keys = Arrays.asList(key);
    Boolean result = (Boolean)redisTemplate.execute(redisScript, keys, value);
    return result;
}
/**
 * 自动关闭
 */
@Override
public void close(){
    unLock();
}
}
controller：

@RequestMapping(&quot;redisLock&quot;)
public String redisLock(){
    try (RedisLock redisLock = new RedisLock(redisTemplate,&quot;redisKey&quot;,30)){
        if (redisLock.getLock()) {
            //延时模拟业务代码执行
            Thread.sleep(15000);
        }
    }catch (Exception e) {
        e.printStackTrace();
    }
    return &quot;方法执行完成&quot;;
}
</code></pre>
<p>​              工具类中实现了AutoCloseable接口和controller中try中的写法是为了实现JDK提供的自动关闭动能（不用写finally解锁）。</p>
<h6 id="_6-3-基于zookeeper实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_6-3-基于zookeeper实现分布式锁" aria-hidden="true">#</a> 6.3 基于Zookeeper实现分布式锁</h6>
<pre><code>          实现Zookeeper分布式锁之前，小伙伴们需要对Zookeeper的持久节点、瞬时节点以及观察器有一定的了解，笔者Zookeeper学的略渣，就不在这瞎总结了，这里就默认大家已经了解。

          实现原理：利用Zookeeper创建瞬时节点有序的特性，在多线程并发创建瞬时节点，会得到有序的节点序列，我们规定序号最小的线程获得锁。其他线程利用观察器监听自己序号前一个序号的存在状态，前一个线程执行完成，删除自己序号的节点，下一个序号的线程得到通知，执行自己的任务。

          加锁信号量：Zookeeper创建瞬时节点有序性

          解锁信号量：Zookeeper删除节点动作

          实现流程：



引入Zookeeper依赖：

&lt;dependency&gt;
        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
        &lt;version&gt;3.4.14&lt;/version&gt;
&lt;/dependency&gt;
Zookeeper分布式锁工具类：

public class ZkLock implements AutoCloseable, Watcher {
private ZooKeeper zooKeeper;
private String znode;
 
public ZkLock() throws IOException {
    this.zooKeeper = new ZooKeeper(&quot;localhost:2181&quot;, 10000,this);
}
 
public boolean getLock(String businessCode) {
    try {
        //创建业务根节点
        Stat stat = zooKeeper.exists(&quot;/&quot; + businessCode, false);
        if (stat==null){
            zooKeeper.create(&quot;/&quot; + businessCode,businessCode.getBytes(),
                    ZooDefs.Ids.OPEN_ACL_UNSAFE,
                    CreateMode.PERSISTENT);
        }
        //创建瞬时有序节点  /order/order_00000001
        znode = zooKeeper.create(&quot;/&quot; + businessCode + &quot;/&quot; + businessCode + &quot;_&quot;, businessCode.getBytes(),
                ZooDefs.Ids.OPEN_ACL_UNSAFE,
                CreateMode.EPHEMERAL_SEQUENTIAL);
        //获取业务节点下 所有的子节点
        List&lt;String&gt; childrenNodes = zooKeeper.getChildren(&quot;/&quot; + businessCode, false);
        //子节点排序
        Collections.sort(childrenNodes);
        //获取序号最小的（第一个）子节点
        String firstNode = childrenNodes.get(0);
        //如果创建的节点是第一个子节点，则获得锁
        if (znode.endsWith(firstNode)){
            return true;
        }
        //不是第一个子节点，则监听前一个节点
        String lastNode = firstNode;
        for (String node:childrenNodes){
            if (znode.endsWith(node)){
                zooKeeper.exists(&quot;/&quot;+businessCode+&quot;/&quot;+lastNode,true);
                break;
            }else {
                lastNode = node;
            }
        }
        //实现阻塞功能
        synchronized (this){
            wait();
        }
        return true;
    } catch (Exception e) {
        e.printStackTrace();
    }
    return false;
}
@Override
public void close() throws Exception {
    zooKeeper.delete(znode,-1);
    zooKeeper.close();
}
@Override
public void process(WatchedEvent event) {
    if (event.getType() == Event.EventType.NodeDeleted){
        synchronized (this){
            notify();
        }
    }
}
}
controller：

@RequestMapping(&quot;zkLock&quot;)
public String zookeeperLock(){
    try (ZkLock zkLock = new ZkLock()) {
        if (zkLock.getLock(&quot;order&quot;)){
            //延时模拟业务代码执行
            Thread.sleep(10000);
        }
    }catch (Exception e) {
        e.printStackTrace();
    }
    return &quot;方法执行完成！&quot;;
}
</code></pre>
<h6 id="_6-4-基于curator实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_6-4-基于curator实现分布式锁" aria-hidden="true">#</a> 6.4 基于Curator实现分布式锁</h6>
<p>​              Curator是Zookeeper客户端的升级版，已经实现了分布式锁的功能，直接使用即可。</p>
<p>实现流程：</p>
<p>引入Curator依赖：</p>
<dependency>
        <groupId>org.apache.curator</groupId>
        <artifactId>curator-recipes</artifactId>
        <version>4.2.0</version>
</dependency>
controller：
<p>@Autowired
private CuratorFramework client;</p>
<p>@RequestMapping(&quot;curatorLock&quot;)
public String curatorLock(){
InterProcessMutex lock = new InterProcessMutex(client, &quot;/order&quot;);
try{
if (lock.acquire(30, TimeUnit.SECONDS)){
//延时模拟业务代码执行
Thread.sleep(10000);
}
}catch (Exception e) {
e.printStackTrace();
}finally {
try {
lock.release();
} catch (Exception e) {
e.printStackTrace();
}
}
return &quot;方法执行完成！&quot;;
}</p>
<h6 id="_6-5-基于redisson实现分布式锁" tabindex="-1"><a class="header-anchor" href="#_6-5-基于redisson实现分布式锁" aria-hidden="true">#</a> 6.5 基于Redisson实现分布式锁</h6>
<p>​              Redisson是Redis客户端的升级版，已经实现了分布式锁的功能，直接使用即可。</p>
<pre><code>          实现流程：
</code></pre>
<p>引入Redisson依赖：</p>
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.11.2</version>
</dependency>
controller：
<p>@Autowired
private RedissonClient redisson;</p>
<p>@RequestMapping(&quot;redissonLock&quot;)
public String redissonLock() {
RLock rLock = redisson.getLock(&quot;order&quot;);
try {
rLock.lock(30, TimeUnit.SECONDS);
//延时模拟业务执行
Thread.sleep(10000);
} catch (InterruptedException e) {
e.printStackTrace();
}finally {
rLock.unlock();
}
return &quot;方法执行完成！！&quot;;
}
在springboot配置文件中配置redis端口：</p>
<p>spring.redis.host=127.0.0.1</p>
<h5 id="_7-实现分布式锁五种方案对比" tabindex="-1"><a class="header-anchor" href="#_7-实现分布式锁五种方案对比" aria-hidden="true">#</a> 7.实现分布式锁五种方案对比</h5>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211224184744623.png" alt="image-20211224184744623"></p>
<h3 id="_15-分布式锁都有哪些实现方案——你都知道吗" tabindex="-1"><a class="header-anchor" href="#_15-分布式锁都有哪些实现方案——你都知道吗" aria-hidden="true">#</a> 15.分布式锁都有哪些实现方案——你都知道吗？</h3>
<h6 id="一、业务场景" tabindex="-1"><a class="header-anchor" href="#一、业务场景" aria-hidden="true">#</a> 一、业务场景</h6>
<p>同一个jvm里多个线程操作同一个有状态的变量，可以通过JVM内的锁保证线程安全。</p>
<p>如果是多个JVM操作同一个有状态的变量，如何保证线程安全呢？</p>
<p>这时候就需要分布式锁来发挥它的作用了</p>
<p>（想自学习编程的小伙伴请搜索圈T社区，更多行业相关资讯更有行业相关免费视频教程。完全免费哦!）</p>
<h6 id="二、特点" tabindex="-1"><a class="header-anchor" href="#二、特点" aria-hidden="true">#</a> 二、特点</h6>
<p>分布式系统往往业务流量比较大、并发较高，对分布式锁的高可用和高性能有较高的要求。一般分布式锁的方案需要满足如下要求：</p>
<p>有高可用的获取锁和释放锁功能
获取锁和释放锁的性能要好
这把锁要是一把可重入锁（避免死锁）
这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）
这把锁最好是一把公平锁（根据业务需求考虑要不要这条）</p>
<h6 id="三、基于数据库的分布式锁方案" tabindex="-1"><a class="header-anchor" href="#三、基于数据库的分布式锁方案" aria-hidden="true">#</a> 三、基于数据库的分布式锁方案</h6>
<p>1、基于表主键唯一做分布式锁
利用主键唯一的特性，如果有多个请求同时提交到数据库的话，数据库会保证只有一个插入操作可以成功，那么我们就可以认为操作成功的那个线程获得了该方法的锁，当方法执行完毕之后，想要释放锁的话，删除这条数据库记录即可</p>
<p>1.1、缺点
数据库单点
没有锁超时机制
不可重入
非公平锁
非阻塞锁
1.2、优化点
数据库主从备份，解决单点问题。因为主从同步有延迟，可能导致数据不一致
定时任务检测锁超时自动释放或者通过connection.commit()操作来释放锁
加锁加上机器和线程信息，加锁之前先查询，支持可重入
中间表，记录加锁失败的机器线程，按照创建时间排序
自旋实现阻塞效果
1.3、原理
一般数据库使用innodb存储引擎，在插入数据的时候会加行级锁。从而达到是并发请求按顺序执行的效果</p>
<p>2、通过数据库mvcc实现乐观锁
更新数据的时候带上指定版本号，如果被其他线程提前更新的版本号，则此次更新失败</p>
<p>2.1、缺点
对数据库表侵入较大，每个表需要增加version字段</p>
<p>高并发下存在很多更新失败</p>
<p>3、数据库的限制
使用排他锁来进行分布式锁的 lock，那么一个排他锁长时间不提交，就会占用数据库连接。一旦类似的连接变得多了，就可能把数据库连接池撑爆。
数据库写入是磁盘io，性能方面差一些
数据库能支持的最大qps也有限制，很难满足高并发的需要</p>
<h6 id="四、基于redis实现分布式锁" tabindex="-1"><a class="header-anchor" href="#四、基于redis实现分布式锁" aria-hidden="true">#</a> 四、基于redis实现分布式锁</h6>
<p>1、原理
1.1、加锁
原子命令：SET key value NX PX milliseconds</p>
<p>PX milliseconds 过期时间，防止加锁线程死掉不能解锁。过期时间设置太短，可能加锁线程还没有执行完正常逻辑，就到了过期时间</p>
<p>NX 如果没有这个key则设置，存在key返回失败</p>
<p>value 随机值（一般用UUID），用来实现只能由加锁线程解锁</p>
<p>1.2、解锁
lua脚本实现get value，delete的操作。加锁的时候设置的value是不会重复的随机值，解锁的时候必须UUID一致才能解锁</p>
<p>2、缺点
获取锁是非阻塞
非公平锁，不支持需要公平锁的场景
redis主从存在延迟，在master宕机发生主从切换时，可能会导致锁失效</p>
<h6 id="五、基于redlock算法实现分布式锁。redisson对redlock算法进行了封装" tabindex="-1"><a class="header-anchor" href="#五、基于redlock算法实现分布式锁。redisson对redlock算法进行了封装" aria-hidden="true">#</a> 五、基于Redlock算法实现分布式锁。redisson对Redlock算法进行了封装</h6>
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson</artifactId>
    <version>3.3.2</version>
</dependency>
<p>1、原理
在Redis的分布式环境中，我们假设有N个Redis master。这些节点完全互相独立，不存在主从复制或者其他集群协调机制。我们确保将在N个实例上使用与在Redis单实例下相同方法获取和释放锁。现在我们假设有5个Redis master节点，同时我们需要在5台服务器上面运行这些Redis实例，这样保证他们不会同时都宕掉。</p>
<p>1.1、加锁
假设有cluster-1，cluster-2，cluster-3总计3个cluster模式集群。如果要获取分布式锁，那么需要向这3个cluster集群通过EVAL命令执行LUA脚本，需要3/2+1=2，即至少2个cluster集群响应成功。set的value要具有唯一性，redisson的value通过UUID+threadId保证value的唯一性</p>
<p>1.获取当前时间（单位是毫秒）。</p>
<p>2.轮流用相同的key和随机值在N个节点上请求锁，在这一步里，客户端在每个master上请求锁时，会有一个和总的锁释放时间相比小的多的超时时间。比如如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围，这个可以防止一个客户端在某个宕掉的master节点上阻塞过长时间，如果一个master节点不可用了，我们应该尽快尝试下一个master节点。</p>
<p>3.客户端计算第二步中获取锁所花的时间，只有当客户端在大多数master节点上成功获取了锁（在这里是3个），而且总共消耗的时间不超过锁释放时间，这个锁就认为是获取成功了。</p>
<p>4.如果锁获取成功了，那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间。</p>
<p>5.如果锁获取失败了，不管是因为获取成功的锁不超过一半（N/2+1)还是因为总消耗时间超过了锁释放时间，客户端都会到每个master节点上释放锁，即便是那些他认为没有获取成功的锁。</p>
<p>1.2、释放锁
需要在所有节点都释放锁就行，不管之前有没有在该节点获取锁成功。</p>
<p>客户端如果没有在多数节点获取到锁，一定要尽快在获取锁成功的节点上释放锁，这样就没必要等到key超时后才能重新获取这个锁</p>
<p>2、安全性论证
开始之前，让我们假设客户端可以在大多数节点都获取到锁，这样所有的节点都会包含一个有相同存活时间的key。但是需要注意的是，这个key是在不同时间点设置的，所以这些key也会在不同的时间超时，但是我们假设最坏情况下第一个key是在T1时间设置的（客户端连接到第一个服务器时的时间），最后一个key是在T2时间设置的（客户端收到最后一个服务器返回结果的时间），从T2时间开始，我们可以确认最早超时的key至少也会存在的时间为MIN_VALIDITY=TTL-(T2-T1)-CLOCK_DRIFT，TTL是锁超时时间、（T2-T1）是最晚获取到的锁的耗时，CLOCK_DRIFT是不同进程间时钟差异，这个是用来补偿前面的(T2-T1）。其他的key都会在这个时间点之后才会超时，所以我们可以确定这些key在这个时间点之前至少都是同时存在的。</p>
<p>如果一个客户端获取大多数节点锁的耗时接近甚至超过锁的最大有效时间时（就是我们为SET操作设置的TTL值），那么系统会认为这个锁是无效的同时会释放这些节点上的锁，所以我们仅仅需要考虑获取大多数节点锁的耗时小于有效时间的情况。在这种情况下，根据我们前面的证明，在MIN_VALIDITY时间内，没有客户端能重新获取锁成功，所以多个客户端都能同时成功获取锁的结果，只会发生在多数节点获取锁的时间都大大超过TTL时间的情况下，实际上这种情况下这些锁都会失效</p>
<h6 id="六、基于zookeeper实现分布式锁" tabindex="-1"><a class="header-anchor" href="#六、基于zookeeper实现分布式锁" aria-hidden="true">#</a> 六、基于zookeeper实现分布式锁</h6>
<p>1、基本排他锁（非公平锁）
1.1、原理
利用临时节点与 watch 机制。每个锁占用一个普通节点 /lock，当需要获取锁时在 /lock 目录下创建一个临时节点，创建成功则表示获取锁成功，失败则 watch/lock 节点，有删除操作后再去争锁。临时节点好处在于当进程挂掉后能自动上锁的节点自动删除即取消锁。</p>
<p>1.2、缺点
所有取锁失败的进程都监听父节点，很容易发生羊群效应，即当释放锁后所有等待进程一起来创建节点，并发量很大。</p>
<p>2、优化后的排他锁（公平锁）
2.1、原理
上锁改为创建临时有序节点，每个上锁的节点均能创建节点成功，只是其序号不同。只有序号最小的可以拥有锁，如果这个节点序号不是最小的则 watch 序号比本身小的前一个节点 (公平锁)。</p>
<p>3、共享锁
3.1、原理
在锁节点下创建临时顺序节点。读节点为R+序号，写节点为W+序号。创建完节点后，获取所有子节点，对锁节点注册子节点变更的watcher监听，确定自己的序号在所有子节点中的位置。对于读请求，没有比自己序号小的写节点，就表示获得了共享锁，执行读取逻辑。对于写请求，如果自己不是序号最小的子节点，就需要进入等待。接收到watcher通知后，重复获取锁。</p>
<p>3.2、缺点
共享锁羊群效应。大量的watcher通知和子节点列表获取，两个操作重复运行。集群规模比较大的情况下，会对zookeeper服务器造成巨大的性能影响和网络冲击</p>
<p>3.3、优化
读请求，监听比自己小的写节点。写请求，监听比自己小的最后一个节点。</p>
<p>4、zookeeper局限
性能上可能并没有缓存服务那么高，因为每次在创建锁和释放锁的过程中，都要动态创建、销毁临时节点来实现锁功能。
ZK 中创建和删除节点只能通过 Leader 服务器来执行，然后将数据同步到所有的 Follower 机器上。
并发度支持不如redis
————————————————</p>
<h3 id="_16-分布式锁应该具备哪些条件" tabindex="-1"><a class="header-anchor" href="#_16-分布式锁应该具备哪些条件" aria-hidden="true">#</a> 16.分布式锁应该具备哪些条件?</h3>
<p>在分布式系统的环境下，一个方法在同一时间，只能被一个机器下的一个线程使用。
高可用的获取锁与释放锁
高性能的获取锁与释放锁
具备可重入特性，也就是可以重新进入，导致多一个任务而并发使用，不用担心数据的错误
具有失效的机制，防止死锁
具有非阻塞锁的特性，取不到锁就返回一个锁找不到，类似于熔断机制</p>
<h3 id="_17-哪种分布式锁实现方案更好" tabindex="-1"><a class="header-anchor" href="#_17-哪种分布式锁实现方案更好" aria-hidden="true">#</a> 17.哪种分布式锁实现方案更好？</h3>
<h5 id="_01-什么是分布式锁" tabindex="-1"><a class="header-anchor" href="#_01-什么是分布式锁" aria-hidden="true">#</a> <strong>01</strong>  什么是分布式锁</h5>
<p>分布式锁是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。</p>
<p>如果是不同的系统或者同个系统不同主机之间需要共享一个或者一组资源，而访问这些资源时，很多时候都是需要互斥来防止彼此干扰保证一致性，便需要使用到分布式锁。</p>
<p>换句话说就是，分布式锁是为了解决数据一致性的问题。</p>
<h5 id="_02-分布式锁需要满足哪些条件" tabindex="-1"><a class="header-anchor" href="#_02-分布式锁需要满足哪些条件" aria-hidden="true">#</a> **02 ** 分布式锁需要满足哪些条件</h5>
<p><strong>排他性</strong>：在同个时间只能有一个客户端允许获取到锁，其他客户端不允许同时获取。</p>
<p><strong>避免死锁</strong>：当这把锁在一段有限时间之后，一定会被释放，可能是正常释放也可能是异常释放。</p>
<p><strong>高可用</strong>：获取或释放锁的机制一定要导读可用性，并且性能要好。</p>
<p>**03 **分布式锁的实现方式</p>
<p>目前，分布式锁有三种主流方式。</p>
<p><strong>① 基于数据库实现</strong></p>
<p><strong>② 基于缓存锁实现</strong></p>
<p><strong>③ 基于ZooKeeper实现</strong></p>
<p>在实际应用场景中，需要根据具体业务去选择，因为这三种方式分布式锁实现方式都不是完美的。下面小编就跟大家讲解一下这三种方式。</p>
<h5 id="_1-基于数据库锁表" tabindex="-1"><a class="header-anchor" href="#_1-基于数据库锁表" aria-hidden="true">#</a> 1.基于数据库锁表</h5>
<p>这种方式完全依靠数据库索引来实现。当想要获得锁时，就向数据库中插入一条记录，释放锁时就会删除这条记录，但这种方式会出现以下问题：</p>
<p><strong>（1）锁没有失效时间</strong>。一旦解锁失败就会导致死锁，其他线程也无法再获取到锁，因为唯一索引insert都会返回失败。</p>
<p><strong>（2）只能是非阻塞锁，insert失败就只能报错，无法进入队伍进行重试。</strong></p>
<p><strong>（3）不可重入，同一线程在没有释放锁之前是无法再获取到锁的。</strong></p>
<p>2.采用乐观锁增加版本号</p>
<p>根据版本号来判断更新之前有没有其他线程更新过，如果被更新过，就会获取失败。</p>
<h5 id="_2-基于缓存锁实现" tabindex="-1"><a class="header-anchor" href="#_2-基于缓存锁实现" aria-hidden="true">#</a> 2.基于缓存锁实现</h5>
<p>缓存锁主要介绍几种redis实现的分布式锁：</p>
<ol>
<li>基于setnx、expire两个命令来实现</li>
</ol>
<p>基于setnx（set if not exist）的特点，当缓存里key不存在时，才会去set，否则直接返回false。如果返回true则获取到锁，否则获取锁失败，为了防止死锁，我们再用expire命令对这个key设置一个超时时间来避免。但是这里看似完美，实则有缺陷，当我们setnx成功后，线程发生异常中断，expire还没来的及设置，那么就会产生死锁。</p>
<ol start="2">
<li>RedLock算法</li>
</ol>
<p>redlock算法，起5个控制节点，分布在不同的机房尽量保证可用性。为了获得锁，客户端会进行如下操作：</p>
<p>(1)得到当前的时间，单位 &gt;&gt;&gt; 微妙。</p>
<p>(2)尝试顺序地在 5 个实例上申请锁，当然需要使用相同的 key 和 random value，这里一个客户端需要合理设置与master节点沟通的timeout大小，避免长时间和一个 fail 了的节点浪费时间。</p>
<p>(3)当客户端在大于等于 3 个 master 上成功申请到锁的时候，且它会计算申请锁消耗了多少时间，这部分消耗的时间采用获得锁的当下时间减去第一步获得的时间戳得到，如果锁的持续时长（lock validity time）比流逝的时间多的话，那么锁就真正获取到了。</p>
<p>(4)如果锁申请到了，那么锁真正的 lock validity time 应该是origin（lock validity time）申请锁期间流逝的时间。</p>
<p>(5)如果客户端申请锁失败了，那么它就会在少部分申请成功锁的 master 节点上执行释放锁的操作，重置状态。</p>
<h5 id="_3-基于zookeeper实现" tabindex="-1"><a class="header-anchor" href="#_3-基于zookeeper实现" aria-hidden="true">#</a> 3.基于zookeeper实现</h5>
<p>zookeeper的内部是一个分层的文件系统目录树结构，规定同一个目录下只能有一个唯一的文件名。</p>
<p>数据模型：</p>
<p>永久节点：节点创建后，不会因为会话失效而消失临时节点：与永久节点相反，如果客户端连接失效，则立即删除节点顺序节点：与上述两个节点特性类似，如果指定创建这类节点时，zk会自动在节点名后加一个数字后缀，并且是有序的。</p>
<p>监视器（watcher）：当创建一个节点时，可以注册一个该节点的监视器，当节点状态发生改变时，watch被触发时，ZooKeeper将会向客户端发送且仅发送一条通知，因为watch只能被触发一次。</p>
<p>zookeeper如何利用这些特性来实现分布式锁：</p>
<p>\1. 创建一个锁目录lock。</p>
<p>\2. 希望获得锁的线程A就在lock目录下，创建临时顺序节点。</p>
<p>\3. 获取锁目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁。</p>
<p>\4. 线程B获取所有节点，判断自己不是最小节点，设置监听(watcher)比自己次小的节点（只关注比自己次小的节点是为了防止发生“羊群效应”）。</p>
<p>\5. 线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是最小的节点，获得锁。</p>
<p>△zookeeper实现分布式排它锁</p>
<p>这三种实现方式各有优缺点，下面给大家整理了一个大概：</p>
<h5 id="数据库锁" tabindex="-1"><a class="header-anchor" href="#数据库锁" aria-hidden="true">#</a> <strong>数据库锁</strong></h5>
<p>优点：直接使用数据库，方便简单。</p>
<p>缺点：分布式系统大多数瓶颈都在数据库，使用数据库锁会增加数据库负担。</p>
<h5 id="缓存锁" tabindex="-1"><a class="header-anchor" href="#缓存锁" aria-hidden="true">#</a> <strong>缓存锁</strong></h5>
<p>优点：性能高，实现起来较为方便，在允许偶发的锁失效情况，不影响系统正常使用，建议采用缓存锁。</p>
<p>缺点：通过锁超时机制不是非常可靠，当线程获得锁后，处理时间过长导致锁超时，就失效了锁的作用。</p>
<h5 id="zookeeper锁" tabindex="-1"><a class="header-anchor" href="#zookeeper锁" aria-hidden="true">#</a> <strong>zookeeper锁</strong></h5>
<p>优点：不依靠超时时间释放锁；可靠性高；系统要求高可靠性时，建议采用zookeeper锁。</p>
<p>缺点：由于需要频繁创建节点和删除节点，在性能比不上缓存锁。</p>
<h3 id="_18-你了解数据库的-binlog-和-redolog-吗-是如何实现一致性的呢" tabindex="-1"><a class="header-anchor" href="#_18-你了解数据库的-binlog-和-redolog-吗-是如何实现一致性的呢" aria-hidden="true">#</a> 18.你了解数据库的 binlog 和 redolog 吗？是如何实现一致性的呢？</h3>
<p>MySQL中binlog和redo log的一致性问题
本人目前在从事MySQL内核的开发和维护工作，以后会写一些MySQL的知识分享。
关于MySQL中binlog和redo log的一致性问题，在网上看过一些文章，感觉不是特别清楚，所以自己总结后和大家分享一下，文章如有问题，欢迎指教。</p>
<p>redo log 和 binlog
redo log
在MySQL InnoDB中，redo log是用来实现事务的持久性，即当事务在提交时，必须先将该事务的所有操作日志写到磁盘上的 redo log file进行持久化，这也就是我们常说的 Write Ahead Log 策略。有了redo log，在数据库发生宕机时，即使内存中的数据还没来得及持久化到磁盘上，我们也可以通过redo log完成数据的恢复，这样就避免了数据的丢失。</p>
<p>binlog
在MySQL中，binlog记录了数据库系统所有的更新操作，主要是用来实现数据恢复和主从复制的。一方面，主从配置的MySQL集群可以利用binlog将主库中的更新操作传递到从库中，以此来实现主从数据的一致性；另一方面，数据库还可以利用binlog来进行数据的恢复。</p>
<p>redo log 和 binlog的区别
redo log和binlog的产生方式不同。redo log是在物理存储引擎层产生，而binlog是在MySQL数据库的Server层产生的，并且binlog不仅针对InnoDB存储引擎，MySQL数据库中的任何存储引擎对数据库的更改都会产生binlog。
redo log和binlog的记录形式不同。MySQL Server层产生的binlog记录的是一种逻辑日志，即通过SQL语句的方式来记录数据库的修改；而InnoDB层产生的redo log是一种物理格式日志，其记录的是对于磁盘中每一个数据页的修改。
redo log和binlog记录的时间点不同。binlog只是在事务提交完成后进行一次写入，而redo log则是在事务进行中不断地被写入，redo log并不是随着事务提交的顺序进行写入的，这也就是说在redo log 中针对一个事务会有多个不连续的记录日志。
binlog和redo log的一致性问题
综上所述，binlog和redo log都是在事务提交阶段记录的。这时我们不禁会有一些疑问：</p>
<p><strong>是先写binlog还是先写redo log的呢？</strong>
写binlog和redo log的顺序对于数据库系统的持久性和主从复制会不会产生影响？
如果有影响，MySQL又是怎么做到binlog和redo log的一致性的呢？
带着这些问题，我深入地研究了MySQL中binlog和redo log的一致性问题。</p>
<p><strong>先写binlog还是先写redo log的呢？</strong>
针对这个疑问，我们可以做出两个假设。</p>
<p><strong>假设一：先写redo log再写binlog</strong>
想象一下，如果数据库系统在写完一个事务的redo log时发生crash，而此时这个事务的binlog还没有持久化。在数据库恢复后，主库会根据redo log中去完成此事务的重做，主库中就有可这个事务的数据。但是，由于此事务并没有产生binlog，即使主库恢复后，关于此事务的数据修改也不会同步到从库上，这样就产生了主从不一致的错误。</p>
<p><strong>假设二：先写binlog再写redo log</strong>
想象一下，如果数据库系统在写完一个事务的binlog时发生crash，而此时这个事务的redo log还没有持久化，或者说此事务的redo log还没记录完（至少没有记录commit log）。在数据库恢复后，从库会根据主库中记录的binlog去回放此事务的数据修改。但是，由于此事务并没有产生完整提交的redo log，主库在恢复后会回滚该事务，这样也会产生主从不一致的错误。</p>
<p>通过上面的假设和分析，我们可以看出，不管是先写redo log还是先写binlog，都有可能会产生主从不一致的错误，那么MySQL又是怎么做到binlog和redo log的一致性的呢？</p>
<p><strong>MySQL的内部XA（两阶段提交）</strong>
XA-2PC (two phase commit, 两阶段提交 )
XA是由X/Open组织提出的分布式事务的规范。XA规范主要定义了(全局)事务管理器(TM: Transaction Manager)和(局部)资源管理器(RM: Resource Manager)之间的接口。XA为了实现分布式事务，将事务的提交分成了两个阶段：也就是2PC (tow phase commit)，XA协议就是通过将事务的提交分为两个阶段来实现分布式事务。</p>
<p>prepare 阶段：第一阶段，事务管理器向所有涉及到的数据库服务器发出prepare&quot;准备提交&quot;请求，数据库收到请求后执行数据修改和日志记录等处理，处理完成后只是把事务的状态改成&quot;可以提交&quot;,然后把结果返回给事务管理器.</p>
<p>commit 阶段：事务管理器收到回应后进入第二阶段，如果在第一阶段内有任何一个数据库的操作发生了错误，或者事务管理器收不到某个数据库的回应，则认为事务失败，回撤所有数据库的事务。数据库服务器收不到第二阶段的确认提交请求，也会把&quot;可以提交&quot;的事务回撤。如果第一阶段中所有数据库都提交成功，那么事务管理器向数据库服务器发出&quot;确认提交&quot;请求，数据库服务器把事务的&quot;可以提交&quot;状态改为&quot;提交完成&quot;状态，然后返回应答。</p>
<p>MySQL中的XA实现分为：外部XA和内部XA。前者是指我们通常意义上的分布式事务实现；后者是指单台MySQL服务器中，Server层作为TM(事务协调者)，而服务器中的多个数据库实例作为RM，而进行的一种分布式事务，也就是MySQL跨库事务；也就是一个事务涉及到同一条MySQL服务器中的两个innodb数据库(因为其它引擎不支持XA)。</p>
<p><strong>内部XA的额外功能</strong>
在MySQL内部，在事务提交时利用两阶段提交(内部XA的两阶段提交)很好地解决了上面提到的binlog和redo log的一致性问题：</p>
<p>第一阶段： InnoDB Prepare阶段。此时SQL已经成功执行，并生成事务ID(xid)信息及redo和undo的内存日志。此阶段InnoDB会写事务的redo log，但要注意的是，此时redo log只是记录了事务的所有操作日志，并没有记录提交（commit）日志，因此事务此时的状态为Prepare。此阶段对binlog不会有任何操作。
第二阶段：commit 阶段，这个阶段又分成两个步骤。第一步写binlog（先调用write()将binlog内存日志数据写入文件系统缓存，再调用fsync()将binlog文件系统缓存日志数据永久写入磁盘）；第二步完成事务的提交（commit），此时在redo log中记录此事务的提交日志（增加commit 标签）。
可以看出，此过程中是先写redo log再写binlog的。但需要注意的是，在第一阶段并没有记录完整的redo log（不包含事务的commit标签），而是在第二阶段记录完binlog后再写入redo log的commit 标签。还要注意的是，在这个过程中是以第二阶段中binlog的写入与否作为事务是否成功提交的标志。</p>
<p>通过上述MySQL内部XA的两阶段提交就可以解决binlog和redo log的一致性问题。数据库在上述任何阶段crash，主从库都不会产生不一致的错误。</p>
<p><strong>此时的崩溃恢复过程如下：</strong></p>
<p>如果数据库在记录此事务的binlog之前和过程中发生crash。数据库在恢复后认为此事务并没有成功提交，则会回滚此事务的操作。与此同时，因为在binlog中也没有此事务的记录，所以从库也不会有此事务的数据修改。
如果数据库在记录此事务的binlog之后发生crash。此时，即使是redo log中还没有记录此事务的commit 标签，数据库在恢复后也会认为此事务提交成功（因为在上述两阶段过程中，binlog写入成功就认为事务成功提交了）。它会扫描最后一个binlog文件，并提取其中的事务ID（xid），InnoDB会将那些状态为Prepare的事务（redo log没有记录commit 标签）的xid和Binlog中提取的xid做比较，如果在Binlog中存在，则提交该事务，否则回滚该事务。这也就是说，binlog中记录的事务，在恢复时都会被认为是已提交事务，会在redo log中重新写入commit标志，并完成此事务的重做（主库中有此事务的数据修改）。与此同时，因为在binlog中已经有了此事务的记录，所有从库也会有此事务的数据修改。
总结
上述利用两阶段提交解决了事务提交时binlog和redo log的一致性问题，此过程的实现是在MySQL 5.6 之前。但是此过程存在严重缺陷：此过程中为了保证MySQL Server层binlog的写入顺序和InnoDB层的事务提交顺序是一致的，MySQL数据库内部使用了prepare_commit_mutex这个锁。但是在启用了这个锁之后，并不能并发写入binlog，从而导致了group commit失效。这个问题在MySQL 5.6中的Binary Log Group Commit（BLGC）得到解决。
————————————————</p>
<h3 id="_19-分布式幂等性如何设计" tabindex="-1"><a class="header-anchor" href="#_19-分布式幂等性如何设计" aria-hidden="true">#</a> 19.分布式幂等性如何设计？</h3>
<h5 id="分布式系统-幂等性设计" tabindex="-1"><a class="header-anchor" href="#分布式系统-幂等性设计" aria-hidden="true">#</a> 分布式系统---幂等性设计</h5>
<p>WEB资源或API方法的幂等性是指一次和多次请求某一个资源应该具有同样的副作用。幂等性是系统的接口对外一种承诺(而不是实现), 承诺只要调用接口成功, 外部多次调用对系统的影响是一致的。幂等性是分布式系统设计中的一个重要概念，对超时处理、系统恢复等具有重要意义。声明为幂等的接口会认为外部调用失败是常态, 并且失败之后必然会有重试。例如，在因网络中断等原因导致请求方未能收到请求返回值的情况下，如果该资源具备幂等性，请求方只需要重新请求即可，而无需担心重复调用会产生错误。实际上，我们常用的HTTP协议的方法是具有幂等性语义要求的，比如：get方法用于获取资源，不应有副作用，因此是幂等的；post方法用于创建资源，每次请求都会产生新的资源，因此不具备幂等性；put方法用于更新资源，是幂等的；delete方法用于删除资源，也是幂等的。</p>
<h5 id="常见用来保证幂等的手段" tabindex="-1"><a class="header-anchor" href="#常见用来保证幂等的手段" aria-hidden="true">#</a> 常见用来保证幂等的手段：</h5>
<h6 id="_1-mvcc方案" tabindex="-1"><a class="header-anchor" href="#_1-mvcc方案" aria-hidden="true">#</a> <strong>1.MVCC方案</strong></h6>
<p>多版本并发控制，该策略主要使用update with condition（更新带条件来防止）来保证多次外部请求调用对系统的影响是一致的。在系统设计的过程中，合理的使用乐观锁，通过version或者updateTime（timestamp）等其他条件，来做乐观锁的判断条件，这样保证更新操作即使在并发的情况下，也不会有太大的问题。例如</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>select` `* ``from` `tablename ``where` `condition=#condition# ``//取出要跟新的对象，带有版本versoin``update tableName ``set` `name=#name#,version=version+1 ``where` `version=#version#
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在更新的过程中利用version来防止，其他操作对对象的并发更新，导致更新丢失。为了避免失败，通常需要一定的重试机制。</p>
<h6 id="_2-去重表" tabindex="-1"><a class="header-anchor" href="#_2-去重表" aria-hidden="true">#</a> <strong>2.去重表</strong></h6>
<p>在插入数据的时候，插入去重表，利用数据库的唯一索引特性，保证唯一的逻辑。</p>
<h6 id="_3-悲观锁" tabindex="-1"><a class="header-anchor" href="#_3-悲观锁" aria-hidden="true">#</a> <strong>3.悲观锁</strong></h6>
<p>select for update，整个执行过程中锁定该订单对应的记录。注意：这种在DB读大于写的情况下尽量少用。</p>
<h6 id="_4-select-insert" tabindex="-1"><a class="header-anchor" href="#_4-select-insert" aria-hidden="true">#</a> <strong>4. select + insert</strong></h6>
<p>并发不高的后台系统，或者一些任务JOB，为了支持幂等，支持重复执行，简单的处理方法是，先查询下一些关键数据，判断是否已经执行过，在进行业务处理，就可以了。注意：核心高并发流程不要用这种方法。</p>
<h6 id="_5-状态机幂等" tabindex="-1"><a class="header-anchor" href="#_5-状态机幂等" aria-hidden="true">#</a> <strong>5.状态机幂等</strong></h6>
<p>在设计单据相关的业务，或者是任务相关的业务，肯定会涉及到状态机，就是业务单据上面有个状态，状态在不同的情况下会发生变更，一般情况下存在有限状态机，这时候，如果状态机已经处于下一个状态，这时候来了一个上一个状态的变更，理论上是不能够变更的，这样的话，保证了有限状态机的幂等。</p>
<h6 id="_6-token机制-防止页面重复提交" tabindex="-1"><a class="header-anchor" href="#_6-token机制-防止页面重复提交" aria-hidden="true">#</a> <strong>6. token机制，防止页面重复提交</strong></h6>
<p>业务要求：页面的数据只能被点击提交一次
　　发生原因：由于重复点击或者网络重发，或者nginx重发等情况会导致数据被重复提交
解决办法：</p>
<ul>
<li>集群环境：采用token加redis（redis单线程的，处理需要排队）</li>
<li>单JVM环境：采用token加redis或token加jvm内存</li>
</ul>
<p>处理流程：</p>
<ul>
<li>数据提交前要向服务的申请token，token放到redis或jvm内存，token有效时间</li>
<li>提交后后台校验token，同时删除token，生成新的token返回</li>
</ul>
<p>token特点:要申请，一次有效性，可以限流</p>
<h6 id="_7-对外提供接口的api如何保证幂等" tabindex="-1"><a class="header-anchor" href="#_7-对外提供接口的api如何保证幂等" aria-hidden="true">#</a> <strong>7. 对外提供接口的api如何保证幂等</strong></h6>
<p>如银联提供的付款接口：需要接入商户提交付款请求时附带：source来源，seq序列号。source+seq在数据库里面做唯一索引，防止多次付款，(并发时，只能处理一个请求)</p>
<p>总结： 幂等性应该是合格程序员的一个基因，在设计系统时，是首要考虑的问题，尤其是在像支付宝，银行，互联网金融公司等涉及的都是钱的系统，既要高效，数据也要准确，所以不能出现多扣款，多打款等问题，这样会很难处理，用户体验也不好 。</p>
<h3 id="_21-如何提高系统的并发能力" tabindex="-1"><a class="header-anchor" href="#_21-如何提高系统的并发能力" aria-hidden="true">#</a> 21.如何提高系统的并发能力？</h3>
<p>随着互联网的高速发展，互联网用户不断增加，系统的性能面临着巨大的考验，其中对数据库的高并发访问便是一个关键的问题，例如淘宝在双十一的时候，用户访问量激增，如果处理不好数据库的数据库的高并发访问，那给淘宝带来的后果是不可估计的，本文从数据库设计，查询的优化，负载均衡等方面详细介绍了该如何提高数据库的高并发访问。</p>
<p>关键词：数据库，高并发访问，负载均衡</p>
<p>近年来，数据库的高并发访问一直是一个焦点问题，随着互联网时代的到来，数据库的高并发访问性能显得尤为重要，如果仍采用传统的访问模式的话，就可能造成许多问题，比如用户的等待时间过长，导致用户的体验极差，系统的崩溃等问题</p>
<p>对于解决该问题，提出以下几点建议：</p>
<h5 id="数据库结构的设计" tabindex="-1"><a class="header-anchor" href="#数据库结构的设计" aria-hidden="true">#</a> 数据库结构的设计</h5>
<p>为了保证数据库的一致性和完整性，在设计表结构时通常采用表关联尽可能降低数据的冗余，如果数据的冗余度比较低，数据的完整性得以保证，可以提高系统的吞吐量，以提高系统的并发访问量。</p>
<p>在设置数据库表结构的时候还应该注意以下几点，能用数字类型存储的数据尽量不要用字符串类型存储，应为数字类型在查找时比较一次就够了，而字符串需要一个字符一个字符的进行比较；在满足数据存储长度的前提下字段的长度应该设置的短一些，这样可以提供查询的效率</p>
<h5 id="查询语句的优化" tabindex="-1"><a class="header-anchor" href="#查询语句的优化" aria-hidden="true">#</a> 查询语句的优化</h5>
<p>在对数据的查询时，应该尽量把索引放在首位，并且查询的结构要尽量简单，其实，有时候顺序不同的一条sql语句，查询效率可以差出很多，比如以下两条sql语句</p>
<p>select * from user where name=lisi and ID &gt;10000</p>
<p>select * from user where ID &gt; 10000 andname=lisi</p>
<p>执行第一条语句时是对全表进行扫描，然后找出ID&gt;10000的数据，而第二条sql语句先根据索引查找ID&gt;10000的用户，再在ID&gt;10000的用户中查找name=’lisi’的人。当表结构中的数据很多时，两个sql语句的查询效率可想而知，以下提出几点具体值得注意的地方：在查询语句where中尽量少使用null值判断，尽量避免使用！=、&gt;等操作符，尽量避免使用or，因为这将导致引擎放弃使用索引而进行全表扫描。</p>
<h5 id="采用主从复制-读写分离-负载均衡的策略" tabindex="-1"><a class="header-anchor" href="#采用主从复制-读写分离-负载均衡的策略" aria-hidden="true">#</a> 采用主从复制，读写分离，负载均衡的策略</h5>
<p>目前，大部分的主流关系型数据库都提供了主从复制的功能，通过配置两台（或多台）数据库的主从关系，可以将一台数据库服务器的数据更新同步到另一台服务器上。网站可以利用数据库的这一功能，实现数据库的读写分离，从而改善数据库的负载压力。一个系统的读操作远远多于写操作，因此写操作发向 master，读操作发向 slaves 进行操作（简单的轮循算法来决定使用哪个slave）。利用数据库的读写分离，Web 服务器在写数据的时候，访问主数据库（Master），主数据库通过主从复制机制将数据更新同步到从数据库（Slave），这样当 Web 服务器读数据的时候，就可以通过从数据库获得数据。这一方案使得在大量读操作的 Web 应用可以轻松地读取数据，而主数据库也只会承受少量的写入操作，还可以实现数据热备份，可谓是一举两得的方案。</p>
<p>因此我们如果想要提高系统对数据库的高并发访问，可以从优化数据库结构，优化表结构，优化查询语句，采用负载均衡，读写分离的方法等方面进行设计优化。</p>
<h3 id="_22-如何处理系统的高并发-高负载" tabindex="-1"><a class="header-anchor" href="#_22-如何处理系统的高并发-高负载" aria-hidden="true">#</a> 22.如何处理系统的高并发，高负载？</h3>
<ol>
<li>
<p>html文件尽量静态化</p>
</li>
<li>
<p>客户端(一般是APP与浏览器) 尽量使用本地缓存 ，减少调用服务端接口次数</p>
</li>
<li>
<p>客户端(一般是APP与浏览器) 限制访问接口频次（例如某个按钮连续被点击.......）</p>
</li>
<li>
<p>图片服务器分离，把图片，视频资源放在单独的文件服务器上，减少主服务器的网络开销，例如放在阿里云的oss上（很方便，例如图片的压缩，裁剪，视频的封面图获取等等操作很方便，当然oss也有一定的费用.....）</p>
</li>
<li>
<p>数据库集群，可以读写分离，主从复制。</p>
</li>
<li>
<p>使用缓存，例如redis，在服务层与数据层中间加入缓存层，让请求尽最大的可能访问缓存（命中缓存），减少数据库的访问</p>
</li>
<li>
<p>使用负载均衡，可以使用nginx作为反向代理负载均衡器，apache集群（当然并不是只有nginx这一种方式），因为nginx处理高并发比较好，apache的稳定性又比较好，二者结合，比较合适。</p>
</li>
<li>
<p>站点层拦截，例如，同一个用户，同一个请求，几秒之内只能请求几次，可以使用缓存实现，使用缓存记录时间信息，（相当于限流，限速....）, 此种限制方式，建议还是在服务端的接口入口处加上吧，因为和我们后端合作的客户端（app，web），往往不会考虑这些负载啊，速度啊，压力之类的事情，往往调用接口不合理（如果客户端没有架构师指导的话）。</p>
</li>
</ol>
<h3 id="_23-画几个你最熟悉的server端模型出来-格式不重要-尽量将图画清楚-说明思路即可" tabindex="-1"><a class="header-anchor" href="#_23-画几个你最熟悉的server端模型出来-格式不重要-尽量将图画清楚-说明思路即可" aria-hidden="true">#</a> 23.画几个你最熟悉的SERVER端模型出来（格式不重要，尽量将图画清楚，说明思路即可）</h3>
<p>1.mysql</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211223160906960.png" alt="image-20211223160906960"></p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211223160926749.png" alt="image-20211223160926749"></p>
<p>php-fpm模型</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211223161015617.png" alt="image-20211223161015617"></p>
<p>nginx模型</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211223161116333.png" alt="image-20211223161116333"></p>
<h3 id="_24-设计任务-最近总有人骚扰我们的投票模块-需要你来设计一个投票限制的东东" tabindex="-1"><a class="header-anchor" href="#_24-设计任务-最近总有人骚扰我们的投票模块-需要你来设计一个投票限制的东东" aria-hidden="true">#</a> 24.设计任务：最近总有人骚扰我们的投票模块，需要你来设计一个投票限制的东东</h3>
<p>要求如下：
１）要求每个QQ号码（假设此QQ号码在UNIT32内可以表示）10分钟这内只能投5票。
２）我们的用户很踊跃，平均每天要有2000万人左右通过此程序投票。
说明：
１）无需写代码，只需要图跟文字即可。
２）对于关键逻辑，请用图加代码表示出来，这也是对你文字表达能力的一个考验。
３）对你能想到的所有的边界条件列出来，这是对你逻辑思维全面与敏捷性的考验。
４）存储部分，尽你所能吧。如果，你需要一个自己设计的存储层，那么把这个存储层的实现，用文字＋图片方式描述清楚，要是设计合理，你会获得华丽的奖分。</p>
<p>解：</p>
<p>1）核心问题：如何统计10分钟之内投了5票？ 平均每天 2000万</p>
<p>&gt;10分钟可以分解成 60*10 s</p>
<p>&gt;每秒qps(请求量) 以二八分法 ：(20000000<em>80%)/(86400</em>20%) ≈1000 (925) 按1000算 , <a href="http://lib.csdn.net/base/redis" target="_blank" rel="noopener noreferrer">Redis<ExternalLinkIcon/></a>读写性能测试<a href="http://lib.csdn.net/base/redis" target="_blank" rel="noopener noreferrer">redis<ExternalLinkIcon/></a>官网测试读写能到10万左右 redis 足够用了</p>
<p>2.如何和存</p>
<p>&gt;10分钟以内就 设置成10分钟过期</p>
<p>&gt;10分钟不能超过5次 10分钟以外就不用管了</p>
<p>&gt;预估数据量：600<em>1000</em>5=300万 10分钟内数据量 300w左右(10分钟以前的都自动过期了)</p>
<p>&gt;key值带上分钟和秒：比如：1234567891（QQ号） 123456789 + 当时的分秒 （0809）=123456789:0809 ，10分钟以内 这个数字不会重复的</p>
<p>3.每次投票前</p>
<p>&gt;计算 <strong>: keys 123456789:*</strong> 返回多少个数据， 计算有多少个值  如果大于5个就返回 10分钟超过5次请等一会再投！</p>
<p>还有没有其他好的方法，有不足的地方请大家指正~~~~</p>
<p><strong>2.谢谢评论的园友给的改进意见更改如下</strong></p>
<p>1.每个QQ号每次访问设置一个自动增涨的值： set 12345678 0 ； EXPIRE 12345678 600 ；INCR 12345678；</p>
<p>2.如果每次查询 12345678  存在就 对比个数有没有大于5 大于 返回 10分钟超过5次请等一会再投！ 不大于 就 INCR 12345678 增加1</p>
<p>3.key每十分钟会过期</p>
<h1 id="十九-分布式微服务" tabindex="-1"><a class="header-anchor" href="#十九-分布式微服务" aria-hidden="true">#</a> 十九.分布式微服务</h1>
<h3 id="_1-为什么需要-dubbo" tabindex="-1"><a class="header-anchor" href="#_1-为什么需要-dubbo" aria-hidden="true">#</a> 1.为什么需要 Dubbo？</h3>
<h3 id="_2-dubbo-的主要应用场景" tabindex="-1"><a class="header-anchor" href="#_2-dubbo-的主要应用场景" aria-hidden="true">#</a> 2.Dubbo 的主要应用场景？</h3>
<h3 id="_3-dubbo-的核心功能" tabindex="-1"><a class="header-anchor" href="#_3-dubbo-的核心功能" aria-hidden="true">#</a> 3.Dubbo 的核心功能？</h3>
<h3 id="_4-dubbo-服务注册与发现的流程" tabindex="-1"><a class="header-anchor" href="#_4-dubbo-服务注册与发现的流程" aria-hidden="true">#</a> 4.Dubbo 服务注册与发现的流程？</h3>
<h3 id="_5-dubbo-的服务调用流程" tabindex="-1"><a class="header-anchor" href="#_5-dubbo-的服务调用流程" aria-hidden="true">#</a> 5.Dubbo 的服务调用流程？</h3>
<h3 id="_6-dubbo-支持哪些协议-每种协议的应用场景、优缺点" tabindex="-1"><a class="header-anchor" href="#_6-dubbo-支持哪些协议-每种协议的应用场景、优缺点" aria-hidden="true">#</a> 6.Dubbo 支持哪些协议，每种协议的应用场景、优缺点？</h3>
<h3 id="_7-dubbo-有些哪些注册中心" tabindex="-1"><a class="header-anchor" href="#_7-dubbo-有些哪些注册中心" aria-hidden="true">#</a> 7.Dubbo 有些哪些注册中心？</h3>
<h3 id="_8-dubbo-如何实现服务治理" tabindex="-1"><a class="header-anchor" href="#_8-dubbo-如何实现服务治理" aria-hidden="true">#</a> 8.Dubbo 如何实现服务治理？</h3>
<h3 id="_9-dubbo-的注册中心集群挂掉-如何正常消费" tabindex="-1"><a class="header-anchor" href="#_9-dubbo-的注册中心集群挂掉-如何正常消费" aria-hidden="true">#</a> 9.Dubbo 的注册中心集群挂掉，如何正常消费？</h3>
<h3 id="_10-dubbo-集群提供了哪些负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_10-dubbo-集群提供了哪些负载均衡策略" aria-hidden="true">#</a> 10.Dubbo 集群提供了哪些负载均衡策略？</h3>
<h3 id="_11-dubbo-的集群容错方案有哪些" tabindex="-1"><a class="header-anchor" href="#_11-dubbo-的集群容错方案有哪些" aria-hidden="true">#</a> 11.Dubbo 的集群容错方案有哪些？</h3>
<h3 id="_12-dubbo-支持哪些序列化方式" tabindex="-1"><a class="header-anchor" href="#_12-dubbo-支持哪些序列化方式" aria-hidden="true">#</a> 12.Dubbo 支持哪些序列化方式？</h3>
<h3 id="_13-说说一次-dubbo-服务请求流程" tabindex="-1"><a class="header-anchor" href="#_13-说说一次-dubbo-服务请求流程" aria-hidden="true">#</a> 13.说说一次 Dubbo 服务请求流程？</h3>
<h3 id="_14-说说-dubbo-工作原理" tabindex="-1"><a class="header-anchor" href="#_14-说说-dubbo-工作原理" aria-hidden="true">#</a> 14.说说 Dubbo 工作原理</h3>
<h3 id="_15-注册中心挂了-consumer-还能不能调用-provider" tabindex="-1"><a class="header-anchor" href="#_15-注册中心挂了-consumer-还能不能调用-provider" aria-hidden="true">#</a> 15.注册中心挂了，consumer 还能不能调用 provider？</h3>
<h3 id="_16-怎么实现动态感知服务下线的呢" tabindex="-1"><a class="header-anchor" href="#_16-怎么实现动态感知服务下线的呢" aria-hidden="true">#</a> 16.怎么实现动态感知服务下线的呢？</h3>
<h3 id="_17-服务提供者没挂-但在注册中心里看不到" tabindex="-1"><a class="header-anchor" href="#_17-服务提供者没挂-但在注册中心里看不到" aria-hidden="true">#</a> 17.服务提供者没挂，但在注册中心里看不到？</h3>
<h3 id="_18-说说dubbo的优先级配置" tabindex="-1"><a class="header-anchor" href="#_18-说说dubbo的优先级配置" aria-hidden="true">#</a> 18.说说Dubbo的优先级配置</h3>
<h3 id="_19-负载平衡的意义什么" tabindex="-1"><a class="header-anchor" href="#_19-负载平衡的意义什么" aria-hidden="true">#</a> 19.负载平衡的意义什么？</h3>
<h3 id="_20-常见负载均衡算法有哪些" tabindex="-1"><a class="header-anchor" href="#_20-常见负载均衡算法有哪些" aria-hidden="true">#</a> 20.常见负载均衡算法有哪些？</h3>
<h3 id="_21-你知道哪些限流算法" tabindex="-1"><a class="header-anchor" href="#_21-你知道哪些限流算法" aria-hidden="true">#</a> 21.你知道哪些限流算法？</h3>
<h3 id="_22-说说什么是计数器-固定窗口-算法" tabindex="-1"><a class="header-anchor" href="#_22-说说什么是计数器-固定窗口-算法" aria-hidden="true">#</a> 22.说说什么是计数器（固定窗口）算法</h3>
<h3 id="_23-说说什么是滑动窗口算法" tabindex="-1"><a class="header-anchor" href="#_23-说说什么是滑动窗口算法" aria-hidden="true">#</a> 23.说说什么是滑动窗口算法</h3>
<h3 id="_24-说说什么是漏桶算法" tabindex="-1"><a class="header-anchor" href="#_24-说说什么是漏桶算法" aria-hidden="true">#</a> 24.说说什么是漏桶算法</h3>
<h3 id="_25-说说什么是令牌桶算法" tabindex="-1"><a class="header-anchor" href="#_25-说说什么是令牌桶算法" aria-hidden="true">#</a> 25.说说什么是令牌桶算法</h3>
<h3 id="_26-什么是微服务" tabindex="-1"><a class="header-anchor" href="#_26-什么是微服务" aria-hidden="true">#</a> 26.什么是微服务？</h3>
<h3 id="_27-spring-cloud-的核心组件有哪些" tabindex="-1"><a class="header-anchor" href="#_27-spring-cloud-的核心组件有哪些" aria-hidden="true">#</a> 27.Spring Cloud 的核心组件有哪些？</h3>
<h3 id="_28-spring-cloud有什么优势" tabindex="-1"><a class="header-anchor" href="#_28-spring-cloud有什么优势" aria-hidden="true">#</a> 28.Spring Cloud有什么优势？</h3>
<h3 id="_29-什么是服务熔断-什么是服务降级" tabindex="-1"><a class="header-anchor" href="#_29-什么是服务熔断-什么是服务降级" aria-hidden="true">#</a> 29.什么是服务熔断？什么是服务降级？</h3>
<h3 id="_30-eureka和zookeeper-作为注册中心-有什么区别" tabindex="-1"><a class="header-anchor" href="#_30-eureka和zookeeper-作为注册中心-有什么区别" aria-hidden="true">#</a> 30.Eureka和Zookeeper，作为注册中心，有什么区别</h3>
<h3 id="_31-spring-boot和spring-cloud的区别" tabindex="-1"><a class="header-anchor" href="#_31-spring-boot和spring-cloud的区别" aria-hidden="true">#</a> 31.Spring Boot和Spring Cloud的区别？</h3>
<h3 id="_32-什么是hystrix-它如何实现容错" tabindex="-1"><a class="header-anchor" href="#_32-什么是hystrix-它如何实现容错" aria-hidden="true">#</a> 32.什么是Hystrix？它如何实现容错？</h3>
<h3 id="_33-说说-rpc-的实现原理" tabindex="-1"><a class="header-anchor" href="#_33-说说-rpc-的实现原理" aria-hidden="true">#</a> 33.说说 RPC 的实现原理</h3>
<h3 id="_34-eureka自我保护机制是什么" tabindex="-1"><a class="header-anchor" href="#_34-eureka自我保护机制是什么" aria-hidden="true">#</a> 34.Eureka自我保护机制是什么?</h3>
<h3 id="_35-什么是ribbon" tabindex="-1"><a class="header-anchor" href="#_35-什么是ribbon" aria-hidden="true">#</a> 35.什么是Ribbon？</h3>
<h3 id="_36-什么是feigin-它的优点是什么" tabindex="-1"><a class="header-anchor" href="#_36-什么是feigin-它的优点是什么" aria-hidden="true">#</a> 36.什么是<code v-pre>Feigin</code>？它的优点是什么？</h3>
<h3 id="_37-ribbon和feign的区别" tabindex="-1"><a class="header-anchor" href="#_37-ribbon和feign的区别" aria-hidden="true">#</a> 37.Ribbon和Feign的区别？</h3>
<h3 id="_38-说说微服务之间是如何独立通讯的" tabindex="-1"><a class="header-anchor" href="#_38-说说微服务之间是如何独立通讯的" aria-hidden="true">#</a> 38.说说微服务之间是如何独立通讯的？</h3>
<h3 id="_39-spring-cloud如何实现服务的注册" tabindex="-1"><a class="header-anchor" href="#_39-spring-cloud如何实现服务的注册" aria-hidden="true">#</a> 39.Spring Cloud如何实现服务的注册?</h3>
<h3 id="_40-说说-dubbo-与-spring-cloud-的区别" tabindex="-1"><a class="header-anchor" href="#_40-说说-dubbo-与-spring-cloud-的区别" aria-hidden="true">#</a> 40.说说 Dubbo 与 Spring Cloud 的区别？</h3>
<h1 id="二十-分布式存储和消息队列" tabindex="-1"><a class="header-anchor" href="#二十-分布式存储和消息队列" aria-hidden="true">#</a> 二十.分布式存储和消息队列</h1>
<h3 id="设计一个秒杀系统" tabindex="-1"><a class="header-anchor" href="#设计一个秒杀系统" aria-hidden="true">#</a> 设计一个秒杀系统</h3>
<p>秒杀系统注意哪些问题（系统负载和超卖两方面回答）</p>
<h3 id="_1-当高并发系统设计时-为什么要分库分表" tabindex="-1"><a class="header-anchor" href="#_1-当高并发系统设计时-为什么要分库分表" aria-hidden="true">#</a> 1.当高并发系统设计时，为什么要分库分表？</h3>
<p>分库分表一定是为了<strong>支撑高并发、数据量大</strong>两个问题的。</p>
<p>分库分表是两回事儿，可能是光分库不分表，也可能是光分表不分库，都有可能。</p>
<p>假如我们现在是一个小创业公司（或者是一个 BAT 公司刚兴起的一个新部门），现在注册用户就 20 万，每天活跃用户就 1 万，每天单表数据量就 1000，然后高峰期每秒钟并发请求最多就 10。天，就这种系统，随便找一个有几年工作经验的，然后带几个刚培训出来的，随便干干都可以。</p>
<p>结果没想到我们运气居然这么好，碰上个 CEO 带着我们走上了康庄大道，业务发展迅猛，过了几个月，注册用户数达到了 2000 万！每天活跃用户数 100 万！每天单表数据量 10 万条！高峰期每秒最大请求达到 1000！同时公司还顺带着融资了两轮，进账了几个亿人民币啊！公司估值达到了惊人的几亿美金！这是小独角兽的节奏！</p>
<p>好吧，没事，现在大家感觉压力已经有点大了，为啥呢？因为每天多 10 万条数据，一个月就多 300 万条数据，现在咱们单表已经几百万数据了，马上就破千万了。但是勉强还能撑着。高峰期请求现在是 1000，咱们线上部署了几台机器，负载均衡搞了一下，数据库撑 1000QPS 也还凑合。但是大家现在开始感觉有点担心了，接下来咋整呢......</p>
<p>再接下来几个月，我的天，CEO 太牛逼了，公司用户数已经达到 1 亿，公司继续融资几十亿人民币啊！公司估值达到了惊人的几十亿美金，成为了国内今年最牛逼的明星创业公司！天，我们太幸运了。</p>
<p>但是我们同时也是不幸的，因为此时每天活跃用户数上千万，每天单表新增数据多达 50 万，目前一个表总数据量都已经达到了两三千万了！扛不住啊！数据库磁盘容量不断消耗掉！高峰期并发达到惊人的 <code v-pre>5000~8000</code>！别开玩笑了，哥。我跟你保证，你的系统支撑不到现在，已经挂掉了！</p>
<p>好吧，所以你看到这里差不多就理解分库分表是怎么回事儿了，实际上这是跟着你的公司业务发展走的，你公司业务发展越好，用户就越多，数据量越大，请求量越大，那你单个数据库一定扛不住。</p>
<h4 id="分表" tabindex="-1"><a class="header-anchor" href="#分表" aria-hidden="true">#</a> 分表</h4>
<p>比如你单表都几千万数据了，你确定你能扛住么？绝对不行，<strong>单表数据量太大</strong>，会极大影响你的 sql <strong>执行的性能</strong>，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。</p>
<p>分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。</p>
<h4 id="分库" tabindex="-1"><a class="header-anchor" href="#分库" aria-hidden="true">#</a> 分库</h4>
<p>分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。</p>
<p>这就是所谓的<strong>分库分表</strong>，为啥要分库分表？你明白了吧。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211225154925515.png" alt="image-20211225154925515"></p>
<h3 id="_2-用过哪些分库分表中间件-不同的分库分表中间件都有什么优点和缺点" tabindex="-1"><a class="header-anchor" href="#_2-用过哪些分库分表中间件-不同的分库分表中间件都有什么优点和缺点" aria-hidden="true">#</a> 2.用过哪些分库分表中间件？不同的分库分表中间件都有什么优点和缺点？</h3>
<p>比较常见的包括：</p>
<ul>
<li>Cobar</li>
<li>TDDL</li>
<li>Atlas</li>
<li>Sharding-jdbc</li>
<li>Mycat</li>
</ul>
<h4 id="cobar" tabindex="-1"><a class="header-anchor" href="#cobar" aria-hidden="true">#</a> Cobar</h4>
<p>阿里 b2b 团队开发和开源的，属于 proxy 层方案，就是介于应用服务器和数据库服务器之间。应用程序通过 JDBC 驱动访问 Cobar 集群，Cobar 根据 SQL 和分库规则对 SQL 做分解，然后分发到 MySQL 集群不同的数据库实例上执行。早些年还可以用，但是最近几年都没更新了，基本没啥人用，差不多算是被抛弃的状态吧。而且不支持读写分离、存储过程、跨库 join 和分页等操作。</p>
<h4 id="tddl" tabindex="-1"><a class="header-anchor" href="#tddl" aria-hidden="true">#</a> TDDL</h4>
<p>淘宝团队开发的，属于 client 层方案。支持基本的 crud 语法和读写分离，但不支持 join、多表查询等语法。目前使用的也不多，因为还依赖淘宝的 diamond 配置管理系统。</p>
<h4 id="atlas" tabindex="-1"><a class="header-anchor" href="#atlas" aria-hidden="true">#</a> Atlas</h4>
<p>360 开源的，属于 proxy 层方案，以前是有一些公司在用的，但是确实有一个很大的问题就是社区最新的维护都在 5 年前了。所以，现在用的公司基本也很少了。</p>
<h4 id="sharding-jdbc" tabindex="-1"><a class="header-anchor" href="#sharding-jdbc" aria-hidden="true">#</a> Sharding-jdbc</h4>
<p>当当开源的，属于 client 层方案，目前已经更名为 <a href="https://github.com/apache/incubator-shardingsphere" target="_blank" rel="noopener noreferrer"><code v-pre>ShardingSphere</code><ExternalLinkIcon/></a>（后文所提到的 <code v-pre>Sharding-jdbc</code>，等同于 <code v-pre>ShardingSphere</code>）。确实之前用的还比较多一些，因为 SQL 语法支持也比较多，没有太多限制，而且截至 2019.4，已经推出到了 <code v-pre>4.0.0-RC1</code> 版本，支持分库分表、读写分离、分布式 id 生成、柔性事务（最大努力送达型事务、TCC 事务）。而且确实之前使用的公司会比较多一些（这个在官网有登记使用的公司，可以看到从 2017 年一直到现在，是有不少公司在用的），目前社区也还一直在开发和维护，还算是比较活跃，个人认为算是一个现在也<strong>可以选择的方案</strong>。</p>
<h4 id="mycat" tabindex="-1"><a class="header-anchor" href="#mycat" aria-hidden="true">#</a> Mycat</h4>
<p>基于 Cobar 改造的，属于 proxy 层方案，支持的功能非常完善，而且目前应该是非常火的而且不断流行的数据库中间件，社区很活跃，也有一些公司开始在用了。但是确实相比于 Sharding jdbc 来说，年轻一些，经历的锤炼少一些。</p>
<p>综上，现在其实建议考量的，就是 Sharding-jdbc 和 Mycat，这两个都可以去考虑使用。</p>
<p>Sharding-jdbc 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖；</p>
<p>Mycat 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了。</p>
<p>通常来说，这两个方案其实都可以选用，但是我个人建议中小型公司选用 Sharding-jdbc，client 层方案轻便，而且维护成本低，不需要额外增派人手，而且中小型公司系统复杂度会低一些，项目也没那么多；但是中大型公司最好还是选用 Mycat 这类 proxy 层方案，因为可能大公司系统和项目非常多，团队很大，人员充足，那么最好是专门弄个人来研究和维护 Mycat，然后大量项目直接透明使用即可。</p>
<h3 id="-3" tabindex="-1"><a class="header-anchor" href="#-3" aria-hidden="true">#</a> </h3>
<h3 id="_3-如何对数据库进行垂直拆分或水平拆分" tabindex="-1"><a class="header-anchor" href="#_3-如何对数据库进行垂直拆分或水平拆分" aria-hidden="true">#</a> 3.如何对数据库进行垂直拆分或水平拆分？</h3>
<p><strong>水平拆分</strong>的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNTM0NDQx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><strong>垂直拆分</strong>的意思，就是<strong>把一个有很多字段的表给拆分成多个表</strong>，<strong>或者是多个库上去</strong>。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会<strong>将较少的访问频率很高的字段放到一个表里去</strong>，然后<strong>将较多的访问频率很低的字段放到另外一个表里去</strong>。因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/fsdfsdffdfdf" alt="在这里插入图片描述"></p>
<p>这个其实挺常见的，不一定我说，大家很多同学可能自己都做过，把一个大表拆开，订单表、订单支付表、订单商品表。</p>
<p>还有<strong>表层面的拆分</strong>，就是分表，将一个表变成 N 个表，就是<strong>让每个表的数据量控制在一定范围内</strong>，保证 SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看具体你怎么操作，也可能是 500 万，或者是 100 万。你的SQL越复杂，就最好让单表行数越少。</p>
<p>好了，无论分库还是分表，上面说的那些数据库中间件都是可以支持的。就是基本上那些中间件可以做到你分库分表之后，<strong>中间件可以根据你指定的某个字段值</strong>，比如说 userid，<strong>自动路由到对应的库上去，然后再自动路由到对应的表里去</strong>。</p>
<p>你就得考虑一下，你的项目里该如何分库分表？一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。</p>
<p>而且这儿还有两种<strong>分库分表的方式</strong>：</p>
<ul>
<li>一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如<strong>时间范围</strong>来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。</li>
<li>或者是按照某个字段 hash 一下均匀分散，这个较为常用。</li>
</ul>
<p>range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。</p>
<p>hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。</p>
<h3 id="网易四道题" tabindex="-1"><a class="header-anchor" href="#网易四道题" aria-hidden="true">#</a> 网易四道题：</h3>
<h4 id="rpc原理-netty原理" tabindex="-1"><a class="header-anchor" href="#rpc原理-netty原理" aria-hidden="true">#</a> RPC原理，netty原理</h4>
<h4 id="要统计10分钟内订单的亏损-你会怎么设计-strom窗口模式" tabindex="-1"><a class="header-anchor" href="#要统计10分钟内订单的亏损-你会怎么设计-strom窗口模式" aria-hidden="true">#</a> 要统计10分钟内订单的亏损，你会怎么设计（strom窗口模式）</h4>
<h4 id="分布式缓存redis原理-zookeeper锁是如何实现的" tabindex="-1"><a class="header-anchor" href="#分布式缓存redis原理-zookeeper锁是如何实现的" aria-hidden="true">#</a> 分布式缓存redis原理，zookeeper锁是如何实现的</h4>
<p>如果使用redis-cluster集群部署Redis，redis-cluster把所有的物理节点映射到[0-16383]slot上。这里有个理解误区，有初学者会想，这个slot是不是存储数据的点？就是只能存16383+1个键？
实际并不是这样，这个slot只是对应节点(Redis服务)的一个存储范围(可以理解为这个Redis的别名)。
比如，现在有3台Redis ，分别给他们分配slot ：</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/11651855-23dea349e1b55817.png?imageMogr2/auto-orient/strip|imageView2/2/w/285/format/webp" alt="img"></p>
<p>image.png</p>
<p>现有一个key要insert到Redis，那么根据 CRC16(key) mod 16384的值，比如得到3000,那就把这个key保存在A服务器里面了。读的时候也一样，有个key要去读，就先 CRC16(key) mod 16384 找到对应的slot，然后就去对应的服务器找数据。看起来，很像个索引吧。</p>
<h4 id="分布式缓存读写不一致问题" tabindex="-1"><a class="header-anchor" href="#分布式缓存读写不一致问题" aria-hidden="true">#</a> 分布式缓存读写不一致问题</h4>
<p>缓存由于其高并发和高性能的特征，已经在项目中被广泛应用。</p>
<p>使用缓存的同时，也带来了缓存和数据库一致性问题。对于缓存数据库一致性问题，有很多解决方案，没有最完美的方案，只有适合自身业务的尽可能完美的方案。</p>
<p><strong>缓存读取和更新过程：</strong></p>
<p>查询时一般先查询缓存，如果缓存<strong>命中</strong>的话，那么直接将数据返回。</p>
<p>如果缓存中没有数据（如<strong>失效</strong>，或者根本没设置数据），那么，应用程序先从数据库中查询数据，如果不为空，则将数据放在缓存中。</p>
<p><strong>一致性问题出现原因：</strong></p>
<p>更新操作需要更新数据库和缓存，而更新数据库和缓存不是原子性的，不能放在一个事务中操作。</p>
<p><strong>一致性问题解决方案：</strong></p>
<p>数据一致性问题是分布式系统中必然存在的问题，数据的一致性可以分为：</p>
<p>①：强一致性：时时刻刻保持一致</p>
<p>②：最终一致性：允许短暂的不一致，但是最后还是一致的</p>
<p>要实现缓存和数据库的强一致性，需要借助于负载的分布式一致性协议，倒不如不用缓存。因此缓存和数据库保证的是最终一致性，我们能做的是，在保证最终一致性的前提下，如果把数据不一致带来的影响降到最低。</p>
<p>既然更新操作才可能会出现缓存和数据库不一致的情况，那么更新时，怎么处理缓存和数据库呢？先更新数据库后更新缓存？先更新数据库后更新缓存？或者先淘汰缓存后更新数据库？</p>
<p><strong>为什么没有先更新缓存后更新数据库？</strong></p>
<p>1）：如果更新数据库失败，那么就造成了数据不一致</p>
<p><strong>先更新数据库后更新缓存的问题</strong>：</p>
<p>1）：两个线程并发更新数据库再更新缓存可能出现缓存更新顺序问题（造成缓存数据不对）</p>
<p>2）：如果更新频繁，读少的情况，那么缓存也被频繁更新，造成不必要的开销</p>
<p>3）：如果缓存的值是需要经过一系列复杂计算的，那么每次都去更新缓存无疑是浪费性能的</p>
<p><strong>先删缓存后更新数据库的问题：</strong></p>
<p>1）：线程A删除缓存更新完数据库前，线程B没有命中缓存，从数据库中查询到了更新前的值存入缓存中</p>
<p>解决方案：<strong>延时双删策略（推荐使用）</strong></p>
<p>即先删除缓存，再更新数据库，休眠一段时间，再删除缓存</p>
<p>伪代码如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>public void write(String key,Object data){
    redis.delKey(key); 
    db.updateData(data); 
    Thread.sleep(1000); redis.delKey(key);
 }
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>为什要休眠1秒钟？为了将这1秒内造成的脏数据删除，可能有线程读取到了更新前的旧数据还未来得及写入缓存</p>
<p>休眠的时间多少如何确定？评估自身项目读数据业务逻辑的耗时，在这基础了加100ms即可。可以确保脏数据已经写入缓存中</p>
<p>读写分离怎么办？</p>
<p>也是采用延时双删策略，休眠时间确保完成主从同步</p>
<p>为了避免休眠造成吞吐量降低，可以将第二次删除作为异步操作</p>
<p>第二次删除失败怎么办？</p>
<p>删除在更新期间写入缓存的旧值失败</p>
<p>解决方案：将需要删除的key发送到消息队列，然后自己消费消息，获得需要删除的key，继续重试删除操作，直到成功。</p>
<p><strong>先更新数据库后删缓存</strong></p>
<p>即Cache Aside Pattern，即缓存旁路模式</p>
<p>失效：应用程序先从缓存中取数据，没有取到，则从数据库中取数据，成功后，放到缓存中</p>
<p>命中：应用程序从缓存中取到数据，然后返回</p>
<p>更新：先把数据存到数据库中，成功后，再删除缓存</p>
<p>问题：线程成功更新了数据库之后，还没来得及删除缓存，此时线程挂了，则会导致其他线程读取的都是脏数据</p>
<p>mysql集群的强一致性：</p>
<p><strong>1.PXC集群模式：</strong></p>
<p>两个集群，假设有2000万数据，每个集群就存放1000万数据，而每个集群里的PXC三个里面的数据都一样。来保证某一个集群里的数据都强一致性。但是强一致性牺牲了性能为代价。</p>
<h3 id="_4-如果要设计一个可以动态扩容缩容的分库分表方案-应该如何做" tabindex="-1"><a class="header-anchor" href="#_4-如果要设计一个可以动态扩容缩容的分库分表方案-应该如何做" aria-hidden="true">#</a> 4.如果要设计一个可以动态扩容缩容的分库分表方案，应该如何做？</h3>
<p><strong>对于分表分库来说，主要是面对以下问题：</strong></p>
<p>选择一个数据库中间件，调研、学习、测试
设计一个分表分库的方案，需要分成多少个库，每个库分成多少个表，比如3个库，每个库3个表
基于选择好的数据库中间件，以及在测试环境建立好的分表分库环境，然后测试以下能否正常进行<strong>分表分库的读写</strong>
完成从单表单库到分表分库的迁移，双写方案
线上系统开始基于分表分库堆外提供服务
扩容了，扩容成6个库，每个库12张表，该如何增加更多的库和表呢？
这个就是必须要面对的事情，就是当你把分表分库方案弄好了之后，然后一堆库和一堆表都建好了，基于分表分库的代码已经开发完成了。数据已经分布到各个库和各个表里面去了，而且你还通过双写方案上了以下系统，已经直接基于分库分表的方案在搞了。
那么现在问题来了，你如果目前分的这些库和这些表又无法支撑了，需要继续扩容了怎么办？这个可能就是说你的库容量又快满了，或者是你的表数据量又太大了，也可能是你每个库并发太高了，又得继续扩容。
<strong>面试题剖析</strong>
停机扩容（不推荐）
这个方案就跟停机迁移一样，步骤几乎一致，唯一得缺点就是那个导数据的工具，是把现有库表中的数据抽取出来慢慢导入到新的库和表里面去。但是最好不要这么做，因为既然选择分表分库就说明数据量实在是太大了，可能多达几亿条，甚至是几十亿，你这么做，可能会出问题。
从单库单表迁移到分库分表的时候，数据量并不是很大，单表最大也就几千万。那么写个工具做迁移还可以，1小时左右数据就可以跑完。
如果3个库+12个表，跑了一段时间，数据量就1-2亿。光是导2亿的数据，就要耗费几个小时，6点刚刚导完数据，还要搞后续的修改配置，重启系统，测试验证，10点菜可以搞完。所以不能这么搞。</p>
<p><strong>优化后的方案</strong>
一开始上来就是32个库，每个库32个表，那么总共就1024张表。
按照这个做法，基本上国内的互联网公司是够用了，第二，无论是并发支撑还是数据支撑都没问题。
每个库正常承载的写入并发量是1000，那么32个库就可以承载32 * 1000 = 32000的写并发，如果每个库承载1500的写并发，那么32 * 1500 = 48000的写并发，接近5万的每秒写入并发，前面再加上一个MQ，削峰，每秒写入MQ8万条数据，每秒消费5万条数据。
有些除非是国内排名非常靠前的这些公司，他们的最核心的系统的数据库，可能会出现几百台数据库这样的规模。</p>
<p>1024 张表，假设每个表放 500 万数据，在 MySQL 里可以放 50 亿条数据。</p>
<p>每秒 5 万的写并发，总共 50 亿条数据，对于国内大部分的互联网公司来说，其实一般来说都够了。</p>
<p>谈分库分表的扩容，第一次分库分表，就一次性给他分个够，32 个库，1024 张表，可能对大部分的中小型互联网公司来说，已经可以支撑好几年了。</p>
<p>一个实践是利用 <code v-pre>32 * 32</code> 来分库分表，即分为 32 个库，每个库里一个表分为 32 张表。一共就是 1024 张表。根据某个 id 先根据 32 取模路由到库，再根据 32 取模路由到库里的表。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211225160128626.png" alt="image-20211225160128626"></p>
<p>刚开始的时候，这个库可能就是逻辑库，建在一个数据库上的，就是一个mysql服务器可能建了 n 个库，比如 32 个库。后面如果要拆分，就是不断在库和 mysql 服务器之间做迁移就可以了。然后系统配合改一下配置即可。</p>
<p>比如说最多可以扩展到32个数据库服务器，每个数据库服务器是一个库。如果还是不够？最多可以扩展到 1024 个数据库服务器，每个数据库服务器上面一个库一个表。因为最多是1024个表。</p>
<p>这么搞，是不用自己写代码做数据迁移的，都交给 dba 来搞好了，但是 dba 确实是需要做一些库表迁移的工作，但是总比你自己写代码，然后抽数据导数据来的效率高得多吧。</p>
<p>哪怕是要减少库的数量，也很简单，其实说白了就是按倍数缩容就可以了，然后修改一下路由规则。</p>
<p>这里对步骤做一个总结：</p>
<ol>
<li>设定好几台数据库服务器，每台服务器上几个库，每个库多少个表，推荐是 32库 * 32表，对于大部分公司来说，可能几年都够了。</li>
<li>路由的规则，orderId 模 32 = 库，orderId / 32 模 32 = 表</li>
<li>扩容的时候，申请增加更多的数据库服务器，装好 mysql，呈倍数扩容，4 台服务器，扩到 8 台服务器，再到 16 台服务器。</li>
<li>由 dba 负责将原先数据库服务器的库，迁移到新的数据库服务器上去，库迁移是有一些便捷的工具的。</li>
<li>我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址。</li>
<li>重新发布系统，上线，原先的路由规则变都不用变，直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li>
</ol>
<h3 id="_5-数据库分库分表以后-如何处理设计主键生成器" tabindex="-1"><a class="header-anchor" href="#_5-数据库分库分表以后-如何处理设计主键生成器" aria-hidden="true">#</a> 5.数据库分库分表以后，如何处理设计主键生成器？</h3>
<p>其实这是分库分表之后你必然要面对的一个问题，就是 id 咋生成？因为要是分成多个表之后，每个表都是从 1 开始累加，那肯定不对啊，需要一个<strong>全局唯一</strong>的 id 来支持，<strong>排序</strong>问题等。所以这都是你实际生产环境中必须考虑的问题。</p>
<h4 id="基于数据库的实现方案" tabindex="-1"><a class="header-anchor" href="#基于数据库的实现方案" aria-hidden="true">#</a> 基于数据库的实现方案</h4>
<h6 id="数据库自增-id" tabindex="-1"><a class="header-anchor" href="#数据库自增-id" aria-hidden="true">#</a> 数据库自增 id</h6>
<p>这个就是说你的系统里每次得到一个 id，都是往一个库的一个表里插入一条没什么业务含义的数据，然后获取一个数据库自增的一个 id。拿到这个 id 之后再往对应的分库分表里去写入。</p>
<p>这个方案的好处就是方便简单，谁都会用；<strong>缺点就是单库生成</strong>自增 id，要是高并发的话，就会有瓶颈的；如果你硬是要改进一下，那么就专门开一个服务出来，这个服务每次就拿到当前 id 最大值，然后自己递增几个 id，一次性返回一批 id，然后再把当前最大 id 值修改成递增几个 id 之后的一个值；但是<strong>无论如何都是基于单个数据库</strong>。</p>
<p><strong>适合的场景</strong>：你分库分表就俩原因，要不就是单库并发太高，要不就是单库数据量太大；除非是你<strong>并发不高，但是数据量太大</strong>导致的分库分表扩容，你可以用这个方案，因为可能每秒最高并发最多就几百，那么就走单独的一个库和表生成自增主键即可。</p>
<h4 id="设置数据库-sequence-或者表自增字段步长" tabindex="-1"><a class="header-anchor" href="#设置数据库-sequence-或者表自增字段步长" aria-hidden="true">#</a> 设置数据库 sequence 或者表自增字段步长</h4>
<p>可以通过设置数据库 sequence 或者表的自增字段步长来进行水平伸缩。</p>
<p>比如说，现在有 8 个服务节点，每个服务节点使用一个 sequence 功能来产生 ID，每个 sequence 的起始 ID 不同，并且依次递增，步长都是 8。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211225161016736.png" alt="image-20211225161016736"></p>
<p><strong>适合的场景</strong>：在用户防止产生的 ID 重复时，这种方案实现起来比较简单，也能达到性能目标。但是服务节点固定，步长也固定，将来如果还要增加服务节点，就不好搞了。</p>
<h4 id="uuid" tabindex="-1"><a class="header-anchor" href="#uuid" aria-hidden="true">#</a> UUID</h4>
<p>好处就是本地生成，不要基于数据库来了；不好之处就是，UUID 太长了、占用空间大，<strong>作为主键性能太差</strong>了；更重要的是，UUID 不具有有序性，会导致 B+ 树索引在写的时候有过多的随机写操作（连续的 ID 可以产生部分顺序写），还有，由于在写的时候不能产生有顺序的 append 操作，而需要进行 insert 操作，将会读取整个 B+ 树节点到内存，在插入这条记录后会将整个节点写回磁盘，这种操作在记录占用空间比较大的情况下，性能下降明显。</p>
<p>适合的场景：如果你是要随机生成个什么文件名、编号之类的，你可以用 UUID，但是作为主键是不能用 UUID 的。</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>UUID.randomUUID().toString().replace(“-”, “”) -> sfsdf23423rr234sfdaf
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="获取系统当前时间" tabindex="-1"><a class="header-anchor" href="#获取系统当前时间" aria-hidden="true">#</a> 获取系统当前时间</h4>
<p>这个就是获取当前时间即可，但是问题是，<strong>并发很高的时候</strong>，比如一秒并发几千，<strong>会有重复的情况</strong>，这个是肯定不合适的。基本就不用考虑了。</p>
<p>适合的场景：一般如果用这个方案，是将当前时间跟很多其他的业务字段拼接起来，作为一个 id，如果业务上你觉得可以接受，那么也是可以的。你可以将别的业务字段值跟当前时间拼接起来，组成一个全局唯一的编号。</p>
<h4 id="snowflake-算法" tabindex="-1"><a class="header-anchor" href="#snowflake-算法" aria-hidden="true">#</a> snowflake 算法</h4>
<p>snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的 + 用其中的 41 bit 作为毫秒数 + 用 10 bit 作为工作机器 id + 12 bit 作为序列号。</p>
<ul>
<li>1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。</li>
<li>41 bit：表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 <code v-pre>2^41 - 1</code>，也就是可以标识 <code v-pre>2^41 - 1</code> 个毫秒值，换算成年就是表示69年的时间。</li>
<li>10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10台机器上哪，也就是1024台机器。但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。意思就是最多代表 <code v-pre>2^5</code>个机房（32个机房），每个机房里可以代表 <code v-pre>2^5</code> 个机器（32台机器）。</li>
<li>12 bit：这个是用来记录同一个毫秒内产生的不同 id，12 bit 可以代表的最大正整数是 <code v-pre>2^12 - 1 = 4096</code>，也就是说可以用这个 12 bit 代表的数字来区分<strong>同一个毫秒内</strong>的 4096 个不同的 id。</li>
</ul>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>public class IdWorker {

    private long workerId;
    private long datacenterId;
    private long sequence;

    public IdWorker(long workerId, long datacenterId, long sequence) {
        // sanity check for workerId
        // 这儿不就检查了一下，要求就是你传递进来的机房id和机器id不能超过32，不能小于0
        if (workerId > maxWorkerId || workerId &lt; 0) {
            throw new IllegalArgumentException(
                    String.format("worker Id can't be greater than %d or less than 0", maxWorkerId));
        }
        if (datacenterId > maxDatacenterId || datacenterId &lt; 0) {
            throw new IllegalArgumentException(
                    String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId));
        }
        System.out.printf(
                "worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d",
                timestampLeftShift, datacenterIdBits, workerIdBits, sequenceBits, workerId);

        this.workerId = workerId;
        this.datacenterId = datacenterId;
        this.sequence = sequence;
    }

    private long twepoch = 1288834974657L;

    private long workerIdBits = 5L;
    private long datacenterIdBits = 5L;

    // 这个是二进制运算，就是 5 bit最多只能有31个数字，也就是说机器id最多只能是32以内
    private long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits);

    // 这个是一个意思，就是 5 bit最多只能有31个数字，机房id最多只能是32以内
    private long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits);
    private long sequenceBits = 12L;

    private long workerIdShift = sequenceBits;
    private long datacenterIdShift = sequenceBits + workerIdBits;
    private long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits;
    private long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits);

    private long lastTimestamp = -1L;

    public long getWorkerId() {
        return workerId;
    }

    public long getDatacenterId() {
        return datacenterId;
    }

    public long getTimestamp() {
        return System.currentTimeMillis();
    }

    public synchronized long nextId() {
        // 这儿就是获取当前时间戳，单位是毫秒
        long timestamp = timeGen();

        if (timestamp &lt; lastTimestamp) {
            System.err.printf("clock is moving backwards.  Rejecting requests until %d.", lastTimestamp);
            throw new RuntimeException(String.format(
                    "Clock moved backwards.  Refusing to generate id for %d milliseconds", lastTimestamp - timestamp));
        }

        if (lastTimestamp == timestamp) {
            // 这个意思是说一个毫秒内最多只能有4096个数字
            // 无论你传递多少进来，这个位运算保证始终就是在4096这个范围内，避免你自己传递个sequence超过了4096这个范围
            sequence = (sequence + 1) &amp; sequenceMask;
            if (sequence == 0) {
                timestamp = tilNextMillis(lastTimestamp);
            }
        } else {
            sequence = 0;
        }

        // 这儿记录一下最近一次生成id的时间戳，单位是毫秒
        lastTimestamp = timestamp;

        // 这儿就是将时间戳左移，放到 41 bit那儿；
        // 将机房 id左移放到 5 bit那儿；
        // 将机器id左移放到5 bit那儿；将序号放最后12 bit；
        // 最后拼接起来成一个 64 bit的二进制数字，转换成 10 进制就是个 long 型
        return ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift)
                | (workerId &lt;&lt; workerIdShift) | sequence;
    }

    private long tilNextMillis(long lastTimestamp) {
        long timestamp = timeGen();
        while (timestamp &lt;= lastTimestamp) {
            timestamp = timeGen();
        }
        return timestamp;
    }

    private long timeGen() {
        return System.currentTimeMillis();
    }

    // ---------------测试---------------
    public static void main(String[] args) {
        IdWorker worker = new IdWorker(1, 1, 1);
        for (int i = 0; i &lt; 30; i++) {
            System.out.println(worker.nextId());
        }
    }

}

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>怎么说呢，大概这个意思吧，就是说 41 bit 是当前毫秒单位的一个时间戳，就这意思；然后 5 bit 是你传递进来的一个<strong>机房</strong> id（但是最大只能是 32 以内），另外 5 bit 是你传递进来的<strong>机器</strong> id（但是最大只能是 32 以内），剩下的那个 12 bit序列号，就是如果跟你上次生成 id 的时间还在一个毫秒内，那么会把顺序给你累加，最多在 4096 个序号以内。</p>
<p>所以你自己利用这个工具类，自己搞一个服务，然后对每个机房的每个机器都初始化这么一个东西，刚开始这个机房的这个机器的序号就是 0。然后每次接收到一个请求，说这个机房的这个机器要生成一个 id，你就找到对应的 Worker 生成。</p>
<p>利用这个 snowflake 算法，你可以开发自己公司的服务，甚至对于机房 id 和机器 id，反正给你预留了 5 bit + 5 bit，你换成别的有业务含义的东西也可以的。</p>
<p>当然，你也可以用 ： 1 个 bit 是不用的 + 用其中的 41 bit 作为毫秒数  + 12 bit 作为序列号 + 用 10 bit 作为工作机器 id，或者颠倒兑换一下顺序，怎么使用根据你自己的业务需要进行组合配用。</p>
<p>这个 snowflake 算法相对来说还是比较靠谱的，所以你要真是搞分布式 id 生成，如果是高并发啥的，那么用这个应该性能比较好，一般每秒几万并发的场景，也足够你用了。</p>
<p>ID是数据的唯一标识，传统的做法是利用UUID和数据库的自增ID，在互联网企业中，大部分公司使用的都是Mysql，并且因为需要事务支持，所以通常会使用Innodb存储引擎，UUID太长以及无序，所以并不适合在Innodb中来作为主键，自增ID比较合适，但是随着公司的业务发展，数据量将越来越大，需要对数据进行分表，而分表后，每个表中的数据都会按自己的节奏进行自增，很有可能出现ID冲突。这时就需要一个单独的机制来负责生成唯一ID，生成出来的ID也可以叫做<strong>分布式ID</strong>，或<strong>全局ID</strong>。下面来分析各个生成分布式ID的机制。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211225161620346.png" alt="image-20211225161620346"></p>
<p>这篇文章并不会分析的特别详细，主要是做一些总结，以后再出一些详细某个方案的文章。</p>
<h5 id="数据库自增id" tabindex="-1"><a class="header-anchor" href="#数据库自增id" aria-hidden="true">#</a> 数据库自增ID</h5>
<p>第一种方案仍然还是基于数据库的自增ID，需要单独使用一个数据库实例，在这个实例中新建一个单独的表：</p>
<p>表结构如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>CREATE DATABASE `SEQID`;

CREATE TABLE SEQID.SEQUENCE_ID (
    id bigint(20) unsigned NOT NULL auto_increment, 
    stub char(10) NOT NULL default '',
    PRIMARY KEY (id),
    UNIQUE KEY stub (stub)
) ENGINE=MyISAM;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以使用下面的语句生成并获取到一个自增ID</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>begin;
replace into SEQUENCE_ID (stub) VALUES ('anyword');
select last_insert_id();
commit;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>stub字段在这里并没有什么特殊的意义，只是为了方便的去插入数据，只有能插入数据才能产生自增id。而对于插入我们用的是replace，replace会先看是否存在stub指定值一样的数据，如果存在则先delete再insert，如果不存在则直接insert。</p>
<p>这种生成分布式ID的机制，需要一个单独的Mysql实例，虽然可行，但是基于性能与可靠性来考虑的话都不够，<strong>业务系统每次需要一个ID时，都需要请求数据库获取，性能低，并且如果此数据库实例下线了，那么将影响所有的业务系统。</strong></p>
<p>为了解决数据库可靠性问题，我们可以使用第二种分布式ID生成方案。</p>
<h5 id="数据库多主模式" tabindex="-1"><a class="header-anchor" href="#数据库多主模式" aria-hidden="true">#</a> 数据库多主模式</h5>
<p>如果我们两个数据库组成一个<strong>主从模式</strong>集群，正常情况下可以解决数据库可靠性问题，但是如果主库挂掉后，数据没有及时同步到从库，这个时候会出现ID重复的现象。我们可以使用<strong>双主模式</strong>集群，也就是两个Mysql实例都能单独的生产自增ID，这样能够提高效率，但是如果不经过其他改造的话，这两个Mysql实例很可能会生成同样的ID。需要单独给每个Mysql实例配置不同的起始值和自增步长。</p>
<p>第一台Mysql实例配置：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>set @@auto_increment_offset = 1;     -- 起始值
set @@auto_increment_increment = 2;  -- 步长
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>第二台Mysql实例配置：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>set @@auto_increment_offset = 2;     -- 起始值
set @@auto_increment_increment = 2;  -- 步长
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>经过上面的配置后，这两个Mysql实例生成的id序列如下： mysql1,起始值为1,步长为2,ID生成的序列为：1,3,5,7,9,... mysql2,起始值为2,步长为2,ID生成的序列为：2,4,6,8,10,...</p>
<p>对于这种生成分布式ID的方案，需要单独新增一个生成分布式ID应用，比如DistributIdService，该应用提供一个接口供业务应用获取ID，业务应用需要一个ID时，通过rpc的方式请求DistributIdService，DistributIdService随机去上面的两个Mysql实例中去获取ID。</p>
<p>实行这种方案后，就算其中某一台Mysql实例下线了，也不会影响DistributIdService，DistributIdService仍然可以利用另外一台Mysql来生成ID。</p>
<p>但是这种方案的扩展性不太好，如果两台Mysql实例不够用，需要新增Mysql实例来提高性能时，这时就会比较麻烦。</p>
<p>现在如果要新增一个实例mysql3，要怎么操作呢？ 第一，mysql1、mysql2的步长肯定都要修改为3，而且只能是人工去修改，这是需要时间的。 第二，因为mysql1和mysql2是不停在自增的，对于mysql3的起始值我们可能要定得大一点，以给充分的时间去修改mysql1，mysql2的步长。 第三，在修改步长的时候很可能会出现重复ID，要解决这个问题，可能需要停机才行。</p>
<p>为了解决上面的问题，以及能够进一步提高DistributIdService的性能，如果使用第三种生成分布式ID机制。</p>
<h5 id="号段模式" tabindex="-1"><a class="header-anchor" href="#号段模式" aria-hidden="true">#</a> 号段模式</h5>
<p>我们可以使用号段的方式来获取自增ID，号段可以理解成批量获取，比如DistributIdService从数据库获取ID时，如果能批量获取多个ID并缓存在本地的话，那样将大大提供业务应用获取ID的效率。</p>
<p>比如DistributIdService每次从数据库获取ID时，就获取一个号段，比如(1,1000]，这个范围表示了1000个ID，业务应用在请求DistributIdService提供ID时，DistributIdService只需要在本地从1开始自增并返回即可，而不需要每次都请求数据库，一直到本地自增到1000时，也就是当前号段已经被用完时，才去数据库重新获取下一号段。</p>
<p>所以，我们需要对数据库表进行改动，如下：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>CREATE TABLE id_generator (
  id int(10) NOT NULL,
  current_max_id bigint(20) NOT NULL COMMENT '当前最大id',
  increment_step int(10) NOT NULL COMMENT '号段的长度',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个数据库表用来记录自增步长以及当前自增ID的最大值（也就是当前已经被申请的号段的最后一个值），因为自增逻辑被移到DistributIdService中去了，所以数据库不需要这部分逻辑了。</p>
<p>这种方案不再强依赖数据库，就算数据库不可用，那么DistributIdService也能继续支撑一段时间。但是如果DistributIdService重启，会丢失一段ID，导致ID空洞。</p>
<p>为了提高DistributIdService的高可用，需要做一个集群，业务在请求DistributIdService集群获取ID时，会随机的选择某一个DistributIdService节点进行获取，对每一个DistributIdService节点来说，数据库连接的是同一个数据库，那么可能会产生多个DistributIdService节点同时请求数据库获取号段，那么这个时候需要利用乐观锁来进行控制，比如在数据库表中增加一个version字段，在获取号段时使用如下SQL：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>update id_generator set current_max_id=#{newMaxId}, version=version+1 where version = #{version}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>因为newMaxId是DistributIdService中根据oldMaxId+步长算出来的，只要上面的update更新成功了就表示号段获取成功了。</p>
<p>为了提供数据库层的高可用，需要对数据库使用多主模式进行部署，对于每个数据库来说要保证生成的号段不重复，这就需要利用最开始的思路，再在刚刚的数据库表中增加起始值和步长，比如如果现在是两台Mysql，那么 mysql1将生成号段（1,1001]，自增的时候序列为1，3，4，5，7.... mysql1将生成号段（2,1002]，自增的时候序列为2，4，6，8，10...</p>
<p>更详细的可以参考滴滴开源的TinyId：<a href="https://github.com/didi/tinyid/wiki/tinyid%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener noreferrer">github.com/didi/tinyid…<ExternalLinkIcon/></a></p>
<p>在TinyId中还增加了一步来提高效率，在上面的实现中，ID自增的逻辑是在DistributIdService中实现的，而实际上可以把自增的逻辑转移到业务应用本地，这样对于业务应用来说只需要获取号段，每次自增时不再需要请求调用DistributIdService了</p>
<h5 id="雪花算法" tabindex="-1"><a class="header-anchor" href="#雪花算法" aria-hidden="true">#</a> 雪花算法</h5>
<p>上面的三种方法总的来说是基于自增思想的，而接下来就介绍比较著名的雪花算法-snowflake。</p>
<p>我们可以换个角度来对分布式ID进行思考，只要能让负责生成分布式ID的每台机器在每毫秒内生成不一样的ID就行了。</p>
<p>snowflake是twitter开源的分布式ID生成算法，是一种算法，所以它和上面的三种生成分布式ID机制不太一样，它不依赖数据库。</p>
<p>核心思想是：分布式ID固定是一个long型的数字，一个long型占8个字节，也就是64个bit，原始snowflake算法中对于bit的分配如下图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1843652/201911/1843652-20191109075949247-616133654.png" alt="雪花算法"></p>
<ul>
<li>第一个bit位是标识部分，在java中由于long的最高位是符号位，正数是0，负数是1，一般生成的ID为正数，所以固定为0。</li>
<li>时间戳部分占41bit，这个是毫秒级的时间，一般实现上不会存储当前的时间戳，而是时间戳的差值（当前时间-固定的开始时间），这样可以使产生的ID从更小值开始；41位的时间戳可以使用69年，(1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69年</li>
<li>工作机器id占10bit，这里比较灵活，比如，可以使用前5位作为数据中心机房标识，后5位作为单机房机器标识，可以部署1024个节点。</li>
<li>序列号部分占12bit，支持同一毫秒内同一个节点可以生成4096个ID</li>
</ul>
<p>根据这个算法的逻辑，只需要将这个算法用Java语言实现出来，封装为一个工具方法，那么各个业务应用可以直接使用该工具方法来获取分布式ID，只需保证每个业务应用有自己的工作机器id即可，而不需要单独去搭建一个获取分布式ID的应用。</p>
<p>snowflake算法实现起来并不难，提供一个github上用java实现的：<a href="https://github.com/beyondfengyu/SnowFlake" target="_blank" rel="noopener noreferrer">github.com/beyondfengy…<ExternalLinkIcon/></a></p>
<p>在大厂里，其实并没有直接使用snowflake，而是进行了改造，因为snowflake算法中最难实践的就是工作机器id，原始的snowflake算法需要人工去为每台机器去指定一个机器id，并配置在某个地方从而让snowflake从此处获取机器id。</p>
<p>但是在大厂里，机器是很多的，人力成本太大且容易出错，所以大厂对snowflake进行了改造。</p>
<h5 id="百度-uid-generator" tabindex="-1"><a class="header-anchor" href="#百度-uid-generator" aria-hidden="true">#</a> 百度（uid-generator）</h5>
<p>github地址：<a href="https://github.com/baidu/uid-generator" target="_blank" rel="noopener noreferrer">uid-generator<ExternalLinkIcon/></a></p>
<p>uid-generator使用的就是snowflake，只是在生产机器id，也叫做workId时有所不同。</p>
<p>uid-generator中的workId是由uid-generator自动生成的，并且考虑到了应用部署在docker上的情况，在uid-generator中用户可以自己去定义workId的生成策略，默认提供的策略是：应用启动时由数据库分配。说的简单一点就是：应用在启动时会往数据库表(uid-generator需要新增一个WORKER_NODE表)中去插入一条数据，数据插入成功后返回的该数据对应的自增唯一id就是该机器的workId，而数据由host，port组成。</p>
<p>对于uid-generator中的workId，占用了22个bit位，时间占用了28个bit位，序列化占用了13个bit位，需要注意的是，和原始的snowflake不太一样，时间的单位是秒，而不是毫秒，workId也不一样，同一个应用每重启一次就会消费一个workId。</p>
<p>具体可参考<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md" target="_blank" rel="noopener noreferrer">github.com/baidu/uid-g…<ExternalLinkIcon/></a></p>
<h5 id="美团-leaf" tabindex="-1"><a class="header-anchor" href="#美团-leaf" aria-hidden="true">#</a> 美团（Leaf）</h5>
<p>github地址：<a href="https://github.com/Meituan-Dianping/Leaf" target="_blank" rel="noopener noreferrer">Leaf<ExternalLinkIcon/></a></p>
<p>美团的Leaf也是一个分布式ID生成框架。它非常全面，即支持号段模式，也支持snowflake模式。号段模式这里就不介绍了，和上面的分析类似。</p>
<p>Leaf中的snowflake模式和原始snowflake算法的不同点，也主要在workId的生成，Leaf中workId是基于ZooKeeper的顺序Id来生成的，每个应用在使用Leaf-snowflake时，在启动时都会都在Zookeeper中生成一个顺序Id，相当于一台机器对应一个顺序节点，也就是一个workId。</p>
<p>总得来说，上面两种都是自动生成workId，以让系统更加稳定以及减少人工成功。</p>
<h5 id="redis" tabindex="-1"><a class="header-anchor" href="#redis" aria-hidden="true">#</a> Redis</h5>
<p>这里额外再介绍一下使用Redis来生成分布式ID，其实和利用Mysql自增ID类似，可以利用Redis中的incr命令来实现原子性的自增与返回，比如：</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>127.0.0.1:6379> set seq_id 1     // 初始化自增ID为1
OK
127.0.0.1:6379> incr seq_id      // 增加1，并返回
(integer) 2
127.0.0.1:6379> incr seq_id      // 增加1，并返回
(integer) 3
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用redis的效率是非常高的，但是要考虑持久化的问题。Redis支持RDB和AOF两种持久化的方式。</p>
<p>RDB持久化相当于定时打一个快照进行持久化，如果打完快照后，连续自增了几次，还没来得及做下一次快照持久化，这个时候Redis挂掉了，重启Redis后会出现ID重复。</p>
<p>AOF持久化相当于对每条写命令进行持久化，如果Redis挂掉了，不会出现ID重复的现象，但是会由于incr命令过得，导致重启恢复数据时间过长。</p>
<h3 id="_8-分库分表第三方框架有哪些" tabindex="-1"><a class="header-anchor" href="#_8-分库分表第三方框架有哪些" aria-hidden="true">#</a> 8.分库分表第三方框架有哪些？</h3>
<h4 id="_1、tddl" tabindex="-1"><a class="header-anchor" href="#_1、tddl" aria-hidden="true">#</a> <strong>1、TDDL</strong></h4>
<p>注意：tddl2.0是2010年的版本，已经没有人维护了。当前版本是5.1.7，网上能够找到的最新版本。项目地址为：https://www.oschina.net/p/tddl5</p>
<p>淘宝根据自己的业务特点开发了TDDL（Taobao Distributed Data Layer 外号:头都大了 ©_Ob）框架，主要解决了分库分表对应用的透明化以及异构数据库之间的数据复制，它是一个基于集中式配置的 jdbc datasource实现，具有主备，读写分离，动态数据库配置等功能。</p>
<p>主要优点：
1.数据库主备和动态切换
2.带权重的读写分离
3.单线程读重试
4.集中式数据源信息管理和动态变更
5.剥离的稳定jboss数据源
6.支持mysql和oracle数据库
7.基于jdbc规范，很容易扩展支持实现jdbc规范的数据源
8.无server,client-jar形式存在，应用直连数据库
9.读写次数,并发度流程控制，动态变更
10.可分析的日志打印,日志流控，动态变更
TDDL必须要依赖diamond配置中心（diamond是淘宝内部使用的一个管理持久配置的系统，目前淘宝内部绝大多数系统的配置，由diamond来进行统一管理，同时diamond也已开源）。
TDDL动态数据源使用示例说明：http://rdc.taobao.com/team/jm/archives/1645
diamond简介和快速使用：<a href="http://jm.taobao.org/tag/diamond%E4%B8%93%E9%A2%98/" target="_blank" rel="noopener noreferrer">http://jm.taobao.org/tag/diamond%E4%B8%93%E9%A2%98/<ExternalLinkIcon/></a>
TDDL源码：https://github.com/alibaba/tb_tddl
TDDL复杂度相对较高。当前公布的文档较少，只开源动态数据源，分表分库部分还未开源，还需要依赖diamond，不推荐使用。</p>
<h4 id="_2、sharding-jdbc" tabindex="-1"><a class="header-anchor" href="#_2、sharding-jdbc" aria-hidden="true">#</a> <strong>2、Sharding-JDBC</strong></h4>
<p>当mysql单表数据量比较大时往往需要分库分表，Sharding-JDBC是当当网开源的数据库分库分表中间件。Sharding-JDBC定位为轻量级java框架，使用客户端直连数据库，以jar包形式提供服务，无proxy代理层，无需额外部署，无其他依赖，DBA也无需改变原有的运维方式。</p>
<h4 id="_3、mycat" tabindex="-1"><a class="header-anchor" href="#_3、mycat" aria-hidden="true">#</a> <strong>3、Mycat</strong></h4>
<p>Mycat是一种数据库中间件，前身是阿里的cobar。</p>
<p>Mycat 是一个开源的分布式数据库系统，是一个实现了 MySQL 协议的的Server，前端用户可以把它看作是一个数据库代理，用 MySQL 客户端工具和命令行访问，而其后端可以用MySQL 原生（Native）协议与多个 MySQL 服务器通信，也可以用 JDBC 协议与大多数主流数据库服务器通信，其核心功能是分表分库，即将一个大表水平分割为 N 个小表，存储在后端 MySQL 服务器里或者其他数据库里。</p>
<p>官方解释:</p>
<p>国内最活跃的、性能最好的开源数据库分库分表中间件</p>
<ul>
<li>一个彻底开源的，面向企业应用开发的大数据库集群</li>
<li>支持事务、ACID、可以替代MySQL的加强版数据库</li>
<li>一个可以视为MySQL集群的企业级数据库，用来替代昂贵的Oracle集群</li>
<li>一个融合内存缓存技术、NoSQL技术、HDFS大数据的新型SQL Server</li>
<li>结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品</li>
<li>一个新颖的数据库中间件产品</li>
</ul>
<h2 id="分布式缓存" tabindex="-1"><a class="header-anchor" href="#分布式缓存" aria-hidden="true">#</a> 分布式缓存</h2>
<h3 id="_34-缓存雪崩、缓存穿透如何理解-如何在业务中避免相关问题" tabindex="-1"><a class="header-anchor" href="#_34-缓存雪崩、缓存穿透如何理解-如何在业务中避免相关问题" aria-hidden="true">#</a> 34.缓存雪崩、缓存穿透如何理解？如何在业务中避免相关问题？</h3>
<h6 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩" aria-hidden="true">#</a> 缓存雪崩</h6>
<p>缓存服务器宕机，所有请求全部落到数据库上，导致数据库挂掉了。此时，就算是重启数据库，马上还会被新的请求给干掉。这就是缓存雪崩。
解决方案：
雪崩前：redis设计成高可用，防止大面积故障，如 Redis Sentinel 和 Redis Cluster
雪崩时：缓存限流、降级
雪崩后：redis持久化，快速备份和恢复数据</p>
<h6 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透" aria-hidden="true">#</a> 缓存穿透</h6>
<p>当一个请求从缓存中取数据时，如果请求的key在缓存中不存在，就会跳过缓存，直接请求数据库，如果数据库中也不存在就会返回null，null是不会写入缓存的，多次请求，就会造成缓存穿透
解决方案：
1、返回空值也存入缓存中，并设置过期时间，不过要考虑到过多的空值的键造成的影响
2、布隆过滤，对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃。</p>
<h6 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿" aria-hidden="true">#</a> 缓存击穿</h6>
<p>某个key访问非常频繁，处于集中式高并发的访问状态，当这个key在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库。
解决方案
将高访问量的数据设置为永不过期;
实现互斥锁，待一个请求构建完释放锁后，其他请求再进行访问。</p>
<h3 id="_35-如何保证数据库与缓存的一致性" tabindex="-1"><a class="header-anchor" href="#_35-如何保证数据库与缓存的一致性" aria-hidden="true">#</a> 35.如何保证数据库与缓存的一致性？</h3>
<p><strong>1.第一种方案：采用延时双删策略</strong>
在写库前后都进行redis.del(key)操作，并且设定合理的超时时间。
伪代码如下：
public void write(String key,Object data){ redis.delKey(key); db.updateData(data); Thread.sleep(500); redis.delKey(key); }
<strong>具体的步骤就是：</strong></p>
<ul>
<li>先删除缓存；</li>
<li>再写数据库；</li>
<li>休眠500毫秒；</li>
<li>再次删除缓存。</li>
</ul>
<p><strong>那么，这个500毫秒怎么确定的，具体该休眠多久呢？</strong>
需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
当然这种策略还要考虑redis和数据库主从同步的耗时。最后的的写数据的休眠时间：则在读数据业务逻辑的耗时基础上，加几百ms即可。比如：休眠1秒。
<strong>设置缓存过期时间</strong>
从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。所有的写操作以数据库为准，只要到达缓存过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。
<strong>该方案的弊端</strong>
结合双删策略+缓存超时设置，这样最差的情况就是在超时时间内数据存在不一致，而且又增加了写请求的耗时。
<strong>2、第二种方案：异步更新缓存(基于订阅binlog的同步机制)</strong>
<strong>技术整体思路：</strong>
MySQL binlog增量订阅消费+消息队列+增量数据更新到redis</p>
<ul>
<li><strong>读Redis</strong>：热数据基本都在Redis</li>
<li><strong>写MySQL</strong>:增删改都是操作MySQL</li>
<li><strong>更新Redis数据</strong>：MySQ的数据操作binlog，来更新到Redis</li>
</ul>
<p><strong>Redis更新</strong>
<strong>1）数据操作主要分为两大块：</strong></p>
<ul>
<li>一个是全量(将全部数据一次写入到redis)</li>
<li>一个是增量（实时更新）</li>
</ul>
<p>这里说的是增量,指的是mysql的update、insert、delate变更数据。
<strong>2）读取binlog后分析 ，利用消息队列,推送更新各台的redis缓存数据。</strong>
这样一旦MySQL中产生了新的写入、更新、删除等操作，就可以把binlog相关的消息推送至Redis，Redis再根据binlog中的记录，对Redis进行更新。
其实这种机制，很类似MySQL的主从备份机制，因为MySQL的主备也是通过binlog来实现的数据一致性。
这里可以结合使用canal(阿里的一款开源框架)，通过该框架可以对MySQL的binlog进行订阅，而canal正是模仿了mysql的slave数据库的备份请求，使得Redis的数据更新达到了相同的效果。
当然，这里的消息推送工具你也可以采用别的第三方：kafka、rabbitMQ等来实现推送更新Redis。
以上就是Redis和MySQL数据一致性详解。</p>
<p><strong>另一种答案：</strong></p>
<h5 id="淘汰缓存还是更新缓存" tabindex="-1"><a class="header-anchor" href="#淘汰缓存还是更新缓存" aria-hidden="true">#</a> 淘汰缓存还是更新缓存？</h5>
<p><strong>选择淘汰缓存</strong></p>
<p>原因：数据可能为简单数据，也可能为较复杂的数据，复杂数据进行缓存的更新操作，成本较高，因此一般推荐淘汰缓存</p>
<h5 id="先淘汰缓存还是先更新数据库" tabindex="-1"><a class="header-anchor" href="#先淘汰缓存还是先更新数据库" aria-hidden="true">#</a> 先淘汰缓存还是先更新数据库？</h5>
<p><strong>选择先*<em>淘汰缓存*</em>，再*<em>更新数据库*</em></strong></p>
<p>原因：假如先更新数据库，再淘汰缓存，假如缓存淘汰失败，那么后面的请求都会得到脏数据，直至缓存过期。假如先淘汰缓存再更新数据库，如果数据库更新失败，只会产生一次缓存miss，相比较而言，后者对业务影响更小一点。</p>
<h5 id="延时双删策略" tabindex="-1"><a class="header-anchor" href="#延时双删策略" aria-hidden="true">#</a> 延时双删策略</h5>
<p>如下场景：同时有一个请求A进行更新操作，另一个请求B进行查询操作。
（1）请求A进行写操作，删除缓存
（2）请求B查询发现缓存不存在
（3）请求B去数据库查询得到旧值
（4）请求B将旧值写入缓存
（5）请求A将新值写入数据库</p>
<p>次数便出现了数据不一致问题。采用延时双删策略得以解决</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>public void write(String key,Object data){
    redisUtils.del(key);
    db.update(data);
    Thread.Sleep(100);
    redisUtils.del(key);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<p>这么做，可以将1秒内所造成的缓存脏数据，再次删除。这个时间设定可根据俄业务场景进行一个调节。</p>
<h5 id="数据库读写分离的场景" tabindex="-1"><a class="header-anchor" href="#数据库读写分离的场景" aria-hidden="true">#</a> 数据库读写分离的场景</h5>
<p>两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。</p>
<p>（1）请求A进行写操作，删除缓存
（2）请求A将数据写入数据库了，
（3）请求B查询缓存发现，缓存没有值
（4）请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值
（5）请求B将旧值写入缓存
（6）数据库完成主从同步，从库变为新值</p>
<p>依旧采用延时双删策略解决此问题</p>
<p>缓存由于其高并发和高性能的特性，已经在项目中被广泛使用，在缓存的使用中，通常会面临一个更新的问题，当数据源产生变化，如何去更新到数据库与缓存之中，并且尽量保证安全与性能。</p>
<p>更新缓存的的Design Pattern有四种：Cache aside, Read through, Write through, Write behind caching，我们下面一一来看一下这四种Pattern。</p>
<h6 id="一-cache-aside-pattern" tabindex="-1"><a class="header-anchor" href="#一-cache-aside-pattern" aria-hidden="true">#</a> <strong>一:Cache Aside Pattern</strong></h6>
<p>标准的Pattern，facebook就是使用这种方式，具体流程图如下：</p>
<p><strong>失效</strong>：应用程序先从cache取数据，没有得到，则从数据库中取数据，成功后，放到缓存中。</p>
<p><strong>命中</strong>：应用程序从cache中取数据，取到后返回。</p>
<p><strong>更新</strong>：先把数据存到数据库中，成功后，再让缓存失效。</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/11772383-77784f5451451b42.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>Cache Aside</p>
<p>读的部分大家都很熟悉，先读cache，如果cache中没有命中，去读底层数据库等存储介质，返回数据，并且设置缓存。</p>
<p>写的部分有一些争议,网上流传很多种做法,简单分析几种：</p>
<h6 id="_1-先更新缓存-再写数据库" tabindex="-1"><a class="header-anchor" href="#_1-先更新缓存-再写数据库" aria-hidden="true">#</a> <strong>1.先更新缓存,再写数据库</strong></h6>
<p>同时有请求A和请求B进行更新操作，那么会出现</p>
<p>（1）线程A更新了数据库</p>
<p>（2）线程B更新了数据库</p>
<p>（3）线程B更新了缓存</p>
<p>（4）线程A更新了缓存</p>
<p>这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。</p>
<h6 id="_2-先删除缓存-再更新数据库" tabindex="-1"><a class="header-anchor" href="#_2-先删除缓存-再更新数据库" aria-hidden="true">#</a> <strong>2.先删除缓存,再更新数据库</strong></h6>
<p>该方案会导致不一致的原因是。同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>
<p>（1）请求A进行写操作，删除缓存</p>
<p>（2）请求B查询发现缓存不存在</p>
<p>（3）请求B去数据库查询得到旧值</p>
<p>（4）请求B将旧值写入缓存</p>
<p>（5）请求A将新值写入数据库</p>
<p>这种线程安全问题需要通过延时双删等方案解决</p>
<p>大概的策略是：</p>
<p>（1）先淘汰缓存</p>
<p>（2）再写数据库（这两步和原来一样）</p>
<p>（3）休眠x秒，再次淘汰缓存</p>
<p>也不考虑</p>
<h6 id="_3-先更新数据库-再更新缓存" tabindex="-1"><a class="header-anchor" href="#_3-先更新数据库-再更新缓存" aria-hidden="true">#</a> <strong>3.先更新数据库,再更新缓存</strong></h6>
<p>即Cache Aside</p>
<p>那么，是不是Cache Aside这个就不会有并发问题了？不是的，比如，一个是读操作，但是没有命中缓存，然后就到数据库中取数据，此时来了一个写操作，写完数据库后，让缓存失效，然后，之前的那个读操作再把老的数据放进去，所以，会造成脏数据。</p>
<p>这个case理论上会出现，不过，实际上出现的概率可能非常低，因为这个条件需要发生在读缓存时缓存失效，而且并发着有一个写操作。而实际上数据库的写操作会比读操作慢得多，而且还要锁表，而读操作必需在写操作前进入数据库操作，而又要晚于写操作更新缓存，所有的这些条件都具备的概率基本并不大。</p>
<h3 id="-4" tabindex="-1"><a class="header-anchor" href="#-4" aria-hidden="true">#</a> </h3>
<h6 id="二-read-write-through-pattern" tabindex="-1"><a class="header-anchor" href="#二-read-write-through-pattern" aria-hidden="true">#</a> **二：**Read/Write Through Pattern</h6>
<p>文档地址：</p>
<p>https://docs.oracle.com/cd/E15357_01/coh.360/e15723/cache_rtwtwbra.htm#COHDG5177</p>
<p>Read Through</p>
<p>Read Through 就是在查询操作中更新缓存，也就是说，当缓存失效的时候（过期或LRU换出），Cache Aside是由调用方负责把数据加载入缓存，而Read Through则用缓存服务自己来加载，从而对应用方是透明的。</p>
<p>Write Through</p>
<p>Write Through 就是双写</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/11772383-4361ddbf08f977da.png?imageMogr2/auto-orient/strip|imageView2/2/w/954/format/webp" alt="img"></p>
<p>Write Through</p>
<h6 id="三-write-behind-caching-pattern" tabindex="-1"><a class="header-anchor" href="#三-write-behind-caching-pattern" aria-hidden="true">#</a> <strong>三：Write Behind Caching Pattern</strong></h6>
<p>Write Behind 又叫 Write Back，大概就是先更新cache，背后批量去更新数据库等。</p>
<p>最终一致性</p>
<p><img src="https:////upload-images.jianshu.io/upload_images/11772383-a6c9270549f72a22.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>Write back</p>
<p>总结：</p>
<p><strong>分布式系统里要么通过2PC或是Paxos协议保证一致性，要么就是拼命的降低并发时脏数据的概率</strong></p>
<p>缓存系统适用的场景就是非强一致性的场景，所以它属于CAP中的AP，BASE理论。</p>
<p>异构数据库本来就没办法强一致，我们只是减少时间窗口，达到最终一致性。</p>
<p>还有别忘了设置过期时间，这是个兜底方案</p>
<p>作者：但时间也偷换概念
链接：https://www.jianshu.com/p/2936a5c65e6b
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h3 id="_36-如何进行缓存预热" tabindex="-1"><a class="header-anchor" href="#_36-如何进行缓存预热" aria-hidden="true">#</a> 36.如何进行缓存预热？</h3>
<p>系统上线时，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p>
<p>这里我考虑2个问题：</p>
<p>A、哪些数据需要预热？</p>
<p>B、如何预热？</p>
<p><strong>关于问题A，根据不同的业务系统有不同的方法。</strong></p>
<ol>
<li>可以将已知的热门数据加载到Redis，这种方法适合于基本不变化的数据；</li>
<li>使用redis-faina（https://github.com/facebookarchive/redis-faina.git）实时监控Redis热key，但是因为redis-faina是通过调用Redis的monitor命令来实现的，可能降低Redis50%左右的性能，所以需要根据实际情况评估；</li>
<li>在proxy层，对每个请求进行收集上报，弊端就是需要修改proxy的代码，需要考虑开发成本和稳定性问题；</li>
<li>Redis-cli --hotkyes 查询热点key，只适用于缓存淘汰策略是lfu的时候（https://yq.aliyun.com/articles/278922）；</li>
<li>TCP消息抓包，例如ELK体系下的packetbeat插件(https://www.elastic.co/guide/en/beats/packetbeat/current/index.html)，可以实现对Redis、MySQL等众多主流服务的数据包抓取、分析、报表展示；</li>
<li>客户端上报，例如nginx+lua将访问量上报到kafka中，然后进行统计</li>
</ol>
<p><strong>关于如何预热：</strong></p>
<p>找出了热点key之后，再根据自己的业务逻辑，到DB中查询数据填充到Redis中去。不过既然考虑预热，那么访问量、数据量都会很大，因此要考虑并行（提高预热速度）+ 限速（并发量太大的话，DB也处理不过来）。</p>
<h3 id="_37-缓存集群如何失效" tabindex="-1"><a class="header-anchor" href="#_37-缓存集群如何失效" aria-hidden="true">#</a> 37.缓存集群如何失效？</h3>
<h3 id="_38-一致性哈希有哪些应用" tabindex="-1"><a class="header-anchor" href="#_38-一致性哈希有哪些应用" aria-hidden="true">#</a> 38.一致性哈希有哪些应用？</h3>
<p>普通的哈希算法使用取余操作：hash(o) mod n，其中 n 代表机器的数量。如果在集群中新增加一个节点时，计算公式会变为：hash(o) mod (n+1)；在集群中删除一个机器时，计算公式变为：hash(o) mod (n-1)。所以当集群中机器数量有所变化时，几乎所有的 Object 的哈希值都会改变。一致性哈希可以保证当从集群中删除一台机器时，仅仅保存在该机器上的 Object 的值会变化；当集群中增加一台机器时，也仅仅是非常小的一部分 Object 的哈希值会发生改变。</p>
<p><strong>一致性哈希</strong>的值一般使用 32bit 保存，所以哈希值的空间范围是0~2^32-1，并且2^32-1后面的值是0 ，如图所示是一个封闭的圆圈。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaW1hZGVhcg==,size_16,color_FFFFFF,t_70" alt="img"></p>
<p>在这个圆圈上会映射两种元素的哈希值，一种元素是Object的哈希值，如图2所示是映射4个object；另一种元素是cache的哈希值，即计算机节点的哈希值，如图3所示是映射3个cache。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/sfsfasgahabzbz" alt="img"></p>
<p>当从集群中删除一个节点，如删除 CacheB，则缓存在 CacheB 上的 Object 将会移动到 CacheC 上，如图4；当集群中新增加一个节点时，如增加 CacheD，则在CacheB和CacheD之间的Object会从CacheC上转移到CacheD上，如图5。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/csvvdvsdgsdvsdbs" alt="img"></p>
<p>如果节点数量较少时，还是会出现数据分布不均匀的情况，通过使用虚拟节点的方法可以解决。虚拟节点是将一个真实的cache在圆圈上复制几份作为虚拟节点，如图6。当集群中增加一个真实cache 时，对应的增加一定数量的虚拟节点，当集群中删除一个真实的cache时，其所对应的虚拟节点都会被删除。</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaW1hZGVhcg==,size_16,color_FFddd" alt="img"></p>
<p>Memcache
一致性哈希可以用于Memcache。</p>
<p>Memcache是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。其分布式由客户端实现。每个客户端维护一个服务器池，通过一致性哈希算法，将数据比较均匀地分布在池中的服务器上。</p>
<p>Memcached 将所有的数据放在内存中，不具备数据持久化的功能，当一台机器宕机时，内存里面保存的数据将会全部丢失。</p>
<p>Memcache数据的分布方法主要采用的是一致性hash算法，算法流程如下：</p>
<p>构造一个长度为2^32的整数环，然后根据服务器节点的hash值，将服务器节点分布到这个环上。
当有需要缓存的数据时，根据该数据的key值计算得到hash值，并将其映射至环上。
在环上顺时针查找与该hash值最近的服务器节点，从而完成key到服务器节点的映射，并将数据存储在该服务器节点上。
如果超过2^32次方仍然找不到服务器，则将数据保存到第一台服务器上。
通过该算法有效的减少了服务器节点增减导致的缓存重新分布。</p>
<p>另外，由于通过一般的hash函数，服务器的映射地点的分布可能会不均匀，故采取虚拟节点的方法，为每个物理服务器节点设置多个“逻辑节点”，可以进一步减小服务器节点增减导致的缓存重新分布。
————————————————</p>
<h3 id="_39-一致性hash原理" tabindex="-1"><a class="header-anchor" href="#_39-一致性hash原理" aria-hidden="true">#</a> 39.一致性hash原理</h3>
<p>在讲一致性Hash之前我们先来讨论一个问题。</p>
<p>问题：现在有亿级用户，每日产生千万级订单，如何将订单进行分片分表？</p>
<p>**小A：**我们可以按照手机号的尾数进行分片，同一个尾数的手机号写入同一片/同一表中。</p>
<p>**大佬：**我希望通过会员ID来查询这个会员的所有订单信息，按照手机号分片/分表的话，前提是需要该用户的手机号保持不变，并且在查询订单列表时需要提前查询该用户的手机号，利用手机号尾数不太合理。</p>
<p>**小B：**按照大佬的思路，我们需要找出一个唯一不变的属性来进行分片/分表。</p>
<p>**大佬：**迷之微笑~</p>
<p><strong>小B：</strong>（信心十足）会员在我们这边保持不变的就是会员ID（int），我们可以通过会员ID的尾数进行分片/分表</p>
<p>**小C：**尽然我们可以用会员ID尾数进行分片/分表，那就用取模的方式来进行分片/分表，通过取模的方式可以达到很好的平衡性。示意图如下：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/125147-20190122102253284-1779133288.png" alt="取模理论"></p>
<p>**大佬：**嗯嗯嗯，在不考虑会员冷热度的情况下小B和小C说的方案绝佳；但是往往我们的会员有冷热度和僵尸会员，通过取模的方式往往会出现某个分片数据异常高，部分分片数据异常低，导致平衡倾斜。示意图如下：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/125147-20190122102757153-1407358986.png" alt="img"></p>
<p>**大佬：**当出现某个分片/分表达到极限时我们需要添加片/表，此时发现我们无法正常添加片/表。因为一旦添加片/或表的时候会导致绝大部分数据错乱，按照原先的取模方式是无法正常获取数据的。示意图如下</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/125147-20190122111105997-295011999.png" alt="img"></p>
<p>添加分片/分表前4,5,6会员的订单分别存储在A，B，C上，当添加了片/表的时候在按照（会员ID%N）方式取模去取数据4,5,6会员的订单数据时发现无法取到订单数据，因为此时4,5,6这三位会员数据分布存在了D，E，A上，具体示意图如下：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/125147-20190122104115739-1036936358.png" alt="img"></p>
<p>**大佬：**所以通过取模的方式也会存在缺陷；好了接下来我们来利用一致hash原理的方式来解决分片/分表的问题。</p>
<p>首先什么是一致性哈希算法?<em><strong>一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。Memcached client也选择这种算法，解决将key-value均匀分配到众多Memcached server上的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删Memcached Server的问题(增删server会导致同一个key,在get操作时分配不到数据真正存储的server，命中率会急剧下降)。</strong></em></p>
<p>还以上述问题为例，假如我们有10片，我们利用Hash算法将每一片算出一个Hash值，而这些Hash点将被虚拟分布在Hash圆环上，理论视图如下：</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/125147-20190122121250550-1883830183.png" alt="img"></p>
<p>按照顺时针的方向，每个点与点之间的弧形属于每个起点片的容量，然后按照同样的Hash计算方法对每个会员ID进行Hash计算得出每个Hash值然后按照区间进行落片/表，以保证数据均匀分布。</p>
<p>如果此时需要在B和C之间新增一片/表(B1)的话，就不会出现按照取模形式导致数据几乎全部错乱的情况，仅仅是影响了(B1,C)之间的数据，这样我们清洗出来也就比较方便，也不会出现数据大批量</p>
<p>瘫痪。</p>
<p>但是如果我们仅仅是将片/表进行计算出Hash值之后，这些点分布并不是那么的均匀，比如就会下面的这种情况，导致区间倾斜。如图</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/125147-20190122122336751-455297445.png" alt="img"></p>
<p>这个时候<em><strong>虚拟节点</strong></em>就此诞生，下面让我们来看一下虚拟节点在一致性Hash中的作用。当我们在Hash环上新增若干个点，那么每个点之间的距离就会接近相等。按照这个思路我们可以新增若干个</p>
<p>片/表，但是成本有限，我们通过复制多个A、B、C的副本({A1-An},{B1-Bn},{C1-Cn})一起参与计算，按照顺时针的方向进行数据分布，按照下图示意:</p>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/125147-20190122145502599-1624117506.png" alt="img"></p>
<p>此时A=[A,C1)&amp;[A1,C2)&amp;[A2,B4)&amp;[A3,A4)&amp;[A4,B1)；B=[B,A1)&amp;[B2,C)&amp;[B3,C3)&amp;[B4,C4)&amp;[B1,A)；C=[C1,B)&amp;[C2,B2)&amp;[C,B3)&amp;[B3,C3)&amp;[C4,A3)；由图可以看出分布点越密集，平衡性约好。</p>
<p>我写了一个测试用例，10台服务器，1000个虚拟节点，根据算法对50000数据精细计算得出每台机器上具体数据的分布</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>192.168.1.0:5011
192.168.1.1:5058
192.168.1.2:5187
192.168.1.3:4949
192.168.1.4:5097
192.168.1.5:4939
192.168.1.6:5129
192.168.1.7:4824
192.168.1.8:4957
192.168.1.9:4849
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<p>我从计算结果中打印出了20数据分布的机器情况具体如下：</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>ConsistentHashTest1202:192.168.1.8
ConsistentHashTest1203:192.168.1.4
ConsistentHashTest1204:192.168.1.9
ConsistentHashTest1205:192.168.1.9
ConsistentHashTest1206:192.168.1.4
ConsistentHashTest1207:192.168.1.3
ConsistentHashTest1208:192.168.1.8
ConsistentHashTest1209:192.168.1.2
ConsistentHashTest1210:192.168.1.0
ConsistentHashTest1211:192.168.1.0
ConsistentHashTest1212:192.168.1.6
ConsistentHashTest1213:192.168.1.2
ConsistentHashTest1214:192.168.1.7
ConsistentHashTest1215:192.168.1.1
ConsistentHashTest1216:192.168.1.9
ConsistentHashTest1217:192.168.1.0
ConsistentHashTest1218:192.168.1.4
ConsistentHashTest1219:192.168.1.4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<p>然后我剔除其中一台服务器“192.168.1.8”，在根据算法进行计算并且同事打印出和上述一直的20条数据的分布情况</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>192.168.1.0:5011
192.168.1.1:5058
192.168.1.2:5187
192.168.1.3:4949
192.168.1.4:5097
192.168.1.5:4939
192.168.1.6:5129
192.168.1.7:4824
192.168.1.8:4957
192.168.1.9:4849
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<div class="language-text line-numbers-mode" data-ext="text"><pre v-pre class="language-text"><code>ConsistentHashTest1202:192.168.1.8
ConsistentHashTest1203:192.168.1.4
ConsistentHashTest1204:192.168.1.9
ConsistentHashTest1205:192.168.1.9
ConsistentHashTest1206:192.168.1.4
ConsistentHashTest1207:192.168.1.3
ConsistentHashTest1208:192.168.1.8
ConsistentHashTest1209:192.168.1.2
ConsistentHashTest1210:192.168.1.0
ConsistentHashTest1211:192.168.1.0
ConsistentHashTest1212:192.168.1.6
ConsistentHashTest1213:192.168.1.2
ConsistentHashTest1214:192.168.1.7
ConsistentHashTest1215:192.168.1.1
ConsistentHashTest1216:192.168.1.9
ConsistentHashTest1217:192.168.1.0
ConsistentHashTest1218:192.168.1.4
ConsistentHashTest1219:192.168.1.4
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[<img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码">](javascript:void(0)😉</p>
<p>根据两次的计算结果对比我们发现减少机器后，每台机器上的数据量增加了，但是原先分布在具体机器上的数据，并没有变化。</p>
<p>但是一致性Hash的分布还会和数据源有关，可能会出现数据倾斜的情况。</p>
<h3 id="_40-php实现的一致性hash算法" tabindex="-1"><a class="header-anchor" href="#_40-php实现的一致性hash算法" aria-hidden="true">#</a> 40.PHP实现的一致性Hash算法</h3>
<h3 id="_41-cap定理" tabindex="-1"><a class="header-anchor" href="#_41-cap定理" aria-hidden="true">#</a> 41.CAP定理</h3>
<p>在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:
- 一致性(Consistency) (所有节点在同一时间具有相同的数据)
- 可用性(Availability) (保证每个请求不管成功或者失败都有响应)
- 分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</p>
<h4 id="_1-、consistency-一致性" tabindex="-1"><a class="header-anchor" href="#_1-、consistency-一致性" aria-hidden="true">#</a> (1)、Consistency 一致性</h4>
<p>一致性又称为原子性或者事务性。表示一个事务的操作是不可分割的，要不然这个事务完成，要不然这个事务不完成，不会出现这个事务完成了一半这样的情况。这种事务的原子性使得数据具有一致性。</p>
<p>我们通常情况下在数据库中存在的脏数据就属于数据没有具有一致性的表现。而在分布式系统中，经常出现的一个数据不具有一致性的情况是读写数据时缺乏一致性。比如两个节点数据冗余，第一个节点有一个写操作，数据更新以后没有有效的使得第二个节点更新数据，在读取第二个节点的时候就会出现不一致的问题出现。</p>
<p>传统的ACID数据库是很少存在一致性问题的，因为数据的单点原因，数据的存取又具有良好的事务性，不会出现读写的不一致。</p>
<h4 id="_2-、availability-可用性" tabindex="-1"><a class="header-anchor" href="#_2-、availability-可用性" aria-hidden="true">#</a> (2)、Availability 可用性</h4>
<p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。</p>
<h4 id="_3-、partition-tolerance-分区容错性" tabindex="-1"><a class="header-anchor" href="#_3-、partition-tolerance-分区容错性" aria-hidden="true">#</a> (3)、Partition Tolerance 分区容错性</h4>
<p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，这样就具有好的分区容错性。</p>
<p>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。
因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三大类：
- CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。
- CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。
- AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</p>
<h3 id="_42-nosql数据库分类" tabindex="-1"><a class="header-anchor" href="#_42-nosql数据库分类" aria-hidden="true">#</a> 42.NoSQL数据库分类：</h3>
<p><img src="@source/docs/theme-reco/img/最高级多方面面试题/image-20211218120110016-1642418807162.png" alt="image-20211218120110016"></p>
<h1 id="二十一-elasticsearch" tabindex="-1"><a class="header-anchor" href="#二十一-elasticsearch" aria-hidden="true">#</a> 二十一.Elasticsearch</h1>
<h3 id="_1-谈谈elasticsearch" tabindex="-1"><a class="header-anchor" href="#_1-谈谈elasticsearch" aria-hidden="true">#</a> 1.谈谈elasticsearch？</h3>
<p>elasticsearch是一种搜索引擎，简称为：es，本质是一个java服务器，使用前需要提前将数据录入才能够使用搜索功能</p>
<p>常用查询字段：match、match_phrase、multi_match、bool</p>
<p>常用分词器：standard analyzer（按词切分，小写处理）、simple analyzer（按照非字母切分，小写处理）、whitespace analyzer（按空格切分，不转小写）</p>
<h3 id="_2-es怎么使用的-es索引是什么" tabindex="-1"><a class="header-anchor" href="#_2-es怎么使用的-es索引是什么" aria-hidden="true">#</a> 2.ES怎么使用的？ES索引是什么？</h3>
<h6 id="-5" tabindex="-1"><a class="header-anchor" href="#-5" aria-hidden="true">#</a> </h6>
<h1 id="二十二-golang" tabindex="-1"><a class="header-anchor" href="#二十二-golang" aria-hidden="true">#</a> 二十二.golang</h1>
<h3 id="_1-golang协程是无序的如何实现有序-暂无答案" tabindex="-1"><a class="header-anchor" href="#_1-golang协程是无序的如何实现有序-暂无答案" aria-hidden="true">#</a> 1.golang协程是无序的如何实现有序（暂无答案）</h3>
<h3 id="_2-php-array与golang的切片-数组的差别-暂无答案" tabindex="-1"><a class="header-anchor" href="#_2-php-array与golang的切片-数组的差别-暂无答案" aria-hidden="true">#</a> 2.php array与golang的切片 数组的差别（暂无答案）</h3>
<h1 id="电商面试常见问题" tabindex="-1"><a class="header-anchor" href="#电商面试常见问题" aria-hidden="true">#</a> 电商面试常见问题</h1>
<h3 id="_1-说说你最近做的这个项目的背景-简单的介绍一下你这个项目" tabindex="-1"><a class="header-anchor" href="#_1-说说你最近做的这个项目的背景-简单的介绍一下你这个项目" aria-hidden="true">#</a> 1.说说你最近做的这个项目的背景，简单的介绍一下你这个项目？</h3>
<p>我们公司之前主要以实体店为主，进行批发与零售，业务也相对比较传统。为了适应市场需求，增强公司竞争力，提升业务绩效，另一方面，也为基于互联网的商务模式创新奠定基础。所以开始 xxx 商城建设项目，其中包含商品管理、订单管理、类目管理、客户管理、合作商管理、客服管理、购物平台、内容管理等，很大程度上分担了人工的压力，对提高客户服务效率和客户满意度能够起到较好的作用。（先大体的描述下项目，然后能够挑一两个自己最为熟悉的模块进行叙述）</p>
<h3 id="_2-项目的整体结构-从框架和具体技术来说" tabindex="-1"><a class="header-anchor" href="#_2-项目的整体结构-从框架和具体技术来说" aria-hidden="true">#</a> 2.项目的整体结构（从框架和具体技术来说）</h3>
<p>框架方面：从大处进行描述，比如本项目是属于电商项目，采用的是 TP 框架，运用php+MySQL+Apache 进行开发。因为 TP 框架是开源的、轻量级的，所以用起来更加方便快捷，从效率和成本方面来讲都是性价比比较高的，所以那时候团队决定用这个框架进行开发。然后再从框架的一些优点特性进行说明下，让面试官觉得你对这个框架很了解技术：描述技术时首先用从自己比较熟悉的模块入手（比如说注册验证时会用到的 JS 技术、正则匹配、ajax 无刷新验证等等），然后由此慢慢的向其他方面的技术进行拓展，在说具体技术的时候如果能说到目前比较新或者是比较有难度的技术，能够让面 试官眼前一亮，这样能为自己的面试增加不少分。</p>
<h3 id="_3-分布式架构-对比传统架构的优势-。" tabindex="-1"><a class="header-anchor" href="#_3-分布式架构-对比传统架构的优势-。" aria-hidden="true">#</a> 3.分布式架构，对比传统架构的优势 。</h3>
<p>①最为明显的一点，在传统的架构中，如果某个功能需要进行维护，那么我们必须停掉整个服务，这对于公司的运营会造成损失。分布式系统在核心功能模块使用单独服务器，维护部分模块不影响用户的其他操作。
②在海量数据处理方面，传统架构显得比较乏力；分布式系统架构采用服务器集群，使用负载均衡，海量数据处理游刃有余！
③在性能(检索)以及维护方面，分布式系统架构也有较为明显的优势。</p>
<h3 id="_4-本项目提供了哪些模块-功能和服务" tabindex="-1"><a class="header-anchor" href="#_4-本项目提供了哪些模块-功能和服务" aria-hidden="true">#</a> 4.本项目提供了哪些模块（功能和服务）</h3>
<p><strong></strong> **商品模块：**其中包括商品管理，类型管理，属性管理，栏目管理等等
<strong></strong> **订单模块：**其中包括下单，退单，库存，收货人信息等
** 会员模块：**会员注册，会员信息管理，会员等级管理，会员权限等
<strong></strong> **购物车模块：**购物车数据存储，增删改查购物车商品，清空购物车等
<strong></strong> **提交订单页面：**提交用户的订单信息, 处理并发问题。
** 个人中心：**包括用户的登录，个人信息的管理，收货地址的管理，用户所下的订单的管理
** 支付模块：**支付方式管理（在线支付、货到付款）等</p>
<h3 id="_5-你负责的哪些模块" tabindex="-1"><a class="header-anchor" href="#_5-你负责的哪些模块" aria-hidden="true">#</a> 5.你负责的哪些模块</h3>
<p>在项目中主要负责相关功能的开发，主要有：
**1) 后台管理系统：**主要实现商品管理、商品规格参数管理、订单管理、会员管理等、CMS(内容管理系统)等，并且提供了跨域支持；
**2) 前台系统：**主要是面向用户访问，使用 js、ajax 进行前后台数据交互（一般是用 json 格式数据返回）
**3) 会员登录：**提供和用户信息相关的接口，比如说用户注册、查询等接口（登录时需要进行多重验证，特别注意安全方面）
**4) 订单功能：**主要是提供和订单相关的业务接口，在订单系统了做了严格的数据校验以及高并发写的支持（这里可以说使用队列实现），并且使用了定时器实现对下单的时间控制，比如说关闭超时未付款的订单；
**5) 搜索功能：**主要是提供商品的搜索，可以采用 Sphinx 全文搜索，当然也有其他的搜索方式；
**6) 会员系统：**主要是维护用户的信息，已购买订单、优惠券、系统消息、修改密码、绑定手机等功能；
**7) 缓存：**主要是用 Redis 实现，并且对 Redis 做了集群来保证 Redis 服务的高可用（缓存方面除了 redis 外还有 memcached）
**8) 支付系统：**主要是负责订单的支付、对账等功能，主要是对接了支付宝的接口；
（根据个人的实际情况选择最为熟悉的模块，进行叙述）</p>
<h3 id="_6-简述下这些模块怎么实现的-描述举例只给出部分功能的过程" tabindex="-1"><a class="header-anchor" href="#_6-简述下这些模块怎么实现的-描述举例只给出部分功能的过程" aria-hidden="true">#</a> 6.简述下这些模块怎么实现的？（描述举例只给出部分功能的过程）</h3>
<p><strong>商品类型管理</strong>
包含功能：添加商品类型、显示商品类型列表、修改商品类别、删除商品类型
描述举例：
1、添加商品类型：在后台模块新建一个商品类型的控制器(TypeController)，并添加add 方法， 同时建立好对应的静态页。新建一个对应的商品类型表，在表里添加数据验证。在商品类型控制器中的 add 方法中完成商品类型的添加。（其中关键点是 create 验证和防止非法字段提交）
2、商品类型列表：在商品类型控制器中添加一个 lst 方法，取出商品类型数据，并在对应的静态页中完成数据遍历，就能在页面中得出相应的商品类型列表</p>
<p><strong>属性管理</strong>
包含功能：添加属性、显示属性列表、根据商品类型搜索属性、修改属性、删除属性
描述举例：
前提条件：建立一个属性表将各字段全部预先设置好，才可以进行一下操作
1、添加属性：在后台模块新建一个 AttributeController 的控制器，并添加 add 方法，并建立好对应的静态页面，修改页面里的表单。然后新建一个 attribute 表对应的模型文件，进行数据验证（验证规则可以查手册），在方法中完成属性添加的代码。在属性控制器中写入 lst 方法，并且完成对应静态页，把取出的数据遍历到对应的静态页
2、根据商品类型搜索属性：（给 select 添加 change 事件，完成提交表单， 表单提交到当前页面。）首先在方法中将商品显示出来，并将商品数据完成遍历,给显示商品 类型的 select 添加 change 事件，完成表单提交，其中会引用 JQ 添加  change 事件，当触 发change 事件后，显示出当前显示的商品类型。在商品类型列表，添加“属性列表“的 连接，在添加完成属性后，跳转到属性列表，直接显示所  属当前商品类型的属性，最后实 现分页.</p>
<p><strong>商品栏目管理</strong>
包含功能：创建栏目、栏目的增删改查 （注：商品类型和商品栏目的区别，类型是大类，
栏目是小类）
描述举例：
前提条件：要创建一个栏目表，以便进行下面的功能开发
1、添加栏目：在 admin 模块里面新建一个 category 的控制器，添加 add 方法，并完成对应页面设计。在页面上设计好表单，在添加栏目时将已经添加的栏目显示出来（新建一个商品栏目模型，在里面定义好方法，用于取出栏目的数据，并且已经格式化好的），然后在 add 方法里将数据取出来，并且进行遍历，在此方法中完成栏目的添加
2、栏目列表：在 category 的控制器里添加 lst 方法，并且完成对应页面的设计，在页面中遍历栏目数据，将其遍历显示到页面中
3、删除栏目：（注：在删除栏目时，如果有子栏目则不能删除）在栏目列表中添加删除栏目的链接（用 U 函数自动生成路径），在相应的 category 控制器里，写上 del 方法，接受传递过来的 id,实例化自定义模型，利用 sql 拼接进行查询，找出对应的栏目记录，将其删除</p>
<p><strong>商品管理</strong>
包含功能：商品的增删改查，在线编辑器，属性选项卡，属性的增删改查，商品相册选项卡，添加相册，文件上传，相册上传等
描述举例：
前提条件：要将商品表创建好，具体字段根据需求开设计
1、添加商品：在后台模块（admin 模块）里新建一个 Goods 控制器，写入 add 方法，同时完成相应的页面设计，在 add 方法对应的页面中对表单行进相应的修改（具体的页面要求感觉需求来修改）。在 add 方法中完成商品的添加功能代码，例如生成唯一的商品 id号、添加商品的时间等（利用前缀+时间+唯一码=唯一 id）
2、图片上传：可以利用 TP 已经定义好的钩子函数，来 完成图片文件的上传，返回保存图片的路径。钩子函数在模型里面会自动调用， 比如：入库之前：_before_insert() 和入库之后：_after_insert() 会被模型里面的 add 方法，自动调用。只需要在上传之前，把图片的路径、上传单个文件的最大值、允许上传格式限制好
3、缩略图：在图片上传的基础上利用 new \Think\Image()按照原生图片的比例生成一个缩略像素*缩略像素的缩略图，每个缩略图都会生成一个唯一的 id 名，并且保存到预设好的路径文件夹中（这里要注意的是生成多张缩略图的时候，必须先生成大图，再生成小图），图片生成后将路径入库。
4、显示属性选项卡：（选项卡的显示重点是给标签设置一个 onclick 事件函数）要在选项卡中显示商品类型，在 goods 控制器里面的 add 方法中取出商品类型数据，然后在相应的页面商品属性选项卡位置遍历商品类型数据，分别显示出来
5、完成商品属性的添加：前提将商品属性表设计好，然后根据实际的静态页面进行表单的修改，修改指定表单的域名（即标签中的 name），修改完成后在 Goods 模型里定义一个钩子_after_insert，在该方法中完成属性数据的入库，由此属性的添加完成.</p>
<p><strong>权限管理</strong>
包含功能：管理员登录，权限管理（权限管理控制），角色管理，管理员管理
权限管理简述：权限管理是根据不同等级，不同管理员的情况下，授予不同的权限，各自操作各自授权。授权方式大体分为两种：一种是直接给管理员授权权限，适合于管理员比较少，权限数量也比较少的情况下；第二种是 RBAC 基于角色的访问控制。
在建表方面，采用五张表,其中有三张主表，权限表、角色表、管理员表，两张从表，角色与权限的中间表、管理员与角色的中间表。
角色表与权限表的关系：一个角色可以有多个权限，一个权限可以属于多个角色，权限表与角色表是多对多的关系，要体现这种关系，要使用角色与权限的中间表；管理员表与角色表的关系：一个管理员可以属于多个角色，一个角色可以包含多个管理员，角色表与管理员表是多对多的关系，要体现这种关系，要使用管理员与角色的中间表。</p>
<p>五张表关系图如下：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/oFA4QOeEEpMHpdTR6F0vWANib9wNKCuafxeGGa8dNfTudNnu5sJ0bzk7NYGrMicD1UfzcHZwFjUNU536tH9GsBfw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><strong>描述举例：</strong>
1、权限管理：在项目中权限管理就是按钮，通过按钮给对应的管理员或者是角色分配权限。在后台模块新建一个权限的控制器，并写入 add 方法，完成对应的页面设计，修改好页面上的表单，完善页面。新建一个权限模型，并且在模型中添加数据验证，设置好验证规则（具体代码参考项目中的），在模型中完成权限添加。在父级权限完成后，继续添加子级权限：在模型里面定义一个方法，用于取出权限，并格式化好权限数据，然后在添加权限控制器里面，取出权限数据，并进行遍历，将遍历出来的子级权限显示在页面中
2、角色管理：角色管理中包含对角色的增删改查，授权等等。添加角色首先要在在后台模块新建一个 RoleController 的控制器，写入添加 add 方法，完成对应的静态页面，取出权限数据，并修改对应的表单。在后台模块里面，添加一个 RoleModel 模型，写入添加数据验证。接下来就是数据入库，在入库时要注意的是该表单提交的数据，是入库两张的表，一个是角色表，一个是角色与权限的中间表，其中角色与权限的中间表的数据，是使用钩子函数_after_insert()来完成。
3、角色删除：如果角色里面有管理员，则不能删除，在删除角色的同时，要删除角色与权限的中间表里面的对应的数据。首先在角色列表中添加删除的链接（用 U 函数自动生成路径），然后在角色控制器中添加删除 del 方法，用于删除角色，其次在角色模型中添加钩子函数_after_delete()用来删除角色与权限中间表对应的角色数据，删除完成
4、管理员管理：在添加管理员时，要分配管理员所属角色，并且将管理员各个数据根据要求设定好格式。创建管理员控制器，添加 add 方法，取出角色数据，并完成页面设计将数据显示到页面上。在管理员模型中添加数据验证，使用静态方法来完成验证，</p>
<p><img src="@source/docs/theme-reco/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>使用模型添加数据，接受明文密码，然后用双重 md5 进行加密，这个过程的代码可以直接写到钩子函数里。使用钩子函数添加管理员与角色中间表的数据，在管理员的模型里面，添加_after_insert()钩子函数</p>
<p><img src="@source/docs/theme-reco/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>5、管理员列表：在管理员的控制器里面添加 lst 方法，用于取出管理员数据，并完成对应的静态页面，要注意：显示管理员的同时，要显示出所属角色的名称，因此要连表查询（管理员表  管理员角色表 角色表）</p>
<p><img src="@source/docs/theme-reco/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>然后在对应的界面中进行管理员数据遍历并且显示到页面上。
6、删除管理员：要操作的表是：it_admin 和 it_admin_role，在删除 it_admin_role表里面数据时，则可以使用钩子函数_after_delete()，钩子函数是 TP 框架里面提供的，
主要有：_before_insert()、_after_insert()、_before_update()、_after_update()，_before_delete()，_after_delete()（该系列函数是在模型里面定义，会被自动调用。）
注意：超级管理员不能被删除（拥有最高权限）</p>
<p><strong>邮件发送验证管理</strong>
包含功能：（原理要理解、）注册、登录、发送、密码找回等
描述举例：
1、原理：</p>
<p><img src="@source/docs/theme-reco/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>邮件的 SMTP（Simple Mail Transfer Protocol）：即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。SMTP 协议属于TCP/IP 协议族，它帮助每台计算机在发送或中转信件时找到下一个目的地。通过 SMTP协议所指定的服务器,就可以把 E－mail 寄到收信人的服务器上了，整个过程只要几分钟。SMTP 服务器则是遵循 SMTP 协议的发送邮件服务器，用来发送或中转发出的电子邮件。
2、用户注册：创建用户表，将所需字段设置好（在设置字段的时候可以预留一些字段以便后面拓展使用）。在前台模块中新建一个 user 控制器，添加 register 方法，并且完成对应静态页。在 user 模型中添加数据验证，返回数据.</p>
<p><img src="@source/docs/theme-reco/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>在控制器中完成注册后，发送邮件：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/oFA4QOeEEpMHpdTR6F0vWANib9wNKCuafE9iaCPpBicuJjkicjIXerSibEPHDbTKeq6icTpkt7AuaCD8aQdPicpc50xAw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>邮件发送后，由用户进行激活认证，因此在控制器中新建 active 方法。方法中首先要接受数据（key 值，用户邮件数据），然后判断链接是否合法，根据传递的 email 查找出 vaildate字段内容和 key 值进行匹配。如果匹配成功那么，就让用户进行激活，激活的同时将 active的初始状态更改为 1，则功能完结
3、密码找回功能：实现方式，根据用户名-&gt;查找出注册时设置的问题-&gt;输入问题的答案-&gt;如果答案正确-&gt;发送一封邮件，根据该邮件里面的链接去完成密码的修改。首先在页面上将密码找回的链接设置好，在 user 控制器里添加 findpwd1 方法（用于找回密码的第一个方法），该方法显示出找回密码输入用户的一个界面，同时应该完成对应页面的编写。再在 user 控制器中添加 findpwd2 方法，根据用户名查找出注册时设置的问题，让用户输入问题的答案。第三是在user 控制器中写入 findpwd3 方法，用于问题答案的匹配并发送邮件，通过邮件的链接来完成密码的修改。最后在 user 控制器中添加一个 update 方法，用于完成密码的修改</p>
<p><strong>购物车管理</strong>
包含功能：提交商品到购物车、显示购物车列表、删除购物车里商品、修改购物车、
清空购物车等等
1、 购物车的实现方式：① 可以把购物车的数据，给存储到 session 里面，一旦关闭浏览器，则商品数据就丢失；②可以把购物车的数据，给存储到 cookie 里面，可以长久的保存购物车里面的数据；③可以把购物车的数据，给存储到数据库里面，可以长久的保存购物车里面的数据；④可以把购物车的数据，给存储到缓存里（memcache,redis），也可以长久的保存购物车的数据。
注：Session 可能会引起并发问题，如果脚本很短，这通常没有问题。但如果脚本运行时间比较长，那就可能会产生问题。在现代 Web 应用程序开发中，有一个非常常见的情况，就是使用 AJAX 技术在同一个页面内发送多个请求获取数据。如果这些请求都需要使用Session，那么第一个请求到达服务器后会取得 Session 锁，其它请求就必须等待，所有请求将串行处理，即使它们彼此之间并没有依赖关系。这将大大增加页面的响应时间。有一个方法可以避免这个问题，就是在使用完 Session 以后立即调用 session_write_close（）方法关闭 Session。这样 Session 锁就会释放，即使当前脚本还在等在处理。需要注意的是，调用该方法后，当前脚本就不能进一步操作 Session 了
2、实例：京东购物车的设置，如果用户已经登录，则把购物车数据保存到数据库里面，如果没有登录，则把购物车的数据给保存到 cookie 里面，当登录时，要判断 cookie是否有购物车的数据，如果有，则把 cookie 里面的数据给移动到数据库里面。
3、提交商品到购物车：在前台模块里新建一个 CartController 控制器，添加 addCart方法</p>
<p><img src="@source/docs/theme-reco/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>4、购物车列表：在购物车模型里添加 cartList 方法，用于显示列表。如果用户已经登录，则直接从购物车数据库里面取出数据，如果用户没有登录，则直接从 cookie里面获取数据。最后在购物车控制器里面的 cartList 的方法中，并取出购物车数据，并在对应的静态页面里完成遍历，显示出来
5、cookie 移到 DB 中：用户登录后，要判断 cookie 里面是否有购物车数据，如果有，则就移动到数据库，在购物车模型里面定义一个方法 cookie2db</p>
<p><img src="@source/docs/theme-reco/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>登录成功后调用 cookie2db 方法即可</p>
<p><strong>订单管理</strong>
描述举例：
1、建立订单控制器，添加 flow 方法，完成对应的静态页面。在 order 控制器里面添加一个 done 方法，用来完成下订单功能:首先接受传递过来的订单信息数据，判断购物车里面是否有商品，防止出现能够直接访问该方法的情况，如果没有商品则提示无法下单，接着判断用户是否已经登陆，如果没有登录把当前访问的地址存储到 session里，跳转登录页面，完成登录后再跳转回来，再判断是否填写收货人的信息，同理，如果没有填写则跳转填写页面。下单时会自动算出订单总额，生成唯一的订单号，并且从session 中取出用户 id，获取收货人信息。随后将订单信息和订单商品信息入库结算完成后，清空购物车，订单完成
2、下订单注意事项：</p>
<p>①在下订单之前要判断库存是否充足：判断商品属性 id 是否有值，如果有说明该商品有属性，直接从 product 表里进行判断，如果没有属性则直接从goods 表里判断库存
②下完订单后要减掉库存：在入库  it_order_goods  表时，要完成减掉库存
③ 高并发下订单问题：使用文件锁，对文件锁定后，不是操作文件，是锁定文件后，执行下订单， 查看库存之前，就要加锁，一直到购买完成(另外 redis 消息队列)</p>
<p><img src="@source/docs/theme-reco/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>④添加事务：防止某些操作只完成一半</p>
<p><strong>网上支付管理</strong>
支付过程主要是调用第三方支付接口
网上支付流程：</p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/oFA4QOeEEpMHpdTR6F0vWANib9wNKCuafPiahsjI9YjqbtnlGZiawLNhqrmDka6IicTnwTV8WeyDBjDic9gxJ9JXZTw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><img src="https://mmbiz.qpic.cn/sz_mmbiz_png/oFA4QOeEEpMHpdTR6F0vWANib9wNKCuafOMVsl0ZdqhibBFmuBN4KrMOx4vRySfBicEwtJkic9yxTQ4hWdS8VHicumg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>商城与银行对接方案：
1、直接与银行对接
优点：
因为直接与银行进行财务结算，交易资金结算比较安全。适合资金流量比较大的企业，这种方案适合于，每月结算金额百万以上的企业。
缺点：
开发工作量比较大，而且银行会不定期升级交易系统，随着银行系统的升级，企业也也需要做相应的改动，所以维护工作量也是比较大的，而且企业每年还需要向银行交纳一定数量的接口使用费用。
2、通过中间公司间接与银行对接</p>
<p><img src="@source/docs/theme-reco/data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="图片"></p>
<p>优点：
开发工作量较少，银行升级系统，不需要企业做相应的修改，除非中间企业的接入规范发生了改变，相对前一种接入方案，这种方案的维护工作量比较少的。因为只与一家企业对接，所以接入费用相对比较低。这种方案适合于：每月结算资金在几十万以下的中小企业。
缺点：
因为是与中间企业进行资金结算，目前所有中间企业都是私企，资金安全是个大问题</p>
<h1 id="docker" tabindex="-1"><a class="header-anchor" href="#docker" aria-hidden="true">#</a> DOCKER:</h1>
<p>docker一些命令</p>
<h1 id="前端300基础面试题-答案、分类学习整理-良心制作-持续更新" tabindex="-1"><a class="header-anchor" href="#前端300基础面试题-答案、分类学习整理-良心制作-持续更新" aria-hidden="true">#</a> 前端300基础面试题+答案、分类学习整理（良心制作）持续更新</h1>
<p>https://juejin.cn/post/6914831351271292936#heading-40</p>
<p>线程 进程 浏览器渲染https://www.cnblogs.com/cangqinglang/p/8963557.html</p>
<p>缓存 https://github.com/lgwebdream/FE-Interview/issues/14</p>
<p>安全 XSS跨站脚本攻击 CSRF跨站请求攻击 https://github.com/lgwebdream/FE-Interview/issues/16</p>
<p>promise https://github.com/xieranmaya/Promise3/blob/8ed9d850c81731dc25ef20e56b2307a114a6bea8/Promise3.js#L124</p>
<p>js异步 是因为调用的模块是异步的 事件循环https://zhidao.baidu.com/question/1606761572094906867.html</p>
<p>webpack打包优化https://www.jianshu.com/p/e4c1a9c40a2e</p>
<p>1.js数据类型</p>
<p>基本类型 string number null undefined boolean symbol bigint</p>
<p>引用类型 object function</p>
<p>1.盒子水平垂直居中</p>
<p>\1. position: absolute;</p>
<p>top: 50%;</p>
<p>left: 50%;</p>
<p>transform: translate(-50%,-50%);</p>
<p>\2. display: flex;</p>
<p>justify-content: center;</p>
<p>align-items: center;</p>
<p>\3. display: table-cell;</p>
<p>vertical-align: middle;</p>
<p>text-align: center;</p>
<p>2.下面是js得获取body标签下所有元素标签</p>
<p>var elems = document.body.getElementsByTagName(&quot;*&quot;);</p>
<p>3.图片懒加载实现原理https://blog.csdn.net/w1418899532/article/details/90515969</p>
<p>大概原理是<img src="D:/BaiduNetdiskDownload/计算机书籍笔记/通用图片" data-src="真是图片" /></p>
<p>当可视区+卷去的高度 &lt; img 距离滚动区域顶部的距离 在给img 赋值真实的图片</p>
<p>4.浏览器输入URL到页面渲染发生了什么</p>
<p>​    1、浏览器的地址栏输入URL并按下回车。</p>
<p>2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。</p>
<p>3、DNS解析URL对应的IP。</p>
<p>4、根据IP建立TCP连接（三次握手）。</p>
<p>为什么要发起三次握手： 为了防止已失效的连接请求报文段突然又传送到服务端，因而产生错误</p>
<p>5、HTTP发起请求。</p>
<p>6、服务器处理请求，浏览器接收HTTP响应。</p>
<p>7、构建DOM树,渲染页面。</p>
<p>8、关闭TCP连接（四次挥手）。</p>
<p>https://blog.csdn.net/baiqiangdoudou/article/details/88548288</p>
<p>HTTP状态码</p>
<p>200 连接成功</p>
<p>301 重定向</p>
<p>304 走缓存</p>
<p>400 请求语法出现错误</p>
<p>404 资源找不到</p>
<p>500 服务器错误</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiYTlmNzc0YjAtYjBiZS00ZmE2LTk5NjMtZmFkNGU2Y2U4ZWJkIiwicmVzb3VyY0d1aWQiOiIxZWQ5NGNjZC1lM2MyLTQ5ZDItYWM0NS1iMjg5NTVjMjFmYWUifQ==" alt="img"></p>
<p>跨域是什么，怎么解决跨域</p>
<p>跨域，指的是浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是<strong>浏览器施加的</strong>安全限制。</p>
<p><strong>所谓同源是指，域名，协议，端口均相同</strong></p>
<p><strong>解决办法：</strong></p>
<p><strong>1、JSONP：</strong></p>
<p>其本质是利用了标签具有可跨域的特性，由服务端返回预先定义好的javascript函数的调用，并且将服务端数据以该函数参数的形式传递过来。<strong>SONP只支持GET请求，不支持POST请求。</strong></p>
<p><strong>2、代理：</strong></p>
<p><strong>例如www.123.com/index.html需要调用www.456.com/server.php，可以写一个接口www.123.com/server.php，由这个接口在后端去调用www.456.com/server.php并拿到返回值，然后再返回给index.html，这就是一个代理的模式。相当于绕过了浏览器端，自然就不存在跨域问题。</strong></p>
<p><strong>3、CORS（XHR2方式）</strong></p>
<p><strong>在php接口脚本中加入以下两句即可：</strong></p>
<p><strong>header('Access-Control-Allow-Origin:*');//允许所有来源访问</strong></p>
<p><strong>header('Access-Control-Allow-Method:POST,GET');//允许访问的方式</strong></p>
<p>nginx反向代理</p>
<p>https://www.cnblogs.com/ddlove/p/9945988.html</p>
<p>cookie和session</p>
<p>1，session 在服务器端，cookie 在客户端（浏览器） 2，session 默认被存在在服务器的一个文件里（不是内存） 3，session 的运行依赖 session id，而 session id 是存在 cookie 中的，也就是说，如果浏览器禁用了 cookie ，同时 session 也会失效（但是可以通过其它方式实现，比如在 url 中传递 session_id） 4，session 可以放在 文件、数据库、或内存中都可以。 5，用户验证这种场合一般会用 session</p>
<p>因此，维持一个会话的核心就是客户端的唯一标识，即 session id</p>
<h2 id="cookie-localstorage-sessionstorage" tabindex="-1"><a class="header-anchor" href="#cookie-localstorage-sessionstorage" aria-hidden="true">#</a> <strong>cookie localstorage sessionstorage</strong></h2>
<p>浏览器垃圾回收机制</p>
<p>标记清除进入环境离开环境</p>
<p>引用计数 引用+1循环引用会有问题</p>
<h2 id="原型-原型链-继承" tabindex="-1"><a class="header-anchor" href="#原型-原型链-继承" aria-hidden="true">#</a> 原型/原型链/继承</h2>
<p>原型原型链</p>
<p>1.所有的函数数据类型都有一个自带的属性：prototype(原型) ， 这个属性的值是一个对象，浏览器会默认给它开辟一个堆内存</p>
<p>2.在浏览器给prototype开辟的堆内存中有一个天生自带的属性：constructor，这个属性的值是当前函数的本身；</p>
<p>3.每一个实例对象都有一个__proto__的属性，这个属性指向当前实例对象所属类的prototype（如果不能确定是谁的实例，都是Object的实例）</p>
<p>原型链</p>
<p>1.我们创建的所以函数都有一个prototype属性，这个属性是一个指针，指向一个对象；这个对象是包含由特定类型的所有实例共享的属性和方法。那么prototype是通过调用构造函数而创建的那个对象实例的原型对象；</p>
<p>2.所有原型对象都会自动获取一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针；</p>
<p>创建Person的新实例，必须使用new 操作符；以这个方法调用构造函数实际会经历4个步骤</p>
<p>1.创建一个新的对象</p>
<p>2.将构造函数的作用域付给新对象（因此this就指向来这个新对象）</p>
<p>3.执行构造函数中的代码（为这个新对象添加属性）</p>
<p>4.返回新对象</p>
<p>继承</p>
<p><a href="https://blog.csdn.net/liu_yunzhao/article/details" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/liu_yunzhao/article/details/90116723继承<ExternalLinkIcon/></a></p>
<p>https://www.cnblogs.com/my466879168/p/12333116.html</p>
<p>原型链继承</p>
<p>function Father(){</p>
<p>this.name = '父亲';</p>
<p>this.eat = function(){</p>
<p>​    console.log('eat')</p>
<p>}</p>
<p>}</p>
<p>Father.prototype = {</p>
<p>construct: Father,</p>
<p>hei: 200,</p>
<p>play: function(){}</p>
<p>}</p>
<p>function Son(sex){</p>
<p>this.sex = sex</p>
<p>}</p>
<p>Son.prototype = new Father(); //原型链继承</p>
<p>Son.prototype.construct = Son;</p>
<p>Son.prototype.playGame = function(){}</p>
<p>构造函数继承</p>
<p>function Son(sex){</p>
<p>Father.call(this); //构造函数继承</p>
<p>this.sex = sex;</p>
<p>}</p>
<p>Son.prototype.playGame = function(){}</p>
<p>var son = new Son('nan')</p>
<p>区别：</p>
<p>1.原型链继承 Son.prototype = new Father() Son没有使用默认提供的原型，而是Father的实例，所以Son的原型，不仅具有自身所有的属性和方法，而且其内部还有个指针，指向Father的原型，最终son指向Son的原型，Son的原型又指向Father的原型，从而使用原型链的方法查询到Father的属性和方法；</p>
<p>2.构造函数继承是通过在Son构造函数中调用Father.call(this)去改变Father构造中this的指向来达到继承，</p>
<p>缺点： 原型链接触不能父类不能传递参数，</p>
<p>构造函数继承不能调用父级原型上的属性和方法</p>
<p>解决方式 组合继承</p>
<p>this指向</p>
<p>this一般理解就是 数据指向 谁调用这个函数 this 就指向谁 普通函数中 this=&gt;window 构造函数中 this=&gt;实例化对象 事件处理函数中 this=&gt;事件触发对象 在es6的箭头函数中 this指向父及作用域，箭头函数中没有this</p>
<p><strong>箭头函数不绑定this，但会捕获上下文的this  ，作为自己的this</strong></p>
<p>call/apply/bind</p>
<p>call 和 apply是 Function 对象的原型方法，</p>
<p><strong>函数实例的call方法，可以指定该函数内部this的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。并且会立即执行该函数。</strong></p>
<p>function.call(thisobj, args... ) 传入多个</p>
<p>function.apply(thisobj, args) 传入数组</p>
<p>var keith = { rascal: 123 };</p>
<p>var rascal = 456;</p>
<p>function a()</p>
<p>console.log(this.rascal);</p>
<p>}</p>
<p>a.call(this); //456</p>
<p>a.call(keith); //123</p>
<p><strong>找出数组中的最大数</strong></p>
<p>var a = [2, 4, 5, 7, 8, 10];</p>
<p>console.log(Math.max.apply(null, a)); //10</p>
<p>console.log(Math.max.call(null,2, 4, 5, 7, 8, 10)); //10</p>
<p>使用 bind() 用来把函数绑定到指定对象上。 function.bind(thisArg [, arg1[, arg2 [, argN]]])</p>
<p><strong>a：第一个参数都是指定函数内部中this的指向（函数执行时所在的作用域），然后根据指定的作用域，调用该函数。</strong></p>
<p><strong>b：都可以在函数调用时传递参数。call，bind方法需要直接传入，而apply方法需要以数组的形式传入。</strong></p>
<p><strong>c：call，apply方法是在调用之后立即执行函数，而bind方法没有立即执行，需要将函数再执行一遍。有点闭包的味道。</strong></p>
<p><strong>d：改变this对象的指向问题不仅有call，apply，bind方法，也可以使用that变量来固定this的指向。</strong></p>
<p>防抖节流 中apply</p>
<p><em>防抖函数的代码使用以上两行代码获取this和参数，是为了让debounce函数最终返回的函数this指向不变以及依然可以接受到e参数。</em></p>
<p>https://blog.csdn.net/weixin_39808181/article/details/114103174</p>
<p>闭包</p>
<p>一个函数可以访问其他函数作用域内的数据，就叫做闭包；</p>
<h3 id="有几种类型的函数" tabindex="-1"><a class="header-anchor" href="#有几种类型的函数" aria-hidden="true">#</a> 有几种类型的函数</h3>
<p>匿名函数，回调函数，递归函数，构造函数</p>
<p>递归函数</p>
<p>在函数内部，有两个特殊的对象，arguments和this，其中，arguments是一个类数组对象，包含传入函数的所有参数，虽然arguments的主要用途是用来保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，执向拥有这个arguments对象的函数</p>
<p>function factorial(num){   if(num &lt;= 1) {    return 1;   } else {    return num * arguments.callee(n - 1)   } }</p>
<p>vue单面应该实现原理</p>
<p>1。 使用location.hash值实现spa； 即：location.hash;</p>
<p>原理：</p>
<p>1 使用事件监听，监听事件hashchange，看window.location.hash的值；window.addEventListener('hashchange',function(){})</p>
<p>2 switch条件语句，对不同的hash，设置不同的展示内容；</p>
<p>3 获取不同的内容时，用ajax发送请求，请求后台数据，成功时，返回获取的数据，遍历数据，展示相应的数据；</p>
<p><strong>2 h5中的history;</strong> 即：window.history; 原理涉及的知识点： 1 history中原始的方法： history.back(); 与在点击后退按钮相同； history.forword(); 与在点击前进按钮相同； history.go() 接受一个整数,跳转到整数指定的页面，go(1) 相当于forword，go(-1)相当于back；go(0) 相当于刷新页面； 2 h5中新增的方法：pushState()方法和replaceState()方法，这 push两个方法可以向历史栈中添加数据，就好像url（）变化了一样；这样就可以模拟浏览前进和后退的，前端路由也是同理； （1）history.pushState(stateObj,title,url)； stateObj:一个与指定网址相关的状态对象，popstate事件触发；该对象会传入回调函数。如果不需要这个对象，可以传入null； title：新页面的标题； url:新的地址，必须与当前页面处于同一域，浏览器的地址将显示这个网址;</p>
<p>vue 服务端渲染ssr</p>
<p><a href="https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F" target="_blank" rel="noopener noreferrer">https://ssr.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93-ssr-%EF%BC%9F<ExternalLinkIcon/></a></p>
<p>vue模版渲染</p>
<p>上述提到的编译器在扫描dom的时候做的三件事儿parse optimize generate</p>
<p>1 parse是使用正则解析template中的vue指令变量等，形成语法树AST（标签的结构 语法树）_c()</p>
<p>2 optimize 标记一些静态节点，用作后面的性能优化，在diff的时候直接略过</p>
<p>3 generate 把第一部生成的AST转化为渲染函数</p>
<p>（1）模板编译分三部分内容</p>
<p>（2）由于静态节点不需要总是重新渲染，所以在生成AST之后、生成渲染函数之前这个节点，需要做一个操作，那就说遍历一遍AST，给所有静态节点做一个标记，这样在虚拟DOM中更新节点时，如果发现节点有这个标记，就不会重新渲染它。</p>
<p>（3）这三部分内容在模板编译中分别抽象出三个模块来实现各自的功能，分别是</p>
<p>1、解析器。</p>
<p>2、优化器。</p>
<p>3、代码生成器。</p>
<p>const code = 'with(this){return 'Hello Berwin'}';</p>
<p>const hello = new Function(code);</p>
<p>https://blog.csdn.net/qq_40542728/article/details/103144941</p>
<p>vue面试题</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiYTlmNzc0YjAtYjBiZS00ZmE2LTk5NjMtZmFkNGU2Y2U4ZWJkIiwicmVzb3VyY0d1aWQiOiI2NjNiOWIwMS00YTY1LTQ3YjYtYmYwMS02ZmZlZDQ0ODhiMDAifQ==" alt="img"></p>
<p>双向数据绑定 响应式原理</p>
<p>initData 的时候 循环遍历data中的值 通过observe对其进行观测，已经观测过的属性会加上_ob_属性，判断有没有监听过，如果没有执行new observer()对其监听，函数中会执行defineReactive方法，次方法会对属性通过object.defineProperty()通过getter/setter重写，在get中执行dep.depend()进行依赖收集 watcher，在set中执行dep.notify()通知视图更新</p>
<p>为何采用异步渲染</p>
<p>如果不采用异步，每次数据更新都会渲染当前组件，为了性能考虑，vue会在本轮数据更新后，再去异步更新视图。</p>
<p>1 dep.notify() 通知watcher进行数据更新</p>
<p>2 subs[i].undate() 依次调用watcher的update</p>
<p>3 queuewatcher 将watcher去重放到队列中</p>
<p>4 nextTick(flushSchedulerQueue) 异步清空watcher队列</p>
<p>nextTick 实现原理</p>
<p>nextTick主要使用宏任务/微任务定义一个异步方法，多次调用nextTick 会将方法存入队列中，通过这个异步请求的方法清空当前队列。</p>
<p>computed和watch区别</p>
<p>原理上两个都是watcher</p>
<p>initComputed -&gt; new Watcher() lazy:true,dirty: true</p>
<p>在dirty为false的时候返回上次的计算结果，dirty为true 计算时会进行依赖收集，dirty改为false</p>
<p>watch deep的原理是递归调用 耗性能</p>
<p>diff算法</p>
<p>时间复杂度 O(n)</p>
<p>1.先同级比较，在比较子节点</p>
<p>2.先判断一方有子节点的，再编译没有子节点的</p>
<p>3.比较都有子节点的</p>
<p>4.递归比较子节点</p>
<p>v-for中key的作用</p>
<p>当Vue用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue将不是移动DOM元素来匹配数据项的改变，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。</p>
<p>为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。key属性的类型只能为 string或者number类型。</p>
<p>描述组件渲染和更新过程</p>
<p>渲染组件时，会通过Vue.extend方法构建自组件的构造函数，并进行实例化，最终调用$mount()进行挂在。更新组件时会进行patchvnode流程，核心就是diff算法。</p>
<p>异步组件加载</p>
<p>如果组件功能多，打包出来的结果会很大，我们可以采用异步的方法来加载组件，主要依赖import()这个语法，可以实现文件的分割加载。</p>
<p>components: {</p>
<p>AddCustomerSchedule:(resolve) =&gt; import(&quot;../components/AddCustom&quot;)</p>
<p>}</p>
<p>1.vue的prop、data、computed 他们三者初始化的顺序是什么？为什么是这个顺序</p>
<p>function initState (vm) {     vm._watchers = [];     var opts = vm.$options;     if (opts.props) { initProps(vm, opts.props); }     if (opts.methods) { initMethods(vm, opts.methods); }     if (opts.data) {       initData(vm);     } else {       observe(vm._data = {}, true /* asRootData */);     }     if (opts.computed) { initComputed(vm, opts.computed); }     if (opts.watch &amp;&amp; opts.watch !== nativeWatch) {       initWatch(vm, opts.watch);     }   } 可以看出来computed在data之后，所以不要在data中引用computed中的属性，只能得到undefined。 data可以调用前面的props，methods的属性 computed中可以调用props，methods，data中的属性</p>
<p>借助vue-template-compiler的browser.js，通过一系列正则，将template转成ast抽象语法树。</p>
<p>将ast转为可运行的代码code(with(this){ return _c('div', [_s(aaa)]) })</p>
<p>通过new Function执行上面的with字符串，</p>
<p>生成虚拟dom；</p>
<p>\2. vue的组件中data为什么是一个函数，组件的实质是什么，组件从注册到在页面渲染是个怎样的过程？</p>
<p>大家知道用组件化来写vue项目,每个.vue文件都是一个个组件。那什么是vue中的组件？ 官网写的很易懂——组件就是一个可复用的vue的实例。 这也就意味着如果你的data是一个普通的对象，那么所有复用这个实例的组件都将引用同一份数据，这就造成了<strong>数据污染</strong>！ 这个时候如果我们将data封装成一个函数，我们在实例化组件的时候只是调用了这个函数生成的数据副本，这就避免了数据污染。</p>
<p>双向数据绑定原理</p>
<p><a href="https://baijiahao.baidu.com/s?id=1614572521202569483&amp;wfr=spider&amp;for=pc&amp;searchword=vue%E5%8E%9F%E7%90%86" target="_blank" rel="noopener noreferrer">https://baijiahao.baidu.com/s?id=1614572521202569483&amp;wfr=spider&amp;for=pc&amp;searchword=vue%E5%8E%9F%E7%90%86<ExternalLinkIcon/></a></p>
<p>vue2双向数据绑定的缺点，vue3的改进</p>
<p>https://blog.csdn.net/Marker__/article/details/106784198</p>
<p>前端八股文 vue https://blog.csdn.net/weixin_43405946/article/details/112274517</p>
<p>项目开发流程</p>
<p>https://blog.csdn.net/qq_33084055/article/details/104940437</p>
<p>面试技巧</p>
<p>https://zhuanlan.zhihu.com/p/125720498</p>
<p>面试问题</p>
<p>https://blog.csdn.net/pengboran/article/details/106957518</p>
<p>https://zhuanlan.zhihu.com/p/224922926</p>
<p>https://zhuanlan.zhihu.com/p/277554605</p>
<p>事件循环</p>
<p>简单地说，对于 JS 运行中的任务，JS 有一套处理收集，排队，执行的特殊机制，我们把这套处理机制称为事件循环（Event Loop）。</p>
<p>先执行主线程-&gt;微任务-&gt;宏任务</p>
<p>promise 面试题</p>
<p>https://blog.csdn.net/johnny_mu/article/details/104347685</p>
<p>https://www.cnblogs.com/zhujieblog/articles/13161364.html</p>
<p>promise基本规则： 1. 首先Promise构造函数会立即执行，而Promise.then()内部的代码在当次事件循环的结尾立即执行(微任务)。 2. promise的状态一旦由等待pending变为成功fulfilled或者失败rejected。那么当前promise被标记为完成，后面则不会再次改变该状态。 3. resolve函数和reject函数都将当前Promise状态改为完成，并将异步结果，或者错误结果当做参数返回。 4. Promise.resolve(value) 返回一个状态由给定 value 决定的 Promise 对象。如果该值是 thenable(即，带有 then 方法的对象)，返回的 Promise 对象的最终状态由 then 方法执行决定；否则的话(该 value 为空，基本类型或者不带 then 方法的对象),返回的 Promise 对象状态为 fulfilled，并且将该 value 传递给对应的 then 方法。通常而言，如果你不知道一个值是否是 Promise 对象，使用 Promise.resolve(value) 来返回一个 Promise 对象,这样就能将该 value 以 Promise 对象形式使用。 5. Promise.all(iterable)/Promise.race(iterable) 简单理解，这2个函数，是将接收到的promise列表的结果返回，区别是，all是等待所有的promise都触发成功了，才会返回，而arce有一个成功了就会返回结果。其中任何一个promise执行失败了，都会直接返回失败的结果。 6. promise对象的构造函数只会调用一次，then方法和catch方法都能多次调用，但一旦有了确定的结果，再次调用就会直接返回结果。</p>
<p>promise静态属性 promise.resolve() promise.reject() promise.all() promise.race()</p>
<p>Promise.all = function (promises) {  return new Promise(function(resolve, reject){   var resolvedCounter = 0   var promiseNum = promises.length   var resolveVdalues = new Array(promiseNum)   for (var i = 0; i &lt; promiseNum; i++){    (function (i) {     promises.resolve(promises[i]).then(function(value){      resolvedCounter++      resolveVdalues[i] = value      if (resolvedCounter === promiseNum) {       return resolve(resolveVdalues)      }     }, function(err) {      return reject(err)     })    })(i)   }  }) } // 原理for循环是同步的，promise构造函数也是同步的，then是异步的微任务， promise.race = function (promises) {  return new Promise(function (resolve, reject) {   for (var i = 0; i &lt; promises.length; i++){    Promise.resolve(promises[i]).then(function (value) {     return resolve(value)    }, function (err) {      return reject(err)    })   }  }) }</p>
<p>http是什么</p>
<p>HTTP是一种能够获取如 HTML 这样的网络资源的 protocol(通讯协议)超文本传输协议。它是在 Web 上进行数据交换的基础，是一种 client-server 协议，也就是说，请求通常是由像浏览器这样的接受方发起的。一个完整的Web文档通常是由不同的子文档拼接而成的，像是文本、布局描述、图片、视频、脚本等等。</p>
<p>超文本就是指“含有指向其他资源链接”内容的文本</p>
<p>Http/2.0 特点：</p>
<p>采用二进制格式而非文本格式； 完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行；（解决了线头阻塞的问题，与Http1最重要的区别） 使用报头压缩，降低开销 服务器推送</p>
<p>https是什么</p>
<p>https主要解决三个安全问题： 内容隐私 防篡改 确认对方身份 https并不是直接通过非对称加密传输过程，而是有握手过程，握手过程主要是和服务器做通讯，生成私有秘钥，最后通过该秘钥对称加密传输数据。还有验证证书的正确性。 证书验证过程保证了对方是合法的，并且中间人无法通过伪造证书方式进行攻击。</p>
<p>web server/web 服务器</p>
<p>主要功能是提供网上信息浏览服务</p>
<p>Web服务器可以解析(handles)HTTP协议。当Web服务器接收到一个HTTP请求(request)，会返回一个HTTP响应(response)。Web服务器可以解析(handles)HTTP协议。当Web服务器接收到一个HTTP请求(request)，会返回一个HTTP响应(response)，例如送回一个HTML页面。</p>
<p>每台服务器上都会安装处理请求的应用——web server。常见的 web server 产品有 apache、nginx、IIS 或 Lighttpd 等。web server 担任管控的角色，对于不同用户发送的请求，会结合配置文件，把不同请求委托给服务器上处理相应请求的程序进行处理（例如 CGI 脚本，JSP 脚本，servlets，ASP 脚本，服务器端 JavaScript，或者一些其它的服务器端技术等），然后返回后台程序处理产生的结果作为响应。</p>
<p>1、Content-Type 的值类型：</p>
<p>1.1 application/json：消息主体是序列化后的 JSON 字符串</p>
<p>1.2 application/x-www-form-urlencoded：数据被编码为名称/值对。这是标准的编码格式</p>
<p>1.3 multipart/form-data： 需要在表单中进行文件上传时，就需要使用该格式。常见的媒体格式是上传文件之时使用的</p>
<p>1.4 text/plain：数据以纯文本形式(text/json/xml/html)进行编码，其中不含任何控件或格式字符。</p>
<p>AMD 和CMD</p>
<p>https://zhuanlan.zhihu.com/p/54952714</p>
<p><strong>1.函数柯里化是什么</strong></p>
<p>函数柯里化（currying）又称部分求值。一个函数中返回另一个函数。</p>
<p>虚拟Dom的实现</p>
<p>Virtual DOM是利用JS的原生对象来模拟DOM，既然DOM是对象，我们也可以用原生的对象来表示DOM。</p>
<p>https://www.cnblogs.com/isLiu/p/8325186.html</p>
<p>Accept 头部的作用什么，如果服务器不支持怎么办</p>
<p>https://blog.csdn.net/weixin_34238642/article/details/85925617</p>
<p>合并重排</p>
<p>https://blog.csdn.net/DZY_12/article/details/102924478</p>
<p>MVC 和MVVM</p>
<p>MVVM主要解决了MVC中大量的DOM操作使页面渲染性能降低，加载速度变慢，影响用户体验。</p>
<h3 id="bfc-定义" tabindex="-1"><a class="header-anchor" href="#bfc-定义" aria-hidden="true">#</a> BFC 定义</h3>
<p>BFC(Block formatting context)直译为&quot;块级格式化上下文&quot;。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<p>循环调用</p>
<p>lodash工具类库</p>
<p>组件 二次封装</p>
<p><img src="https://app.yinxiang.com/files/common-services/binary-datas/c2VydmljZVR5cGU9MiZzZXJ2aWNlRGF0YT17Im5vdGVHdWlkIjoiYTlmNzc0YjAtYjBiZS00ZmE2LTk5NjMtZmFkNGU2Y2U4ZWJkIiwicmVzb3VyY0d1aWQiOiI5MjZlODgwYS0wYTk1LTRmYzUtYTcxZi1iZmM5OWVkZDY1YjkifQ==" alt="img"></p>
<p>vue extence</p>
<p>mixin 合并原则</p>
<p>diffpach</p>
<p>indexed</p>
</div></template>


