<template><div><h1 id="php程序员面试算法宝典" tabindex="-1"><a class="header-anchor" href="#php程序员面试算法宝典" aria-hidden="true">#</a> PHP程序员面试算法宝典</h1>
<p>猿媛之家组编 琉忆 楚秦等编著</p>
<h3 id="◆-2-3-概率与组合" tabindex="-1"><a class="header-anchor" href="#◆-2-3-概率与组合" aria-hidden="true">#</a> ◆ 2.3 概率与组合</h3>
<blockquote>
<blockquote>
<p>2.3.1 抽球人数是多少难度系数：★★★☆☆被考查系数：★★★★☆题目描述：在一个不透明的箱子里，一共有红、黄、蓝、绿和白五种颜色的小球，每种颜色的小球大小相同，质量相等，数量充足。每个人从篮子里抽出两个小球，如果要保证有两个人抽到的小球颜色相同，那么至少需要抽球的人数为（　）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.11个B.8个C.16个D.13个分析与解答：C。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目要求两个人抽到的小球颜色相同，而此题有两个关键点需要注意：第一，每个人取的是两个球，而不是一个球，所以，必须要求两个球的颜色都是一模一样的才能称为小球颜色相同；第二，每种球的数量充足，可以理解为球的数量是无限的，不存在某一种颜色的球被全部取完后面的人无法取到的情况。由于球的颜色有5种，根据排列组合原理，5种情况下取的球的颜色情况可以分为两类情况：1）取的两个球的颜色相同（每个人取的球的颜色是相同的），有5种情况。2）取的两个球的颜色不同，C（5, 2）=10，有10种情况。以上两种情况合计共有15种情况。如果前15个人取的球的颜色都不相同，那么当第16个人取球时，必然会与前面的15个人中的某一个相同。由此可知，本题的答案为16个，即选项C正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.2 案件发生在A区的可能性是多少难度系数：★★☆☆☆被考查系数：★★★☆☆题目描述：S市共有A、B两个区，人口比例为3∶5。据历史统计，A区的犯罪率为0.01%，B区的犯罪率为0.015%，现有一起新案件发生在S市，那么案件发生在A区的可能性是（　）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.37.5%B.32.5%C.28.6%D.26.1%分析与解答：C。根据题目意思可知，假设A区的人数为3N，那么，B区人口数为5N，A区犯罪的人数为3N×0.01%，B区犯罪的人数为5N×0.015%。A区犯罪的可能性 =（A区犯罪人数）/（A区犯罪人数+B区犯罪人数）=（3N×0.01%）/（3N×0.01%+5N×0.015%）= 28.6%。所以，选项C正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.4 对称矩阵有多少个难度系数：★★★☆☆被考查系数：★★☆☆☆题目描述：对称矩阵是指元素以主对角线为对称轴对应相等的矩阵。如果一个矩阵中的各个元素取值为0或1，那么该矩阵为01矩阵，大小为N×N的01对称矩阵的个数为（　）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.power（2, n）B.power（2, n×n/2）C.power（2, （n×n+n）/2）D.power（2, （n×n-n）/2）分析与解答：C。通过题意可知，对称矩阵可以根据对角线下方的元素推断出上方的元素。因此，只需要存储对角线及其以下的元素即可确定该矩阵内容。所以可以得出这样一个结论，对称矩阵可由它的下三角矩阵唯一确定。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>本题中，第一行需要填充1个元素，第二行需要填充2个元素……第n行需要填充n个元素，加起来有1+2+3+…+n=n（n+1）/2个元素。此外，每个数字是0或1两种可能，因此，一共有power（2, n（n+1）/2）个不同的对角矩阵。所以，本题的答案为C。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.5 A、B点有多少种走法难度系数：★★★★☆被考查系数：★★★☆☆题目描述：在如下6×8的矩阵中，从A点移动到B点一共有（　）种走法。要求每次只能向上或者向右移动一格，并且不能经过点P。[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.492B.494C.496D.498分析与解答：A。本题中要求解两个点之间的可能路径条数，可以采用将不可能的路径条数排除的方法。假设向右走一步记为“右”，向上走一步记为“上”。在这样一个6×8的矩阵中，从A点到B点，共需要走12步，其中7步必须向右，5步必须向上，但次序可以不同。于是，选定5个给“上”，剩下的7个给“右”，因此，一共存在是C（7, 12）种可能性。同时要求P点不能走，要排除经过P点（乘法原理）的情况，那么A点走到P点的可能次数是C（3, 6），从P点走到B点的可能次数是C（4, 6），因此，本题的结果是C（7, 12）-C（3, 6）×C（4, 6）=492。所以，选项A正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.6 多少种排队方式难度系数：★★★☆☆被考查系数：★★★☆☆题目描述：每年9月份是找工作的旺季，此时很多同学会去图书馆借阅《程序员面试、笔试宝典》这本书。现在图书馆外有6名同学排队，其中3名同学要将手中的《程序员面试、笔试宝典》还至图书馆，有3名同学希望从图书馆中可以借到《程序员面试、笔试宝典》。若当前图书馆内已无库存，要保证借书的3名同学都可以借到书，请问这6位同学有多少种排队方式（　）。A.60</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>B.120C.180D.360分析与解答：C。本题中，一共有6个人参与借书与还书这个行为，而图书馆之前是没有图书的，所以，要保证借书的3名同学都能借到书，必须同时满足以下三个条件：1）第1个同学肯定是还书的而不是借书的。如果第1个同学是借书的，那么他肯定借不到书，因为图书馆没有库存。所以，一共有3种人的可能性（因为有3个人来还书）。2）最后1个同学肯定是借书的而不是还书的。如果最后1个同学是还书的，那么前面5个人肯定有3个借书的，2个还书的，最终肯定有1个人借不到书，与要求不符合。所以，一共对应3可能性（因为有3个人来借书）。3）中间的4个人分别有两个人是借书的，有两个人是还书的，一共有A（4, 4）种可能性，合计24种可能性。但是其中有4种可能性不合理，即4个人的借还书情况顺序为：借借还还，为什么要排除的数是4呢？因为借书对应2个人的行为，还书也对应2个人的行为，二者取积，其结果就是4了。所以，一共有3×3×（24-4）=180。所以，选项C正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.9 圆桌上一共有多少种坐法难度系数：★★★☆☆被考查系数：★★★★☆题目描述：村主任带着4对父子参加某娱乐节目在某村庄的拍摄。村里为了保护小孩不被拐走，有个规矩，那就是吃饭的时候小孩左右只能是其他小孩或者自己的父母。那么4对父子在圆桌上一共有（　）种坐法（旋转一下，每个人面对的方向变更后算是一种新的坐法）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.144B.240C.288D.480分析与解答：D。根据题意，可以知道位置排列只有以下两种可能，如下图：[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>[插图]对于第一种方式：由于孩子和孩子是面对面的，父亲和父亲是面对面的。所以，8个位置可以等效为4个位置，孩子的位置定了，父亲的位置也就定了。而孩子的排列数为4×3×2，旋转只有4种可能（因为等效下来只有4个位置）。所以，总可能数为4×4×3×2=96。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于第二种方式：孩子的排列有4×3×2×1，孩子的位置定了，其中两位父亲的位置就定了，剩下两位父亲就可以随意排列了，此时可以旋转8次，总可能数为8×4×3×2×2=384。综上所述，总共有384+96=480种可能。所以，选项D正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.10 兵马俑博物馆可容纳多少人难度系数：★★☆☆☆被考查系数：★★★☆☆题目描述：如果兵马俑博物馆参观者到达的速率是每分钟20人，平均每个人停留20分钟，那么该博物馆至少需要容纳（　）人。A.100B.200C.300D.400分析与解答：D。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>本题中，参观者到达的速率是每分钟20人，平均每个人在馆内停留20分钟，在这20分钟里面，大家都还没走，那么总共需要同时容纳20×20=400人。所以，选项D正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.11 两种策略的预期收益是多少难度系数：★★★☆☆被考查系数：★★★☆☆题目描述：对立的两方争夺一个价值为1的物品，双方采取的策略可以分为鸽子策略和鹰策略。如果双方都是鸽子策略，那么双方各有1/2的概率获得该物品；如果双方均为鹰策略，那么双方各有1/2的概率取胜，胜方获得价值为1的物品，付出价值为1的代价，负方付出价值为1的代价；如果一方为鸽子策略，一方为鹰策略，那么鹰策略获得价值为1的物品，在争夺的结果出来之前，没人知道对方是鸽子策略还是鹰策略，当选择鸽子策略的人的比例是某一个值时，选择鸽子策略和选择鹰策略的预期收益是相同的，那么该值是（　）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.0.2B.0.4C.0.5D.0.7分析与解答：C。本题中，假设选择鸽子的人的比例为p，那么选择鹰的人的比例为1-p。此时选择鸽子的预期收益为：p×1/2×1/2（对方选择鸽子的收益）+0（对方选择鹰的收益），选择鹰的预期收益为：（（1-p）×1/2×（1-1）+（1-p）×1/2×（-1））×1/2（对方选择鹰的收益）+（1-p）×1×1/2（对方选择鸽子的收益）。如果鸽子和鹰的预期收益一样，则p×1/2×1/2=（1-p）×1/2×（-1）×1/2+（1-p）×1×1/2，得到p=0.5。所以，选项C正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.13 合法表达式有多少个难度系数：★★★☆☆被考查系数：★★☆☆☆题目描述：一个合法的表达式由括号（）包围，括号（）可以嵌套和连接，如（（））（）也是合法的表达式。现有6对括号（），它们可以组成的合法表达式的个数为（　）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.15B.30C.64D.132分析与解答：D。本题中，可以把左括号看作1，右括号看作0，这些括号的组合就是01的排列。此时需要满足从第一个数开始的任意连续子序列中，0的个数不多于1的个数，也就是右括号的个数不多于左括号的个数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>假设不考虑这个限制条件，那么全部的01排列共有C（2n, n）种，也就是一半为0，一半为1的情况。需要注意的是，最终的结果还需要考虑一些不符合项的内容。在任何不符合条件的序列中，找出使得0的个数超过1的个数的第一个0的位置，然后在包括这个0的部分序列中，以1代替所有的0并以0代表所有的1。结果总的序列变成一个有（n+1）个1和（n-1）个0的序列，而且这个过程是可逆的。也就是说，任何一个由（n+1）个1和（n-1）个0构成的序列都能反推出一个不符合条件的序列。所以，不符合条件的序列个数为C（2n,n-1）。合法的排列数有C（2n, n）-C（2n, n-1）=C（12, 6）-C（12, 5）=132。因此，选项D正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.14 会Java和C++程序的有多少人难度系数：★★★☆☆被考查系数：★★★☆☆题目描述：某团队有2/5的人会写Java程序，有3/4的人会写C++程序，那么这个团队里同时会写Java程序和C++程序的至少有（　）人。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.3B.4C.5D.8分析与解答：A。本题中，因为2/5的5和3/4的4的最小公倍数为20，所以，会Java语言的至少有8个人（也可能是8的若干倍），会C++语言的有15个人（也可能是15的若干倍）。那么，同时会使用Java语言和C++语言的人至少有8+15-20=3，所以，至少有3个人同时会Java语言和C++语言。因此，选项A正确。2.3.15 乘坐甲车的概率是多少</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>难度系数：★★☆☆☆被考查系数：★★★☆☆题目描述：甲、乙两路公交车间隔均为10分钟，公交车发车时刻的分钟数个位分别是1和9，那么对于一个随机到达的乘客，他乘坐甲车的概率为（　）。A.0.1B.0.2C.0.3D.0.9分析与解答：B。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>本题中，对于一名乘客而言，每10分钟里面，如果他在时间区间[0, 1）或[9, 10]内到达公交站，那么他会乘坐公交车甲，此时他坐甲车的概率p为0.2。如果他在时间区间[1, 9）内到达公交站，那么他会乘坐公交车乙，此时他乘坐乙车的概率q为0.8。所以，选项B正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.16 A到Z的最短路径数是多少难度系数：★★★★☆被考查系数：★★★☆☆题目描述：假设下图中每个正方形的边长为1，则从A到Z的最短路径条数为（　）。A.11B.12C.13D.14</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>[插图]分析与解答：C。本题中，假设为上图的左下角与右上角补充两个小正方形，那么此时从点A到点Z需要横着走4格，竖着走2格，此时最短路径有C（6, 2）或C（6, 4）种情况，即（6×5）/2=15种情况。当然，最终结果不是15，由于整个图形补充了两个缺口，所以，必须在15的基础上减去2，最终结果为15-2=13。因此，选项C正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.17 选取红黄白球的概率是多少难度系数：★★★☆☆被考查系数：★★★☆☆题目描述：袋中有红球、黄球和白球各一个，每次任意取一个放回，如此连续3次，则下列事件中概率是8/9的是（　）。A.颜色不全相同</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>.颜色全不相同C.颜色全相同D.颜色无红色分析与解答：A。对于选项A，如果每次任取一个球，则取到一个红球、一个黄球和一个白球的概率相等，均为1/3，所以，颜色不全相同的概率P1=1-C（3, 1）×1/3×1/3×13=8/9。因此，选项A正确。对于选项B，颜色全不相同的概率P2=C（3, 1）×C（2, 1）/3×3×3=2/9。因此，选项B错误。对于选项C，颜色全相同的概率P3=C（3, 1）×1/3×1/3×1/3=1/9。因此，选项C错误。对于选项D，颜色无红色，表明在三次取球的过程中，每次取到的都是其他颜色的球，颜色无红色的概率P4=2/3×2/3×2/3=8/27。因此，选项D错误。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.18 一共有多少种染色情况难度系数：★★★★☆被考查系数：★★★☆☆题目描述：用两种颜色去染排成一个圈的6个棋子，如果是通过旋转得到的则只能算一种排列方式，那么一共有（　）种染色情况。A.10B.11C.14D.15</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：C。本题中，假设两种颜色分别是黑色与白色，默认情况下是白色，考虑到通过旋转得到的形式只能算为一种，那么，用p（n）表示有n个黑棋的种类，此时可以得出以下结论：1）p（0）=p（6）=1。全是白色或者全是黑色，只存在1种可能情况。2）p（1）=p（5）=1。1个白棋子与5个黑棋子或者1个黑棋子与5个白棋子，只存在1种可能情况。3）p（2）=p（4）=3。存在3种可能，分别是黑白棋子相邻的一种，隔一个的一种，隔两个的一种。4）p（3）=4。3个黑棋子与3个白棋子，一共四种组合，分别是黑黑黑白白白、黑黑白黑白白、黑黑白白黑白、黑白黑白黑白。一共有p（0）+p（1）+p（2）+p（3）+p（4）+p（5）+p（6）=14种染色方案。所以，选项C正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.19 肇事车是白车的概率是多少难度系数：★★★☆☆被考查系数：★★★★☆题目描述：某城市发生了一起汽车撞人逃逸事件，该城市只有两种颜色的车，其中白色车占15%，黑色车占85%。事发时有一个人在现场看见似乎是一辆白色的车，但是根据专家在现场分析，在当时那种条件能看正确的可能性是80%。那么，肇事车是白车的概率是（　）。A.12%B.29%</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>C.41%D.80%分析与解答：C。本题中，肇事车的情况一共存在着以下4种可能性：1）如果肇事车是白色车，那么被正确识别的概率P1=15%×80%=12%。2）如果肇事车是白色车，那么被看成是黑车的概率P2=15%×20%=3%。3）如果肇事车是黑色车，那么被正确识别的概率P3=85%×80%=68%。4）如果肇事车是黑色车，那么被看成是白车的概率P4=85%×20%=17%。所以，肇事车是白色车的概率P=P1/（P1+P4）=12%/（12%+17%）=41.3%。因此，选项C正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.21 一红一黑的概率是多少难度系数：★★★☆☆被考查系数：★★★☆☆题目描述：从一副牌（52张，不含大小王）里抽出两张牌，其中一红一黑的概率是（　）。A.25/51B.1/3C.1/2D.26/51分析与解答：D。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>每副牌中，有四种花色的牌以及大小王，各个花色的牌都是13张，分别为1、2、3、4、5、6、7、8、9、10、J、Q、K，从52张牌中抽两张牌，一共有C（52, 2）种情况。一红指的是红桃与方片，一黑指的是黑桃与梅花，抽到一红的可能情况是C（26, 1），抽到一黑的可能情况是C（26, 1），所以，抽到一红一黑的概率P=C（26, 1）×C（26, 1）/C（52, 2）=26/51。因此，选项D正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.22 谁会赢难度系数：★★★☆☆被考查系数：★★★☆☆题目描述：有一堆石子共100枚，甲乙轮流从该堆中取石子，每次可取2枚、4枚或6枚，假设取得最后石子的玩家为赢，若甲先取，则（　）。A.谁都无法取胜B.乙必胜C.甲必胜D.不确定</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：C。很显然，只要先取的人保证最后剩8枚，无论后取的人取几枚石子（如果后取石子的人取2枚，则先取石子的人取6枚；如果后取石子的人取4枚，则先取石子的人取4枚；如果后取石子的人取6枚，则先取石子的人取2枚），先取石子的人都可以取得胜利。所以，只要先取的人能够保证最后剩余8枚即可保证自己获得胜利。那么，问题来了，如何保证呢？其实很简单，只要保证每一个回合内取的数是一个可控的固定数即可，显然，8就是这个固定数。先取的人只需要保证第一次取完后，剩下的数字是8的倍数，以后无论后取的人怎么取，只要先取的人取的石子数与后取的人取的石子数相加为8，就一定能胜。100%8=4，所以，本题中，只需要甲先取4枚石子，然后在后续的取数中，每一个回合所取数与上一个回合乙所取数之和为8，就能保证必胜。因此，选项C正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.3.23 乘坐不同交通工具的概率是多少难度系数：★★☆☆☆被考查系数：★★★☆☆题目描述：有朋自远方来，他乘火车、轮船、汽车或飞机来的概率分别是0.3、0.2、0.1和0.4，坐各种交通工具迟到的概率分别是1/4、1/3、1/12和0，下列语句中，正确的是（　）。A.如果他准点，那么他乘飞机的概率大于等于0.5</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>B.坐陆路（火车，汽车）交通工具准点机会比坐水路（轮船）要低C.如果他迟到，那么他乘火车的概率是0.5D.如果他准点，那么他坐轮船或汽车的概率等于坐火车的概率分析与解答：C、D。假设“朋友乘火车、轮船、汽车、飞机来”分别为事件a、b、c、d，根据题意，事件a、b、c、d之间是互斥的，且P（a）=0.3，P（b）=0.2，P（c）=0.1，P（d）=0.4，那么他坐各种交通工具不迟到的概率分别是：1-1/4=3/4，1-1/3=2/3，1-1/12=11/12，1-0=1。根据这些条件，可以得出以下结论：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于选项A，如果他准点，那么他乘飞机的概率P1=（0.4×1）/（0.3×3/4+0.2×2/3+0.1×11/12+0.4×1）=8/17=0.47，该值比0.5小。所以，选项A错误。对于选项B，他乘火车的准点率P2=0.3×3/4=9/40=27/120=0.225，他坐汽车的准点率P3=0.1×11/12=11/120=0.0917，他坐轮船的准点率P4=0.2×2/3=2/15=16/120=0.133，显然，他坐火车准点机会比坐轮船要高。所以，选项B错误。对于选项C，如果他迟到，那么他乘火车的概率P5 = （0.3×1/4）/（0.3×1/4+0.2×1/3+0.1×1/12+0.4×0）=0.5。所以，选项C正确。对于选项D，如果他准点，那么他乘轮船的概率P6 = （0.2×2/3）/（0.3×3/4+0.2×2/3+0.1×11/12+0.4×1）=8/51，他乘汽车的概率P7 = （0.1×11/12）/（0.3×3/4+0.2×2/3+0.1×11/12+0.4×1） =11/102，他乘火车的概率P8=（0.3×3/4）/（0.3×3/4+0.2×2/3+0.1×11/12+0.4×1）=9/34。此时，乘轮船或汽车的概率：8/51+11/102=9/34，即等于乘火车的概率。所以，选项D正确。因此，本题的答案为C、D。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-4-数学计算" tabindex="-1"><a class="header-anchor" href="#◆-2-4-数学计算" aria-hidden="true">#</a> ◆ 2.4 数学计算</h3>
<blockquote>
<blockquote>
<p>2.4.1 一共等了女神多少分钟难度系数：★★★☆☆被考查系数：★★★★☆题目描述：实验高中的小明暗恋女神同学已经三年了，高考结束后，小明决定向女神同学表白。这天，小明来到女神楼下等待女神的出现，时间一分一秒地流逝，两个多小时过去了，女神还没有出现，小明看了下表，时针和分针的位置正好跟开始等的时候互换，请问小明一共等了女神（　）分钟。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.165B.150C.172D.166分析与解答：D。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>根据题目中的描述，可以画一个表示时针与分针的图例，如下图所示。[插图]假设小明开始等待女神的那一时刻时针与分针的夹角为 θ 弧度，那么，等到时针与分针正好互换位置时，时针走过了 θ 弧度。而由于分针转动一圈表示的时间为一个小时，钟表一圈是一个圆，表示的弧度值为2π，分针因为要转若干圈才能到达时针的位置，记分钟所转圈数为n，此时分针转过的角度则为（2πn-θ）弧度。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目强调，“时间一分一秒地流逝，两个多小时过去了，女神还没有出现”，通过这条信息可知，分针转了2到3圈，接近3圈，此时的n值取3。所以，时针转过的角度值为θ，分针转过的角度值为2π×3-θ=6π-θ。对于时针而言，2π代表一圈，即12个小时，那么弧度θ表示的时间值为12×θ/2π小时；对于分针而言，2π代表一圈，即60分钟，那么（6π-θ）表示的是60×（6π-θ）/2π分钟。由于时钟走过的时间值与分钟走过的时间值所代表的时间量是一个量，故而二者是相等的，由此可以构建如下等式关系：（12θ/2π）×60= 60×（6π-θ）/2π求解上述等式可知，θ=6π/13，即小明等待的时间反映在钟表上为6π/13弧度值。所以，小明一共等了12×（6π/13）/2π小时，即36/13小时，合166分钟。因此，选项D正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.4.2 使用了什么进制运算</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果等式12×25=311成立，那么使用的是（　）进制运算。A.七B.八C.九D.十一分析与解答：C。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>当进行乘法运算时，无论是什么进制的数进行运算，其基本方法都是相同的，以十进制数的计算为例：2×5=10。如果是七进制，那么运算结果最后一位一定是10%7=3，相乘后进位值为10/7=1。同理，如果是八进制，相乘结果最后一位一定等于10%8=2。如果是九进制，最后一位一定是10%9=1。如果是十一进制，最后一位一定是10%11=A（类似于十六进制中，使用A表示数字10）。本题中，计算结果为311，最后一位为1，可以排除选项A、选项B和选项D，只有选项C满足题意，所以，选项C正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.4.7 如何才能找到最好的羽毛球员工</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：公司里面有1001个员工，现在要在公司里面找到最好的羽毛球选手，也就是第一名，每个人都必须参赛，那么至少要比赛多少次才能够找到最好的羽毛球员工？分析与解答：本题中，可以采用两两比赛的方式找出最好的羽毛球员工。具体而言，就是将1001个员工两两分组，分成500组，然后剩下一个人，采用二者之间取高手的方法，即类似于归并排序的方式，比出冠军后，让冠军之间再比，主要是要想想多余的那一个选手如何处理，必然要在第一次决出冠军后加入比赛组。具体过程如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）分成500组，1人空出　（500次，淘汰500人）（2）250组，空1人　　　　（250次，淘汰250人）（3）125组，空1人　　　　（125次，淘汰125人）（4）63组　　　　　　　　（63次，淘汰63人）（5）31组，空1人　　　　（31次）（6）16组　　　　　　　　（16次）（7）8组　　　　　　　　（8次）（8）4组　　　　　　　　（4次）（9）2组　　　　　　　　（2次）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（10）1组　　　　　　　　（1次，得出冠军）结果：如果是两两比赛，那么次数是：500+250+125+63+31+16+8+4+2+1=1000次。如果是场次，那么次数是：10场比赛。如果只求两两比赛的次数，那么可以用另外一个简单的方法来考虑：每一场比赛只能淘汰一个人，只有比1000场比赛才能淘汰掉1000个人，从而剩余最后一个，一定是第一名。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.4.8 亮着的灯泡有多少个难度系数：★★★☆☆被考查系数：★★★★☆题目描述：现在有100个灯泡，每个灯泡都是关着的，第一趟把所有的灯泡打开，第二趟把偶数位的灯泡置反（也就是开了的关掉，关了的打开），第三趟让第3，6，9…的灯泡置反……第100趟让第100个灯泡置反，那么经过一百趟以后有多少灯泡亮着？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：根据题目意思可以得出以下三个结论：1）对于每盏灯，当拉动的次数是奇数时，灯就是亮着的，当拉动的次数是偶数时，灯就是关着的。2）每盏灯拉动的次数与它的编号所含约数的个数有关，它的编号有几个约数，这盏灯就被拉动几次。3）1～100这100个数中有哪几个数，约数的个数是奇数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由于最开始灯是灭的，所以，只有经过奇数次改变开关状态的灯是亮的，相对应的数学解释就是灯的编号有奇数个不同的约数。一个数的约数都是成对出现的，只有完全平方数，它的约数个数才是奇数，例如：1的约数为1，4的约数为1、2、4，9的约数为1、3、9，以此类推，这100盏灯中有10盏灯是亮着的。它们的编号分别是： 1、4、9、16、25、36、49、64、81、100。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.4.9 工作时长是多少难度系数：★★★☆☆被考查系数：★★★★☆题目描述：有A、B、C三个人负责装修房子，一面墙，单独工作时，A需要花费18小时砌好，B需要花费24小时，C需要花费30小时。现A、B、C三人顺序轮流砌墙，每人工作1小时换班，完工时，B总共工作了（　）小时。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>A.8小时B.7小时44分C.7小时D.6小时48分分析与解答：B。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>根据题目意思可知，A工作一个小时完成整个工程量的1/18，B工作一个小时完成整个工程量的1/24，C工作一个小时完成整个工程量的1/30。由于A、B、C三个人顺序轮流砌，每人工作1小时换班，所以，A、B、C三个人每三小时的工程量为1/18+1/24+1/30，合计47/360。而360除以47得7余31，也就是说，3个人一共工作了7个三小时后，还剩余31/360的工作量未能完成。此时轮到A工作， A每小时完成整个工程量的1/18，所以，剩下的31/360-1/18=11/360的工程量需要B来完成，完成11/360的工程量，B需要花费的时间为11×24/360=11/15小时。由此可知，B的工作时间为7小时+（11/15）×60分钟，即7小时44分。因此，选项B正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.4.12 如何正确计算余数难度系数：★★★☆☆被考查系数：★★★☆☆题目描述：87的100次方除以7的余数是（　）。A.1B.2C.3D.4分析与解答：D。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于取余运算符%，满足如下等式关系：（a×b）%c=（a%c）×（b%c）%c，所以，（87100）%7=（87%7）100%7=（3100）%7。对于任意n（n≥0），（3n）%7只存在6种可能，依次为1、3、2、6、4和5，根据等式递推可得到：87100%7=3100%7=950%7=250%7=3210%7=410%7=165%7=25%7=32%7=4。所以，选项D正确。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.4.13 最高的效率是多少难度系数：★★★☆☆被考查系数：★★☆☆☆题目描述：计算三个稠密矩阵A、B、C的乘积ABC，假定三个矩阵的尺寸分别为m×n、n×p和p×q，且m＜n＜p＜q，以下计算顺序中，效率最高的是（　）。A.（AB）CB.A（BC）C.（AC）BD.（BC）A</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：A。根据矩阵运算知识，可以排除选项C与选项D，因为矩阵A与矩阵B相乘，矩阵A的列数必须与矩阵B的行数相等。对于选项A与选项B，一个m×n的矩阵A乘以n×q的矩阵B，会用矩阵A的第一行，乘以矩阵B的第一列并相加。这一运算需要耗费n次乘法以及n-1次加法，矩阵B有q列，矩阵A有m行，所以，A×B的复杂度为m×（2n-1）×q。根据上面的分析可知，选项A的复杂度为m×（2n-1）×p+m×（2p-1）×q，而选项B的复杂度为m×（2n-1）×q+n×（2p-1）×q，很显然，选项A的效率高于选项B。所以，选项A正确。</p>
</blockquote>
</blockquote>
<h2 id="◆-第3章-排序算法" tabindex="-1"><a class="header-anchor" href="#◆-第3章-排序算法" aria-hidden="true">#</a> ◆ 第3章 排序算法</h2>
<blockquote>
<blockquote>
<p>第3章 排序算法使一串记录，按照其中的某个或某些关键字的大小，递增或递减排列起来的操作叫作排序。排序算法就是如何使记录按照要求排列的方法。排序算法在很多领域都得到了足够的重视，尤其是在大量数据的处理方面。一个优秀的算法可以节省大量的资源。在各个领域，考虑到数据的各种限制和规范，要想得到满足实际需要的优秀算法，需要经过大量的推理和分析。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>例如：随机输入一个序列的n个数，序列为：a1,a2,a3,…,an，通过算法实现输出：n个数的排列顺序为：a1',a2',a3',…,an'，使得a1'≤a2'≤a3'≤…≤an'（根据实际需求也可以实现从大到小的排序，方法不唯一）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）关于排序算法的一些术语说明：稳定性：如果a原本在b前面，而a=b，那么排序之后a仍然在b的前面。不稳定性：如果a原本在b的前面，而a=b，那么排序之后a可能会出现在b的后面。内排序：所有排序操作都在内存中完成。外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>时间复杂度：一个算法执行所耗费的时间。空间复杂度：运行完一个程序所需内存的大小。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）相关排序算法的对比如下：[插图]注释：n表示数据规模；k表示“桶”的个数；In-place表示占用常数内存，不占用额外内存；Out-place表示占用额外内存。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）算法根据稳定性分类如下：[插图]</p>
</blockquote>
</blockquote>
<h3 id="◆-3-1-如何实现冒泡排序" tabindex="-1"><a class="header-anchor" href="#◆-3-1-如何实现冒泡排序" aria-hidden="true">#</a> ◆ 3.1 如何实现冒泡排序</h3>
<blockquote>
<blockquote>
<p>3.1 如何实现冒泡排序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>冒泡排序，顾名思义就是整个过程就像气泡一样往上升，单向冒泡排序的基本思想是（假设由小到大排序）：对于给定的n个记录，从第一个记录开始依次对相邻的两个记录进行比较，当前面的记录大于后面的记录时，交换其位置，进行一轮比较和换位后，n个记录中的最大记录将位于第n位；然后对前（n-1）个记录进行第二轮比较；重复该过程直到进行比较的记录只剩下一个时为止。算法原理如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）比较相邻的元素，如果第一个比第二个大，那么就交换这两个元素。2）对每一对相邻元素做同样的工作，从第一对开始到最后一对结束，最后的元素应该会是最大的数。3）除了最后一个元素外，针对其他的元素重复以上的步骤。4）对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较为止。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>以数组array（36, 25, 48, 12, 25, 65, 43, 57）为例，具体排序过程如下：初始状态：[36 25 48 12 25 65 43 57]1趟排序：[25 36 12 25 48 43 57] 65]2趟排序：[25 12 25 36 43 48] 57 65]3趟排序：[12 25 25 36 43] 48 57 65]4趟排序：[12 25 25 36] 43 48 57 65]5趟排序：[12 25 25] 36 43 48 57 65]6趟排序：[12 25] 25 36 43 48 57 65]7趟排序：[12] 25 25 36 43 48 57 65]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>根据以上的实现原理，实现代码如下：[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>程序的运行结果为[插图]在传统的冒泡排序基础上，可以进一步改进冒泡排序算法，通过设置一个标志bool，用于记录每趟排序中最后一次交换的位置。由于bool标志之后的记录均已交换到位，因此下一趟排序时只要扫描到bool位置即可，不需要再对bool后的循环排序。改进后的冒泡排序算法2如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>因为传统冒泡排序中每一趟排序操作只能找到一个最大值或最小值，所以可以考虑在每趟排序中进行正向和反向两遍冒泡的方法，一次得到最大者和最小者，从而可使排序趟数将近减少一半。再次改进后的冒泡排序法3如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>以上介绍的冒泡排序法中，它们执行的效率：传统冒泡排序法＜改进后冒泡排序法2＜改进后冒泡排序法3。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：最佳情况：T（n）=O（n），当输入的数据为正序时，则是最佳情况。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>最差情况：T（n）=O（n2），当输入的数据是反序时，则是最差情况，需依次从头到尾重新排序。平均情况：T（n）=O（n2）。</p>
</blockquote>
</blockquote>
<h3 id="◆-3-2-如何实现插入排序" tabindex="-1"><a class="header-anchor" href="#◆-3-2-如何实现插入排序" aria-hidden="true">#</a> ◆ 3.2 如何实现插入排序</h3>
<blockquote>
<blockquote>
<p>3.2 如何实现插入排序难度系数：★★★☆☆被考查系数：★★★☆☆分析与解答：插入排序的基本思想：对于给定的一组记录，初始时假设第一个记录自成一个有序序列，其余的记录为无序序列。接着从第二个记录开始，按照记录的大小依次将当前处理的记录插入到其之前的有序序列中，直至最后一个记录插入到有序序列中为止。以数组array（38, 65, 97, 76, 13, 27, 49）为例，直接插入排序具体步骤如下：第一步插入38以后：[38] 65 97 76 13 27 49第二步插入65以后：[38 65] 97 76 13 27 49</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第三步插入97以后：[38 65 97] 76 13 27 49第四步插入76以后：[38 65 76 97] 13 27 49第五步插入13以后：[13 38 65 76 97] 27 49第六步插入27以后：[13 27 38 65 76 97] 49第七步插入49以后：[13 27 38 49 65 76 97]</p>
</blockquote>
</blockquote>
<h3 id="◆-3-3-如何实现归并排序" tabindex="-1"><a class="header-anchor" href="#◆-3-3-如何实现归并排序" aria-hidden="true">#</a> ◆ 3.3 如何实现归并排序</h3>
<blockquote>
<blockquote>
<p>3.3 如何实现归并排序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>归并排序是利用递归与分治技术将数据序列划分成越来越小的子表，再对子集排序，最后用递归方法将排好序的子表合并成为越来越大的有序序列。归并排序中，“归”代表的是递归的意思，即递归的将数组折半的分离为两个子数组，如数组：[2, 6, 1, 0]，会先折半，分为[2, 6]和[1, 0]两个子数组，然后再折半将数组分离，分为[2]、[6]、[1]和[0]。“并”就是将分开的数据按照从小到大或者从大到小的顺序再放到一个数组中。如上面的[2]和[6]合并到一个数组中是[2, 6]，[1]和[0]合并到一个数组中是[0, 1]，然后再将[2, 6]和[0, 1]合并到一个数组中即为[0, 1, 2, 6]。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>具体而言，归并排序算法的原理如下：对于给定的一组记录（假设共有n个记录），首先将数组一分为二，对于每个子数组采用同样的方法递归地划分为更小的数组，直到子数组的大小为1（大小为1的子数组是有序的）。接着需要把相邻的两个子数组进行归并（归并后的子数组还是有序的）为更大的数组，直到归并后的数组大小跟原数组相同时算法结束。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>所以，归并排序的关键就是两步：第一步，划分子表；第二步，合并半子表。以数组array（49,38,65, 97, 76, 13, 27）为例，排序过程如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）数组初始序列为：[24,13,26,1,2,27,38,15]2）第一趟划分子数组：[24,13,26,1]，[2,27,38,15]3）对子数组继续划分：[24,13]，[26,1]，[2,27]，[38,15]4）对子数组继续划分：[24]，[13]，[26]，[1]，[2]，[27]，[38]，[15]5）归并：[13,24]，[1，26]，[2,27]，[15，38]6）继续归并：[1，13，24,26]，[2,15,27,38]7）继续归并：[1，2，13，15，24, 26, 27,38]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>根据以上的实现原理，实现代码如下：[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>程序的运行结果为[插图]算法性能分析：最佳情况：T（n）=O（nlogn）。最差情况：T（n）=O（nlogn）。平均情况：T（n）=O（nlogn）。</p>
</blockquote>
</blockquote>
<h3 id="◆-3-4-如何实现快速排序" tabindex="-1"><a class="header-anchor" href="#◆-3-4-如何实现快速排序" aria-hidden="true">#</a> ◆ 3.4 如何实现快速排序</h3>
<blockquote>
<blockquote>
<p>3.4 如何实现快速排序难度系数：★★★★★被考查系数：★★★★☆分析与解答：快速排序是一种非常高效的排序算法，它采用“分而治之”的思想，把大的问题拆分为小的问题，小的问题再拆分为更小的问题。其原理如下：对于一组给定的记录，通过一趟排序后，将原序列分为两部分，其中前一部分的所有记录均比后一部分的所有记录小，然后再依次对前后两部分的记录进行快速排序，递归该过程，直到序列中的所有记录均有序为止。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>快速算法是通过分治递归来实现的，其效率在很大程度上取决于参考元素的选择，可以选择数组的中间元素，也可以随机得到三个元素，然后选择中间的那个元素（三数中值法）。另外还有一点，就是当分割时，如果分割出来的子序列的长度很小（小于20）的话，那么通常递归的排序效率就没有诸如插入排序或希尔排序那么快了。因此可以先判断数组的长度，如果小于10的话，那么直接用插入排序，而不是递归调用快速排序。算法性能分析：最佳情况：T（n）=O（nlog2n）。最差情况：T（n）=O（n2）。平均情况：T（n）=O（nlog2n）。</p>
</blockquote>
</blockquote>
<h3 id="◆-3-5-如何实现选择排序" tabindex="-1"><a class="header-anchor" href="#◆-3-5-如何实现选择排序" aria-hidden="true">#</a> ◆ 3.5 如何实现选择排序</h3>
<blockquote>
<blockquote>
<p>3.5 如何实现选择排序难度系数：★★★☆☆被考查系数：★★★☆☆分析与解答：选择排序是一种简单直观的排序算法，它的基本原理如下：对于给定的一组记录，经过第一轮比较后得到最小的记录，然后将该记录与第一个记录的位置进行交换；接着对不包括第一个记录以外的其他记录进行第二轮比较，得到最小的记录并与第二个记录进行位置交换；重复该过程，直到进行比较的记录只有一个时为止。算法原理如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>每一趟在n-i+1（i=1,2,…,n-1）个记录中选择关键字最小的记录作为有序序列中第i个记录，其中最便捷的是简单选择排序，其过程如下：通过n-i 次关键字间的比较，从（n-i+1）个记录中选择出关键字最小的记录，并与第i个记录交换位置。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>以数组array（38, 65, 97, 76, 13, 27, 49）为例，具体步骤如下：第一趟排序后：13 [65 97 76 38 27 49]第二趟排序后：13 27 [97 76 38 65 49]第三趟排序后：13 27 38 [76 97 65 49]第四趟排序后：13 27 38 49 [97 65 76]第五趟排序后：13 27 38 49 65 [97 76]第六趟排序后：13 27 38 49 65 76 [97]最后排序结果：13 27 38 49 65 76 97</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>选择排序、快速排序、希尔排序和堆排序都不是稳定的排序算法，而冒泡排序、插入排序和归并排序都是稳定的排序算法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>引申：请简单描述顺序查找和二分查找（也称为折半查找）算法。顺序查找是在一个已知无（或有）序队列中找出与给定关键字相同的数的具体位置。原理是让关键字与队列中的数从最后一个开始逐个比较，直到找出与给定关键字相同的数为止，它的缺点是效率低。二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是折半查找要求线性表必须采用顺序存储结构，而且表中元素要按关键字有序排列。实现代码如下：</p>
</blockquote>
</blockquote>
<h3 id="◆-3-7-如何实现堆排序" tabindex="-1"><a class="header-anchor" href="#◆-3-7-如何实现堆排序" aria-hidden="true">#</a> ◆ 3.7 如何实现堆排序</h3>
<blockquote>
<blockquote>
<p>3.7 如何实现堆排序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>堆是一种特殊的树形数据结构，其每个结点都有一个值，通常提到的堆都是指一棵完全二叉树，根结点的值小于（或大于）两个子结点的值。同时，根结点的两棵子树也分别是一个堆。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>堆排序是一种树形选择排序，在排序过程中，将R[1…n]看成是一棵完全二叉树的顺序存储结构，利用完全二叉树中双亲结点和孩子结点之间的内在关系来选择最小的元素。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>堆一般分为大顶堆和小顶堆两种。如果根结点的关键字既大于或等于左子树的关键字值，又大于或等于右子树的关键字值，那么这个堆被称之为大顶堆。此时，堆顶元素必为最大值。如果根结点的关键字既小于或等于左子树的关键字值，又小于或等于右子树的关键字值，那么这个堆被称之为小顶堆。此时，堆顶元素必为最小值。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>堆排序的思想是对于给定的n个记录，初始时把这些记录看作一棵顺序存储的二叉树，然后将其调整为一个大顶堆，再将堆的最后一个元素与堆顶元素（即二叉树的根结点）进行交换后，堆的最后一个元素即为最大记录；接着将前（n-1）个元素（即不包括最大记录）重新调整为一个大顶堆，再将堆顶元素与当前堆的最后一个元素进行交换后得到次大的记录，重复该过程直到调整的堆中只剩一个元素时为止，该元素即为最小记录，此时可得到一个有序序列。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>堆排序主要包括两个过程：一是构建堆；二是交换堆顶元素与最后一个元素的位置。算法原理如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）将初始待排关键字序列R[1…n]构建成大顶堆，此堆为初始的无序区；</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区R[1…n-1]和新的有序区R[n],且满足R[1…n-1]≤R[n]；</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）由于交换后新的堆顶R[1]可能违反大顶堆的性质，因此需要对当前无序区R[1…n-1]调整为大顶堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区R[1…n-2]和新的有序区R[n-1,n-1]。不断重复此过程直到有序区的元素个数为（n-1），则整个排序过程完成。</p>
</blockquote>
</blockquote>
<h3 id="◆-3-8-如何实现计数排序" tabindex="-1"><a class="header-anchor" href="#◆-3-8-如何实现计数排序" aria-hidden="true">#</a> ◆ 3.8 如何实现计数排序</h3>
<blockquote>
<blockquote>
<p>3.8 如何实现计数排序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计数排序（Counting sort）是一种稳定的排序算法。计数排序需要使用一个额外的数组countArr，其中第i个元素是待排序数组arr中值等于i的元素个数。然后根据数组countArr将arr中的元素排到正确的位置。注意，它只能对整数进行排序。算法原理如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）找出待排序的数组中最大和最小的元素；2）统计数组中每个值为i的元素出现的次数，存入数组countArr的第i项，countArr[i]表示数组中等于i的元素出现的次数；</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）从待排序列arr的第一个元素开始，将arr[i]放到正确的位置，即前面有几个元素小于等于它，它就放在第几个位置。</p>
</blockquote>
</blockquote>
<h3 id="◆-3-9-如何实现桶排序" tabindex="-1"><a class="header-anchor" href="#◆-3-9-如何实现桶排序" aria-hidden="true">#</a> ◆ 3.9 如何实现桶排序</h3>
<blockquote>
<blockquote>
<p>3.9 如何实现桶排序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>桶排序（Bucket sort）的工作原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序，有可能再使用别的排序算法或是以递归方式继续使用桶排序。算法原理如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）设置一个定量的数组当作空桶；2）遍历输入数据，并且把数据一个个放到对应的桶里去；</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）对每个非空的桶进行排序；4）从非空的桶里把排好序的数据合并起来。</p>
</blockquote>
</blockquote>
<h2 id="◆-第4章-链表" tabindex="-1"><a class="header-anchor" href="#◆-第4章-链表" aria-hidden="true">#</a> ◆ 第4章 链表</h2>
<blockquote>
<blockquote>
<p>它的存储特点为：可以用任意一组存储单元来存储单链表中的数据元素（存储单元可以是不连续的），而且除了存储每个数据元素ai外，还必须存储指示其直接后继元素的信息。这两部分信息组成的数据元素ai的存储映像称为结点。N个结点链在一起被称为链表。如果结点只包含其后继结点的信息，这样的链表就被称为单链表，而链表的第一个结点通常被称为头结点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>单链表又可以将其分为有头结点的单链表和无头结点的单链表，如下图所示。[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在单链表的开始结点之前附设一个类型相同的结点，称之为头结点，头结点的数据域可以不存储任何信息（也可以存放如线性表的长度等附加信息），头结点的指针域存储指向开始结点的指针（即第一个元素结点的存储位置）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>具体而言，头结点的作用主要有以下两点：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）对于带头结点的链表，当在链表的任何结点之前插入新结点或删除链表中任何结点时，所要做的都是修改前一个结点的指针域，因为任何结点都有前驱结点。若链表没有头结点，则首元素结点没有前驱结点，在其前面插入结点或删除该结点时操作会复杂些，需要进行特殊的处理。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）对于带头结点的链表，链表的头指针是指向头结点的非空指针，因此对空链表与非空链表的处理是一样的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由于头结点有诸多的优点，因此本章中所介绍的算法都使用了带头结点的单链表。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如下是一个单链表数据结构的定义示例：[插图]</p>
</blockquote>
</blockquote>
<h3 id="◆-4-1-如何实现链表的逆序" tabindex="-1"><a class="header-anchor" href="#◆-4-1-如何实现链表的逆序" aria-hidden="true">#</a> ◆ 4.1 如何实现链表的逆序</h3>
<blockquote>
<blockquote>
<p>4.1 如何实现链表的逆序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：给定一个带头结点的单链表，请将其逆序。即如果单链表原来为head→1→2→3→4→5→6→7，逆序后变为head→7→6→5→4→3→2→1。分析与解答：由于单链表分数组不同，单链表中每个结点的地址都存储在其前驱结点的指针域中，因此，对单链表中任意一个结点的访问只能从链表的头指针开始遍历。在对链表的操作过程中，需要特别注意在修改结点指针域的时候，记录下后继结点的地址，否则会丢失后继结点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：就地逆序法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>假定原链表为1→2→3→4→5→6→7，就地逆序法的主要思路：先逆序除第一个结点以外的子链表（将1→2→3→4→5→6→7变为1→7→6→5→4→3→2），接着把结点1添加到逆序的子链表的后面（1→2→3→4→5→6→7变为7→6→5→4→3→2→1）。这个方法的缺点是改变了链表原来的结构。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如下是以单链表数据结构定义的就地逆序法示例：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：以上这种方法只需要对链表进行一次遍历，因此，时间复杂度为O（n）。其中，n 为链表的长度。但是需要常数个额外的变量来保存当前结点的前驱结点与后继结点，因此，空间复杂度为O（1）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：递归法假定原链表为1→2→3→4→5→6→7，递归法的主要思路为：先逆序除第一个结点以外的子链表（将1→2→3→4→5→6→7变为1→7→6→5→4→3→2），接着把结点1添加到逆序的子链表的后面（1→2→3→4→5→6→7变为7→6→5→4→3→2→1）。同理，在逆序链表2→3→4→5→6→7时，也是先逆序子链表3→4→5→6→7（逆序为2→7→6→5→4→3），接着实现链表的整体逆序（2→7→6→5→4→3转换为7→6→5→4→3→2）。实现代码如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：递归法也只需要对链表进行一次遍历，因此，算法复杂度也为O（n）。其中，n 为链表的长度。递归法的主要优点是：算法的思路比较直观，容易理解，而且也不需要保存前驱结点的地址；缺点是：算法实现的难度较大。此外，由于递归法需要不断地调用自己，需要额外的压栈与弹栈操作，因此，与方法一相比性能会有所下降。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法三：插入法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>插入法的主要思路：从链表的第二个结点开始，把遍历到的结点插入到头结点的后面，直到遍历结束。假定原链表为head→1→2→3→4→5→6→7，在遍历到2时，将其插入到头结点后，链表变为head→2→1→3→4→5→6→7，同理将后序遍历到的所有结点都插入到头结点head后，就可以实现链表的逆序。实现代码如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：以上这种方法也只需要对单链表进行一次遍历，因此，时间复杂度为O（n）。其中，n 为链表的长度。与方法一相比，这种方法不需要保存前驱结点的地址，与方法二相比，这种方法不需要递归的调用，效率更高。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-2-如何从无序链表中移除重复项" tabindex="-1"><a class="header-anchor" href="#◆-4-2-如何从无序链表中移除重复项" aria-hidden="true">#</a> ◆ 4.2 如何从无序链表中移除重复项</h3>
<blockquote>
<blockquote>
<p>4.2 如何从无序链表中移除重复项</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>给定一个没有排序的链表，去掉其重复项，并保留原顺序，如链表1→3→1→5→5→7，去掉重复项后变为1→3→5→7。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：方法一：顺序删除主要思路为：通过双重循环直接在链表上执行删除操作。外层循环用一个指针从第一个结点开始遍历整个链表，然后内层循环用另外一个指针遍历其余结点，将与外层循环遍历到的指针所指结点的数据域相同的结点删除。如下图所示。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>假设外层循环从outerCur 开始遍历，当内层循环指针innerCur 遍历到上图虚线所框的位置（outerCur→data=innerCur→data）时，此时需要把innerCur指向的结点删除。具体步骤如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）用tmp记录待删除的结点的地址。2）为了能够在删除tmp结点后继续遍历链表中其余的结点，使innerCur指针指向它的后继结点：innerCur=innerCur→next。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）从链表中删除tmp结点。4）释放tmp结点所占的内存空间。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：由于这个算法采用双重循环对链表进行遍历，因此，时间复杂度为O（n2）。其中，n为链表的长度。在遍历链表的过程中，使用了常量个额外的指针变量来保存当前遍历的结点、前驱结点和被删除的结点，因此，空间复杂度为O（1）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：递归法主要思路为：对于结点cur，首先递归地删除以cur→next为首的子链表中重复的结点，接着从以cur→next为首的子链表中找出与cur有着相同数据域的结点并删除。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法三：空间换时间</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通常情况下，为了降低时间复杂度，往往在条件允许的情况下，通过使用辅助空间实现。具体而言，主要思路如下。1）建立一个数组，数组中的内容为已经遍历过的结点内容，并将其初始化为空。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）从头开始遍历链表中的所有结点，存在以下两种可能性：① 如果结点内容已经在数组中，则删除此结点，继续向后遍历。② 如果结点内容不在数组中，则保留此结点，将此结点内容添加到数组中，继续向后遍历。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>引申：如何从有序链表中移除重复项。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：上述介绍的方法也适用于链表有序的情况，但是由于以上方法没有充分利用到链表有序这个条件，因此，算法的性能肯定不是最优的。本题中，由于链表具有有序性，因此，不需要对链表进行两次遍历。所以，有如下思路：用cur 指向链表第一个结点，此时需要分为以下两种情况讨论。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）如果cur→data=cur→next→data，那么删除cur→next结点。2）如果cur→data!=cur→next→data，那么cur=cur→next，继续遍历其余结点。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-3-如何计算两个单链表所代表的数之和" tabindex="-1"><a class="header-anchor" href="#◆-4-3-如何计算两个单链表所代表的数之和" aria-hidden="true">#</a> ◆ 4.3 如何计算两个单链表所代表的数之和</h3>
<blockquote>
<blockquote>
<p>4.3 如何计算两个单链表所代表的数之和</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：给定两个单链表，链表的每个结点代表一位数，计算两个数的和。例如，输入链表（3→1→5）和链表（5→9→2），输出：8→0→8，即513+295=808，注意个位数在链表头。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：整数相加法主要思路为：分别遍历两个链表，求出两个链表所代表的整数的值，然后把这两个整数进行相加，最后把它们的和用链表的形式表示出来。这种方法的优点是计算简单。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-4-如何对链表进行重新排序" tabindex="-1"><a class="header-anchor" href="#◆-4-4-如何对链表进行重新排序" aria-hidden="true">#</a> ◆ 4.4 如何对链表进行重新排序</h3>
<blockquote>
<blockquote>
<p>4.4 如何对链表进行重新排序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>给定链表L0→L1→L2→…→Ln-1→Ln，把链表重新排序为L0→Ln→L1→Ln-1→L2→Ln-2→…。要求：①在原来链表的基础上进行排序，即不能申请新的结点；②只能修改结点的next域，不能修改数据域。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>主要思路为：1）首先找到链表的中间结点。2）对链表的后半部分子链表进行逆序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）把链表的前半部分子链表与逆序后的后半部分子链表进行合并，合并的思路为：分别从两个链表各取一个结点进行合并。实现方法如下图所示（以自然数数组1～7为例）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：查找链表的中间结点的方法的时间复杂度为O（n），逆序子链表的时间复杂度也为O（n），合并两个子链表的时间复杂度也为O（n）。因此，整个方法的时间复杂度为O（n），其中，n表示的是链表的长度。由于这个方法只用了常数个额外指针变量，因此，空间复杂度为O（1）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>引申：如何查找链表的中间结点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：主要思路为：用两个指针从链表的第一个结点开始同时遍历结点，一个快指针每次走两步，另外一个慢指针每次走一步；当快指针先到链表尾部时，慢指针则恰好到达链表中部。快指针到链表尾部时，如果链表长度为奇数，那么慢指针指向的即是链表中间指针；如果链表长度为偶数，那么慢指针指向的结点和该结点的下一个结点都是链表的中间结点。在上面的代码中，FindMiddleNode（）就是用来求取链表中间结点的方法。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-5-如何找出单链表中的倒数第k个元素" tabindex="-1"><a class="header-anchor" href="#◆-4-5-如何找出单链表中的倒数第k个元素" aria-hidden="true">#</a> ◆ 4.5 如何找出单链表中的倒数第k个元素</h3>
<blockquote>
<blockquote>
<p>4.5 如何找出单链表中的倒数第k个元素</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>找出单链表中的倒数第k个元素，如给定单链表：1→2→3→4→5→6→7，则单链表的倒数第3（即k=3）个元素为5。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：方法一：顺序遍历两遍法主要思路为：首先遍历一遍单链表，求出整个单链表的长度n，然后把求倒数第k 个元素转换为求顺数第n-k个元素，再去遍历一次单链表就可以得到结果。但是该方法需要对单链表进行两次遍历。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：快慢指针法由于单链表只能从头到尾依次访问链表的各个结点，所以，如果要找单链表的倒数第k个元素，也只能从头到尾进行遍历查找。在查找过程中，设置两个指针，让其中一个指针比另外一个指针先前移k步，然后两个指针同时往前移动。循环直到先行的指针值为NULL时，另外一个指针所指的位置就是所要找的位置。实现代码如下。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：这种方法只需要对链表进行一次遍历，因此，时间复杂度为O（n）。另外，由于只需要常量个指针变量来保存结点的地址信息，因此，空间复杂度为O（1）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>引申：如何将单链表向右旋转k个位置。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：给定单链表1→2→3→4→5→6→7，k=3，那么旋转后的单链表变为5→6→7→1→2→3→4。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：主要思路为：①首先找到链表倒数第k+1个结点slow和尾结点fast（如下图所示）；②把链表断开为两个子链表，其中后半部分子链表结点的个数为k；③使原链表的尾结点指向链表的第一个结点；④使链表的头结点指向原链表倒数第k个结点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>[插图]</p>
</blockquote>
</blockquote>
<h3 id="◆-4-6-如何检测一个较大的单链表是否有环" tabindex="-1"><a class="header-anchor" href="#◆-4-6-如何检测一个较大的单链表是否有环" aria-hidden="true">#</a> ◆ 4.6 如何检测一个较大的单链表是否有环</h3>
<blockquote>
<blockquote>
<p>4.6 如何检测一个较大的单链表是否有环</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：单链表有环指的是单链表中某个结点的next指针域指向链表中在它之前的某一个结点，这样在链表的尾部形成一个环形结构。如何判断单链表是否有环存在？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：方法：快慢指针遍历法定义两个指针fast（快）与slow（慢），两者的初始值都指向链表头，指针slow每次前进一步，指针fast 每次前进两步。两个指针同时向前移动，快指针每移动一次都要跟慢指针比较，如果快指针等于慢指针，就证明这个链表是带环的单向链表，否则证明这个链表是不带环的循环链表。实现代码见下面引申部分。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-7-如何把链表相邻元素翻转" tabindex="-1"><a class="header-anchor" href="#◆-4-7-如何把链表相邻元素翻转" aria-hidden="true">#</a> ◆ 4.7 如何把链表相邻元素翻转</h3>
<blockquote>
<blockquote>
<p>4.7 如何把链表相邻元素翻转</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：把链表相邻元素翻转，如给定链表为1→2→3→4→5→6→7，则翻转后的链表变为2→1→4→3→6→5→7。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：方法一：交换值法最容易想到的方法就是交换相邻两个结点的数据域，这种方法由于不需要重新调整链表的结构，因此比较容易实现，但是这种方法并不是考官所期望的解法。方法二：就地逆序主要思路为：通过调整结点指针域的指向来直接调换相邻的两个结点。如果单链表恰好有偶数个结点，那么只需要将奇偶结点对调，如果链表有奇数个结点，那么除最后一结点外的其他结点进行奇偶对调。为了便于理解，下图给出了其中第一对结点对调的方法。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-8-如何把链表以k个结点为一组进行翻转" tabindex="-1"><a class="header-anchor" href="#◆-4-8-如何把链表以k个结点为一组进行翻转" aria-hidden="true">#</a> ◆ 4.8 如何把链表以K个结点为一组进行翻转</h3>
<blockquote>
<blockquote>
<p>4.8 如何把链表以K个结点为一组进行翻转</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：K链表翻转是指把每K个相邻的结点看成一组进行翻转，如果剩余结点不足K个，则保持不变。假设给定链表1→2→3→4→5→6→7和一个数K，如果K的值为2，那么翻转后的链表为2→1→4→3→6→5→7。如果K的值为3，那么翻转后的链表为：3→2→1→6→5→4→7。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：主要思路为：首先把前K个结点看成一个子链表，采用前面介绍的方法进行翻转，把翻转后的子链表链接到头结点后面，然后把接下来的K个结点看成另外一个单独的链表进行翻转，把翻转后的子链表链接到上一个已经完成翻转子链表的后面。具体实现方法如下图所示。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-9-如何合并两个有序链表" tabindex="-1"><a class="header-anchor" href="#◆-4-9-如何合并两个有序链表" aria-hidden="true">#</a> ◆ 4.9 如何合并两个有序链表</h3>
<blockquote>
<blockquote>
<p>4.9 如何合并两个有序链表</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：已知两个链表head1和head2各自有序（如升序排列），请把它们合并成一个链表，要求合并后的链表依然有序。</p>
</blockquote>
</blockquote>
<h3 id="◆-5-1-如何实现栈" tabindex="-1"><a class="header-anchor" href="#◆-5-1-如何实现栈" aria-hidden="true">#</a> ◆ 5.1 如何实现栈</h3>
<blockquote>
<blockquote>
<p>方法一：数组实现在采用PHP数组来实现栈的时候，可以先创建一个空数组作为栈，在后期使用过程中每当向数组压入一个元素，数组的容量是可以自动扩容的。实现思路如下图所示。</p>
</blockquote>
</blockquote>
<h3 id="◆-5-3-如何翻转栈的所有元素" tabindex="-1"><a class="header-anchor" href="#◆-5-3-如何翻转栈的所有元素" aria-hidden="true">#</a> ◆ 5.3 如何翻转栈的所有元素</h3>
<blockquote>
<blockquote>
<p>在上图中，对于栈（1, 2, 3, 4, 5），进行翻转的操作：首先把栈底元素移动到栈顶得到栈（5, 1, 2, 3, 4），然后对不包含栈顶元素的子栈进行递归调用（对子栈元素进行翻转），子栈（1, 2, 3, 4）翻转的结果为（4, 3, 2, 1），因此，最终得到翻转后的栈为（5, 4, 3, 2, 1）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>此外，由于栈的后进先出的特点，使得只能取栈顶的元素，因此，要把栈底的元素移动到栈顶也需要递归调用才能完成。主要思路：把不包含该栈顶元素的子栈的栈底的元素移动到子栈的栈顶，然后把栈顶的元素与子栈栈顶的元素（其实就是与栈顶相邻的元素）进行交换。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>为了容易理解递归调用，可以认为在进行递归调用时，子栈已经实现了把栈底元素移动到了栈顶。在上图中为了把栈（1, 2,3, 4, 5）的栈底元素5移动到栈顶，首先对子栈（2, 3, 4,5），进行递归调用，调用的结果为（5, 2, 3, 4），然后对子栈顶元素5，与栈顶元素1进行交换得到栈（5, 1, 2, 3, 4），实现了把栈底元素移动到了栈顶。</p>
</blockquote>
</blockquote>
<h2 id="◆-第6章-二叉树" tabindex="-1"><a class="header-anchor" href="#◆-第6章-二叉树" aria-hidden="true">#</a> ◆ 第6章 二叉树</h2>
<blockquote>
<blockquote>
<p>6.1 二叉树基础知识</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>二叉树（Binary Tree）也称为二分树、二元树、对分树等，它是n（n≥0）个有限元素的集合，该集合或者为空，或者由一个称为根（root）的元素及两个不相交的、被分别称为左子树和右子树的二叉树组成。当集合为空时，称该二叉树为空二叉树。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在二叉树中，一个元素也称作一个结点。二叉树的递归定义为：二叉树或者是一棵空树，或者是一棵由一个根结点和两棵互不相交的分别称作根结点的左子树和右子树所组成的非空树，左子树和右子树又同样都是一棵二叉树。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>以下是二叉树的一些常见的基本概念：1）结点的度：结点所拥有的子树的个数称为该结点的度。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）叶结点：度为0的结点称为叶结点，或者称为终端结点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）分支结点：度不为0的结点称为分支结点，或者称为非终端结点。一棵树的结点除叶结点外，其余的都是分支结点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4）左孩子、右孩子、双亲：树中一个结点的子树的根结点称为这个结点的孩子。这个结点称为它孩子结点的双亲。具有同一个双亲的孩子结点互称为兄弟。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5）路径、路径长度：如果一棵树的一串结点n1,n2,…,nk有如下关系：结点ni是ni+1的父结点（1≤i＜k），就把n1,n2,…,nk称为一条由n1～nk的路径。这条路径的长度是k-1。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>6）祖先、子孙：在树中，如果有一条路径从结点M到结点N，那么M就称为N的祖先，而N称为M的子孙。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>7）结点的层数：规定树的根结点的层数为1，其余结点的层数等于它的双亲结点的层数加1。8）树的深度：树中所有结点的最大层数称为树的深度。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>9）树的度：树中各结点度的最大值称为该树的度，叶子结点的度为0。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>10）满二叉树：在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子结点都在同一层上，这样的一棵二叉树称作满二叉树。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>11）完全二叉树：一棵深度为k的有n个结点的二叉树，对树中的结点按从上至下、从左到右的顺序进行编号，如果编号为i（1≤i≤n）的结点与满二叉树中编号为i的结点在二叉树中的位置相同，则这棵二叉树称为完全二叉树。完全二叉树的特点：叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。需要注意的是，满二叉树肯定是完全二叉树，而完全二叉树不一定是满二叉树。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>二叉树的基本性质如下：性质1：一棵非空二叉树的第i层上最多有2i-1个结点（i≥1）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>性质2：一棵深度为k的二叉树中，最多具有2k-1个结点，最少有k个结点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>性质3：对于一棵非空的二叉树，度为0的结点（即叶子结点）总是比度为2的结点多一个，即如果叶子结点数为n0，度数为2的结点数为n2，则有n0=n2+1。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>证明：用n0表示度为0（叶子结点）的结点总数，用n1表示度为1的结点总数，n2表示度为2的结点总数，n表示整个完全二叉树的结点总数。则n=n0+n1+n2，根据二叉树和树的性质，可知n=n1+2×n2+1 （所有结点的度数之和+1=结点总数），根据两个等式可知n0+n1+n2=n1+2×n2+1，所以，n2=n0-1，即n0=n2+1。所以，答案为1。性质4：具有n个结点的完全二叉树的深度为‘log2n’+1。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>例题1：一棵完全二叉树上有1001个结点，其中叶子结点的个数是多少？分析：二叉树的公式：n=n0+n1+n2=n0+n1+（n0-1）=2×n0+n1-1。而在完全二叉树中，n1只能取0或1。若n1=1，则2×n0=1001，可推出n0为小数，不符合题意；若n1=0，则2×n0-1=1001，则n0=501。所以，答案为501。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>例题2：如果根的层次为1，具有61个结点的完全二叉树的高度为多少？分析：根据二叉树的性质，具有n个结点的完全二叉树的深度为□□log2n□□+1，因此，含有61个结点的完全二叉树的高度为6层。所以，答案为6。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>例题3：在具有100个结点的树中，其边的数目为多少？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析：在一棵树中，除了根结点之外，每一个结点都有一条入边，因此，总边数应该是100-1，即99条。所以，答案为99。</p>
</blockquote>
</blockquote>
<h2 id="◆-第7章-数组" tabindex="-1"><a class="header-anchor" href="#◆-第7章-数组" aria-hidden="true">#</a> ◆ 第7章 数组</h2>
<blockquote>
<blockquote>
<p>数组是由某种类型的数据按照一定的顺序组成的数据的集合。如果将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。用于区分数组的各个元素的数字编号称为下标。</p>
</blockquote>
</blockquote>
<h3 id="◆-7-1-如何找出数组中唯一的重复元素" tabindex="-1"><a class="header-anchor" href="#◆-7-1-如何找出数组中唯一的重复元素" aria-hidden="true">#</a> ◆ 7.1 如何找出数组中唯一的重复元素</h3>
<blockquote>
<blockquote>
<p>7.1 如何找出数组中唯一的重复元素</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>数字1～1000放在含有1001个元素的数组中，其中只有唯一的一个元素值重复，其他数字均只出现一次。设计一个算法，将数组中重复元素找出来，要求每个数组元素只能访问一次。如果不使用辅助存储空间，能否设计一个算法实现？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>拿到题目，首先需要做的就是分析题目所要达到的目标及其中的限定条件。从题目的描述可以发现，本题的目标就是在一个有且仅有一个元素值重复的数组中找出这个唯一的重复元素，而限定条件就是每个数组元素只能访问一次，并且不许使用辅助存储空间。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：空间换时间法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>申请一个额外的数组用来存储每个数出现的次数，并把数组中所有元素初始化为0（假设数组为newArr，那么newArr[i]用来存储数字i+1出现的次数），显然重复元素就是出现次数大于0的元素。实现代码如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>上述方法是一种典型的以空间换时间的方法，它的时间复杂度为O（n），空间复杂度为O（n）。很显然，在题目没有明确限制的情况下，上述方法不失为一种好方法，但是由于题目要求不能用额外的辅助空间，所以上述方法不可取，是否存在其他满足题意的方法呢？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：累加求和法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机技术与数学本身是一家，抛开计算机专业知识，上述问题其实可以转换成一个数学问题。数学问题的目标是在一个数字序列中寻找重复的那个数。根据题目意思可以看出，1～1000个数中，除了唯一一个数重复以外，其他各数有且仅有出现一次，由数学性质可知，这1001个数包括1～1000中的每一个数各1次，外加1～1000中某一个数。很显然，1001个数中有1000个数是固定的，唯一一个不固定的数也知道其范围（1～1000中某一个数），那么最容易想到的方法就是累加求和法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>所谓累加求和法，指的是将数组中的所有N+1（此处N的值取1000）个元素相加，然后用得到的和减去1+2+3+…+N（此处N的值为1000）的和，得到的差即为重复的元素的值。这一点不难证明。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>上述方法的时间复杂度为O（n），空间复杂度为O（1）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在使用求和法计算时，需要注意一个问题，即当数据量巨大时，有可能会导致计算结果溢出。以本题为例，1～1000范围内的1000个数累加，其和为（1+1000）×1000/2，即500500，普通的int型变量能够表示出来，所以，本题中不存在此问题。但如果累加的数值巨大时，就很有可能溢出了。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：上述方法的时间复杂度为O（n），并且没有申请辅助的存储空间。方法四：数据映射法数组取值操作可以看作一个特殊的函数f:D→R，定义域为下标值0～1000，值域为1～1000。如果对任意一个数i，把f（i）叫作它的后继，i叫作f（i）的前驱。0只有后继，没有前驱，其他数字既有后继也有前驱，重复的那个数字有两个前驱。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>采用此种方法，可以发现一个规律，即从0开始画一个箭头指向它的后继，从它的后继继续指向后继的后继，这样，必然会有一个结点指向之前已经出现过的数，即为重复的数。利用下标与单元中所存储的内容之间的特殊关系进行遍历，一旦访问过该单元就赋予它一个标记（把数组中的元素变为它的相反数），再利用标记作为发现重复数字的关键。以数组array=[1, 3, 4, 3, 5, 2 ]为例。从下标0开始遍历数组：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）array[0]的值为1，说明没有被遍历过，接下来遍历下标为1的元素，同时标记已遍历过的元素（变为相反数）：array=[-1, 3, 4, 3, 5, 2 ];2）array[1]的值为3，说明没被遍历过，接下来遍历下标为3的元素，同时标记已遍历过的元素：array=[-1,-3, 4, 3, 5, 2 ];3）array[3]的值为3，说明没被遍历过，接下来遍历下标为3的元素，同时标记已遍历过的元素：array=[-1,-3, 4,-3, 5, 2 ];4）array[3]的值为-3，说明3已经被遍历过了，即找到了重复的元素。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>每个数在数组中都有自己的位置，如果一个数是在自己应该在的位置（在本题中它的值就是它的下标，即所在的位置），那永远不会对它进行调换，也就是不会访问到它，除非它就是那个多出的数，那与它相同的数访问到它的时候便就是结果了；如果一个数所在的位置不是它应该待的地方，那它会去找它应该在的位置，在它位置的数也应该去找它应该在的位置，碰到了负数，也就是说已经出现了这个数，所以就得出结果了。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：上述方法的时间复杂度为O（n），并且没有申请辅助的存储空间。这个方法的缺点是修改了数组中元素的值，当然也可以在找到重复元素之后对数组进行一次遍历，把数组中的元素改为它的绝对值，以此来恢复对数组的修改。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法五：环形相遇法这个方法采用类似于判断单链表是否存在环的方法来求解问题。“判断单链表是否存在环”是一个非常经典的问题，同时单链表可以采用数组实现，此时可以把每个元素值作为next指针指向下一个元素。本题可以转化为“已知一个单链表中存在环，找出环的入口点”。具体思路：将array[i]看作第i个元素的索引，即array[i]-＞array[array[i]]-＞array[array[array[i]]]-＞array[array[array[array[i]]]]-＞…最终形成一个单链表，由于数组a中存在重复元素，则一定存在一个环，且环的入口元素即为重复元素。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>该题的关键在于，数组array的大小是n，而元素的范围是[1,n-1]，所以array[0]不会指向自己，进而不会陷入错误的自循环。如果元素的范围中包含0，则该题不可直接采用该方法。以数组序列[1, 3, 4, 2, 5, 3 ]为例。按照上述规则，这个数组序列对应的单链表如下图所示。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>从上图可以看出这个链表有环，且环的入口点为3，所以，这个数组中重复元素为3。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在实现时可以参考求单链表环的入口点的算法：用两个速度不同的变量slow和fast来访问，其中slow 每次前进一步，fast 每次前进两步。在有环结构中，它们总会相遇。接着从数组首元素与相遇点开始分别遍历，每次各走一步，它们必定相遇，且相遇第一点为环入口点。</p>
</blockquote>
</blockquote>
<h3 id="◆-7-2-如何查找数组中元素的最大值和最小值" tabindex="-1"><a class="header-anchor" href="#◆-7-2-如何查找数组中元素的最大值和最小值" aria-hidden="true">#</a> ◆ 7.2 如何查找数组中元素的最大值和最小值</h3>
<blockquote>
<blockquote>
<p>7.2 如何查找数组中元素的最大值和最小值</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>给定数组a1, a2, a3, …, an，要求找出数组中的最大值和最小值。假设数组中的值两两各不相同（以自然数数组[1, 2, 3, 4, 5, 6, 7, 8, 9]为例）。</p>
</blockquote>
</blockquote>
<h3 id="◆-7-4-如何找出数组中丢失的数" tabindex="-1"><a class="header-anchor" href="#◆-7-4-如何找出数组中丢失的数" aria-hidden="true">#</a> ◆ 7.4 如何找出数组中丢失的数</h3>
<blockquote>
<blockquote>
<p>方法二：异或法在解决这个问题前，首先回顾一下异或运算的性质。简单地说，在进行异或运算时，当参与运算的两个数相同时，异或结果为假，当参与异或运算的两个数不相同时，异或结果为真。</p>
</blockquote>
</blockquote>
<h3 id="◆-7-14-如何对数组进行循环移位" tabindex="-1"><a class="header-anchor" href="#◆-7-14-如何对数组进行循环移位" aria-hidden="true">#</a> ◆ 7.14 如何对数组进行循环移位</h3>
<blockquote>
<blockquote>
<p>7.14 如何对数组进行循环移位</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：蛮力法蛮力法也是最简单的方法，题目中需要将数组元素循环右移K位，只需要每次将数组中的元素右移一位，循环K次即可。例如，假设原数组为abcd1234，那么按照此种方式，具体移动过程：abcd1234→4abcd123→34abcd12→234abcd1→1234abcd。此种方法也很容易写出代码。以数组[1, 2, 3, 4, 5, 6, 7, 8]为例，实现代码如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>以上方法虽然可以实现数组的循环右移，但是由于每移动一次，其时间复杂度就为O（n）。所以，移动K次，其总的时间复杂度为O（K×n），0＜K＜n，与题目要求的O（n）不符合，需要继续往下探索。对于上述代码，需要考虑到，K不一定小于n，有可能等于n，也有可能大于n。当K＞n时，右移K-n之后的数组序列跟右移K位的结果一样；当K＞n时，右移K位与右移K'（其中K'=K%n）位等价，根据以上分析，相对完备的代码如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：上例中，算法的时间复杂度为O（n2），与K值无关，但时间复杂度仍然太高，是否还有其他更好的方法呢？仔细分析上面的方法，不难发现，上述方法的移动采取的是一步步移动的方式，由于题目中已经告知了需要移动的位数为K，为什么不能一步到位呢？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通常情况下，以空间换时间往往能够降低时间复杂度，本题也不例外。首先定义一个辅助数组T，把数组A的第n-K+1到n位数组中的元素存储到辅助数组T中，然后再把数组A中的第1到n-K位数组元素存储到辅助数组T中，然后将数组T中的元素复制回数组A，这样就完成了数组的循环右移，此时的时间复杂度为O（n）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法三：翻转法把数组看成由两段组成的，记为XY。左旋转相当于要把数组XY变成YX。先在数组上定义一种翻转的操作，就是翻转数组中数字的先后顺序。把X翻转后记为XT。显然有（XT）T=X。首先对X和Y两段分别进行翻转操作，这样就能得到XTYT。接着再对XTYT进行翻转操作，得到（XTYT）T=（YT）T（XT）T=YX。正好是期待的结果。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法性能分析：这个算法的时间复杂度为O（n）。主要是完成翻转（逆序）操作，并且只用了一个辅助空间。引申：上述问题中K不一定为正整数，有可能为负整数。当K为负整数时，右移K位，可以理解为左移（-K）位，所以，此时可以将其转换为能够求解的情况。</p>
</blockquote>
</blockquote>
<h3 id="◆-7-15-如何在有规律的二维数组中进行高效的数据查找" tabindex="-1"><a class="header-anchor" href="#◆-7-15-如何在有规律的二维数组中进行高效的数据查找" aria-hidden="true">#</a> ◆ 7.15 如何在有规律的二维数组中进行高效的数据查找</h3>
<blockquote>
<blockquote>
<p>7.15 如何在有规律的二维数组中进行高效的数据查找</p>
</blockquote>
</blockquote>
<h2 id="◆-第8章-基本数字运算" tabindex="-1"><a class="header-anchor" href="#◆-第8章-基本数字运算" aria-hidden="true">#</a> ◆ 第8章 基本数字运算</h2>
<blockquote>
<blockquote>
<p>第8章 基本数字运算</p>
</blockquote>
</blockquote>
<h3 id="◆-8-1-如何判断一个自然数是否是某个数的二次方" tabindex="-1"><a class="header-anchor" href="#◆-8-1-如何判断一个自然数是否是某个数的二次方" aria-hidden="true">#</a> ◆ 8.1 如何判断一个自然数是否是某个数的二次方</h3>
<blockquote>
<blockquote>
<p>8.1 如何判断一个自然数是否是某个数的二次方</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：设计一个算法，判断给定的一个数n 是否是某个数的二次方，不能使用平方根运算。例如，16就满足条件，因为它是4的二次方；而15则不满足条件，因为不存在一个数其二次方值为15。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：直接计算法由于不能使用平方根运算，因此最直接的方法就是计算二次方。主要思路：对1～n的每个数i，计算它的平方m，如果m＜n，那么继续遍历下一个值（i+1），如果m=n，那么就说明n是m的二次方，如果m＞n，那么就说明n不能表示成某个数的二次方。实现代码如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由于这个算法只需要从1遍历到n0.5就可以得出结果，因此算法的时间复杂度为O（n0.5）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：二分查找法与方法一类似，这个方法的主要思路还是查找从1～n的数字中，是否存在一个数m，比m 的二次方为n。只不过在查找的过程中使用的是二分查找的方法。具体思路为：首先判断mid=（1+n）/2的二次方power与m的大小；如果power＞m，那么就说明要在[1，mid-1]区间继续查找；否则在[mid+1，n]区间继续查找。</p>
</blockquote>
</blockquote>
<h3 id="◆-8-2-如何判断一个数是否为2的n次方" tabindex="-1"><a class="header-anchor" href="#◆-8-2-如何判断一个数是否为2的n次方" aria-hidden="true">#</a> ◆ 8.2 如何判断一个数是否为2的n次方</h3>
<blockquote>
<blockquote>
<p>8.2 如何判断一个数是否为2的n次方</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：“与”操作法那么是否存在效率更高的算法呢？通过对20，21，22，…，2n进行分析，发现这些数字的二进制形式分别为：1，10，100，…。从二进制的表示可以看出，如果一个数是2的n次方，那么这个数对应的二进制表示中有且只有一位是1，其余位都为0。因此，判断一个数是否为2的n次方可以转换为这个数对应的二进制表示中是否只有一位为1。如果一个数的二进制表示中只有一位是1，例如num=00010000，那么num-1的二进制表示为num-1=00001111。由于num与num-1二进制表示中每一位都不相同，因此num&amp;（num-1）的运算结果为0。可以利用这种方法来判断一个数是否为2的n次方。实现代码如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>这个方法的时间复杂度为O（1）。</p>
</blockquote>
</blockquote>
<h3 id="◆-8-3-如何不使用除法操作符实现两个正整数的除法" tabindex="-1"><a class="header-anchor" href="#◆-8-3-如何不使用除法操作符实现两个正整数的除法" aria-hidden="true">#</a> ◆ 8.3 如何不使用除法操作符实现两个正整数的除法</h3>
<blockquote>
<blockquote>
<p>8.3 如何不使用除法操作符实现两个正整数的除法</p>
</blockquote>
</blockquote>
<h3 id="◆-8-5-如何根据已知随机数生成函数计算新的随机数" tabindex="-1"><a class="header-anchor" href="#◆-8-5-如何根据已知随机数生成函数计算新的随机数" aria-hidden="true">#</a> ◆ 8.5 如何根据已知随机数生成函数计算新的随机数</h3>
<blockquote>
<blockquote>
<p>8.5 如何根据已知随机数生成函数计算新的随机数</p>
</blockquote>
</blockquote>
<h3 id="◆-8-6-如何判断1024-末尾有多少个0" tabindex="-1"><a class="header-anchor" href="#◆-8-6-如何判断1024-末尾有多少个0" aria-hidden="true">#</a> ◆ 8.6 如何判断1024!末尾有多少个0</h3>
<blockquote>
<blockquote>
<p>方法二：因子法5与任何一个偶数相乘都会增加末尾0的个数，由于偶数的个数肯定比5的个数多，因此1～1024所有数字中有5的因子的数字的个数决定了1024!末尾0的个数。因此，只需要统计因子5的个数即可。此外，5与偶数相乘会使末尾增加一个0，25（有两个因子5）与偶数相乘会使末尾增加两个0，125（有三个因子5）与偶数相乘会使末尾增加三个0，625（有四个因子5）与偶数相乘会使末尾增加四个0。对于本题而言：</p>
</blockquote>
</blockquote>
<h3 id="◆-8-8-如何求有序数列的第1500个数的值" tabindex="-1"><a class="header-anchor" href="#◆-8-8-如何求有序数列的第1500个数的值" aria-hidden="true">#</a> ◆ 8.8 如何求有序数列的第1500个数的值</h3>
<blockquote>
<blockquote>
<p>8.8 如何求有序数列的第1500个数的值</p>
</blockquote>
</blockquote>
<h3 id="◆-8-9-如何求二进制数中1的个数" tabindex="-1"><a class="header-anchor" href="#◆-8-9-如何求二进制数中1的个数" aria-hidden="true">#</a> ◆ 8.9 如何求二进制数中1的个数</h3>
<blockquote>
<blockquote>
<p>8.9 如何求二进制数中1的个数</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>给定一个整数，输出这个整数的二进制表示中1的个数。例如，给定整数7，其二进制表示为111，因此输出结果为3。</p>
</blockquote>
</blockquote>
<h3 id="◆-8-10-如何计算一个数的n次方" tabindex="-1"><a class="header-anchor" href="#◆-8-10-如何计算一个数的n次方" aria-hidden="true">#</a> ◆ 8.10 如何计算一个数的n次方</h3>
<blockquote>
<blockquote>
<p>8.10 如何计算一个数的n次方</p>
</blockquote>
</blockquote>
<h2 id="◆-第9章-排列组合与概率" tabindex="-1"><a class="header-anchor" href="#◆-第9章-排列组合与概率" aria-hidden="true">#</a> ◆ 第9章 排列组合与概率</h2>
<blockquote>
<blockquote>
<p>排列组合常用于字符串或序列的排列和组合中，而求解排列组合的方法也比较固定：第一种是类似于动态规划的方法，即保存中间结果，依次附上新元素，产生新的中间结果；第二种是递归法，通常是在递归函数里使用for循环，遍历所有排列或组合的可能，然后在for循环语句内调用递归函数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>概率论是计算机科学非常重要的基础学科之一，因为概率型面试、笔试题可以综合考查求职者的思维能力、应变能力、数学能力，所以概率题也是在程序员求职过程中经常会遇到的考题。</p>
</blockquote>
</blockquote>
<h3 id="◆-9-1-如何拿到最多金币" tabindex="-1"><a class="header-anchor" href="#◆-9-1-如何拿到最多金币" aria-hidden="true">#</a> ◆ 9.1 如何拿到最多金币</h3>
<blockquote>
<blockquote>
<p>9.1 如何拿到最多金币</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：10个房间里放着随机数量的金币。每个房间只能进入一次，并只能在一个房间中拿金币。一个人采取如下策略：前4个房间只看不拿。随后的房间只要看到比前4个房间都多的金币数，就拿。否则就拿最后一个房间的金币。编程计算这种策略拿到最多金币的概率。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：这道题是一个求概率的问题。由于10个房间里放的金币的数量是随机的，因此在编程实现时首先需要生成10个随机数来模拟10个房间里金币的数量。然后判断通过这种策略是否能拿到最多的金币。如果仅仅通过一次模拟来求拿到最多金币的概率显然是不准确的，那么就需要进行多次模拟，通过记录模拟的次数m，拿到最多金币的次数n，从而可以计算出拿到最多金币的概率n/m。显然这个概率与金币的数量以及模拟的次数有关系。模拟的次数越多越能接近真实值。下面以金币数为1～10的随机数、模拟次数为1000次为例给出实现代码：</p>
</blockquote>
</blockquote>
<h3 id="◆-9-2-如何求正整数n所有可能的整数组合" tabindex="-1"><a class="header-anchor" href="#◆-9-2-如何求正整数n所有可能的整数组合" aria-hidden="true">#</a> ◆ 9.2 如何求正整数n所有可能的整数组合</h3>
<blockquote>
<blockquote>
<p>9.2 如何求正整数n所有可能的整数组合</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>给定一个正整数n，求解出所有和为n 的整数组合，要求组合按照递增方式展示，而且唯一。例如，4=1+1+1+1、1+1+2、1+3、2+2、4（即4+0）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：以数值4为例，和为4的所有的整数组合一定都小于4（1, 2, 3, 4）。首先选择数字1，然后用递归的方法求和为3（即4-1）的组合，一直递归下去直到用递归求和为0的组合时，所选的数字序列就是一个和为4的数字组合。然后第二次选择2，接着用递归求和为2（即4-2）的组合；同理下一次选3，然后用递归求和为1（即4-3）的所有组合。以</p>
</blockquote>
</blockquote>
<h3 id="◆-9-4-如何等概率地从大小为n的数组中选取m个整数" tabindex="-1"><a class="header-anchor" href="#◆-9-4-如何等概率地从大小为n的数组中选取m个整数" aria-hidden="true">#</a> ◆ 9.4 如何等概率地从大小为n的数组中选取m个整数</h3>
<blockquote>
<blockquote>
<p>9.4 如何等概率地从大小为n的数组中选取m个整数</p>
</blockquote>
</blockquote>
<h3 id="◆-9-5-组合1、2、5这三个数使其和为100的组合个数" tabindex="-1"><a class="header-anchor" href="#◆-9-5-组合1、2、5这三个数使其和为100的组合个数" aria-hidden="true">#</a> ◆ 9.5 组合1、2、5这三个数使其和为100的组合个数</h3>
<blockquote>
<blockquote>
<p>方法二：数字规律法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>针对这种数学公式的运算，一般都可以通过找出运算的规律简化运算的过程。对于本题而言，对x+2y+5z=100进行变换可以得到x+5z=100-2y。从这个表达式可以看出，x+5z是偶数且x+5z≤100。因此，求满足x+2y+5z=100组合的个数就可以转换为求满足“x+5z是偶数且x+5z≤100”的个数。可以通过对z的所有可能的取值（0≤z≤20）进行遍历从而计算满足条件的x的值。</p>
</blockquote>
</blockquote>
<h3 id="◆-9-6-如何判断有几盏灯泡还亮着" tabindex="-1"><a class="header-anchor" href="#◆-9-6-如何判断有几盏灯泡还亮着" aria-hidden="true">#</a> ◆ 9.6 如何判断有几盏灯泡还亮着</h3>
<blockquote>
<blockquote>
<p>9.6 如何判断有几盏灯泡还亮着</p>
</blockquote>
</blockquote>
<h2 id="◆-第10章-海量数据处理" tabindex="-1"><a class="header-anchor" href="#◆-第10章-海量数据处理" aria-hidden="true">#</a> ◆ 第10章 海量数据处理</h2>
<blockquote>
<blockquote>
<p>第10章 海量数据处理</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>因此通过对海量数据的挖掘能有效地揭示用户的行为模式，加深对用户需求的理解，提取用户的集体智慧，从而为研发人员决策提供依据，提升产品用户体验，进而占领市场，所以当前各大互联网公司都将研究工作的重点放在了海量数据分析上。但是，只寄希望于硬件扩容是很难满足海量数据的分析需要的，如何利用现有条件进行海量信息处理，已经成为各大互联网公司亟待解决的问题。所以，海量信息处理正日益成为当前程序员笔试、面试中一个新的亮点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>不同于常规量级数据中提取信息，在海量信息中提取有用数据，存在以下几个方面的问题。首先，数据量过大，数据中什么情况都可能存在，如果信息数量只有20条，人工就可以逐条进行查找、比对。可是当数据规模扩展到数千条、数亿条甚至更多时，只通过人工已经无法解决存在的问题，必须通过工具或者程序进行处理。其次，对海量数据进行信息处理，还需要有良好的软硬件配置，合理使用工具，合理分配系统资源。通常情况下，如果需要处理的数据量非常大，超过了TB级，小型机及大型工作站是要考虑的，普通的计算机如果有好的处理方法也可以考虑，如通过联机做成工作集群。最后，对海量数据进行信息处理时，要求很好的处理方法和技巧，如何进行数据挖掘算法的设计以及如何进行数据的存储访问等都是研究的难点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>针对海量数据的处理，可以使用的方法非常多，常见的方法有Hash法、Bit-map（位图）法、Bloom filter 法、数据库优化法、倒排索引法、外排序法、Trie 树、堆、双层桶法以及MapReduce 法等。其中，Hash 法、Bit-map（位图）法、Trie 树以及堆等方法的考查频率最高、使用范围最为广泛，是读者需要重点掌握的方法。</p>
</blockquote>
</blockquote>
<h3 id="◆-10-1-如何从大量的url中找出相同的url" tabindex="-1"><a class="header-anchor" href="#◆-10-1-如何从大量的url中找出相同的url" aria-hidden="true">#</a> ◆ 10.1 如何从大量的url中找出相同的url</h3>
<blockquote>
<blockquote>
<p>10.1 如何从大量的url中找出相同的url</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：给定a、b两个文件，各存放50亿个url，每个url各占64B，内存限制是4GB，找出a、b两个文件共同的url。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：因为每个url需要占64B，所以50亿个url占用的空间大小为50亿×64=5GB×64=320GB。由于内存大小只有4GB，因此不可能一次性把所有的url都加载到内存中处理。对于这个类型的题目，一般都需要使用分治法，即把一个文件中的url按照某一特征分成多个文件，使得每个文件的内容都小于4GB，这样就可以把这个文件一次性读到内存中进行处理了。对于本题而言，主要的实现思路为以下几点。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）遍历文件a，对遍历到的url求hash（url）%500，根据计算结果把遍历到的url分别存储到a0，a1，a2，…，a499（将计算结果为i的url存储到文件ai中），这样每个文件的大小约为600MB。当某一个文件中url的大小超过2GB时，可以按照类似的思路把这个文件继续分为更小的子文件（例如，如果a1大小超过2GB，那么可以把文件继续分成a11, a12, …）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）使用同样的方法遍历文件b，把文件b中的url分别存储到文件b0，b1，…，b499中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）通过上面的划分，与ai中url相同的url一定在bi中。由于ai与bi中所有的url的大小不会超过4GB，因此可以把它们同时读入到内存中进行处理。具体思路：遍历文件ai，把遍历到的url存入到hash_set中，接着遍历文件bi中的url，如果这个url在hash_set中存在，那么说明这个url是这两个文件共同的url，可以把这个url保存到另外一个单独的文件中。当把文件a0～a499都遍历完成后，就找到了两个文件共同的url。</p>
</blockquote>
</blockquote>
<h3 id="◆-10-2-如何从大量数据中找出高频词" tabindex="-1"><a class="header-anchor" href="#◆-10-2-如何从大量数据中找出高频词" aria-hidden="true">#</a> ◆ 10.2 如何从大量数据中找出高频词</h3>
<blockquote>
<blockquote>
<p>10.2 如何从大量数据中找出高频词</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：有一个1GB大小的文件，文件里面每一行是一个词，每个词的大小不超过16B，内存大小限制是1MB，要求返回频数最高的100个词。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：由于文件大小为1GB，而内存大小只有1MB，因此不可能一次把所有的词读入到内存中处理，需要采用分治的方法，把一个大的文件分解成多个小的子文件，从而保证每个文件的大小都小于1MB，进而可以直接被读取到内存中处理。具体的思路如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）遍历文件。对遍历到的每一个词，执行如下hash操作：hash（x）%2000，将结果为i的词存放到文件ai中，通过这个分解步骤，可以使每个子文件的大小为400KB左右。如果这个操作后某个文件的大小超过1MB了，那么就可以采用相同的方法对这个文件继续分解，直到文件的大小小于1MB为止。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）统计出每个文件中出现频率最高的100个词。最简单的方法为，使用hash_map来实现，具体实现方法：遍历文件中的所有词，对于遍历到的词，如果在hash_map中不存在，那么把这个词存入hash_map中（键为这个词，值为1），如果这个词在hash_map中已经存在了，那么把这个词对应的值加1。遍历完后可以非常容易地找出出现频率最高的100个词。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）第2）步找出了每个文件出现频率最高的100个词，这一步可以通过维护一个小顶堆来找出所有词中出现频率最高的100个。具体方法：遍历第一个文件，把第一个文件中出现频率最高的100个词构建成一个小顶堆（如果第一个文件中词的个数小于100，可以继续遍历第二个文件，直到构建好有100个结点的小顶堆为止）。继续遍历，如果遍历到的词的出现次数大于堆顶上词的出现次数，可以用新遍历到的词替换堆顶的词，然后重新调整这个堆为小顶堆。当遍历完所有文件后，这个小顶堆中的词就是出现频率最高的100个词。当然这一步也可以采用类似归并排序的方法把所有文件中出现频率最高的100个词排序，最终找出出现频率最高的100个词。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>引申：怎么在海量数据中找出重复次数最多的一个？前面的算法是求解top100，而这道题目只是求解top1，可以使用同样的思路来求解。唯一不同的是，在求解出每个文件中出现次数最多的数据后，接下来从各个文件中出现次数最多的数据中找出出现次数最多的数，不需要使用小顶堆，只需要使用一个变量就可以完成。</p>
</blockquote>
</blockquote>
<h3 id="◆-10-3-如何找出某一天访问百度网站最多的ip" tabindex="-1"><a class="header-anchor" href="#◆-10-3-如何找出某一天访问百度网站最多的ip" aria-hidden="true">#</a> ◆ 10.3 如何找出某一天访问百度网站最多的IP</h3>
<blockquote>
<blockquote>
<p>10.3 如何找出某一天访问百度网站最多的IP</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：现有海量日志数据保存在一个超级大的文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个IP。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：由于这道题只关心某一天访问百度最多的IP，因此可以先对文件进行一次遍历，把这一天访问百度网站的IP的相关信息记录到一个单独的文件中。接下来可以用上一节介绍的方法来求解。由于求解思路是一样的，这里就不再详细介绍了。唯一需要确定的是，把一个大文件分为几个小文件比较合适。以IPv4为例，由于一个IP地址占用32bit，因此最多会有232种取值情况。如果使用hash（IP）%1024值，那么就把海量IP日志分别存储到1024个小文件中。这样，每个小文件最多包含4M个IP地址。如果使用2048个小文件，那么每个文件会最多包含2M个IP地址。因此，对于这类题目而言，首先需要确定可用内存的大小，然后确定数据的大小。由这两个参数就可以确定hash函数应该怎么设置才能保证每个文件的大小都不超过内存的大小，从而可以保证每个小文件都能被一次性加载到内存中。</p>
</blockquote>
</blockquote>
<h3 id="◆-10-4-如何在大量的数据中找出不重复的整数" tabindex="-1"><a class="header-anchor" href="#◆-10-4-如何在大量的数据中找出不重复的整数" aria-hidden="true">#</a> ◆ 10.4 如何在大量的数据中找出不重复的整数</h3>
<blockquote>
<blockquote>
<p>10.4 如何在大量的数据中找出不重复的整数</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：在2.5亿个整数中找出不重复的整数。注意：内存不足以容纳这2.5亿个整数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：由于这道题目与前面的题目类似，也是无法一次性把所有数据加载到内存中，因此也可以采用类似的方法求解。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：分治法采用hash函数的方法，把这2.5亿个整数划分到更小的文件中，从而保证每个文件的大小不超过可用的内存大小。然后对每个小文件而言，所有的数据都可以一次性被加载到内存中，因此可以使用hash_map或hash_set来找到每个小文件中不重复的整数。当处理完所有的文件后就可以找出这2.5亿个整数中所有的不重复的整数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：位图法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于整数相关的算法的求解，位图法是一种非常实用的算法。对本题而言，如果可用的内存空间超过1GB就可以使用这种方法。具体思路：假设整数占用4B（如果占用8B，则求解思路类似，只不过需要占用更大的内存），也就是32bit，可以表示的整数的个数为232。由于本题只查找不重复的数，而不关心具体数字出现的次数，因此可以分别使用2个bit来表示各个数字的状态：用00表示这个数字没有出现过，01表示出现过1次，10表示出现了多次， 11暂不使用。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>根据上面的逻辑，在遍历这2.5亿个整数时，如果这个整数对应的位图中的位为00，那么就修改成01；如果为01，则修改为10；如果为10，则保持原值不变。这样当所有数据遍历完成后，可以再遍历一遍位图，位图中值为01的bit对应的数字就是没有重复的数字。</p>
</blockquote>
</blockquote>
<h3 id="◆-10-5-如何在大量的数据中判断一个数是否存在" tabindex="-1"><a class="header-anchor" href="#◆-10-5-如何在大量的数据中判断一个数是否存在" aria-hidden="true">#</a> ◆ 10.5 如何在大量的数据中判断一个数是否存在</h3>
<blockquote>
<blockquote>
<p>10.5 如何在大量的数据中判断一个数是否存在</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：在2.5亿个整数中判断一个数是否存在。注意：内存不足以容纳这2.5亿个整数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：显然2.5亿数据量太大，不可能一次性把所有的数据都加载到内存中，那么最容易想到的方法就是分治法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：分治法对于大数据相关的算法题，分治法是一个非常好的方法。针对这道题，主要的思路：可以根据实际可用内存的情况，确定一个hash函数，如hash（value）%1000，通过这个hash函数可以把这2.5亿个数字划分到1000个文件中（a1，a2，…，a1000），然后对待查找的数字使用相同的hash函数求出hash值，假设计算出的hash值为i，如果这个数存在，那么它一定在文件ai中。通过这种方法就可以把题目的问题转换为文件ai中是否存在这个数。那么在接下来的求解过程中可以选用的思路比较多，如下所示：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）由于划分后的文件比较小，可以直接被装载到内存中，可以把文件中所有的数字都保存到hash_set中，然后判断待查找的数字是否存在。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）如果这个文件中的数字占用的空间还是太大，那么就可以用相同的方法把这个文件继续划分为更小的文件，然后确定待查找的数字可能存在的文件，最后在相应的文件中继续查找。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：位图法对于这类判断数字是否存在、判断数字是否重复的问题，位图法是一种非常高效的方法。这里以32位整型为例，它可以表示数字的个数为232。可以申请一个位图，让每个整数对应位图中的一个bit，这样232个数需要位图的大小为512MB。具体实现的思路：申请一个512MB大小的位图，并把所有的位都初始化为0；接着遍历所有的整数，对遍历到的数字，把相应位置上的bit设置为1。最后判断待查找的数对应的位图上的值是多少，如果是0，则表示这个数字不存在，如果是1，则表示这个数字存在。</p>
</blockquote>
</blockquote>
<h3 id="◆-10-6-如何查询最热门的查询串" tabindex="-1"><a class="header-anchor" href="#◆-10-6-如何查询最热门的查询串" aria-hidden="true">#</a> ◆ 10.6 如何查询最热门的查询串</h3>
<blockquote>
<blockquote>
<p>10.6 如何查询最热门的查询串</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：搜索引擎会通过日志文件把用户每次检索使用的所有查询串都记录下来，每个查询串的长度为1～255B。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>假设目前有1000万个记录（这些查询串的重复度比较高，虽然总数是1000万，但如果除去重复后，则不超过300万个。一个查询串的重复度越高，说明查询它的用户越多，也就是越热门）。请统计最热门的10个查询串，要求使用的内存不能超过1GB。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：从题目中可以发现，每个查询串最长为255B，1000万个字符串需要占用2.55GB内存，因此无法把所有字符串同时读入到内存中处理。对于这种类型的题目，分治法是一个非常实用的方法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：分治法对字符串设置一个hash 函数，通过这个hash 函数把字符串划分到更多更小的文件中，从而保证每个小文件中的字符串都可以直接被加载到内存中处理，然后求出每个文件中出现次数最多的10个字符串；最后通过一个小顶堆统计出所有文件中出现最多的10个字符串。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>从功能角度出发，这种方法是可行的，但是因为需要对文件遍历两遍，而且hash函数也需要被调用1000万次，所以性能不是很好。针对这道题的特殊性，下面介绍另外一种性能较好的方法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：hash_map法虽然字符串的总数比较多，但是字符串的种类不超过300万个，因此可以考虑把所有字符串出现的次数保存在一个hash_map 中（键为字符串，值为字符串出现的次数）。hash_map所需要的空间为300万×（255+4）=3M×259=777MB（其中，数值4表示用4个字节记录字符串出现次数）。由此可见，1GB的内存空间是足够用的。基于以上的分析，本题的求解思路如下：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）遍历字符串，如果字符串在hash_map中不存在，则直接存入hash_map中，键为这个字符串，值为1。如果字符串在hash_map中已经存在，则把对应的值直接加1。这一步操作的时间复杂度为O（N），其中N为字符串的数量。2）在第一步的基础上找出出现频率最高的10个字符串。可以通过小顶堆的方法来完成，遍历hash_map的前10个元素，并根据字符串出现的次数构建一个小顶堆，然后接着遍历hash_map，只要遍历到的字符串的出现次数大于堆顶字符串的出现次数，就用遍历的字符串替换堆顶的字符串，然后把堆调整为小顶堆。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）对所有剩余的字符串都遍历一遍，遍历完成后堆中的10个字符串就是出现次数最多的字符串。这一步的时间复杂度为O（Nlog10）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法三：trie树法方法二中使用hash_map 来统计每个字符串出现的次数。当这些字符串有大量相同前缀时，可以考虑使用trie 树来统计字符串出现的次数。可以在树的结点中保存字符串出现的次数，0表示没有出现。具体的实现方法：在遍历字符串的时候，在trie树中查找对应的字符串，如果找到，则把结点中保存的字符串出现的次数加1，否则为这个字符串构建新的结点，构建完成后把叶子结点中字符串的出现次数设置为1。这样遍历完字符串后就可以知道每个字符串的出现次数，然后通过遍历这个树就可以找出出现次数最多的字符串。trie树经常被用来统计字符串的出现次数。它的另外一个大的用途就是字符串查找，判断是否有重复的字符串等。</p>
</blockquote>
</blockquote>
<h3 id="◆-10-7-如何统计不同电话号码的个数" tabindex="-1"><a class="header-anchor" href="#◆-10-7-如何统计不同电话号码的个数" aria-hidden="true">#</a> ◆ 10.7 如何统计不同电话号码的个数</h3>
<blockquote>
<blockquote>
<p>10.7 如何统计不同电话号码的个数</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：已知某个文件内包含一些电话号码，每个号码为8位数字，统计不同号码的个数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：这个题目本质上也是求解数据重复的问题，对于这类问题，首先会考虑位图法。对本题而言，8位电话号码可以表示的范围为00000000～99999999。如果用1bit表示一个号码，那么总共需要1亿个bit，总共需要大约100MB的内存。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通过上面的分析可知，这道题的主要思路：申请一个位图并初始化为0，然后遍历所有电话号码，把遍历到的电话号码对应的位图中的bit设置为1。当遍历完成后，如果bit值为1，则表示这个电话号码在文件中存在，否则这个bit 对应的电话号码在文件中不存在。所以bit值为1的数量就是不同电话号码的个数。求解这道题时，最核心的算法是如何确定电话号码对应的是位图中的哪一位。下面重点介绍这个转化的方法，这里使用下面的对应方法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>00000000对应位图最后一位：0×0000…000001。00000001对应位图倒数第二位：0×0000…0000010（1向左移1位）。00000002对应位图倒数第三位：0×0000…0000100（1向左移2位）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>00000012对应位图的倒数第十三位：0×0000…0001 0000 0000 0000。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通常而言，位图都是通过一个整数数组来实现的（这里假设一个整数占用4B）。由此可以得出，通过电话号码获取位图中对应位置的方法为（假设电话号码为P）：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）通过P/32就可以计算出该电话号码在bitmap数组中的下标（因为每个整数占用32bit，通过这个公式就可以确定这个电话号码需要移动多少个32位，也就是可以确定它对应的bit在数组中的位置）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）通过P%32就可以计算出这个电话号码在这个整型数字中具体的bit的位置，也就是1这个数字对应的左移次数。因此，只要把1向左移P%32位，然后把得到的值与这个数组中的值做或运算，就可以把这个电话号码在位图中对应的位设置为1。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>这个转换的操作可以通过一个非常简单的函数来实现：[插图]</p>
</blockquote>
</blockquote>
<h3 id="◆-10-8-如何从5亿个数中找出中位数" tabindex="-1"><a class="header-anchor" href="#◆-10-8-如何从5亿个数中找出中位数" aria-hidden="true">#</a> ◆ 10.8 如何从5亿个数中找出中位数</h3>
<blockquote>
<blockquote>
<p>10.8 如何从5亿个数中找出中位数</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：从5亿个数中找出中位数。数据排序后，位置在最中间的数就是中位数。当样本数为奇数时，中位数=（N+1）/2；当样本数为偶数时，中位数为N/2与1+N/2的均值。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：如果这道题目没有内存大小的限制，则可以把所有的数字排序后找出中位数，但是最好的排序算法的时间复杂度都是O（NlogN）（N为数字的个数）。这里介绍另外一种求解中位数的算法——双堆法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：双堆法这个算法的主要思路是维护两个堆，一个大顶堆，一个小顶堆，且这两个堆需要满足如下两个特性。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>特性一：大顶堆中最大的数小于或等于小顶堆中最小的数。特性二：保证这两个堆中的元素个数的差不能超过1。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>若数据总数为偶数时，当这两个堆建立好以后，中位数显然就是两个堆顶元素的平均值。当数据总数为奇数时，根据两个堆的大小，中位数一定在数据多的堆的堆顶。对本题而言，具体实现思路：维护两个堆maxHeap与minHeap，这两个堆的大小分别为max_size和min_size，然后开始遍历数字。对于遍历到的数字data：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）如果data＜maxHeap的堆顶元素，此时为了满足特性1，只能把data插入到maxHeap中。为了满足特性二，需要分以下几种情况讨论。① 如果max_size≤min_size，则说明大顶堆元素个数小于小顶堆元素个数，此时把data直接插入大顶堆中，并把这个堆调整为大顶堆。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>② 如果max_size＞min_size，为了保持两个堆元素个数的差不超过1，则需要把maxHeap堆顶的元素移动到minHeap中，接着把data插入到maxHeap中。同时通过对堆的调整，分别让两个堆保持大顶堆与小顶堆的特性。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）如果maxHeap堆顶元素≤data≤minHeap堆顶元素，则为了满足特性一，可以把data插入任意一个堆中，为了满足特性二，需要分以下几种情况讨论：① 如果max_size＜min_size，显然需要把data插入到maxHeap中；② 如果max_size＞min_size，显然需要把data插入到minHeap中；③ 如果max_size==min_size，可以把data插入到任意一个堆中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）如果data＞maxHeap的堆顶元素，此时为了满足特性一，只能把data插入到minHeap中。为了满足特性二，需要分以下几种情况讨论：① 如果max_size≥min_size，那么把data插入到minHeap中；② 如果max_size＜min_size，那么需要把minHeap堆顶元素移到maxHeap中，然后把data插入到minHeap中。通过上述方法可以把5亿个数构建成两个堆，两个堆顶元素的平均值就是中位数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由于需要把所有的数据都加载到内存中，当数据量很大时，因为无法把数据一次性加载到内存中，因此这种方法比较适用于数据量小的情况。对本题而言，5亿个数字，每个数字在内存中占4B，5亿个数字需要的内存空间为2GB内存。当可用的内存不足2GB时，显然不能使用这种方法，下面介绍另外一种方法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：分治法分治法的核心思想是把一个大的问题逐渐转换为规模较小的问题来求解。对于本题而言，顺序读取这5亿个数字；</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）对于读取到的数字num，如果它对应的二进制中最高位为1，则把这个数字写入到f1中，如果最高位是0，则写入到f0中。通过这一步就可以把这5亿个数字划分成两部分，而且f0中的数字都大于f1中的数字（因为最高位是符号位）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）通过上面的划分很容易知道中位数是在f0中还是在f1中。假设f1中有1亿个数，那么中位数一定在文件f0中，且它的值为f0文件中的数字排序的第1.5亿个数与它后面一个数的平均值。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3）对于f0，可以用次高位的二进制的值继续把这个文件一分为二，使用同样的思路可以确定中位数是哪个文件中的第几个数。直到划分后的文件可以被加载到内存时，把数据加载到内存中以后排序，从而找出中位数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>需要注意的是，这里有一种特殊情况需要考虑，当数据总数为偶数时，如果把文件一分为二后发现两个文件中的数据有相同的个数，那么中位数就是f0文件中的最大值与f1文件中的最小值的平均值。如果要求一个文件中所有数据的最大值或最小值，可以使用前面介绍的分治法进行求解。</p>
</blockquote>
</blockquote>
<h3 id="◆-10-9-如何按照query的频度排序" tabindex="-1"><a class="header-anchor" href="#◆-10-9-如何按照query的频度排序" aria-hidden="true">#</a> ◆ 10.9 如何按照query的频度排序</h3>
<blockquote>
<blockquote>
<p>10.9 如何按照query的频度排序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>题目描述：有10个文件，大小均为1GB，每个文件的每一行存放的都是用户的query，每个文件的query都可能重复。要求按照query的频度排序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分析与解答：对于这种题，如果query的重复度比较大，则可以考虑一次性把所有query读入到内存中处理；如果query的重复率不高，可用的内存不足以容纳所有的query，那么就需要使用分治法或者其他的方法来解决。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法一：hash_map法如果query的重复率比较高，则说明不同的query总数比较小，可以考虑把所有的query都加载到内存中的hash_map中（由于hash_map中针对每个不同的query只保存一个键值对，因此，这些query 占用的空间会远小于10GB，有希望把它们一次性都加载到内存中）。接着就可以对hash_map按照query出现的次数进行排序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>方法二：分治法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>这种方法需要根据数据量的大小以及可用内存的大小来确定问题划分的规模。对本题而言，可以顺序遍历10个文件中的query，通过hash函数hash（query）%10把这些query划分到10个文件中。通过这样的划分，每个文件的大小为1GB左右，当然可以根据实际情况来调整hash函数。如果可用内存很小，则可以把这些query划分到更多更小的文件中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果划分后的文件还是比较大，则可以使用相同的方法继续划分，直到每个文件都可以被读取到内存中进行处理为止，然后对每个划分后的小文件使用hash_map统计每个query出现的次数，最后根据出现次数排序，并把排序好的query以及出现次数写入到另外一个单独的文件中。这样针对每个文件，都可以得到一个按照query出现次数排序的文件。接着对所有的文件按照query 的出现次数进行排序，这里可以使用归并排序（由于无法把所有的query都读入到内存中，因此这里需要使用外排序）。</p>
</blockquote>
</blockquote>
<h1 id="如何统计不同电话号码的个数" tabindex="-1"><a class="header-anchor" href="#如何统计不同电话号码的个数" aria-hidden="true">#</a> <a href="https://www.cnblogs.com/qmillet/p/12561942.html" target="_blank" rel="noopener noreferrer">如何统计不同电话号码的个数？<ExternalLinkIcon/></a></h1>
<h3 id="题目描述" tabindex="-1"><a class="header-anchor" href="#题目描述" aria-hidden="true">#</a> 题目描述</h3>
<p>已知某个文件内包含一些电话号码，每个号码为 8 位数字，统计不同号码的个数。</p>
<h3 id="解答思路" tabindex="-1"><a class="header-anchor" href="#解答思路" aria-hidden="true">#</a> 解答思路</h3>
<p>这道题本质还是求解数据重复的问题，对于这类问题，一般首先考虑位图法。</p>
<p>对于本题，8 位电话号码可以表示的号码个数为 108 个，即 1 亿个。我们每个号码用一个 bit 来表示，则总共需要 1 亿个 bit，内存占用约 100M。</p>
<p>思路如下：</p>
<p>申请一个位图数组，长度为 1 亿，初始化为 0。然后遍历所有电话号码，把号码对应的位图中的位置置为 1。遍历完成后，如果 bit 为 1，则表示这个电话号码在文件中存在，否则不存在。bit 值为 1 的数量即为 不同电话号码的个数。</p>
<h3 id="方法总结" tabindex="-1"><a class="header-anchor" href="#方法总结" aria-hidden="true">#</a> 方法总结</h3>
<p><strong>求解数据重复问题，记得考虑位图法。</strong></p>
<h1 id="如何找出某一天访问百度网站最多的-ip" tabindex="-1"><a class="header-anchor" href="#如何找出某一天访问百度网站最多的-ip" aria-hidden="true">#</a> 如何找出某一天访问百度网站最多的 IP？</h1>
<p><img src="https://csdnimg.cn/release/blogv2/dist/pc/img/reprint.png" alt="img"></p>
<p><a href="https://blog.csdn.net/jack1liu" target="_blank" rel="noopener noreferrer">新猿一马<ExternalLinkIcon/></a> 2020-04-13 08:24:47 <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/articleReadEyes.png" alt="img"> 242 <img src="https://csdnimg.cn/release/blogv2/dist/pc/img/tobarCollect.png" alt="img"> 收藏</p>
<p>分类专栏： <a href="https://blog.csdn.net/jack1liu/category_9900445.html" target="_blank" rel="noopener noreferrer">大数据学习<ExternalLinkIcon/></a></p>
<p>版权</p>
<p><a href="https://blog.csdn.net/jack1liu/category_9900445.html" target="_blank" rel="noopener noreferrer"><img src="https://img-blog.csdnimg.cn/20201014180756925.png?x-oss-process=image/resize,m_fixed,h_224,w_224" alt="img">大数据学习<ExternalLinkIcon/></a>专栏收录该内容</p>
<p>3 篇文章0 订阅</p>
<p>订阅专栏</p>
<h3 id="题目描述-1" tabindex="-1"><a class="header-anchor" href="#题目描述-1" aria-hidden="true">#</a> 题目描述</h3>
<p>现有海量日志数据保存在一个超大文件中，该文件无法直接读入内存，要求从中提取某天访问百度次数最多的那个 IP。</p>
<h3 id="解答思路-1" tabindex="-1"><a class="header-anchor" href="#解答思路-1" aria-hidden="true">#</a> 解答思路</h3>
<p>这道题只关心某一天访问百度最多的 IP，因此，可以首先对文件进行一次遍历，把这一天访问百度 IP 的相关信息记录到一个单独的大文件中。接下来采用的方法与上一题一样，大致就是先对 IP 进行哈希映射，接着使用 HashMap 统计重复 IP 的次数，最后计算出重复次数最多的 IP。</p>
<blockquote>
<p>注：这里只需要找出出现次数最多的 IP，可以不必使用堆，直接用一个变量 max 即可。</p>
</blockquote>
<h3 id="方法总结-1" tabindex="-1"><a class="header-anchor" href="#方法总结-1" aria-hidden="true">#</a> 方法总结</h3>
<ol>
<li>分而治之，进行哈希取余；</li>
<li>使用 HashMap 统计频数；</li>
<li>求解<strong>最大</strong>的 TopN 个，用<strong>小顶堆</strong>；求解<strong>最小</strong>的 TopN 个，用<strong>大顶堆</strong>。</li>
</ol>
</div></template>


