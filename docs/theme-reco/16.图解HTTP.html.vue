<template><div><h1 id="图解http" tabindex="-1"><a class="header-anchor" href="#图解http" aria-hidden="true">#</a> 图解HTTP</h1>
<p>上野宣</p>
<h3 id="◆-6-4-请求首部字段" tabindex="-1"><a class="header-anchor" href="#◆-6-4-请求首部字段" aria-hidden="true">#</a> ◆ 6.4 请求首部字段</h3>
<blockquote>
<blockquote>
<p>虚拟主机运行在同一个IP上，因此使用首部字段Host加以区分</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>首部字段Host会告知服务器，请求的资源所处的互联网主机名和端口号。Host首部字段在HTTP/1.1规范内是唯一一个必须被包含在请求内的首部字段。首部字段Host和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段Host必须存在的意义。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>若服务器未设定主机名，那直接发送一个空值即可。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>形如If-xxx这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>只有当If-Match的字段值跟ETag值匹配一致时，服务器才会接受请求</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>服务器会比对If-Match的字段值和资源的ETag值，仅当两者一致时，才会执行请求。反之，则返回状态码412 Precondition Failed的响应。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>还可以使用星号（*）指定If-Match的字段值。针对这种情况，服务器将会忽略ETag的值，只要资源存在就处理请求。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果在If-Modified-Since字段指定的日期时间后，资源发生了更新，服务器会接受请求</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>首部字段If-Modified-Since，属附带条件之一，它会告知服务器若If-Modified-Since字段值早于资源的更新时间，则希望能处理该请求。而在指定If-Modified-Since字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码304Not Modified的响应。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>If-Modified-Since用于确认代理或客户端拥有的本地资源的有效性。获取资源的更新日期时间，可通过确认首部字段Last-Modified来确定。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>首部字段If-Unmodified-Since和首部字段If-Modified-Since的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码412Precondition Failed作为响应返回。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通过TRACE方法或OPTIONS方法，发送包含首部字段Max-Forwards的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，会将Max-Forwards的值减1后重新赋值。当服务器接收到Max-Forwards值为0的请求时，则不再进行转发，而是直接返回响应。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>图：代理B到源服务器的请求失败了，但客户端不知道[插图]图：由于未知原因，导致请求陷入代理之间的循环，但客户端不知道</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization的请求，以告知服务器认证所需要的信息。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于只需获取部分资源的范围请求，包含首部字段Range即可告知服务器资源的指定范围。上面的示例表示请求获取从第5001字节至第10000字节的资源。接收到附带Range首部字段请求的服务器，会在处理请求之后返回状态码为206 Partial Content的响应。无法处理该范围请求时，则会返回状态码200 OK的响应及全部资源。</p>
</blockquote>
</blockquote>
<h3 id="◆-6-5-响应首部字段" tabindex="-1"><a class="header-anchor" href="#◆-6-5-响应首部字段" aria-hidden="true">#</a> ◆ 6.5 响应首部字段</h3>
<blockquote>
<blockquote>
<p>[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>首部字段Accept-Ranges是用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源。可指定的字段值有两种，可处理范围请求时指定其为bytes，反之则指定其为none。</p>
</blockquote>
</blockquote>
<h3 id="◆-6-6-实体首部字段" tabindex="-1"><a class="header-anchor" href="#◆-6-6-实体首部字段" aria-hidden="true">#</a> ◆ 6.6 实体首部字段</h3>
<blockquote>
<blockquote>
<p>[插图]图：客户端会对接收的报文主体执行相同的MD5算法，然后与首部字段Content-MD5的字段值比较</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>首部字段Content-MD5是一串由MD5算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对报文主体执行MD5算法获得的128位二进制数，再通过Base64编码后将结果写入Content-MD5字段值。由于HTTP首部无法记录二进制值，所以要通过Base64编码处理。为确保报文的有效性，作为接收方的客户端会对报文主体再执行一次相同的MD5算法。计算出的值与字段值作比较后，即可判断出报文主体的准确性。采用这种方法，对内容上的偶发性改变是无从查证的，也无法检测出恶意篡改。其中一个原因在于，内容如果能够被篡改，那么同时意味着Content-MD5也可重新计算然后被篡改。所以处在接收阶段的客户端是无法意识到报文主体以及首部字段Content-MD5是已经被篡改过的。</p>
</blockquote>
</blockquote>
<h3 id="◆-6-8-其他首部字段" tabindex="-1"><a class="header-anchor" href="#◆-6-8-其他首部字段" aria-hidden="true">#</a> ◆ 6.8 其他首部字段</h3>
<blockquote>
<blockquote>
<p>HTTP首部字段是可以自行扩展的。所以在Web服务器和浏览器的应用上，会出现各种非标准的首部字段。接下来，我们就一些最为常用的首部字段进行说明。●X-Frame-Options●X-XSS-Protection●DNT●P3P</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>首部字段X-Frame-Options属于HTTP响应首部，用于控制网站内容在其他Web网站的Frame标签内的显示问题。其主要目的是为了防止点击劫持（clickjacking）攻击。</p>
</blockquote>
</blockquote>
<h3 id="◆-7-1-http的缺点" tabindex="-1"><a class="header-anchor" href="#◆-7-1-http的缺点" aria-hidden="true">#</a> ◆ 7.1 HTTP的缺点</h3>
<blockquote>
<blockquote>
<p>HTTP主要有这些不足，例举如下。●通信使用明文（不加密），内容可能会被窃听●不验证通信方的身份，因此有可能遭遇伪装●无法证明报文的完整性，所以有可能已遭篡改</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果要问为什么通信时不加密是一个缺点，这是因为，按TCP/IP协议族的工作机制，通信内容在所有的通信线路上都有可能遭到窥视。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>即使已经过加密处理的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本身还是会被看到的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>窃听相同段上的通信并非难事。只需要收集在互联网上流动的数据包（帧）就行了。对于收集来的数据包的解析工作，可交给那些抓包（Packet Capture）或嗅探器（Sniffer）工具。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>■加密处理防止被窃听在目前大家正在研究的如何防止窃听保护信息的几种对策中，最为普及的就是加密技术。加密的对象可以有这么几个。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一种方式就是将通信加密。HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全传输层协议）的组合使用，加密HTTP的通信内容。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTPSecure，超文本传输安全协议）或HTTP over SSL。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>还有一种将参与通信的内容本身加密的方式。由于HTTP协议中没有加密机制，那么就对HTTP协议传输的内容本身加密。即把HTTP报文里所含的内容进行加密处理。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。主要应用在Web服务中。有一点必须引起注意，由于该方式不同于SSL或TLS将整个通信线路加密处理，所以内容仍有被篡改的风险。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>不验证通信方的身份就可能遭遇伪装HTTP协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中URI真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>HTTP协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。● 无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的Web服务器。● 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。● 无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。● 无法判定请求是来自何方、出自谁手。● 即使是无意义的请求也会照单全收。无法阻止海量请求下的DoS攻击（Denial of Service，拒绝服务攻击）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>查明对手的证书虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>从某个Web网站上下载内容，是无法确定客户端下载的文件和服务器上存放的文件是否前后一致的。文件内容在传输途中可能已经被篡改为其他的内容。即使内容真的已改变，作为接收方的客户端也是觉察不到的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Man-in-the-Middle attack,MITM）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>虽然有使用HTTP协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是MD5和SHA-1等散列值校验的方法，以及用来确认文件的数字签名方法。</p>
</blockquote>
</blockquote>
<h3 id="◆-7-2-http-加密-认证-完整性保护-https" tabindex="-1"><a class="header-anchor" href="#◆-7-2-http-加密-认证-完整性保护-https" aria-hidden="true">#</a> ◆ 7.2 HTTP+加密+认证+完整性保护=HTTPS</h3>
<blockquote>
<blockquote>
<p>对于HTTP来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。为了统一解决上述这些问题，需要在HTTP上再加入加密处理和认证等机制。我们把添加了加密及认证机制的HTTP称为HTTPS（HTTP Secure）。[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（Secure Socket Layer）和TLS（Transport LayerSecurity）协议代替而已。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>SSL是独立于HTTP的协议，所以不光是HTTP协议，其他运行在应用层的SMTP和Telnet等协议均可配合SSL协议使用。可以说SSL是当今世界上应用最为广泛的网络安全技术。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>SSL采用一种叫做公开密钥加密（Public-key cryptography）的加密处理方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>加密和解密都会用到密钥。没有密钥就无法对密码解密，反过来说，任何人只要持有密钥就能解密了。如果密钥被攻击者获得，那加密也就失去了意义。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>加密和解密同用一个密钥的方式称为共享密钥加密（Commonkey crypto system），也被叫做对称密钥加密。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>以共享密钥方式加密时必须将密钥也发给对方。可究竟怎样才能安全地转交？在互联网上转发密钥时，如果通信被监听那么密钥就可会落入攻击者之手，同时也就失去了加密的意义。另外还得设法安全地保管接收到的密钥。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>公开密钥加密方式很好地解决了共享密钥加密的困难。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>其中一个原因是，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。因此，如果是非敏感信息则使用HTTP通信，只有在包含个人信息等敏感数据时，才利用HTTPS加密通信。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>特别是每当那些访问量较多的Web网站在进行加密处理时，它们所承担着的负载不容小觑。在进行加密处理时，并非对所有内容都进行加密处理，而是仅在那些需要信息隐藏时才会加密，以节约资源。</p>
</blockquote>
</blockquote>
<h3 id="◆-11-1-针对web的攻击技术" tabindex="-1"><a class="header-anchor" href="#◆-11-1-针对web的攻击技术" aria-hidden="true">#</a> ◆ 11.1 针对Web的攻击技术</h3>
<blockquote>
<blockquote>
<p>在HTTP请求报文内加载攻击代码，就能发起对Web应用的攻击。通过URL查询字段或表单、HTTP首部、Cookie等途径把攻击代码传入，若这时Web应用存在安全漏洞，那内部信息就会遭到窃取，或被攻击者拿到管理权限。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>主动攻击（active attack）是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>被动攻击（passive attack）是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标Web应用访问发起攻击。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>被动攻击通常的攻击模式如下所示。步骤1： 攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌入攻击代码的HTTP请求。步骤2： 当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。步骤3： 中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码。步骤4： 执行完攻击代码，存在安全漏洞的Web应用会成为攻击者的跳板，可能导致用户所持的Cookie等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>利用被动攻击，可发起对原本从互联网上无法直接访问的企业内网等网络的攻击。只要用户踏入攻击者预先设好的陷阱，在用户能够访问到的网络范围内，即使是企业内网也同样会受到攻击。</p>
</blockquote>
</blockquote>
<h3 id="◆-11-2-因输出值转义不完全引发的安全漏洞" tabindex="-1"><a class="header-anchor" href="#◆-11-2-因输出值转义不完全引发的安全漏洞" aria-hidden="true">#</a> ◆ 11.2 因输出值转义不完全引发的安全漏洞</h3>
<blockquote>
<blockquote>
<p>实施Web应用的安全对策可大致分为以下两部分。●客户端的验证●Web应用端（服务器端）的验证○ 输入值验证○ 输出值转义</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>多数情况下采用JavaScript在客户端验证数据。可是在客户端允许篡改数据或关闭JavaScript，不适合将JavaScript验证作为安全的防范对策。保留客户端验证只是为了尽早地辨识输入错误，起到提高UI体验的作用。Web应用端的输入值验证按Web应用内的处理则有可能被误认为是具有攻击性意义的代码。输入值验证通常是指检查是否是符合系统业务逻辑的数值或检查字符编码等预防对策。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>浏览器打开该URI后，直观感觉没有发生任何变化，但设置好的脚本却偷偷开始运行了。当用户在表单内输入ID和密码之后，就会直接发送到攻击者的网站（也就是hackr.jp），导致个人登录信息被窃取。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>之后，ID及密码会传给该正规网站，而接下来仍然是按正常登录步骤，用户很难意识到自己的登录信息已遭泄露。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>SQL注入（SQL Injection）是指针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击。该安全隐患有可能引发极大的威胁，有时会直接导致个人信息及机密信息的泄露。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>SQL注入攻击有可能会造成以下等影响。●非法查看或篡改数据库内的数据●规避认证●执行和数据库服务器业务关联的程序等</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>OS命令注入攻击（OS Command Injection）是指通过Web应用，执行非法的操作系统命令达到攻击的目的。只要在能调用Shell函数的地方就有存在被攻击的风险。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>可以从Web应用中通过Shell来调用操作系统命令。倘若调用Shell时存在疏漏，就可以执行插入的非法OS命令。OS命令注入攻击可以向Shell发送命令，让Windows或Linux操作系统的命令行启动程序。也就是说，通过OS注入攻击可执行OS上安装着的各种程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>向首部主体内添加内容的攻击称为HTTP响应截断攻击</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>HTTP首部注入攻击有可能会造成以下一些影响。●设置任何Cookie信息●重定向至任意URL●显示任意的主体（HTTP响应截断攻击）■HTTP首部注入攻击案例</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>HTTP响应截断攻击HTTP响应截断攻击是用在HTTP首部注入的一种攻击。攻击顺序相同，但是要将两个%0D%0A%0D%0A并排插入字符串后发送。利用这两个连续的换行就可作出HTTP首部与主体分隔所需的空行了，这样就能显示伪造的主体，达到攻击目的。这样的攻击叫做HTTP响应截断攻击。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>滥用HTTP/1.1中汇集多响应返回功能，会导致缓存服务器对任意内容进行缓存操作。这种攻击称为缓存污染。使用该缓存服务器的用户，在浏览遭受攻击的网站时，会不断地浏览被替换掉的Web网页。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>目录遍历（Directory Traversal）攻击是指对本无意公开的文件目录，通过非法截断其目录路径后，达成访问目的的一种攻击。这种攻击有时也称为路径遍历（Path Traversal）攻击。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通过Web应用对文件处理操作时，在由外部指定文件名的处理存在疏漏的情况下，用户可使用．../等相对路径定位到/etc/passed等绝对路径上，因此服务器上任意的文件或文件目录皆有可能被访问到。这样一来，就有可能非法浏览、篡改或删除Web服务器上的文件。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>远程文件包含漏洞（Remote File Inclusion）是指当部分脚本内容需要从其他文件读入时，攻击者利用指定外部服务器的URL充当依赖文件，让脚本读取之后，就可运行任意脚本的一种攻击。这主要是PHP存在的安全漏洞，对PHP的include或require来说，这是一种可通过设定，指定外部服务器的URL作为文件名的功能。但是，该功能太危险，PHP5.2.0之后默认设定此功能无效。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>下面以include读入由查询字段指定文件的功能为例，讲解远程文件包含漏洞。该功能可通过以下查询字段形式指定文件名，并在脚本内的include语句处读入这个指定文件。</p>
</blockquote>
</blockquote>
<h3 id="◆-11-3-因设置或设计上的缺陷引发的安全漏洞" tabindex="-1"><a class="header-anchor" href="#◆-11-3-因设置或设计上的缺陷引发的安全漏洞" aria-hidden="true">#</a> ◆ 11.3 因设置或设计上的缺陷引发的安全漏洞</h3>
<blockquote>
<blockquote>
<p>强制浏览有可能会造成以下一些影响。●泄露顾客的个人信息等重要情报●泄露原本需要具有访问权限的用户才可查阅的信息内容●泄露未外连到外界的文件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>直接通过URL访问原本必须经过认证才能在Web页面上使用的文件（HTML文件、图片、PDF等文档、CSS以及其他数据等）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>即使没有对这篇日记的访问权限，只要知道这图片的URL，通过直接指定URL的方式就能显示该图片。日记的功能和文本具有访问对象的控制，但不具备对图片访问对象的控制，从而产生了安全漏洞。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>不正确的错误消息处理（Error Handling Vulnerability）的安全漏洞是指，Web应用的错误信息内包含对攻击者有用的信息。与Web应用有关的主要错误信息如下所示。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>●Web应用抛出的错误消息●数据库等系统抛出的错误消息Web应用不必在用户的浏览画面上展现详细的错误消息。对攻击者来说，详细的错误消息有可能给他们下一次攻击以提示。■不正确的错误消息处理导致安全漏洞的案例</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>开放重定向（Open Redirect）是一种对指定的任意URL作重定向跳转的功能。而与此功能相关联的安全漏洞是指，假如指定的重定向URL到某个具有恶意的Web网站，那么用户就会被诱导至那个Web网站。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>可信度高的Web网站如果开放重定向功能，则很有可能被攻击者选中并用来作为钓鱼攻击的跳板。</p>
</blockquote>
</blockquote>
<h3 id="◆-11-4-因会话管理疏忽引发的安全漏洞" tabindex="-1"><a class="header-anchor" href="#◆-11-4-因会话管理疏忽引发的安全漏洞" aria-hidden="true">#</a> ◆ 11.4 因会话管理疏忽引发的安全漏洞</h3>
<blockquote>
<blockquote>
<p>下面列举了几种攻击者可获得会话ID的途径。●通过非正规的生成方法推测会话ID●通过窃听或XSS攻击盗取会话ID●通过会话固定攻击（Session Fixation）强行获取会话ID</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>会话劫持攻击案例</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>攻击者在得知该Web网站存在可跨站攻击（XSS）的安全漏洞后，就设置好用JavaScript脚本调用document.cookie以窃取Cookie信息的陷阱，一旦用户踏入陷阱（访问了该脚本），攻击者就能获取含有会话ID的Cookie。攻击者拿到用户的会话ID后，往自己的浏览器的Cookie中设置该会话ID，即可伪装成会话ID遭窃的用户，访问Web网站了。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>下面我们以认证功能为例讲解会话固定攻击。这个Web网站的认证功能，会在认证前发布一个会话ID，若认证成功，就会在服务器内改变认证状态。[插图]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>Session AdoptionSession Adoption是指PHP或ASP.NET能够接收处理未知会话ID的功能。恶意使用该功能便可跳过会话固定攻击的准备阶段，从Web网站获得发行的会话ID的步骤。即，攻击者可私自创建会话ID构成陷阱，中间件却会误以为该会话ID是未知会话ID而接受。</p>
</blockquote>
</blockquote>
<h3 id="◆-11-5-其他安全漏洞" tabindex="-1"><a class="header-anchor" href="#◆-11-5-其他安全漏洞" aria-hidden="true">#</a> ◆ 11.5 其他安全漏洞</h3>
<blockquote>
<blockquote>
<p>点击劫持（Clickjacking）是指利用透明的按钮或链接做成陷阱，覆盖在Web页面之上。然后诱使用户在不知情的情况下，点击那个链接访问内容的一种攻击手段。这种行为又称为界面伪装（UI Redressing）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>已设置陷阱的Web页面，表面上内容并无不妥，但早已埋入想让用户点击的链接。当用户点击到透明的按钮时，实际上是点击了已指定透明属性元素的iframe页面。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>DoS攻击（Denial of Service attack）是一种让运行中的服务呈停止状态的攻击。有时也叫做服务停止攻击或拒绝服务攻击。DoS攻击的对象不仅限于Web网站，还包括网络设备及服务器等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>主要有以下两种DoS攻击方式。● 集中利用访问请求造成资源过载，资源用尽的同时，实际上服务也就呈停止状态。●通过攻击安全漏洞使服务停止。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>其中，集中利用访问请求的DoS攻击，单纯来讲就是发送大量的合法请求。服务器很难分辨何为正常请求，何为攻击请求，因此很难防止DoS攻击。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>多台计算机发起的DoS攻击称为DDoS攻击（DistributedDenial of Service attack）。DDoS攻击通常利用那些感染病毒的计算机作为攻击者的攻击跳板。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通常的后门程序分为以下3种类型。●开发阶段作为Debug调用的后门程序●开发者为了自身利益植入的后门程序●攻击者通过某种方法设置的后门程序</p>
</blockquote>
</blockquote>
</div></template>


