<template><div><h1 id="计算机组成与操作系统" tabindex="-1"><a class="header-anchor" href="#计算机组成与操作系统" aria-hidden="true">#</a> 计算机组成与操作系统</h1>
<p>王玉娟主编</p>
<h3 id="◆-1-2-计算机系统的组成" tabindex="-1"><a class="header-anchor" href="#◆-1-2-计算机系统的组成" aria-hidden="true">#</a> ◆ 1.2 计算机系统的组成</h3>
<blockquote>
<blockquote>
<p>计算机系统的层次结构通常由5个以上不同的级别组成，每一级都能进行程序设计</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第1级是微程序设计级。这是一个实在的硬件级，它由机器硬件直接执行微指令。如果某一个应用程序直接用微指令来编写，那么可在这一级上运行该应用程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第2级是一般机器级，也称为机器语言级。这一级由微程序解释机器指令系统，也是硬件级。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第3级是操作系统级，它由操作系统程序实现。这些操作系统程序由机器指令和广义指令组成。广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第4级是汇编语言级，它给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行。如果应用程序采用汇编语言编写，则机器必须要有这一级的功能；如果应用程序不采用汇编语言编写，则这一级可以不要。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第5级是高级语言级，它是面向用户的，为方便用户编写应用程序而设置。这一级由各种高级语言编译程序支持和执行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机硬件系统是指构成计算机的所有实体部件的集合，通常这些部件由电子元器件、导线、机械装置等物理部件组成，它们都是看得见、摸得到的。计算机硬件主要由5大部件组成，即运算器、控制器、存储器、输入设备和输出设备，其中包含接口和其他外部设备。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通常将运算器和控制器称为中央处理器（CentralProcessing Unit，CPU），CPU和存储器一起称为主机，而输入设备和输出设备均称为外围设备。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.计算机的主要部件（1）运算器。运算器是计算机的数据加工处理部件，它的主要功能是进行算术运算和逻辑运算。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>运算器通常由算术逻辑运算部件（Arithmetic Logical Unit，ALU）、通用寄存器组或累加器以及数据传送逻辑电路等组成</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算术逻辑运算部件ALU可以完成算术运算和逻辑运算，其核心部分是加法器。寄存器组或累加器可以暂存数据，一个寄存器可以存放一个数据。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）控制器。控制器是统一指挥和控制计算机各部件工作的中央机构，它的主要功能是按照人们预先确定的操作步骤，控制整个计算机的各部件协调地进行工作。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>控制器主要由指令部件、时序部件、控制信号形成部件组成</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>控制器从内存储器中逐条地取出指令，并对该指令进行译码，产生相应的操作信号，控制计算机完成指令所规定的操作。时序部件用来产生各种时序信号，协调计算机的各部件有条不紊地工作。控制信号形成部件是控制器的核心，用来产生计算机工作时所需要的控制信号。可以用两种方式产生控制信号：一种是组合逻辑电路的方法，另一种是微程序技术。目前主要采用第二种方式产生计算机信号。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）存储器。存储器是计算机用来存放程序和数据的部件，具有“记忆”功能。它的基本功能是按照指定的存储位置“读出”或“写入”信息。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>存储器主要由地址寄存器、数据寄存器、存储体及读/写控制电路等组成</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>地址寄存器中保存“读/写”数据的存储单元地址，数据寄存器中保存要进行“读/写”的数据。存储体中包含若干个存储单元，存储单元可以存放一个数据或一条指令。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>存储器有读出和写入两个基本操作。不论进行哪一种操作，都应该事先知道存储单元的地址。为了区分存储体中的存储单元，要求为每个存储单元进行编号，这个编号就称为存储单元地址。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机中，表示信息的最小单位是位（bit），1位可以表示二进制数“1”或“0”。我们将8位二进制数构成的单位称为1个字节（Byte），存储信息的最小单位是字节。将1个或n个字节构成的整体称为1个字（Word），1个存储单元可以存放1个字。若存储单元的地址按照存储器中“字”的个数进行编址，称为字地址；若存储单元的地址按照存储器中“字节”的个数进行编址，则称为字节地址。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>存储器分为内存储器（内存）和外存储器（外存）。内存由半导体器件RAM和ROM构成，用来存放CPU正在执行的指令和数据；外存由磁性材料等构成，用来存放暂时不执行的程序和数据，常用的外存有软盘、硬盘、光盘、U盘和磁带机等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）输入设备。输入设备的任务是将人们编制好的程序和原始数据送到计算机中。其功能就是将它们转换成计算机能够识别的电信号，并将这些电信号存放到计算机的存储器中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>常用的输出设备有显示器、打印机、绘图仪、刻录机等。输出设备与主机之间也需要通过设备接口进行连接。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>将计算机基本组成的5个部件，用一组导线按照某种方式连接起来，就构成了计算机的硬件系统，这一组导线称为总线（Bus），其中包括地址总线、数据总线和控制总线。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在计算机中采用总线结构，可以减少信息传送线的数目，还可以提高计算机扩充内存和外设的灵活性。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>介绍3种常用的总线结构。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）单总线结构。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）双总线结构。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）多总线结构</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机软件系统主要包括系统软件、程序设计语言和应用软件。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>系统软件是指为了方便用户使用计算机和充分发挥计算机的效率，向用户提供的一系列软件，其中包括操作系统、语言处理程序、支持软件等。系统软件的作用是对计算机系统进行管理、调度、监控和维护，提供程序的运行和开发环境，向用户提供各种服务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>根据操作系统提供给用户的工作环境的不同来进行分类.可将操作系统分成单用户操作系统、多道批处理系统、分时系统、实时系统、网络操作系统和分布式操作系统等多种</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>语言处理程序包括汇编程序、编译程序、解释程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>汇编程序是将用汇编语言书写的源程序翻译成用二进制代码“0”或“1”表示的机器语言，形成了计算机可执行的机器指令代码。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>编译程序是将用高级语言书写的源程序翻译成等价的机器语言程序，最终产生了一个可以在计算机上执行的目标程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>解释程序是将用高级语言书写的源程序分段地转换为相同功能的指令序列，并且执行这段等价的指令序列，即边解释边执行，没有产生目标程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>用汇编语言编写的程序，计算机不能直接识别，需要有一种翻译程序将其翻译成机器语言程序（二进制代码），然后计算机方可执行，这样的过程称为“汇编”。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机不能直接执行用高级语言编写的源程序，必须经过编译程序或解释程序对高级语言源程序进行翻译，计算机才能识别并执行。由于用高级语言编写的源程序不依赖于具体的计算机硬件，因此具有较好的通用性和可移植性。</p>
</blockquote>
</blockquote>
<h3 id="◆-1-3-计算机的基本工作原理" tabindex="-1"><a class="header-anchor" href="#◆-1-3-计算机的基本工作原理" aria-hidden="true">#</a> ◆ 1.3 计算机的基本工作原理</h3>
<blockquote>
<blockquote>
<p>冯·诺依曼计算机的主要特点描述如下。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.采用二进制表示数据和指令</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>数据和指令在代码的外形上没有区别，都是由“1”和“0”组成的代码序列，只是各自约定的含义不同而已。采用二进制便于电子器件的实现，运算规则简单，抗干扰能力强，可靠性高。二进制的“1”、“0”正好与逻辑推理中的“真”、“假”相对应，便于计算机进行逻辑运算。数字技术就是用“1”和“0”来表示、处理、存储、传输信息的技术，便于信息数字化。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.存储程序工作方式</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>存储程序工作方式是冯·诺依曼思想的核心内容。所谓存储程序工作方式，就是将事先编制好的程序（包含指令和数据）存入内存中，计算机在运行程序时自动、连续地从内存中依次取出机器指令并解释执行（对内存中的存储单元进行一维线性编址，按照存储单元地址存取指令，从内存中逐条取出指令并且串行执行），直至程序执行结束。这也是计算机能够高速自动运行的基础。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.计算机由5大部件组成</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机硬件由控制器、运算器、存储器、输入设备和输出设备组成，使用总线将5大部件连接在一起，并且规定了5大部件的功能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机的主要性能指标</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.机器字长</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>机器字长是指CPU一次能够处理二进制数据的位数，它标志着计算机的计算精度。机器字长越长，计算精度越高。机器的字长也会影响机器的运算速度。倘若CPU字长较短，又要运算位数较多的数据，那么需要经过两次或多次的运算才能完成，这样势必影响整机的运行速度。机器字长还决定了寄存器、运算器和数据总线等部件的位数，因此它直接影响到硬件的价格。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>现代计算机的机器字长一般都是8位的整数倍，如16位、32位、64位和128位等，即字长由2字节、4字节、8字节或16字节组成，所以也可用“字节”来表示机器字长。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.内存容量</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>内存的存储单元个数之和被称为内存容量，而存储单元的编址方法可以以“字（Word）”为单位，也可以以“字节（Byte）”为单位。一般情况下，计算机的内存容量是以“字节”为单位进行编址的。如果存储单元的地址码用16位二进制表示，那么其内存容量为216B，习惯上将210＝1024称为1K，1MB＝1024KB，1GB＝1024MB，1TB＝1024GB，因而216B是64KB。计算机的内存容量越大，所存储的信息就越多，处理问题的能力就越强。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.运算速度</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机的运算速度与许多因素有关，如计算机的主频、执行什么操作、内存的工作速度等。计算机执行不同的机器指令需要不同的时间，通常用执行各种指令的平均时间来描述运算速度，现在一般采用MIPS（Million Instruction Per Second）作为运算速度的计量单位，其含义是每秒执行100万条指令，10MIPS就是每秒执行1000万条指令。对于相同类型的计算机，可以用CPU的时钟频率来比较它们的运算速度，频率越高，执行每个操作的时间越短，计算机的运算速度就越高。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.外围设备的配置</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5.系统软件的配置</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>6.性能价格比</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>因为既要考虑计算机的性能（如计算机的系统结构、硬件组成、外设配置、软件种类等），又要考虑计算机的价格，性价比的值大，表明计算机的性能好而价格低。每一个用户都希望性价比大。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>7.可靠性、可用性和可维修性</p>
</blockquote>
</blockquote>
<h3 id="◆-1-4-计算机的分类与应用" tabindex="-1"><a class="header-anchor" href="#◆-1-4-计算机的分类与应用" aria-hidden="true">#</a> ◆ 1.4 计算机的分类与应用</h3>
<blockquote>
<blockquote>
<p>计算机加工处理的对象是信息，而这些信息在计算机中是用二进制编码表示的，由此可见数据的精度取决于表示信息的编码位数。计算机内部采用浮点数表示，而且计算机的字长从16位、32位增加到64位甚至更长；为了获得更高的精度，还可以采用双倍字长参加运算。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机内部设有一种具有记忆功能的装置——存储器，内存用来存储正在运行中的程序和数据，外存用来存储需要长期保存的程序和数据，并且能准确、快速地写入或读出信息。目前微型计算机的内存容量一般是2GB，硬盘容量是512GB，能够大量存储原始数据和程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机除了应用于工业生产之外，还被广泛应用于国防、交通等行业的过程控制中，例如飞机模拟训练、城市交通管理、火车调度等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>利用微型机控制锅炉温度，与人工操作相比，不但实时性和可靠性得到了很大提高，而且解放了劳动力，人身安全也得到了保障。尤其是单片机的应用，给日常生活带来了极大的方便，例如用单片机控制空调、电冰箱、洗衣机、微波炉等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机网络一般分为广域网（Wide Area Network，WAN）、城域网（MetropolitanArea Network，MAN）和局域网（Local Area Network，LAN）三种。</p>
</blockquote>
</blockquote>
<h3 id="◆-1-5-操作系统的概念" tabindex="-1"><a class="header-anchor" href="#◆-1-5-操作系统的概念" aria-hidden="true">#</a> ◆ 1.5 操作系统的概念</h3>
<blockquote>
<blockquote>
<p>计算机系统中的主要硬件有CPU（运算器和控制器）、内存、磁盘以及键盘、显示器、磁盘驱动器、打印机和网络接口等形形色色的外部设备。在计算机系统内运行的各个程序为了各自的“利益”，无时无刻不在争夺这些有限的资源。操作系统的作用就类似于城市交通的决策、指挥、控制和调度中心，它组织和管理整个计算机系统的硬件和软件资源，在用户和程序之间分配系统资源，使之协调一致地、高效地完成各种复杂的任务。</p>
</blockquote>
</blockquote>
<h3 id="◆-1-6-操作系统的形成与发展" tabindex="-1"><a class="header-anchor" href="#◆-1-6-操作系统的形成与发展" aria-hidden="true">#</a> ◆ 1.6 操作系统的形成与发展</h3>
<blockquote>
<blockquote>
<p>多道程序设计技术是指在内存中驻留多个作业，外存中存放的作业形成等待队列。当某作业处理结束或因某种原因不能运行时，系统根据一定的调度原则从外存中调入几个作业进入内存，让它们交替进行，使得处理机充分利用。这种处理方式在单处理机系统中，从微观上来看只能交替运行，而宏观上可以认为它们是并行的。将多道程序技术引入批处理系统就形成了一个多道批处理系统。现代计算机上的批处理系统，多为多道批处理系统。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在批处理系统中采用多道程序设计技术，它的特点是：（1）多道性：在内存中允许驻留多道相互独立的程序。（2）并行性：多道程序并行执行，即它们先后开始了各自的运行，但都未运行完毕。从而有效地提高了资源利用率和系统的吞吐量。（3）串行性：多道程序轮流使用CPU，交替执行。（4）无序性：多道程序执行的先后顺序与它们进入内存的时间无严格的对应性，也许先进入内存的程序后完成，而后进入内存的程序先完成。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>批处理系统克服了手工操作的缺点，实现了作业自动过渡，改善了CPU和输入/输出设备的使用情况。但在进行批处理的过程中，监督程序、系统程序和用户程序之间存在着一种调用关系，任何一个环节出问题，整个系统就停止运行，用户程序也可能会破坏监督程序和系统程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>随着CPU速度的提高，系统规模的扩大，CPU与I/O设备之间速度不匹配的矛盾日渐突出。为了缓和此矛盾，20世纪60年代初，出现了通道技术和中断技术。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通道使CPU从繁忙的控制工作中解脱出来，又能使其接受CPU的控制，不必由人工干预，既快又安全。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>所谓通道，实质是一台功能单一、结构简单的I/O处理机，它独立于CPU，并直接控制外部设备与主机之间的信息传送。当需要进行I/O时，CPU启动通道，之后CPU继续执行其他程序，通道就可以独立工作，通道执行通道程序，完成外部设备的启动、关闭以及信息传输等操作；在传送规定的数据后，它才向CPU发出一次中断请求，CPU终止正在运行的程序，进行中断处理，处理完后，返回中断点继续工作。中断是指主机接到外部信号，如外部设备完成一个预定的I/O操作过程的信号，它就要求主机暂停正在执行的工作，转而对它进行必要的处理（如检查I/O过程中是否发生过某种错误等），处理完后，主机再回到原中断点继续工作。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通道和中断技术的出现使得硬件有了并行处理的能力，同时也为软件的发展提供了物质基础。通道技术大大减轻了主机处理输入/输出及管理外部设备的负担，使主机集中时间完成复杂的计算任务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>所谓分时系统就是在主机上连接多台终端，用户在自己的办公室，通过自己的终端就可上机。分时系统之所以得到广泛的应用：原因一，它方便用户使用，用户可在自己的终端上提交作业；原因二，它以交互的方式直接控制作业的运行；原因三，多个用户以分时的方式共享主机，用户感觉不到其他用户的存在，好像自己独占主机一样。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>操作系统的形成至今已有50多年的历史，20世纪50年代中期出现的第一个简单批处理操作系统，到20世纪60年代中期产生的多道程序技术，不久又出现了分时操作系统。多道程序的引入和分时系统的出现标志着操作系统走向成熟。</p>
</blockquote>
</blockquote>
<h3 id="◆-1-7-操作系统的基本特征" tabindex="-1"><a class="header-anchor" href="#◆-1-7-操作系统的基本特征" aria-hidden="true">#</a> ◆ 1.7 操作系统的基本特征</h3>
<blockquote>
<blockquote>
<p>操作系统的4个基本特征</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.并发性（Concurrence）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>并发性是指两个或多个事件在同一时间间隔内发生。在多道程序环境下，并发性是指宏观上在一段时间内有多道程序在同时运行，但微观上看，在单处理机系统中，每一时刻只能执行一道程序，所以这些程序是在同一时间间隔内交替执行。在多处理机系统中，并发程序不仅在宏观上是并发的，而且在微观上也是并行运行的。在分布式系统中，多台计算机并存，使程序的并发特征得到更充分的体现。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>并行是指两个或多个事件在同一时刻发生，而并发是指两个或多个事件在同一时间间隔内发生。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.共享性（Sharing）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>资源共享是指系统中的软/硬件资源不再为某个程序所独占，而是供多个应用程序共同使用。操作系统要在多个并发程序间通过调度来分配处理器时间，并且保证对系统数据共享的正确性以及数据的完整性。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>根据资源的属性不同，共享可分为互斥共享和同时共享两种方式。互斥共享是指系统中的资源虽能提供给多个进程使用，但在一段时间内却只允许一个进程访问该资源。同时共享允许在一段时间内，由多个进程同时对资源进行访问。当然，“同时”仍然是宏观上的，微观上，这些进程可能是交替地对该资源进行访问。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.虚拟性（Virtual）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>虚拟是指将一个物理的实体映射为若干个逻辑实体。物理实体是客观存在的，逻辑实体是用户感觉上存在的，即主观上的一种想象。虚拟的例子在操作系统中有很多，如在多道程序系统中，即使只有一个处理机，每次只能执行一道程序，但在采用多道程序设计技术后，在一段时间间隔内，宏观上看起来有多个程序运行。在用户看来，就好像有多个处理机在各自运行自己的程序。即将一个物理上的处理机虚拟为多个逻辑上的处理机，即多个虚拟处理机。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.不确定性</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在操作系统中，不确定性有以下两种表现。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）程序执行结果的不确定，程序执行结果的不可再现。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）多道程序设计环境下，每道程序在何时执行，各自执行的程序以及每道程序所需的时间是不确定的，也是不可预知的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>操作系统必须能处理随时可能发生的事件，如从外部设备来的中断，输入/输出请求。程序运行时发生故障的类型及发生的时间等也都是不可预测的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>操作系统应保证只要运行环境相同，程序多次运行都会获得完全相同的结果，这种进程的异步性是操作系统的一个重要特征。</p>
</blockquote>
</blockquote>
<h3 id="◆-1-8-操作系统的主要功能及性能评价" tabindex="-1"><a class="header-anchor" href="#◆-1-8-操作系统的主要功能及性能评价" aria-hidden="true">#</a> ◆ 1.8 操作系统的主要功能及性能评价</h3>
<blockquote>
<blockquote>
<p>计算机系统的主要硬件资源有处理机、内存储器、外存储器、输入/输出设备。软件和信息资源往往以文件形式存储在外存储器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5个方面来说明操作系统的基本功能</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.处理机管理</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在单道作业或单用户的情况下，处理机为一个作业或一个用户所独占，对处理机的管理十分简单。但在多道程序或多用户的情况下，要组织多个作业同时运行，就要解决对处理机分配调度策略、分配实施和资源回收等问题，这就是处理机管理功能。正是由于操作系统对处理机管理策略的不同，其提供的作业处理方式也就不同（如成批处理方式、分时处理方式和实时处理方式），从而呈现在用户面前，成为具有不同性质功能的操作系统。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.存储管理</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>存储管理的主要工作是对内部存储器进行分配、保护和扩充。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）内存分配。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如何分配内存，以保证系统及各用户程序的存储区互不冲突，这就是内存分配所要解决的问题。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）存储保护。系统中有多个程序在运行，如何保证一道程序在执行过程中不会有意或无意地破坏另一道程序？如何保证用户程序不会破坏系统程序？这就是存储保护问题。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）内存扩充。当用户作业所需要的内存量超过计算机系统所提供的内存容量时，如何把内部存储器和外部存储器结合起来管理，为用户提供一个容量比实际内存大得多的虚拟存储器，而用户使用这个虚拟存储器和使用内存一样方便，这就是内存扩充所要完成的任务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.设备管理</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>设备管理主要解决以下问题：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）设备独立性。用户向系统申请和使用的设备与实际操作的设备无关，即在用户程序中或在资源申请命令中使用设备的逻辑名，此即为设备独立性。这一特征不仅为用户使用设备提供了方便，而且也提高了设备的利用率。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）设备分配。各个用户程序在其运行的开始、中间或结束时都可能有输入或输出，因此随时需要请求使用外部设备。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对设备分配通常有三种基本技术，即独享、共享及虚拟技术。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）设备的传输控制。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.文件管理</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>把程序和数据统称为信息或文件。一个文件在暂时不用时，就被放到外部存储器（如磁盘、磁带、光盘等）上保存起来。这样，外存上保存了大量的文件。对这些文件如不能很好管理，就会引起混乱，甚至遭受破坏。这就是管理信息文件需要解决的问题。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>信息的共享、保密和保护，也是文件系统所要解决的问题。如果系统允许多个用户协同工作，那么就应该允许用户共享信息文件。但这种共享应该是受控制的，应该有授权和保密机制。还要有一定的保护机制以免文件被非授权用户调用和修改，即使在意外情况下，如系统失效、用户对文件使用不当，也能尽量保护信息免遭破坏，也就是说，系统是安全可靠的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5.用户接口</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>操作系统提供两种方式的接口来和用户发生关系，为用户服务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一种用户接口是程序一级的接口，即提供一组广义指令（或称系统调用、程序请求）供用户程序和其他系统程序调用。当这些程序要求进行数据传输、文件操作或有其他资源要求时，通过这些广义指令向操作系统提出申请，并由操作系统代为完成。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>另一种接口是作业一级的接口，提供一组控制操作命令（或称作业控制语言，或像UNIX中的Shell命令语言）供用户去组织和控制自己作业的运行。作业控制方式可以分为两大类：脱机控制和联机控制。操作系统提供脱机控制作业语言和联机控制作业语言。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>效率是操作系统的一个重要性能指标。一般由4个参数来衡量系统的效率。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）系统的吞吐量：即在单位时间内系统处理作业的数量。吞吐量越大，系统的效率越高。（2）资源利用率：即系统中各部件的使用程度。资源利用率越高越好。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）批处理系统的作业周转时间：作业从进入系统开始到执行完成退出系统为止的时间间隔称为该作业的周转时间。作业周转时间越短越好。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）响应时间：从用户向系统发出请求到获得系统的应答所需的时间。响应时间越短越好。</p>
</blockquote>
</blockquote>
<h3 id="◆-1-9-操作系统的类型" tabindex="-1"><a class="header-anchor" href="#◆-1-9-操作系统的类型" aria-hidden="true">#</a> ◆ 1.9 操作系统的类型</h3>
<blockquote>
<blockquote>
<p>可将操作系统分成单用户操作系统、多道批处理系统、分时系统、实时系统、网络操作系统、分布式操作系统和嵌入式操作系统。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分时系统是在多道批处理系统基础上发展起来的。在分时系统中，用户通过计算机交互会话来联机控制自己的作业运行。一个分时系统可以带几十个甚至上百个终端，每个用户都可以在自己的终端上操作或控制作业的运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>所谓“分时”，是指将CPU的时间划分成长短相同（或基本相同）的时间段，称为时间片，通过操作系统的管理，把这些时间片依次轮流地分配给各个用户使用，如果某个用户作业在时间片结束时，整个任务尚未完成，那么该作业被迫暂停下来，释放出CPU等待下一轮的时间片再继续执行，此时CPU又分配给下一个用户作业。由于计算机的处理速度很快，只要时间片的间隔取得适当，那么一个用户作业从用完分配给它的一个时间片到得到下一个时间片，中间虽然有一个“等待间隔”，但用户难以察觉，好像整个系统全由用户独占一样。向用户提供这样的工作环境，使计算机具有这种特征的操作系统，称为分时操作系统。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分布式操作系统具有的特点</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）系统处理能力强。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）处理速度大为提高。分布式操作系统可将要运行的作业分布到若干处理机上并发执行，运行速度明显提高。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）可靠性高。当系统中某台处理机由于软、硬件故障不能正常工作时，其他处理机能兼顾这台处理机的工作，使得整个系统能够正常运行。一旦失效的处理机得以修复，操作系统能将它立即添加到系统中，并使整个系统均衡工作。</p>
</blockquote>
</blockquote>
<h2 id="◆-第2章-处理机管理" tabindex="-1"><a class="header-anchor" href="#◆-第2章-处理机管理" aria-hidden="true">#</a> ◆ 第2章 处理机管理</h2>
<blockquote>
<blockquote>
<p>处理机包括运算器和控制器两部分。运算器对数据进行算术运算和逻辑运算，控制器是计算机的指挥和控制中心。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在处理机管理中，进程是一个非常重要的概念。进程是可以作为资源分配和独立运行的基本单位。操作系统所具有的基本特征也是基于进程而形成的。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-1-处理机分类" tabindex="-1"><a class="header-anchor" href="#◆-2-1-处理机分类" aria-hidden="true">#</a> ◆ 2.1 处理机分类</h3>
<blockquote>
<blockquote>
<p>处理机除了CPU之外，还有MPU（Micro Processor Unit，微处理器单元）、MCU（Micro Controller Unit，微控制器单元）和DSP（Digital Signal Processing/Processor，数字信号处理）。其中后三种处理器主要用于嵌入式系统中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.MPUMPU的基础是CPU，主要应用在嵌入式系统中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>MCU又称单片机，顾名思义，就是将整个计算机系统集成到一块芯片中。MCU一般以某一种微处理器内核为核心，芯片内部集成ROM/EPROM、RAM、总线、总线逻辑、定时/计数器、Watchdog、I/O、串行口、A/D、D/A、Flash RAM、EEPROM等各种必要功能和外设。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>MCU和MPU相比，最大特点是单片化，体积大大减小，从而使功耗和成本下降、可靠性提高。MCU是目前嵌入式系统工业的主流。MCU的片上外设资源一般比较丰富，适合于控制，因此称为微控制器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>DSP处理器对系统结构和指令进行了特殊设计，使其适合于执行DSP算法，编译效率较高，指令执行速度也较快。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-2-cpu的功能" tabindex="-1"><a class="header-anchor" href="#◆-2-2-cpu的功能" aria-hidden="true">#</a> ◆ 2.2 CPU的功能</h3>
<blockquote>
<blockquote>
<p>只要把程序装入主存后，即可由计算机自动地完成取指令和执行指令的任务。计算机中完成这个任务的工作部件称为中央处理器（CPU）。它具有以下4个方面的基本功能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.指令控制</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>程序是顺序地执行指令，故称为指令控制。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>程序是指令的顺序集合，其指令的先后次序不能任意颠倒，必须严格地按规定的顺序执行</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>保证计算机按顺序执行程序（指令）是CPU的首要任务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.操作控制</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一条指令的功能通常是由若干个操作信号组合起来实现的。执行指令的微观过程就是完成一个相应的微操作序列。这些微操作的产生、组合、传送和管理，完全由CPU指挥和控制，从而协调各个功能部件按指令的要求完成任务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.时间控制</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对各种操作实施时间上的控制，称为时间控制。一方面，各种指令的操作信号均受到时间的严格控制；另一方面，一条指令的执行过程也受到时间的严格控制。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.数据加工</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>数据加工是指计算机对数据进行算术运算和逻辑运算，将原始数据加工处理成最终结果，这是CPU的根本任务。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-3-cpu的组成" tabindex="-1"><a class="header-anchor" href="#◆-2-3-cpu的组成" aria-hidden="true">#</a> ◆ 2.3 CPU的组成</h3>
<blockquote>
<blockquote>
<p>以前CPU主要由运算器和控制器两大部分组成</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>目前CPU芯片集成了一些其他逻辑功能部件来扩充CPU的功能，如浮点运算器、Cache和MMX等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在控制器的控制下逐条执行程序中指令的过程。在程序运行中，控制器对整个计算机进行控制，使各部件在规定的时刻执行相应的操作。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>控制器最基本的功能有两个：一是控制指令执行的顺序；二是控制每条指令的具体执行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>为了控制指令的执行顺序，CPU中设置了指令地址寄存器PC（即程序计数器），用它来存放指令的地址。在执行一条指令的同时，必须形成后续指令的地址，以便程序能继续运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>中断处理。即在程序运行中对于某些突发事件的紧急处理。当出现来自系统外部或计算机内部的任何异常或意外事件（如计算机出现故障、程序出现错误、外设请求、实时请求等）时，CPU可以暂停执行现行程序，转去处理这些事件，在这里需要改变PC的内容，而且要保留改变前的PC的内容，待处理完后再返回继续执行原被中断的程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一条指令的执行主要分为以下两个阶段：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>①从存储器取出指令。根据程序计数器PC的内容，向地址寄存器发出地址和读指令操作信号。取出现行指令后，为了正确执行该条指令，将取出的指令存放在控制器中专门设置的指令寄存器IR中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>②分析和执行指令。分析指令就是把指令寄存器中的现行指令进行译码。首先分析其操作码，为此需要设置操作码译码器，通过对操作码的分析，产生相应的控制电位，提供给控制信号形成部件；</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>控制器中应该设置控制信号形成部件，用来产生执行指令时所需要的各种微操作信号；还应该设置一个时序部件，用来产生定时信号，对各种微操作进行严格的时间控制。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>控制器大致可分为以下几部分。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）指令部件。指令部件的作用是完成取指令并分析指令，它由3个部分构成。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>①程序计数器（PC）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>指令寄存器（IR）。指令寄存器用来存放正在执行的指令。为了保证实现指令的全部功能，该寄存器中的内容在执行指令的过程中不允许发生变化。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>③指令译码器（ID）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）时序部件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）控制信号形成部件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>运算器由算术逻辑单元（ALU）、累加寄存器（AC）、数据缓冲寄存器（DR）和状态条件寄存器（PSW）组成，它是数据加工处理部件，完成计算机的各种算术和逻辑运算。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>运算器有两个主要功能：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）执行所有的算术运算，如加、减、乘、除等基本运算及附加运算。（2）执行所有的逻辑运算，并进行逻辑测试，如与、或、非、零值测试或两个值的比较等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>CPU中一般设置两类寄存器：通用寄存器和控制类寄存器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通用寄存器是在数据处理过程中可以被指定为不同用途的一组寄存器。为了提高处理数据的速度，CPU使用通用寄存器来临时存放地址和数据，由于CPU可以直接访问这些数据和地址，因此可以减少访问主存的次数，从而提高运算速度。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通用寄存器一般可以由程序编址访问，究竟设置多少个通用寄存器与指令系统的设计有关</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>控制类寄存器</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）程序计数器PC。在程序开始执行前，必须将程序的第一条指令所在的主存单元地址送入PC，即程序的起始地址；当执行指令时，CPU将自动修改PC的内容，使其保持的地址总是将要执行的下一条指令的地址；当程序发生转移时，PC接收转移地址。因此程序计数器的结构应该具有寄存信息和计数两种功能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）指令寄存器IR。指令寄存器用来存放当前正在执行的一条指令。通过译码器对指令的操作码部分进行译码，以便识别该指令所要求的操作，由控制器发出具体的操作控制信号序列。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）地址寄存器MAR。地址寄存器用来保存CPU所访问的主存单元的地址，通过MAR将主存单元地址发送到地址总线上。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）数据寄存器MDR。数据寄存器又称为输入/输出数据缓冲器。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-4-cpu的内部总线结构" tabindex="-1"><a class="header-anchor" href="#◆-2-4-cpu的内部总线结构" aria-hidden="true">#</a> ◆ 2.4 CPU的内部总线结构</h3>
<blockquote>
<blockquote>
<p>所谓内部总线是指连接CPU、寄存器和运算器之间的一条公共信息传送线路，它能分时地发送和接收各部件的信息。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-5-指令系统" tabindex="-1"><a class="header-anchor" href="#◆-2-5-指令系统" aria-hidden="true">#</a> ◆ 2.5 指令系统</h3>
<blockquote>
<blockquote>
<p>计算机的工作过程就是执行程序的过程，而程序是一组机器指令的有序集合。机器指令（以下简称为指令）就是计算机执行某种操作的命令。每一条指令规定计算机完成一定的功能，它是程序人员和计算机会话的最小单位。通常机器语言是由一系列的指令（语句）组成的，其语法就是指令的格式，这是计算机硬件能直接理解并执行的语言。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>指令的操作码表示该指令应该进行什么样的操作。不同的指令由不同的操作码来表示，每一种编码代表一条指令。若操作码长度为N位，则有2N种不同的操作。因此，操作码的位数决定着所能表示的操作种类信息。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>固定长度操作码是指指令的操作码部分所占的二进制位数固定不变。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>可变长度操作码是指指令的操作码部分所占的二进制位数是可变的，这是应用操作码扩展技术的结果。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-6-进程的基本概念" tabindex="-1"><a class="header-anchor" href="#◆-2-6-进程的基本概念" aria-hidden="true">#</a> ◆ 2.6 进程的基本概念</h3>
<blockquote>
<blockquote>
<p>操作系统的重要特征是并发和共享。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程是设计和分析操作系统的有力工具，只有以进程的观点去分析操作系统，才能理解操作系统是怎样进行管理和控制的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>程序是指令的有序集合，是一个在时间上按严格次序前后相继的操作序列，仅当前一个操作执行完后，才能执行后继操作，它是一个静态的概念。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>并发执行是为了增强计算机系统的处理能力和提高资源利用率所采取的一种同时操作技术。多道程序系统程序执行环境的变化可引起多道程序的并发执行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>程序并发执行结果产生了一些和程序顺序执行时不同的特性，这些特性概括起来可以分为下列几个方面：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）间断性。程序在并发执行时，由于它们共享硬件或软件资源，并且程序之间相互合作完成一项共同任务，因而使程序之间相互制约。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>程序的执行一般是非连续的，即呈现走走停停的状态，当现行执行程序需要等待某个事件时，系统就将CPU控制权转交给其他程序，当所等待的事件发生后，在以后的某个时刻，该程序可再次获得CPU。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）独立性。并发程序在运行过程中，既然是作为一个独立的运行实体，它也必然具有作为一个单位去获得资源的独立性，否则，必然无法独立运行。例如，一个接收进程，每当它要接收一批数据时，它必须申请相应数量的缓冲区，只要系统为它分配了其所需的缓冲区后，它便可以进行接收操作。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）通信性。对于相互合作的程序，为了更有效地协调运行，相互之间应进行通信。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）不可再现性。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程定义为：“可并发执行的程序在一个数据集上的一次执行过程，它是系统进行资源分配的基本单位”。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程应具有以下几个特征：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）动态性：动态性是进程的最基本的特征。进程是程序的一次执行过程，有一定的生命周期。它由创建而产生、由调度而执行，因得不到资源而暂停，并由撤销而死亡。而程序是静态的，是存放在介质上的一组有序指令的集合。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）并发性：并发性是进程的重要特征，同时也是操作系统的重要特征。并发性指多个进程实体同存于内存中，能在一段时间内同时运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）独立性：进程是一个能独立运行的基本单位，即一个独立获得资源和独立调度的单位，而程序不作为独立单位参加运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）异步性：进程按各自独立的不可预知的速度向前推进，即进程按异步方式进行</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（5）结构特征：为了体现进程的动态特性，进程实体由程序段、数据段和进程控制块（PCB）3部分组成，其中PCB模块记录了进程运行过程中的所有信息，是操作系统中最重要的数据结构。所谓创建进程，实质上是创建进程实体中的PCB；撤销进程，实质上是撤销进程的PCB。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-7-进程的状态及其组成" tabindex="-1"><a class="header-anchor" href="#◆-2-7-进程的状态及其组成" aria-hidden="true">#</a> ◆ 2.7 进程的状态及其组成</h3>
<blockquote>
<blockquote>
<p>一个进程至少可划分为3种基本状态</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）就绪状态。进程已获得了除处理机以外的所有资源，一旦获得处理机就可以立即执行，此时进程所处的状态为就绪状态。在系统中处于就绪状态的进程一般有多个，通常把这些进程排成一个队列组织起来，队列的排列次序一般按照进程优先级的大小来排序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）运行状态。当一个进程获得必要的资源并正在处理机上执行时，该进程所处的状态即为运行状态。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>处于运行状态的进程数一定小于或等于处理机的个数。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）阻塞状态。阻塞状态又称等待状态。正在执行的进程，由于发生某事件而无法往下继续执行（如等待输入/输出完成），此时进程所处的状态为阻塞状态。当进程处于阻塞状态时，即使把处理机分配给该进程，它也无法运行。所以阻塞进程不能参加竞争处理机。一般情况下，系统根据进程等待事件的原因不同，将进程排列成多个等待队列。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）就绪状态→运行状态。处于就绪状态的进程，它已具备了运行的条件，但由于未能获得处理机，故仍然不能运行。对于单处理机系统而言，处于就绪状态的进程往往不止一个，同一时刻只能有一个就绪进程获得处理机。进程调度程序根据调度算法（如优先级或时间片规定）把处理机分配给某个就绪进程，就建立该进程运行状态标记，并把控制转到该进程，把它由就绪状态变为运行状态，这样进程就投入运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）运行状态→就绪状态。这种状态变化通常出现在分时操作系统中，正在运行的进程由于规定的运行时间片用完而使系统发出超时中断请求，超时中断处理程序把该进程的状态修改为就绪状态，根据其自身的特征而插入到就绪队列的适当位置，保存进程现场信息，收回处理机并转入进程调度程序。于是，正在运行的进程就由运行状态变为就绪状态。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）运行状态→阻塞状态。处于运行状态的进程能否继续运行，除了受时间限制外，还受其他种种因素的影响。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）阻塞状态→就绪状态。被阻塞的进程在其被阻塞的原因获得解除后，并不能立即投入运行，因为，也许还有其他进程在等待处理机，于是将其状态由阻塞变成就绪，以等待处理机，仅当进程调度程序把处理机再次分配给它时，才可恢复当时阻塞前的现场继续运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在许多系统中，除了上述3种基本状态外，又增加了两种状态，创建状态和退出状态。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）创建状态。进程正在创建之中，还不能运行，此时进程所处的状态为创建状态。操作系统在创建进程时，要为进程分配PCB结构，填写相关内容；为进程分配进程组，连接进程的父子关系；为进程分配所需的资源；为进程建立地址空间，填写有关管理内存的表格；加载程序等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>当就绪队列接纳新创建的进程时，操作系统把处于创建状态的进程移入就绪队列，此时，进程从创建状态转化为就绪状态。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）退出状态。进程已正常或异常结束，释放了除进程控制块之外的其他资源，此时进程所处状态为退出状态。处于退出状态的进程仍然暂时停留在系统中，以便让其他相关进程从该退出进程的PCB中收集有关信息。例如，记账进程要了解该进程占用了多少CPU时间，使用了哪些类型的资源，以便记账。另外还要将退出代码传递给其父进程等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在某些系统中，为了更好地管理和调度进程及适应系统的功能目标，引入了挂起状态。进程的挂起主要是将进程从内存移到外存。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>为了管理和控制进程的运行，操作系统为每个进程定义了一个数据结构——进程控制块（Process Control Block，PCB），用于记录进程的属性信息。系统根据PCB而感知进程的存在，PCB是进程存在的唯一标志。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>PCB包含一个进程的描述信息、控制信息及资源信息，有些系统中还有进程调度等待所使用的现场保护区。PCB集中反映一个进程的动态特征。在进程并发执行时，由于资源共享，带来各进程之间的相互制约。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在创建一个进程时，应首先创建其PCB，然后才能根据PCB中的信息对进程实施有效地管理和控制。当一个进程完成其功能之后，系统则释放PCB，进程也随之消亡。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程的PCB所包含的内容</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>下面几项基本内容是必需的</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.描述信息描述信息主要包括下列几种：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）进程名或进程标识号。每个进程都有唯一的进程名或进程标识号。在识别一个进程时，进程名或进程标识号代表该进程。（2）用户名或用户标识号。每个进程都隶属于某个用户，用户名或用户标识号有利于资源共享与保护。（3）家族关系。在有的系统中，进程之间互成家族关系。因此，在PCB中设置相应的项描述其家族关系。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.控制信息控制信息包括：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）进程当前状态。进程当前状态说明进程当前处于何种状态。进程在活动期间可分为就绪状态、执行状态和阻塞状态。任一进程在任一时刻只能具有这3种状态中的一种。这3种状态的含义是：执行状态表示该进程占有处理机；就绪状态表示该进程准备占有处理机；而阻塞状态则表示进程因某种原因而暂时不能占有处理机。在有的系统中，阻塞状态会进一步划分为不同原因或不同地点（内存或外存）的阻塞状态。（2）进程优先级。进程优先级是选取进程占有处理机的重要依据。与进程优先级有关的PCB表项有：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>①占有CPU时间。②进程优先级偏移。③占据内存时间等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）程序开始地址。程序开始地址规定该进程的程序从此地址开始执行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）各种计时信息。给出进程占有和利用资源的有关情况。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（5）通信信息。通信信息用来说明该进程在执行过程中与别的进程所发生的信息交换情况。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.资源管理信息</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>PCB中包含最多的是资源管理信息，包括有关存储器的信息、使用输入/输出设备的信息和有关文件系统的信息等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.CPU现场保护结构</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>当前进程因等待某个事件而进入等待状态或因某事件发生被中止在处理机上的执行时，为了以后该进程能在被中断处恢复执行，需要保护当前进程的CPU现场。CPU中设有专门的CPU现场保护结构，以存储退出执行时的进程现场数据。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一个PCB表往往要占据较大的存储空间（一般占几百到几千个字节）。在有的系统中，为了减少PCB对内存的占用量，只允许PCB中最常用的部分，如CPU现场保护、进程描述信息、控制信息等常驻内存。PCB结构中的其他部分则存放于外存之中，待该进程将要执行时与其他数据一起装入内存。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-8-进程控制" tabindex="-1"><a class="header-anchor" href="#◆-2-8-进程控制" aria-hidden="true">#</a> ◆ 2.8 进程控制</h3>
<blockquote>
<blockquote>
<p>进程和处理机管理的一个重要任务是进程控制。所谓进程控制，就是系统使用一些具有特定功能的程序段来创建、撤销进程以及完成进程各状态间的转换，从而达到多进程高效率协调、并发执行和实现资源共享的目的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>为了防止操作系统及其关键数据（如PCB等）受到用户程序有意或无意的破坏，通常将处理机的执行状态分成两种：核心态与用户态。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）核心态又称管态、系统态，是操作系统管理程序执行时机器所处的状态。它具有较高的特权，能执行一切指令，访问所有的寄存器和存储区。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）用户态又称目态，是用户程序执行时机器所处的状态。这是具有较低特权的执行状态，只能执行规定的指令，访问指定的寄存器和存储区。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一般情况下，把核心态下执行的某些具有特定功能的程序段称为原语，引进原语的主要目的是为了实现进程的通信和控制。原语可分为两类：一类是机器指令级的，其特点是执行期间不允许中断，正如在物理学中的原子一样。在操作系统中，它是一个不可分割的基本单位；另一类是功能级的，其特点是作为原语的程序段不允许并发执行。这两类原语都在核心态下执行，且都是为了完成某个系统管理所需要的功能和被高层软件所调用。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>原语是操作系统核心（不是由进程而是由一组程序模块所组成）的一个组成部分，它必须在核心态下执行，并且常驻内存，而个别系统有一部分不在核心态下运行。原语和系统调用都能被进程所调用，两者的差别：原语有不可中断性，原语是通过在其执行过程中关闭中断实现的，且一般由系统进程调用；而系统调用的功能可被用户态下运行的进程调用，例如，文件的建立、打开、关闭、删除等，都是借助中断进入用户态程序，然后转交给相应的系统进程实现其功能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>操作系统通常允许一个进程创建和控制另一个进程，前者称为父进程，后者称为子进程。创建父进程的进程称为祖父进程，子进程又可创建子孙进程，从而形成了—个树形结构的进程家族</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程创建方式有以下几种：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）由系统进程模块统一创建。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）由父进程创建。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由系统统一创建的进程之间的关系是平等的，它们之间一般不存在资源继承关系。而由父进程创建的进程之间则存在隶属关系，且互相构成树形结构的家族关系。属于某个家族的一个进程可以继承其父进程所拥有的资源。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>无论是用哪一种方式创建进程，在系统生成时，都必须由操作系统创建一部分承担系统资源分配和管理工作的系统进程。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>无论是系统创建方式还是父进程创建方式，都必须调用创建原语来实现。创建原语扫描系统的PCB链表，在找到相关PCB表之后，填入调用名提供的有关参数，最后形成代表进程的PCB结构。这些参数包括：进程名、进程优先级P0、进程正文段起始地址D0、资源清单R0等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>以下几种情况导致进程被撤销：（1）该进程已完成所要求的功能而正常终止。（2）由于某种错误导致非正常终止。（3）祖先进程要求撤销某个子进程。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>无论哪一种情况导致进程被撤销，进程都必须释放它所占用的各种资源和PCB结构本身，以利于资源的有效利用。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>当一个祖先进程撤销某个子进程时，还需审查该子进程是否还有自己的子孙进程，若有的话，还需要撤销其子孙进程的PCB结构和释放它们所占有的资源。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>撤销原语首先检查PCB进程链或进程家族，寻找所要撤销的进程是否存在。如果找到了所要撤销进程的PCB结构，则撤销原语释放该进程所占有的资源之后，把对应的PCB结构从进程链或进程家族中摘下并返回给PCB空队列。如果被撤销的进程有自己的子进程，则撤销原语应先撤销其子进程的PCB结构并释放子进程所占用的资源之后，再撤销当前进程的PCB结构和释放其资源。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>这里主要介绍实现进程的执行状态到阻塞状态，又由阻塞状态到就绪状态转换的两种原语，即阻塞原语与唤醒原语</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>阻塞原语在一个进程期待某一事件（如键盘输入数据、写盘、等待其他进程发来数据等）发生，但发生条件尚不具备时，被该进程自己调用来阻塞自己。阻塞原语在阻塞一个进程时，由于该进程正处于执行状态，故应先中断处理机和保存该进程的CPU现场。然后将被阻塞进程设置成“阻塞”状态后插入阻塞队列中，再转进程调度程序选择新的就绪进程投入运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>当阻塞队列中的进程所等待的事件发生时，等待该事件的所有进程都将被唤醒。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一个处于阻塞状态的进程不可能自己唤醒自己。唤醒一个进程有两种方法：一种是由系统进程唤醒；另一种是由事件发生进程唤醒。当由系统进程唤醒阻塞进程时，系统进程统一控制事件的发生并将“事件发生”这一消息通知阻塞进程。从而使得该进程因等待事件已发生而进入就绪队列。阻塞进程也可由事件发生进程唤醒。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>唤醒原语既可被系统进程调用，也可被事件发生进程调用。称调用唤醒原语的进程为唤醒进程。唤醒原语首先将被唤醒进程从相应的阻塞队列中摘下，将被唤醒进程设置为就绪状态之后，送入就绪队列。在把被唤醒进程送入就绪队列之后，唤醒原语既可以返回原调用程序，也可以转向进程调度，以便让调度程序有机会选择一个合适的进程执行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>当需要挂起某个进程时可调用挂起原语</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>调用挂起原语的进程只能挂起它自己或它的子孙</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>挂起原语的主要操作过程：以被挂起的进程标识名为索引，到PCB集合中查找该进程的PCB，得到该进程的内部标识，并检查该进程的状态。若状态为执行，则中断处理机，把CPU状态保存在PCB中，停止运行该进程并将状态改为挂起就绪；若状态为阻塞，则改为挂起阻塞；若状态为就绪，则改为挂起就绪（若状态为执行，则从就绪队列中按某种算法选择一个进程投入运行）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>激活原语使处于挂起状态的进程变成活动，即把挂起就绪状态变成活动就绪状态，把挂起阻塞状态变成活动阻塞状态。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>激活原语也可以有多种激活方式：如激话一个具有指定标识名的进程，或者激活某进程及其所有的子孙进程。</p>
</blockquote>
</blockquote>
<h3 id="◆-2-9-线程" tabindex="-1"><a class="header-anchor" href="#◆-2-9-线程" aria-hidden="true">#</a> ◆ 2.9 线程</h3>
<blockquote>
<blockquote>
<p>在操作系统中引入进程的目的是为了使多个程序并发执行，从而改善资源利用率及提高系统的吞吐量。那么，在操作系统中再引入线程则是为了减少程序并发执行时所付出的时空开销，使操作系统具有更好的并发性。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程的两个基本属性：（1）进程是一个可拥有资源的独立单位。（2）进程同时又是一个可以独立调度和分配的基本单位。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>然而为使程序能并发执行，系统还必须进行以下的一系列操作。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）创建进程。系统在创建进程时，必须为其分配其所必需的、除处理机以外的所有资源。例如，内存空间、I/O设备以及建立相应的PCB。（2）撤销进程。系统在撤销进程时，又必须先对这些资源进行回收操作，然后再撤销PCB。（3）进程切换。在对进程进行切换时，由于要保留当前进程的CPU环境和设置新选中进程的CPU环境，为此需要花费不少处理机时间。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由于进程是—个资源拥有者，因而在进程的创建、撤销和切换中，系统必须为之付出较大的时空开销。也正因为如此，在系统中所设置的进程数目不宜过多，进程切换的频率也不宜太高，这样就限制了并发程度的进一步提高。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如何能使多个程序更好地并发执行，同时又尽量减少系统的开销，已成为近年来设计操作系统时所追</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>产生了线程概念</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>线程是进程内一个相对独立的、可调度的执行单元。线程自己基本上不拥有资源，只拥有一点在运行时必不可少的资源（如程序计数器、一组寄存器和栈），但它可以与同属一个进程的其他线程共享进程拥有的全部资源。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>多线程是指一个进程中有多个线程，这些线程共享该进程资源。这些线程驻留在相同的地址空间中，共享数据和文件。如果一个线程修改了一个数据项，其他线程可以了解和使用此结果数据。一个线程打开并读一个文件时，同一进程中的其他线程也可以同时读此文件。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>我们从调度、并发性、系统开销、拥有资源等方面来比较线程与进程</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.调度</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在引入线程的操作系统中，则把线程作为调度和分配的基本单位，而把进程作为资源拥有的基本单位，使传统进程的两个属性分开，线程便能轻装运行，从而可显著地提高系统的并发程度。在同一进程中，线程的切换不会引起进程的切换，在由一个进程中的线程切换到另一个进程中的线程时，将会引起进程的切换。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.并发性</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能更有效地使用系统资源和提高系统吞吐量。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.拥有资源</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一般地说，线程自己不拥有资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源。一个进程的代码段、数据段以及系统资源，如已经打开的文件、I/O设备等，可供同一进程的所有线程共享。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.系统开销</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统所付出的开销将显著地大于在创建或撤销线程时的开销。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>线程切换只需保存和设置少量寄存器的内容，并不涉及存储器管理方面的操作</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程切换的开销远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现也变得比较容易。在有的系统中，线程的切换、同步和通信都无须操作系统内核的干预。</p>
</blockquote>
</blockquote>
<h2 id="◆-第3章-进程同步与通信" tabindex="-1"><a class="header-anchor" href="#◆-第3章-进程同步与通信" aria-hidden="true">#</a> ◆ 第3章 进程同步与通信</h2>
<blockquote>
<blockquote>
<p>当多个进程竞争一台打印机时，有可能多个进程的输出结果交织在一起，难以区分。为了保证系统的正常运行，使程序的执行具有可再现性，操作系统必须提供某种机制。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程之间的协作关系包括互斥、同步和通信。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>互斥是指多个进程不能同时使用同一个资源。当某个进程使用某种资源时，其他进程必须等待。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>同步是指多个进程中发生的事件存在着某种时序关系，某些进程的执行必须先于另一些进程。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通信是指多个进程之间要传递一定量的信息。</p>
</blockquote>
</blockquote>
<h3 id="◆-3-1-进程同步与互斥" tabindex="-1"><a class="header-anchor" href="#◆-3-1-进程同步与互斥" aria-hidden="true">#</a> ◆ 3.1 进程同步与互斥</h3>
<blockquote>
<blockquote>
<p>1.并发带来的问题</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在单处理机多道程序设计环境系统中，进程被交替地执行，表现出一种并发执行的特征。虽然进程间来回切换需要一定的开销，但这种交替执行在处理效率上还是带来了很大的好处。由于并发执行的进程之间相对执行速度是不可预测的，它取决于其他进程的活动、操作系统的调度策略等，这就带来了以下困难。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）全局变量的共享问题。如果两个进程都使用了同一个全局变量，并都对该变量进行了读/写操作，那么不同的读/写执行顺序是非常关键的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）操作系统很难最佳地管理资源的分配。如果某个进程请求使用某个特定的I/O设备，并得到了这个设备，但该进程在使用该设备前被挂起了，操作系统仍然把这个设备锁定给该进程，而不能分配给其他进程，因为操作系统不知道被挂起的进程何时又将开始执行。此外，资源分配还会导致死锁的危险。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）定位程序的错误很困难。这是因为并发程序的不确定性和不可再现性。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>操作系统为此要关注的事情有以下几方面。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）操作系统必须记录每个进程的情况，并通过进程控制块实现。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）操作系统必须为每个进程分配和释放各种资源，这些资源包括处理机、存储器、文件和I/O设备。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）操作系统必须保护每个进程的数据和资源，避免遭到其他进程的干涉和破坏。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）保证进程执行结果的正确性，进程的执行结果与速度无关。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程互斥是指由于共享资源所要求的排他性，进程之间要相互竞争，某个进程使用这种资源时，其他进程必须等待。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程同步是指多个进程中发生的事件存在着某种时序关系，必须协同动作、相互配合，以共同完成一个任务。进程同步的主要任务是使并发执行的诸多进程有效地共享资源和相互合作，从而使程序的执行具有可再现性。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程通信是指多个进程之间要传递一定的信息。这种情况下，进程之间知道对方的程度最高，需要传递的信息量也最大。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>竞争双方本来毫无关系，但由于竞争同一资源，使两者产生了相互制约关系，这种制约关系就是互斥。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程同步要求各进程必须按规定时序执行，以共同完成一项任务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.1.2 临界资源和临界区</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程间的互斥涉及共享资源的竞争使用</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>被竞争的资源在使用时必须受到一定的限制</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>竞争使用这些资源的进程在执行使用这些资源的程序代码时也必须受到一定的限制。这就引出了临界资源和临界区的概念。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.临界资源</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>操作系统中将一次仅允许一个进程访问的资源称为临界资源（Critical Resource）。对临界资源，进程之间只能通过互斥的方式来共享这些资源。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>临界资源既可以是硬件资源，也可以是软件资源。例如，许多物理设备都属于临界资源，如打印机和磁带机等。以打印机为例，它显然不会允许两个进程同时使用。还有一些软件范畴的资源，如共享的变量、缓冲区、表格、队列等，也属于临界资源。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>并发执行的P1和P2共享count变量，它们之间不同的并发顺序可能会导致不同的执行结果，使结果失去了可再现性。为了防止这种错误的发生，对变量count也应按临界资源处理，即采取措施强迫P1和P2互斥访问count变量。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.临界区</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>操作系统中把并发进程中访问临界资源的那段代码称为临界区（Critical Section）。临界区也叫互斥区，是一个程序片段的集合，这些程序片段分散在不同的进程中，对某个共享的临界资源进行特定的操作。为实现对临界资源的互斥访问，应保证相关进程互斥地进入各自的临界区。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>若在一组进程的各自临界区中都使用了相同的共享变量，则把这组临界区称为“相关临界区”。对相关临界区管理的基本原则是：若干进程必须互斥地进入相关临界区执行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>并发进程在执行过程中，如果需要访问一个临界资源（如申请打印机），则需要先检查该资源是否可访问，只有当该资源在可访问的情况下，该进程才可以进入自己的临界区对该资源进行访问，并为之设置正被访问的标识，以屏蔽其他试图访问该资源的进程。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果该资源目前正被其他进程访问，则该进程不能进入自己的临界区。相应地，并发进程在完成对临界资源的访问后，需要将相应标识改为可访问，以供后续进程继续访问。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>为了实现进程对临界资源的互斥访问，必须保证并发执行的进程互斥的进入临界区。因此，必须在临界区前面增加一段用于进行检查的代码，把这段代码称为进入区（Enter Section）。相应地，在临界区后面也要加上一段用于退出临界区的代码，称为退出区（Exit Section），用于将临界区正被访问标识恢复为未被访问标识。进程中除去上述进入区、临界区和退出区之外的其他代码，称为剩余区</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.1.3 信号量和P/V操作</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>信号量机制是操作系统提供的一种实现进程互斥与同步管理的有效手段。操作系统从进程管理者的角度来处理进程的互斥和同步问题，由管理者来协调竞争各方对临界资源的互斥使用。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>信号量机制已被广泛应用于各种类型的操作系统中，用于实现进程之间的互斥和同步管理。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果信号量的初值为1，表示仅允许一个进程访问临界区，此时的信号量转换为互斥信号量。P操作和V操作分别置于进入区和退出区</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>利用信号量可以实现进程之间的同步，即可以控制进程执行的先后次序。如果有两个进程P1和P2，要求P2必须在P1执行完毕之后才可以执行，则只需要设置一个信号量S，其初值为0，将V（S）操作放在进程P1的代码段C1后面，将P（S）操作放在进程P2的代码段C2前面</p>
</blockquote>
</blockquote>
<h3 id="◆-3-2-经典进程同步与互斥问题" tabindex="-1"><a class="header-anchor" href="#◆-3-2-经典进程同步与互斥问题" aria-hidden="true">#</a> ◆ 3.2 经典进程同步与互斥问题</h3>
<blockquote>
<blockquote>
<p>3.2 经典进程同步与互斥问题</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.2.1 生产者—消费者问题</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>生产者—消费者问题是最著名的同步问题，它描述一组生产者（P1，…，Pm）向一组消费者（C1，…，Cq）提供产品。它们共享一个有界缓冲池，缓冲池是由若干个大小相等的缓冲区组成，每个缓冲区可以容纳一个产品。生产者向其中投放产品，消费者从中取得产品</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>假定缓冲池中有n个缓冲区（B0，B1，…，Bn－1）。由于缓冲池是临界资源，同一时刻它只允许一个生产者向其中投入产品，或者一个消费者从中取出产品。即生产者之间、生产者与消费者之间、消费者之间都必须互斥地使用缓冲池。所以必须设置互斥信号量mutex，它代表缓冲池资源数量，初值为l。在生产者—消费者问题中，除了对缓冲池访问的互斥问题，还存在同步问题，即生产者和消费者两进程P和C之间应满足下列两个同步条件：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）只有缓冲池中至少有一个缓冲区已投入产品后，消费者才能从中提取产品，否则消费者必须等待。（2）只有缓冲池中至少有一个缓冲区是空时，生产者才能把产品放入缓冲区，否则生产者必须等待。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在生产者—消费者问题中需要注意以下几个问题：（1）把共享缓冲池中的n个缓冲区视为临界资源，进程在使用时，首先要检查是否有其他进程在临界区，如果确认没有时再进入。在程序中，P（mutex）和V（mutex）用于对临界资源的互斥访问，必须成对出现。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）信号量full表示有数据的缓冲区的数量，初值为0。empty表示空闲缓冲区的数量，初值为n。它们表示的都是资源的数量，因此称为资源信号量。它们之间存在如下关系：full+empty=n。对资源信号量的P、V操作，同样需要成对出现，与互斥信号量不同的是，对同一个资源信号量的P操作和V操作分别处于不同的进程中。例如，P（empty）在生产者进程中，而V（empty）在消费者进程中。当生产者进程因执行P（empty）而阻塞时，由消费者进程用V（empty）将其唤醒；同理，当消费者进程因执行P（full）而阻塞时，由生产者进程用V（full）将其唤醒。（3）多个P操作的次序不能颠倒。在程序中，应先对资源信号量执行P操作，再对互斥信号量执行P操作，否则可能会引起死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.2.2 读者—写者问题</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一个数据对象若被多个并发进程所共享，且其中一些进程只要求读该数据对象的内容，而另一些进程则要求写操作，对此，把只要求读的进程称为“读者”，而把要求写的进程称为“写者”。在读者—写者问题中，要求任何时刻“写者”最多只允许有一个，而“读者”则允许有多个。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对共享资源的读/写操作的限制条件是：（1）允许任意多的读进程同时读。（2）一次只允许一个写进程进行写操作。（3）如果有一个写进程正在进行写操作，禁止任何读进程进行读操作。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>我们可以用信号量解决读者—写者问题，引入一个互斥信号量Wmutex。为了记录谁是第一个读者，可以用一个全局整型变量Rcount做一个计数器。而在解决问题的过程中，由于全局变量Rcount属于临界资源，对于它的访问也需要互斥进行，所以需要引入另一个互斥信号量Rmutex。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>该解决方案采用的是读者优先算法。即当读者进行读时，后续的写者必须等待，直到所有的读者均离开后，写者才可以进入。除读者优先算法外，还可以用写者优先和公平策略两种解决方案</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.2.3 哲学家进餐问题</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>该问题体现了进程对有限资源的竞争访问。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5个哲学家围着一个圆桌而坐，桌上摆着5个碗，每两个碗之间有一支筷子，共5支筷子。哲学家们的生活就是进餐和思考问题。平时哲学家思考，当需要进餐时，他只有拿到其左右两侧的筷子时才可以进餐。如果他成功地取得两支筷子，便可以进餐，之后，再放下筷子继续思考，如此反复。显然，由于每支筷子都是由相邻两位哲学家共享，就可能出现竞争状态，因此必须采取有效方法以保证每一位哲学家都能进餐。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由于每支筷子同时只能供一位哲学家使用，所以它是临界资源。因此可以用互斥信号量来实现。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>上述算法虽然保证了两个相邻哲学家不会同时进餐的问题，但是还有一个严重的问题：如果所有的哲学家总是先拿左边的筷子，再拿右边的筷子，那么就有可能出现这样的情况，5个哲学家都拿起了左边的筷子，而他们想拿右边的筷子时，却因为筷子已被其他哲学家拿去而无法拿到，此时所有的哲学家都不能进餐，这就出现了死锁现象。对于这样的死锁问题，可以采取以下几种解决方法：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）至多只允许有4位哲学家同时去拿左边的筷子，最终能保证至少有一位哲学家能够进餐，并在用餐结束后释放出他用过的两只筷子，从而使更多的哲学家能够进餐。（2）仅当哲学家的左、右两只筷子都可用时，才允许他拿起筷子进餐。（3）规定奇数号哲学家先拿他左边的筷子，然后再去拿他右边的筷子；而偶数号哲学家则相反。按此规定，将是1、2号哲学家竞争1号筷子；3、4号哲学家竞争3号筷子。即5位哲学家都先竞争奇数号筷子，获得后，再去竞争偶数号筷子，最后总会有一位哲学家能获得两支筷子而进餐。</p>
</blockquote>
</blockquote>
<h3 id="◆-3-3-管程机制" tabindex="-1"><a class="header-anchor" href="#◆-3-3-管程机制" aria-hidden="true">#</a> ◆ 3.3 管程机制</h3>
<blockquote>
<blockquote>
<p>虽然信号量机制是一种既方便又有效的进程同步机制，但每个要访问临界资源的进程都必须使用大量的P、V操作，并且还要注意多个P、V操作的顺序，以免出现死锁或其他错误结果。为了解决这些问题，便产生了一种高级同步机制——管程（Monitors）。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>管程的定义：一个共享资源的数据结构以及一组能为并发进程在其上执行的针对该资源的一组操作，这组操作能同步进程和改变管程中的数据。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>管程的基本思想是把信号量及其操作原语封装在一个对象内部，即将共享资源以及针对共享资源的所有操作集中在一个模块中。管程是一种程序设计语言结构，每一个管程是一个基本程序单位，可以被单独编译。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在管程机制下，进程的同步与互斥管理对用户来说简单了许多，同步或互斥处理是否正确不再由用户程序控制，而是由一种系统内部机制来决定，因此具有管程的系统具有以下特点：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）管程内部的局部变量只能通过管程中的过程进行访问，其他任何外部过程都不能对其进行访问。（2）进程只能通过调用管程的某一个过程才能进入管程，这样可以保证所有进入管程的进程有统一的入口。（3）任何时刻，只能有一个进程在管程中执行，其他调用管程的任何进程都被挂起，以等待管程变为可用，即对管程实施互斥访问。</p>
</blockquote>
</blockquote>
<h3 id="◆-3-4-进程通信" tabindex="-1"><a class="header-anchor" href="#◆-3-4-进程通信" aria-hidden="true">#</a> ◆ 3.4 进程通信</h3>
<blockquote>
<blockquote>
<p>进程通信是指进程之间的信息交换。其所交换的信息量，少则是一个状态或数值，多则是成千上万个字节。进程之间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。在进程互斥中，进程通过修改信号量向其他进程表明临界资源是否可用；在生产者—消费者问题中，生产者通过缓冲池将所生产的产品传送给消费者。应当指出，信号量机制作为同步工具是卓有成效的，但作为通信工具，则不够理想，主要表现在：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）效率低。生产者每次只能向缓冲区中投放一个产品，消费者每次只能从缓冲区中取得一个产品。（2）通信对用户不透明。可见，用户要利用低级通信工具实现进程通信是非常不方便的。因为，共享数据结构的设置、数据的传送、进程的互斥与同步，都必须由程序员去实现，操作系统只提供共享存储器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>高级进程通信，是指用户可直接利用操作系统所提供的一组通信命令，高效地传送大量数据的一种通信方式。操作系统隐藏了进程通信的实现细节，或者说，通信过程对用户是透明的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>高级通信机制可归结为三大类：共享存储器系统、消息传递系统及管道通信系统。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.共享存储器系统</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在共享存储器系统中，相互通信的进程共享某些数据结构或共享存储区，进程之间能够通过它们进行通信。由此，又可把它们进一步分成如下两种类型。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）基于共享数据结构的通信方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如在生产者—消费者问题中，就是利用有界缓冲区这种数据结构来实现通信的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>操作系统却只需要提供共享存储器。因此，这种通信方式是低效的，只适于传递少量数据。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）基于共享存储区的通信方式。为了传输大量数据，在存储器中划出了一块共享存储区，诸进程可通过对共享存储区中的数据进行读或写来实现通信，这种通信方式属于高级通信。进程在通信前，向系统申请共享存储区中的一个分区，并指定该分区的关键字；若系统已经给其他进程分配了这样的分区，则将该分区的描述符返回给申请者。接着，申请者把获得的共享存储分区连接到本进程上。此后，便可像读、写普通存储器一样地读、写共用存储分区。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.消息传递系统</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>消息传递系统因其实现方式的不同，又可分为以下两类。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1）直接通信方式。发送进程直接将消息发送给接收进程，并将它挂在接收进程的消息缓冲队列上。接收进程从消息缓冲队列中取得消息。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）间接通信方式。发送进程将消息发送到某种中间实体中，接收进程从中取得消息。这种中间实体一般称为信箱，故这种通信方式也称为信箱通信方式，被广泛应用于计算机网络中，相应的系统被称为电子邮件系统。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.管道通信系统</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>所谓管道，是指用于连接一个读进程和一个写进程，以实现它们之间通信的共享文件，又称为pipe文件。向管道（共享文件）提供输入的发送进程（即写过程），以字符流形式将大量的数据送入管道；而接受管道输出的接收进程（即读进程），可从管道中接收数据。由于发送进程和接收进程是利用管道进行通信的，故又称为管道通信。这种方式首创于UNIX系统，因它能传送大量的数据，且很有效，故又被引入许多其他操作系统中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>管道通信机制必须提供以下3方面的协调能力</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）互斥。当一个进程正在对pipe进行读/写操作时，另一个进程必须等待。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）同步。管道的大小是有限的。所以当管道满时，写（输入）进程必须等待，直到读（输出）进程取走数据后，再把它唤醒。当读进程读一空pipe时，也应睡眠等待，直至写进程将数据写入管道后，才将它唤醒。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）对方是否存在。只有确定对方已存在时，方能进行通信。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程通信中需要考虑的问题有通信链路、数据格式和进程的同步方式等</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.通信链路的建立方式</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）显式建立链路。由发送进程在通信之前，用“建立连接”命令（原语）请求系统为其建立一条通信链路；在链路使用完后，再利用显式命令方式拆除链路。这种方式主要用于计算机网络中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）隐式建立链路。发送进程无须明确提出建立链路的请求，只需利用系统提供的发送命令（原语），系统会自动地为其建立一条链路。这种方式主要用于单机系统中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.通信方向</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）单向通信</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）双向通信</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>双向通信方式由于进程之间可以对发过的消息进行回送确认，因此比较可靠。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.通信链路的连接方式</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）点对点方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）多点方式。用一条链路连接多个进程（＞2）。例如，广播方式就是一个进程向其他多个进程同时发送消息。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.通信链路的容量</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>链路的容量是指通信链路上是否有用于暂存数据的缓冲区。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）无容量通信链路。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）有容量通信链路。通信链路中设置了缓冲区，因而可以暂存数据，缓冲区的数目越大，通信链路的容量越大。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5.数据格式</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）字节流格式。发送方发送的数据没有一定的格式，接收方不需要保留各次发送之间的分界。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）报文格式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通常把报文分为报头和正文两部分。报头包括报文传送时所需要的控制信息，如发送进程名、报文的长度、数据类型、数据的发送日期和时间等。而正文部分才是真正要发送的信息内容。另外，根据报文的长度还可以分为定长报文和不定长报文。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>6.同步方式</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>根据收发进程在进行收发操作时是否相互等待，同步方式可分为两种：（1）阻塞方式。操作方要等待操作结束，才能继续执行。（2）非阻塞方式。操作方在提交后立即返回，不需要等待。</p>
</blockquote>
</blockquote>
<h3 id="◆-3-5-消息传递系统的实现" tabindex="-1"><a class="header-anchor" href="#◆-3-5-消息传递系统的实现" aria-hidden="true">#</a> ◆ 3.5 消息传递系统的实现</h3>
<blockquote>
<blockquote>
<p>消息传递系统</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在这种机制中，发送消息利用发送原语send实现，接收消息用原语receive实现。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在使用消息传递系统时，需要使用信号量来保证消息缓冲区的互斥，以及协调发送进程与接收进程的同步</p>
</blockquote>
</blockquote>
<h2 id="◆-第4章-进程调度与死锁" tabindex="-1"><a class="header-anchor" href="#◆-第4章-进程调度与死锁" aria-hidden="true">#</a> ◆ 第4章 进程调度与死锁</h2>
<blockquote>
<blockquote>
<p>进程调度即处理机调度。在多道程序设计环境中，进程数往往多于处理机数，这将导致多个进程竞争使用处理机。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>系统必须按照一定的算法把处理机动态地分配给就绪队列中某一个进程，并使之执行，这就是进程调度的任务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程调度是控制、协调进程对CPU的竞争，按照一定的调度算法，使某一就绪进程获得对CPU的控制权。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-1-调度级别与准则" tabindex="-1"><a class="header-anchor" href="#◆-4-1-调度级别与准则" aria-hidden="true">#</a> ◆ 4.1 调度级别与准则</h3>
<blockquote>
<blockquote>
<p>一个批处理型作业，从进入系统并驻留在外存的后备队列上开始，直至作业运行完毕，可能要经历高级调度、中级调度和低级调度三级调度</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.高级调度</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>高级调度又称为作业调度，用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程、分配必要的资源，然后，再将新创建的进程排在就绪队列上，准备执行。在批处理系统中，作业进入系统后，是先驻留在外存上的，由作业调度将它们分批地装入内存。然而在分时系统中，为了做到及时响应，用户通过键盘输入的命令或数据等，都是被直接送入内存的，因而无须再配置作业调度机制。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在实时系统中，通常也不需要作业调度</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.中级调度</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>中级调度程序又称对换调度。引入中级调度的主要目的是为了提高内存利用率和系统吞吐量。为此，应使那些暂时不能运行的进程不再占用宝贵的内存资源，而将它们暂时调到外存上去等待，此时的进程状态为挂起状态。当这些进程重新具备运行条件、且内存又稍有空闲时，由中级调度来决定把外存上的哪些又具备运行条件的就绪进程，重新调入内存，并修改其状态为就绪状态，挂在就绪队列上等待进程调度。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.低级调度</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>低级调度又称为进程调度，用来决定就绪队列中的哪个进程应获得处理机，然后再由分派程序执行把处理机分配给该进程的具体操作。进程调度是最基本的一种调度，在批处理系统、分时系统和实时系统中都必须配置这一级调度。进程调度可采用下述两种调度方式：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）非抢占方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>不允许其他进程抢占已经分配出去的处理机</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>这种调度方式的优点是实现简单、系统开销小，适用于大多数的批处理系统环境。但它很难满足紧急任务的要求——立即执行，因而可能造成难以预料的后果。显然，在要求比较严格的实时系统中，不宜采用这种调度方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）抢占方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>允许调度程序根据某种原则暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一个进程。抢占的原则比较多，例如优先权原则，允许优先权高的新到进程抢占优先权较低的进程的处理机；还有分时系统和大多数的实时系统中的时间片原则等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>能够引起进程调度的原因有很多，下面列举一些常见的</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）正在执行的进程执行完毕，或者因为某种原因而终止运行。（2）执行中进程自己调用阻塞原语将自己阻塞起来进入睡眠等待状态。（3）执行中的进程因提出I/O请求而暂停执行。（4）在进程通信或同步过程中执行了某种原语操作，如P操作、Block原语等。（5）在分时系统中时间片已经用完。（6）在允许抢占式的调度方式中，有一个优先级更高的进程进入就绪队列。（7）一个系统状态进程因为发生了中断等原因而返回到用户态时。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>当上述情况发生时，处理机都被释放，系统就需要重新启动进程调度。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程调度的任务就是从就绪队列中按照一定的算法选择一个或几个进程并将处理机分配给它。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>衡量和比较调度算法优劣的因素通常有以下几个方面</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.响应时间</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.周转时间</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>周转时间是从作业等待进入内存，在就绪队列中排队，在CPU上运行，以及等待I/O操作所花时间的总和。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.优先权</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在批处理系统、分时系统和实时系统中都可以引入优先权准则，以保证某些紧急的作业得到及时处理。优先权准则就是按照进程的紧急程度、进程的大小、进程的等待时间等多种因素给每个进程规定一个优先级，系统调度时按照优先级的高低选择进程。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.截止时间</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>截止时间是衡量实时系统的主要指标，因而也是选择实时系统调度算法的重要准则。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5.CPU利用率</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>CPU的利用率高低体现了CPU实际运行用户进程时间的多少，即CPU处于忙状态的时间与开机运行的总时间之比。在实际系统中，利用率一般在40%～90%之间。由于在计算机系统中，价格最高的就是CPU，所以处理机的利用率成为衡量操作系统性能的重要指标。而调度算法又对处理机的利用率有很大影响。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>6.吞吐量</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>系统吞吐量是指单位时间内处理机所完成的作业数目。它是用来评价批处理系统的重要指标。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>7.各类资源的平衡利用</p>
</blockquote>
</blockquote>
<h3 id="◆-4-2-调度算法" tabindex="-1"><a class="header-anchor" href="#◆-4-2-调度算法" aria-hidden="true">#</a> ◆ 4.2 调度算法</h3>
<blockquote>
<blockquote>
<p>一些常用的调度算法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.先来先服务调度算法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>先来先服务（First Come First Served，FCFS）是一种最简单的调度算法。可以用在进程调度或者作业调度中。它的基本思想是按照进程或作业进入等待队列的先后次序进行调度，先进入的进程或作业优先调度。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>先来先服务采用的处理机调度方式是非抢占式，因此操作系统不会强行暂停当前正在运行的进程。该算法有利于长进程，不利于短进程；有利于CPU繁忙型进程，不利于I/O繁忙型进程。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.短作业（进程）优先调度算法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>短作业（进程）优先（Shortest Job First，SJF或Shortest Process First，SPF）算法的基本思想是对预期执行时间短的作业或进程优先调度。该算法是对FCFS的一种改进，其目的是减少进程调度中的平均周转时间。虽然该算法可以减少作业或进程的平均等待时间，提高系统的吞吐量，但它也存在以下一些缺点：（1）对长作业或进程不利。如果系统中持续有更短的作业或进程出现，可能导致长作业或进程被“饿死”。（2）该算法没有考虑作业或进程的紧迫程度，因而不能保证紧迫的作业或进程得到及时的处理或响应。（3）由于作业或进程的执行时间是用户估计的，因而不够准确，从而影响了调度性能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.优先权调度算法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>为了照顾到进程的紧急程度，使得紧急的进程能够及时得到处理，很多操作系统使用了优先权（Priority）调度算法。优先权调度算法适用于作业调度和进程调度。当该算法用于作业调度时，系统将从后备队列中选择若干个优先权较高的作业调入内存。当用于进程调度时，把处理机分配给就绪队列中优先权最高的进程。进程调度中使用优先权调度算法又可以分为两种方式：可抢占方式和不可抢占方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于优先权算法，其关键在于如何确定进程的优先权。优先权的确定方式有两种：静态和动态。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>静态优先权是在进程创建时确定该进程的优先权，且该进程的优先权在其整个运行期间保持不变。确定优先权的因素有进程的类型、进程对资源的要求和用户的要求。系统进程的优先权通常高于用户进程；对处理机和内存要求较少的进程具有较高的优先权；用户的紧迫程度也是确定进程优先权的一个因素。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>动态优先权是指进程的优先权可以根据进程的不断推进而改变，以期得到更好的性能。动态优先权的变化取决于进程的等待时间和占有处理机的时间。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>随着进程等待时间的增加，该进程的优先权将以某种速率增加。这样做的目的是使优先权较低的进程在等待足够长的时间后，其优先权提高，进而被调度执行；当一个进程占有处理机的时间不断增长时，其优先权会以某种速率降低，这样做的目的是使持续执行的进程，在运行了一段时间后将处理机让给其他进程，以防止一个长进程长期垄断处理机。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.时间片轮转调度算法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>系统将所有的就绪进程按FCFS原则，排成一个队列，每次系统调度时，把处理机分配给队首的进程，并令其执行一个时间片，时间片的大小一般是几毫秒到几百毫秒。当一个进程被分配的时间片用完时，由系统时钟发出一个中断，调度程序暂停当前进程的执行，并将其送到就绪队列的末尾，同时从就绪队列的队首选择另一个进程运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>时间片长度的选择要适当，一般要保证一个基本的交互过程在一个时间片内完成</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5.多级反馈队列调度算法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>多级反馈队列调度算法是时间片轮转调度算法的发展，是目前公认的比较好的进程调度算法。在这种算法中，设置多个就绪队列，每个队列的优先权不同，第一个队列的优先权最高，第二个队列次之，以此类推，队列的优先权逐个降低</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>算法的实施过程为：（1）设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先级逐个降低。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）各级就绪队列进程具有不同的时间片。优先级最高的第1级队列中的进程时间片最短，随着队列的级别增加其进程的优先级降低，时间片的值增大。通常，优先级提高一级其时间片的值降低一半。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）各级队列按FCFS的原则排序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）调度方法是当一个新建进程进入内存后，首先将它放入第一级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该级队列的一个时间片内执行完，便可准备退出；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二级队列的末尾，再同样地按FCFS的原则等待调度执行；如果它在第二级队列中运行一个时间片后仍未完成，再依次将它放入第三级队列，……，如此下去，当一个进程从第一级队列依次降到第n级队列（最后一个队列）后，在第n级队列中便采用按时间片轮转的方式运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（5）当第一级队列空闲时，调度程序才调度第二级队列中的进程运行；当第n～（i－1）级队列均空时，才会调度第i级队列中的进程运行。如果处理机正在第i级队列中为某进程服务时，又有新进程进入优先级高的队列（第n～（i－1）中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i队列的末尾，把处理机分配给新到的高优先级进程。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在UNIX系统中，对进程调度就是采用多级反馈队列轮转调度方式。其核心是选择一个已经在内存且优先级最高的就绪进程投入运行，时间片到达后，就剥夺该进程的运行，将该进程反馈到优先级低一级的队列的末尾，然后再选择一个优先级最高且在内存中的就绪进程投入运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>多级反馈队列调度算法具有较好的性能，能较好地满足各种类型用户的需要。它不仅较合理地考虑了分时系统的平均响应时间，考虑了批处理系统的短进程优先，而且还能使以I/O为主的进程优先于CPU为主的进程。这种调度算法能适用于同时支持分时、实时、批处理的通用操作系统。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-3-死锁" tabindex="-1"><a class="header-anchor" href="#◆-4-3-死锁" aria-hidden="true">#</a> ◆ 4.3 死锁</h3>
<blockquote>
<blockquote>
<p>死锁有系统死锁和进程死锁，一般所说的“死锁”都是指进程死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>关于死锁，要注意以下几点：（1）参与死锁的进程至少是两个。（2）参与死锁的进程至少有两个已经占有资源。（3）参与死锁的所有进程都在等待资源。（4）参与死锁的进程是当前系统中所有进程的子集。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>死锁产生的原因可归结为如下两点：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>系统资源不足：当系统中供多个进程共享的资源，如打印机、输入设备等，其数量不足以满足各个进程的需要时，会引起各个进程对资源的竞争而产生死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程执行顺序不当：进程在运行过程中，请求和释放资源的顺序不当，也同样会产生进程死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.竞争资源产生的死锁</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>两个进程都在等待对方释放出所占有的资源，但又都因不能继续获得自己所需要的资源而不能继续运行，从而也不能释放出自己所占有的资源，以致进入死锁状态。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.进程运行顺序不当引起死锁</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>产生死锁有4个必要条件：（1）互斥条件。进程互斥使用资源，任意时刻一个资源只被一个进程独占。其他进程请求一个已被占用的资源，只能等占用者释放后才能使用。（2）不可剥夺条件。进程所获得的资源在未使用完毕之前，不能被其他进程强行剥夺，而只能由获得该资源的进程自己释放。（3）请求和保持。进程每次申请它所需要的一部分资源，在等待该资源的同时，继续占用已分配到的资源不释放。（4）循环等待。产生死锁时，各进程所占有的资源必然构成一个闭合环路，环路中每一个进程已获得的资源同时被下一个进程所请求。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>目前处理死锁的方法可以归结为以下几种：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）预防死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>该方法是通过设置某些限制条件，去破坏产生死锁的4个必要条件中的一个或几个条件，来预防发生死锁。预防死锁是一种较简单的方法，已被广泛使用。但通常因为所施加的限制条件太严格，可能导致系统资源利用率和系统吞吐量降低。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2）避免死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）检测死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>此方法允许系统在运行过程中发生死锁。但可以通过系统所设置的检测机制，及时地检测出死锁的发生，并精确地确定与死锁有关的进程和资源；然后采取适当措施，将已发生的死锁清除掉。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）解除死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>当检测到系统中已发生死锁时，需将进程从死锁状态中解脱出来。常用的实施方法是撤销或挂起一些进程，以便回收一些资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。死锁的检测和解除措施，有可能使系统获得较好的资源利用率和吞吐量，但在实现上难度也最大。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-4-死锁的预防" tabindex="-1"><a class="header-anchor" href="#◆-4-4-死锁的预防" aria-hidden="true">#</a> ◆ 4.4 死锁的预防</h3>
<blockquote>
<blockquote>
<p>产生死锁的4个必要条件，只要其中的一个不能成立，就可以避免死锁的产生，从而预防死锁的发生。由于条件（1）是资源的固有特性，因此不能加以改变，只能通过破坏其他3个条件来预防死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.破坏“请求和保持”条件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>采用资源的静态分配（动态分配是指进程临时使用时才提出申请，系统再进行分配）。就是说，在一个进程开始执行前就申请它所需的全部资源，并由系统在调度时为之分配所需全部资源。从而，它在执行过程中就不再需要申请另外的资源了。另一种办法是，每个进程仅在它不再占有资源时才可以提出申请资源，即在它们申请另外的资源之前，必须先释放它当前分到的全部资源。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>这两种方法都存在着缺点：资源利用率很低，预先静态分配进程全部所需资源，会造成一些资源在很长时间内得不到使用；再有，造成进程延迟运行，仅当进程获得其所需全部资源后，方能开始运行。例如由于有些进程长期占用某类资源，致使其他进程推迟，甚至得不到运行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.破坏“不可剥夺”条件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>该策略规定，一个已保持了某些资源的进程，若新的资源申请要求不能立即得到满足，便处于阻塞状态。而一个处于阻塞状态进程的全部资源可以被抢占。就是说，这些资源隐式地释放了，被剥夺的资源重新添加到资源表中。仅当该进程重新获得它原有资源以及得到新申请的资源，它才能重新启动。这种策略实现起来较为复杂，而且代价太大。因为一个资源在使用一段时间后被强行剥夺，会造成前阶段工作失效。而且，反复地申请和释放资源，使进程执行无限推迟，还增加系统开销，延长了进程的周转时间，降低系统的吞吐量。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.破坏“环路等待”条件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>按资源的类型进行线性排队，并赋予不同的序号。一般原则是，较为紧缺稀少的资源赋予较大的序号。对资源的申请，必须按序请求，先申请序号小的资源，后申请序号大的资源。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-5-避免死锁" tabindex="-1"><a class="header-anchor" href="#◆-4-5-避免死锁" aria-hidden="true">#</a> ◆ 4.5 避免死锁</h3>
<blockquote>
<blockquote>
<p>避免死锁的实质在于：如何使系统避免进入不安全状态</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>最具有代表性的避免死锁算法是Dijkstra的银行家算法。这是由于该算法能用于银行系统现金贷款的发放而得名。这种算法要求事先知道每个进程对资源的最大需求量。其基本思想是：在分配资源前，先要进行一个序列检查，以判断这种分配是否可能导致死锁（安全状态与否）；如果系统是安全的，则予以分配。</p>
</blockquote>
</blockquote>
<h3 id="◆-4-6-死锁的检测与解除" tabindex="-1"><a class="header-anchor" href="#◆-4-6-死锁的检测与解除" aria-hidden="true">#</a> ◆ 4.6 死锁的检测与解除</h3>
<blockquote>
<blockquote>
<p>假如系统为进程分配资源时，不采取任何限制性措施来保证不进入死锁状态，即系统任其自由发展进入不安全状态，并允许可能导致的死锁现象发生，则系统必须提供检测和解除手段。为此，系统必须采取以下措施：保存资源的请求和分配信息；提供一种算法，以利用这些信息来检测系统是否已进入死锁状态。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>死锁检测中的数据结构和算法</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一旦检测到死锁，就需要解除死锁。下面是解除死锁的方法。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）撤销所有的死锁进程。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）把每个死锁的进程恢复到前面定义的某个检查点，并重新运行这些进程。要实现这个方法需要操作系统有构造重新运行和重新启动机制。该方法的风险是有可能再次发生原来发生的死锁，但是操作系统的不确定性（随机性），使得不会总是发生同样的事情。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）有选择的撤销死锁进程，直到不存在死锁。选择撤销进程的顺序基于最小代价原则。在每次撤销一个进程后，要调用死锁检测算法，以检测是否仍然存在死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）剥夺资源，直到不存在死锁。该方法和（3）一样也需要基于最小代价原则选择要剥夺的资源。同样也需要在每次剥夺一个资源后，调用死锁检测算法，检测系统是否仍然存在死锁。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>关于最小代价原则，可以从以下几个方面进行考虑。（1）到目前为止消耗的处理机时间最少。（2）到目前为止产生的输出最少。（3）预计剩下的执行时间最长。（4）到目前为止分配的资源总量最少。（5）进程的优先级最低。（6）撤销某进程对其他进程的影响最小。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于死锁最简单的方法就是鸵鸟算法：把头埋在沙子里，假装什么也没有发生。每个人对该方法的看法不同。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>大多数操作系统，如UNIX、Linux和Windows，处理死锁的方法仅仅是忽略它，其前提是大多数用户宁可接受偶然情况下发生死锁，也不愿意受到只能创建一个进程，只能创建一个文件的限制。如果可以不花太大的代价就能解决死锁，那么就没有问题了。但这种代价通常很大，而且会给进程带来许多不便的限制。于是必须在方便性和正确性之间做出合理的权衡，那就是学习鸵鸟把自己埋起来，假装什么也不知道。</p>
</blockquote>
</blockquote>
<h2 id="◆-第5章-存储管理" tabindex="-1"><a class="header-anchor" href="#◆-第5章-存储管理" aria-hidden="true">#</a> ◆ 第5章 存储管理</h2>
<blockquote>
<blockquote>
<p>存储器的功能是存放二进制表示的程序和数据，计算机正是依赖它自动连续工作。冯·诺依曼型计算机的基本特征是事先把程序和数据存放在存储器中，在运算过程中由存储器快速提供给中央处理器进行处理，这就是程序存储工作方式。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>存储器管理的主要对象是内存。</p>
</blockquote>
</blockquote>
<h3 id="◆-5-1-存储器概述" tabindex="-1"><a class="header-anchor" href="#◆-5-1-存储器概述" aria-hidden="true">#</a> ◆ 5.1 存储器概述</h3>
<blockquote>
<blockquote>
<p>存储元件必须具有两个截然不同的物理状态，才能被用来表示二进制代码“0”和“1”。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.按存储器的器件和存储介质分类</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>按构成存储器的器件和存储介质主要可分为半导体器件、磁性材料和光介质存储器。用半导体器件构成的存储器称为半导体存储器；磁性材料存储器主要有磁芯存储器和磁表面存储器，后者又分为磁盘存储器和磁带存储器；光介质存储器一般做成光盘，利用光盘表面对极细的激光束的反射程度来区别存“0”还是存“1”，这是20世纪80年代才出现的新型存储器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>从原理上讲，只要具有两个明显稳定的物理状态的器件和介质都能用来存储二进制信息。但真正能用来作为存储器的器件和介质还必须满足一些技术上的要求，例如，便于和电信号转换、便于读/写、速度高、可靠性高等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.按存取方式分类</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）顺序存取存储器（Sequential Access Memory，SAM）。这类存储器的特点是信息顺序写入或读出，SAM属于可读/可写存储器，其特点是数据所在的位置不同，读/写的时间就有差异，即存取时间的长短与位置有关。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>它不按字单元编址，而以记录块为单位编址。磁带存储器就是一种顺序存储器，它的最大优点是存储容量大，缺点则是存取速度慢。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）随机存取存储器（Random Access Memory，RAM）。随机存储器（又称为读/写存储器）指通过指令可以随机地对存储器的各个单元进行访问，每个单元的读出时间和写入时间都是常数，它与各单元所处的位置无关。随机存取存储器的特点是CPU或I/O设备在任何时刻都可按地址访问其任一个存储单元，而且访问时间与地址无关。这类存储器的特点是数据的易失性，即一旦断电，所存的数据全部丢失。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>半导体存储器一般属于这类存储器。随机存取存储器（RAM）主要用来存放当前运行的程序、各种输入/输出数据、中间运算结果及堆栈等，其存储的内容既可随时读出，也可随时写入和修改。RAM存储单元是存储器的核心部分。按工作方式不同，可分为静态和动态两类，按所用元件类型，又可分为双极型和MOS型两种，因此存储单元电路形式多种多样。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>随机存取存储器主要充当高速缓冲存储器和主存储器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）直接存取存储器（Direct Access Memory，DAM）。此类存储器的存取方式介于RAM和SAM之间，对信息的存取包含两个逻辑操作：首先直接选取需要存取信息所在的区域，然后用顺序方式存取。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>此类存储器的容量也比较大，速度则介于SAM和RAM之间，读/写时间一般为ms级，主要用做辅存。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（4）只读存储器（Read Only Memory，ROM）。只读存储器是一种对其内容只能读出不能写入的存储器。在正常读/写操作下，这类存储器的内容只能读出而不能写入。数据一旦写入存储器就固定不变了，切断电源信息也不会丢失，所以只读存储器常用于存储数字系统及计算机中不需改写的数据。如汉字字型库、字符及图形符号、数据转换表及计算机操作系统程序等。ROM从本质上讲是非易失性的，即存储的数据不会因断电而消失，这是与RAM的主要区别。有的ROM位于主存中特定区域（如ROM BIOS）其访问方式和RAM一样按地址访问，也有的ROM用做辅存，采用顺序访问方式，如CD-ROM。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.按存储器在计算机中的作用划分</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>按在计算机中的作用可以分为主存储器（主存或内存）、辅助存储器（外存）、缓冲存储器等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（1）主存储器。主存设在主机内部，主存储器是计算机系统中的重要部件，用来存放计算机运行时的大量程序和数据，主存储器目前一般由MOS半导体存储器构成。其特点是速度较高，但容量较小，价格也较高。由于CPU可直接随机地对主存进行读/写，而且访问极其频繁，所以主存的性能在很大程度上影响了整个计算机系统的性能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>从主存实现的读/写功能来区分，主存储器可由只读存储区ROM和读写存储区RAM两部分组成，它们分别采用ROM和RAM存储器芯片实现的。ROM存储区用来存储内容固定不变的程序和数据，如操作系统的内核部分、系统刚加电时运行的硬件诊断程序等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>从主存所用的半导体工艺来区分，存储器芯片又可以分为静态存储器SRAM（Static Random Access Memory，SRAM）和动态存储器（DynamicRandom Access Memory，DRAM）两种类型。由于动态存储器集成度高、生产成本低，被广泛用于组成大容量的主存储器。静态存储器的集成度较小、读/写速度快、生产成本高，通常用于组成容量较小的高速缓冲存储器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）辅助存储器。辅助存储器又称外存储器。CPU不能对外存直接访问，而必须通过配备专门的设备才能够对它进行读/写（如磁盘驱动器等），这是它与内存之间的一个本质的区别。它主要由磁表面存储器组成。辅助存储器用来存放当前暂时不用的程序或数据，需要时再成批地调入主存，所存储的信息在断电后也不会消失。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>外存储器的内容需要调入主存后才能被CPU访问。外存储器的特点是容量大，所以可存放大量的程序和数据。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>几种常用的辅助存储器有磁盘、光盘、闪存、磁盘阵列等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>闪存的应用主要有以下两大领域：用于完全整合型的移动存储设备U盘和用于代替硬盘作为快速存储的固态闪存硬盘。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>固态闪存硬盘（Solid Flash Drives，SFD）是由控制单元和存储单元（Flash芯片）组成的，简单地说就是用固态电子存储芯片阵列而制成的硬盘（目前最大容量为5TB），固态闪存硬盘的接口规范和定义、功能及使用方法上与普通硬盘完全相同，在产品外形和尺寸上也完全与普通硬盘一致，包括3.5&quot;，2.5&quot;，1.8&quot;多种类型。由于固态闪存硬盘没有普通硬盘的旋转介质，因而抗震性极佳，同时工作温度很宽可工作在-45～+85℃。广泛应用于军事、车载、航空、导航设备等领域。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>SFD存在以下几点优点</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>数据存取速度快。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>防震抗摔。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>闪存硬盘工作时噪声小、发热量小、散热快</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>SFD存在的不足主要是数据的不可恢复性。如果是传统的磁盘或者磁带存储方式，发生磁道损坏时，通过数据恢复可以还原一部分数据。但是如果是固态闪存硬盘，一但芯片发生损坏，要想找回数据那几乎就是不可能的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（3）高速缓冲存储器（Cache）。高速缓冲存储器（Cache）放置在两个访问速度不同的存储部件之间，例如放在CPU和主存之间，用来暂存程序和数据，以加快部件间的信息交换。目前由双极型半导体组成，构成计算机系统中的一个高速小容量存储器。其存取速度接近CPU的工作速度。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>CPU能够直接访问的存储器称为内存储器，高速缓存和主存都是内存储器。在配置了高速缓存的计算机内，主存储器和高速缓存之间要不断交换数据。如果计算机没有配置高速缓存，内存储器就是主存储器，两个名称可以换用。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>磁性存储器是一种永久性存储器，半导体存储器是一种易失性存储器。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>人们通常将1个二进制位称为“位（bit）”，将8位二进制位称为“字节（Byte）”</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在计算机中，一串数码作为一个整体来处理或运算的，称为一个计算机字，简称字。字通常分为若干字节（每字节一般是8位），字的长度用位数来表示。计算机的每个字所包含的位数称为字长。根据计算机的不同，字长有固定的和可变的两种。固定字长，即字长度不论什么情况都是固定不变的；可变字长，则在一定范围内，其长度是可变的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果一台计算机的字长是另一台计算机的两倍，即使两台计算机的速度相同，在相同的时间内，前者能做的工作是后者的两倍。字长是衡量计算机性能的一个重要因素。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>通常，主存是按机器字为单位来进行读/写操作的，一次操作的信息位数就是一个计算机的字长。在存储器中，通常每个信息单元存储一个字，因此每个字都是可以寻址的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>目前的计算机的处理器大部分已达到64位，一个字可以包含多个字节。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>主存储器的工作原理：由CPU发来的地址送到存储器地址寄存器中，在读/写控制线路的作用下，经过地址译码后，选中存储体中某一存储单元，对该存储单元进行读/写操作，读出或写入的信息都暂存于存储器数据寄存器中（Memory DataRegister，MDR）。进行读操作时，存储单元内容不被破坏，仍为原值。而在写操作时，则旧的内容将被新的信息所取代。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在计算机发展的初期人们就认识到：容量要求很大的存储系统，仅仅采用单一结构的存储器是行不通的。它至少需要两种存储器：主存和辅存。使用速度较快、容量不大的磁芯或半导体存储器作为主存，而用容量极大，价格便宜的磁带、磁盘作为辅存。采用虚拟存储器技术，把CPU当前正在运行的程序和数据放在主存中，而暂不执行的程序和数据则放在辅存中，形成了虚拟存储系统。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>高速缓存解决了主存的速度问题，辅存则解决了主存的容量问题</p>
</blockquote>
</blockquote>
<h3 id="◆-5-2-高速缓冲存储器" tabindex="-1"><a class="header-anchor" href="#◆-5-2-高速缓冲存储器" aria-hidden="true">#</a> ◆ 5.2 高速缓冲存储器</h3>
<blockquote>
<blockquote>
<p>在现代高性能的计算机系统中，对存储器既要求速度快，又要求容量大，同时价格又要合理，按照现在所能达到的技术水平，仅仅用一种技术组成单一的存储器是不可能同时满足上述要求的，只有采用层次结构，把几种存储技术结合起来，才能解决存储器高速度、大容量和合理成本三者的矛盾。其中一种重要的提高存储器速度的措施是在主存储器与CPU之间增加一个高速缓冲器（Cache）来存储使用频繁的指令和数据，以提高访存操作的平均速度。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>存储器设计目标之一是以较少的成本使存储体系与CPU的速度匹配，同时还要求存储器具有尽可能大的容量。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>Cache存储器介于CPU和主存之间，它的工作速度远远大于主存，全部功能由硬件实现，并且对程序员是透明的，即程序员不能对Cache进行操作和控制。</p>
</blockquote>
</blockquote>
<h3 id="◆-5-3-内存分配方式" tabindex="-1"><a class="header-anchor" href="#◆-5-3-内存分配方式" aria-hidden="true">#</a> ◆ 5.3 内存分配方式</h3>
<blockquote>
<blockquote>
<p>内存空间是由存储单元（字节或字）组成的一维连续的地址空间，用来存放当前正在运行的程序和数据。内存分配的功能是提供恰当的算法为每个进入内存的程序分配内存空间，并采用合适的数据结构对已分配的或空闲的内存空间进行管理。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>内存分配方式分为连续分配和离散分配。连续分配是指为用户程序分配连续的内存空间，它包括单一连续分配和分区分配。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分区分配其主要思想是将内存用户区分成若干分区，每个分区存储一道程序。它又可以分为固定分区式（静态分配）和动态分区式（动态分配）。固定分区式中分区大小固定，作业运行期间不允许“移动”和申请新的内存空间；动态分区式的分区大小和数目可变，作业运行期间允许申请新的内存空间，由于会产生多个不可利用的内存零头（称“碎片”），所以需要采用紧凑技术，因此作业的物理地址空间在运行区间可能“移动”。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>离散分配是指用户程序分散存储在许多不相邻的内存分区中，从而避免由紧凑“碎片”带来的额外的系统开销。根据离散分配时所用基本方式的不同，可以将其分为页式存储管理、段式存储管理和段页式存储管理三种方式。</p>
</blockquote>
</blockquote>
<h3 id="◆-6-1-i-o硬件组成" tabindex="-1"><a class="header-anchor" href="#◆-6-1-i-o硬件组成" aria-hidden="true">#</a> ◆ 6.1 I/O硬件组成</h3>
<blockquote>
<blockquote>
<p>I/O系统是用于实现数据输入、输出及数据存储的系统</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在单总线结构中，允许I/O设备之间或I/O设备与内存之间直接交换信息，只需CPU分配总线使用权，不需要CPU干预信息的交换，即总线资源是由各大功能部件分时共享的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>由于所有部件都挂在同一条总线上，因此不允许两个部件同时使用单总线，总线负载也很重，这不但影响操作速度，甚至可能使系统吞吐量达到饱和状态以至于无法胜任的程度。所以，单总线结构一般用于速度要求不高的计算机中。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在双总线结构中，因CPU可通过存储总线访问内存，因而减轻了系统总线的负担，同时，也加大了信息传送的效率。另外，在这种结构中，内存与外设之间可通过系统总线传送信息，不必经过CPU，所以提高了CPU的工作效率。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在双总线的基础上增加了I/O总线，这种结构称为三总线结构</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在三总线结构中，I/O总线是外设与通道之间传送数据的公共通路，其中通道又称为I/O处理机。因为三总线结构中采用了通道，它减轻了CPU对数据的I/O控制，使整个系统的效率得到很大的提高，所以在中、大型计算机系统中多采用三总线结构。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>根据总线所传输的信息内容不同，总线可以分为地址总线、数据总线和控制总线。任何类型的计算机总线都包含这3种总线。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>数据总线的特点是：◆ 双向传输。例如，在CPU和内存之间的数据线，既可以传送CPU到内存的数据，也可以传送内存到CPU的数据。◆ 数据线的数据与计算机字长相同。◆ 采用三态电路。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>控制总线的特点是：◆ 单向传输。◆ 控制总线的数目取决于计算机系统的性能。上述3种总线由微处理器芯片的引脚分别引出。</p>
</blockquote>
</blockquote>
<h3 id="◆-7-1-文件概念" tabindex="-1"><a class="header-anchor" href="#◆-7-1-文件概念" aria-hidden="true">#</a> ◆ 7.1 文件概念</h3>
<blockquote>
<blockquote>
<p>在MS-DOS系统中，一个文件的名字包括文件名和扩展名两部分；前者用于识别文件，长度为1～8个字符；后者用于标识文件特性，长度为0～3个字符；两者之间用一个圆点隔开。文件名和扩展名均不区分大小写，可用字符包括字母、数字及一些特殊符号。扩展名常常用作定义各种类型的文件，系统有一些约定扩展名。例如，COM表示可执行的二进制代码文件；EXE表示可执行的浮动二进制代码文件；LIB表示库程序文件；BAT表示批命令文件；OBJ表示编译或汇编生成的目标文件等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在现代操作系统中，不但信息组织成文件，对设备的访问也都是基于文件进行的。例如，打印一批数据就是向打印机设备文件写数据，从键盘接收一批数据就是从键盘设备文件读数据。</p>
</blockquote>
</blockquote>
<h3 id="◆-7-2-文件结构和文件系统" tabindex="-1"><a class="header-anchor" href="#◆-7-2-文件结构和文件系统" aria-hidden="true">#</a> ◆ 7.2 文件结构和文件系统</h3>
<blockquote>
<blockquote>
<p>介绍常用的几种文件的物理结构</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.顺序文件将一个文件中逻辑上连续的信息存放到存储介质依次相邻的块上便形成顺序结构，这类文件叫顺序文件，又称连续文件。显然，这是一种逻辑记录顺序和物理记录顺序完全一致的文件，通常，记录按存放的顺序依次被读出或修改。连续文件是把一个逻辑上连续的文件信息存放在连续编号的物理块中。例如，文件file1长度为2500字节，存放在连续分块的磁带上，每块大小设为512字节，这样它要占用5块。设首块编号是11</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一切存于磁带上的文件都只能是顺序文件。此外，卡片机、打印机、纸带机介质上的文件也属于此类文件。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>顺序文件的优点是在顺序存取时速度较快，常用于存放系统文件，如操作系统文件、编译程序文件和其他由系统提供的实用程序文件。因为这类文件往往被从头至尾依次存取。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>顺序文件也存在如下缺点：（1）要求建立文件时就确定它的长度，依此来分配相应的存储空间，这往往很难实现。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>（2）它不便于文件的动态扩充。在实际计算时，作为输出结果的文件往往随执行过程不断增加新内容。当该文件需要扩大空间而其后的存储单元已被别的文件占用时，就必须另外寻找一个足够大的空间，把原空间中的内容和新加入的内容复制进去。这种文件的“大搬家”是很费时的。（3）可能出现外部碎片，就是在存储介质上存在很多空闲块，但它们都不连续，无法被连续文件使用，造成浪费。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.链接文件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>把一个逻辑上连续的文件分散地存放在不同的物理块中，这些物理块既不要求连续，也不必规则排列。为了使系统能找到下一个逻辑块所在的物理块，可在各物理块中设立一个指针（称为链接字），它指示该文件的下一个物理块</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>链接文件克服了顺序文件的缺点，但又带来了新的问题：（1）一般仅适用于对信息的顺序访问，而不利于对文件的随机存取。例如，为了存取逻辑块号2中的信息，必须从头向后顺次检索，通过65#块的链接字才能知道所需的物理块号。（2）每个物理块上增加了一个链接字，为信息管理添加了一些麻烦。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.索引文件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>索引文件是实现非连续分配的另一种方案：系统为每个文件建立一个索引表，其中的表项指出存放该文件的各个物理块号，而整个索引表由文件说明项指出</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>适用于数据记录保存在随机存取存储设备上的文件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>这种结构除了具备链接文件的优点之外，还克服了它的缺点，它可以方便地进行随机存取。但是这种组织形式需要增加索引表，增加了空间开销。如果索引表仅放在盘上，那么在存取文件时首先得取出索引表，然后才能查表、得到物理块号，这样就至少增加了一次访盘操作，从而降低了存取文件的速度，加重了I/O负担。一种改进办法是把索引表部分或全部放入内存，这是以内存空间为代价来换取存取速度的改善。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.多重索引文件</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>当文件很大时，不仅存放文件信息需要大量盘块，而且相应的索引表也必然很大</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>单—索引表结构已无法满足灵活性和节省内存的需要，为此人们提出多重索引结构（又称多级索引结构）。在这种结构中采用了间接索引方式，即由最初索引项中得到某一盘块号，该块中存放的信息是另一组盘块号；而后者每一块中又可存放下一组盘块号（或者是文件本身信息）。这样间接几级（通常为1～3级），最末尾的盘块中存放的信息一定是文件内容</p>
</blockquote>
</blockquote>
<h3 id="◆-7-4-文件系统实现" tabindex="-1"><a class="header-anchor" href="#◆-7-4-文件系统实现" aria-hidden="true">#</a> ◆ 7.4 文件系统实现</h3>
<blockquote>
<blockquote>
<p>文件系统是在建立在某种存储介质上的，目前最常用的存储介质就是磁盘。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>磁盘在出厂之前，都做过低级格式化，即进行了扇区的划分。低级格式化之后的硬盘，一般先进行分区，所谓分区就是把硬盘分成几部分，以便于用户使用。如果一个计算机系统中只有一块硬盘，而用户又希望安装多个操作系统，为了使多个操作系统互不干扰，必须将它们安装在不同的分区上。硬盘被分区之后，可分别对每个分区进行高级格式化，即在该分区上创建文件系统，如FAT 32、NTFS等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>分区相当于把一块硬盘划分成多个逻辑硬盘，每个逻辑硬盘逻辑的第一个扇区都为引导记录，分别用于不同的操作系统的引导，即多引导。整个硬盘的第一个扇区超脱了所有的分区之外，它不属于任何一个分区，它被称为主引导记录（Main BootRecord，MBR）。</p>
</blockquote>
</blockquote>
<h3 id="◆-8-1-网络操作系统简介" tabindex="-1"><a class="header-anchor" href="#◆-8-1-网络操作系统简介" aria-hidden="true">#</a> ◆ 8.1 网络操作系统简介</h3>
<blockquote>
<blockquote>
<p>网络操作系统应具有以下5个方面的功能</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.网络通信</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.资源共享管理</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在局域网中，典型的共享资源有硬盘、打印机、文件和数据。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.网络服务</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.网络管理</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>网络管理最基本的任务是安全管理。通过存取控制来确保存取数据的安全性；通过容错技术来保证系统出现故障时数据的安全性。此外，还要对网络性能进行监视，对网络使用情况进行统计，以便为提高网络性能提供必要的信息，如进行网络维护和记账等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5.互操作能力</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>网络操作系统都具有以下8种服务</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.文件服务（File Service）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.打印服务（Print Service）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.数据库服务（Data Base Service）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.通信服务（Communication Service）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>局域网提供的通信服务主要有：工作站与工作站之间的对等通信、工作站与网络服务器之间的通信服务等功能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>5.信息服务（Message Service）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>局域网可以通过存储转发方式或对等方式完成电子邮件服务。目前，信息服务已经发展为文本、图像、数字视频与语音数据的传输服务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>6.分布式服务（Distributed Service）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>7.网络管理服务</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>网络操作系统提供了丰富的网络管理服务工具，可以提供网络性能分析、网络状态监控、存储管理等多种管理服务。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>8.Internet/Intranet服务</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>为适应Internet与Intranet的应用，网络操作系统一般都支持TCP/IP协议，提供各种Internet服务，使局域网服务器很容易成为Web服务器，全面支持Internet与Intranet访问。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>传输控制协议（TCP）和网际协议（IP）</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>但TCP/IP实际上是一组协议，它包括上百个各种功能的协议，如远程登录、文件传输和电子邮件等，而TCP协议和IP协议是保证数据完整传输的两个基本的重要协议。通常说TCP/IP是Internet协议族，而不仅是TCP和IP。</p>
</blockquote>
</blockquote>
<h3 id="◆-8-2-系统的安全性" tabindex="-1"><a class="header-anchor" href="#◆-8-2-系统的安全性" aria-hidden="true">#</a> ◆ 8.2 系统的安全性</h3>
<blockquote>
<blockquote>
<p>“数字签名”与普通文本签名的最大区别在于，它可以使用个性鲜明的图形文件，你只要利用扫描仪或作图工具将你的个性签名、印章甚至相片等，制作成BMP文件，就可以当做“数字签名”的素材。目前可以提供“数字签名”功能的软件很多，用法和原理都大同小异，其中比较常用的有“OnSign”。安装“OnSign”后，在Word、Outlook等程序的工具栏上，就会出现，“OnSign”的快捷按钮，每次使用时，需输入自己的密码，以确保他人无法盗用。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>可以将计算机病毒的表现现象分为三大类，即发作前、发作时和发作后。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机病毒发作前是指从计算机病毒感染计算机系统，潜伏在系统内开始，一直到激发条件满足，病毒发作的一个阶段。在这个阶段内，病毒的行为以潜伏、传播为主。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>①平时运行正常的计算机突然无缘无故地死机。病毒感染计算机，修改了系统中断等，引起系统不稳定。②操作系统无法正常启动。病毒感染了系统文件，无法被操作系统正确加载。③运行速度明显变慢。病毒占用了大量系统资源。④以前能正常运行的软件经常发生内存不足的错误。可能是计算机病毒驻留后台占用了大量的内存资源。⑤打印机和通信发生异常。可能是计算机病毒驻留内存后占用了打印、通信端口的中断服务程序，使之不能工作。⑥无意中要求对软盘进行读/写。可能是计算机病毒自动查找软盘是否存在时引起的系统异常。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>⑦以前能正常运行的应用程序经常发生死机或者非法错误。可能是由于计算机病毒感染应用程序后破坏了应用程序本身的正常功能，或者计算机病毒本身存在兼容性问题造成的。⑧系统文件的时间、日期、大小发生变化。这是最明显感染病毒的现象。病毒感染文件，会将自身附加到原文件后面，造成原文件大小增加，文件的访问和修改日期也会随之更改。⑨运行Word，打开Word文档后，该文件另存为时只能以模板方式保存。这往往是Word感染宏病毒所致。</p>
</blockquote>
</blockquote>
<h3 id="◆-8-3-操作系统接口" tabindex="-1"><a class="header-anchor" href="#◆-8-3-操作系统接口" aria-hidden="true">#</a> ◆ 8.3 操作系统接口</h3>
<blockquote>
<blockquote>
<p>操作系统在隐藏了内部实现细节后向用户提供了接口，支持用户与操作系统之间进行交互。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>用户接口可以两种形式呈现在用户面前：一种是联机命令形式，直接提供给用户在终端上使用；另一种是系统调用形式，提供给用户在编程时使用。人们通常把上述两种形式分别称为联机命令接口和程序接口。在新型操作系统中，为进一步方便用户使用计算机，又普遍增加了一种基于图像的图形用户接口。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程控制类系统调用。这类系统调用主要用于对进程的控制，如创建和终止进程的系统调用、获得和设置进程属性的系统调用、撤销和执行进程的系统调用、进程等待等系统调用。以UNIX及Linux为例，具体有创建进程的调用fork（）、阻塞当前执行进程的系统调用wait（）、终止进程的系统调用exit（）、获得进程标识符的系统调用getPid（）、获取进程优先级的系统调用getPriority（）、暂停当前进程的系统调用pause（）等。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>文件操作类系统调用。此类系统调用用户经常使用且种类较多。包括文件的打开（Open）、关闭（Close）、读（Read）、写（Write）、创建（Create）、删除（Delete）等系统调用。其中Read和Write两个系统调用，是文件操纵类中使用最频繁的。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进程通信类系统调用。该类系统调用用在进程之间传递信息和信号：主要包括套接字（Socket）的建立、链接、控制和删除等；进程间通信用的消息队列、共享存储区以及有关同步机制的建立、控制和删除等有关系统调用。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对于系统调用，控制是由原来的用户态转换为系统态，这要借助于中断和陷入处理机制来完成，在该机制中包括中断和陷入硬件机构、中断和陷入处理程序两部分。</p>
</blockquote>
</blockquote>
<h3 id="◆-8-4-bios基础" tabindex="-1"><a class="header-anchor" href="#◆-8-4-bios基础" aria-hidden="true">#</a> ◆ 8.4 BIOS基础</h3>
<blockquote>
<blockquote>
<p>BIOS，完整地说应该是ROM-BIOS，是只读存储器基本输入/输出系统的简写，它实际上是被固化到计算机中的一组程序，为计算机提供最低级的、最直接的硬件控制。准确地说，BIOS是硬件与软件程序之间的一个“转换器”或者说是接口（虽然它本身也只是一个程序），负责解决硬件的即时需求，并按软件对硬件的操作要求具体执行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>计算机启动时，首先进入BIOS，然后加电自检，即进行系统自测、初始化和参数设置的校验等，最后系统将新设置的参数存入系统主板上的CMOS RAM中，以便再启动时使用。BIOS主要有以下几个管理功能。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.BIOS中断服务程序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>BIOS中断服务程序实质上是微机系统中软件与硬件之间的一个可编程接口，主要用于程序软件功能与微机硬件之间实施衔接。如DOS和Windows操作系统中对软盘、硬盘、光驱、键盘、显示器等外设的管理，都是直接建立在BIOS系统中断服务程序的基础上，而且操作人员也可以通过访问INT 5、INT 13等中断点而直接调用BIOS中断服务程序。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>2.BIOS系统设置程序</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>3.POST上电自检</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4.BIOS系统启动自举程序</p>
</blockquote>
</blockquote>
</div></template>


