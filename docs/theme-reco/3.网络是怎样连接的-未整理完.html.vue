<template><div><h1 id="网络是怎样连接的" tabindex="-1"><a class="header-anchor" href="#网络是怎样连接的" aria-hidden="true">#</a> 网络是怎样连接的</h1>
<p>户根勤</p>
<h2 id="◆-探索之旅路线图" tabindex="-1"><a class="header-anchor" href="#◆-探索之旅路线图" aria-hidden="true">#</a> ◆ 探索之旅路线图</h2>
<p>要实现应用程序之间的交互，我们需要一个能够在浏览器和Web服务器之间传递请求和响应的机制。网络是由很多计算机等设备相互连接组成的，因此在通信的过程中需要确定正确的通信对象，并将请求和响应发送给它们。请求和响应在传递的过程中可能会丢失或损坏[插图]，因此这些情况也必须要考虑到。所以说，我们需要一种机制，无论遇到任何情况都能够将请求和响应准确无误地发送给对方。由于请求和响应都是由0和1组成的数字信息，所以可以说，我们需要的是一种能够将数字信息搬运到指定目的地的机制。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>这种机制是由操作系统中的网络控制软件，以及交换机、路由器等设备分工合作来实现的，它的基本思路是将数字信息分割成一个一个的小块，然后装入一些被称为“包”（Packet）的容器中来运送。</p>
<p>包相当于信件或者包裹，而交换机和路由器则相当于邮局或快递公司的分拣处理区。包的头部存有目的地等控制信息，通过许多交换机和路由器的接力，就可以根据控制信息对这些包进行分拣，然后将它们一步一步地搬运到目的地。无论是家庭和公司里的局域网，还是外面的互联网，它们只是在规模上有所不同，基本的机制都是相同的。</p>
<p><strong>浏览器并不会亲自负责数据的传送。传送消息是搬运数字信息的机制负责的工作，因此浏览器会委托它将数据发送出去。具体来说，就是委托操作系统中的网络控制软件将消息发送给服务器。</strong></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202110302829.png" alt="image-20211202110302829"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202110406267.png" alt="image-20211202110406267"></p>
<h2 id="◆-第1章-浏览器生成消息——探索浏览器内部" tabindex="-1"><a class="header-anchor" href="#◆-第1章-浏览器生成消息——探索浏览器内部" aria-hidden="true">#</a> ◆ 第1章 浏览器生成消息——探索浏览器内部</h2>
<p>（1）生成HTTP请求消息</p>
<p>（2）向DNS服务器查询Web服务器的IP地址</p>
<p>请求消息生成之后，浏览器会委托操作系统向Web服务器发送请求，但浏览器必须告诉操作系统接收方的IP地址才行，因此浏览器必须先查出Web服务器的IP地址。网址中只有Web服务器的域名，因此浏览器需要向DNS服务器查询域名对应的IP地址</p>
<p>（3）全世界DNS服务器的大接力</p>
<p>（4）委托协议栈发送消息</p>
<p>查询到IP地址之后，浏览器就可以将消息委托给操作系统发送给Web服务器了，但这个委托到底是如何完成的呢</p>
<h3 id="◆-1-1-生成http请求消息" tabindex="-1"><a class="header-anchor" href="#◆-1-1-生成http请求消息" aria-hidden="true">#</a> ◆ 1.1 生成HTTP请求消息</h3>
<p>实际上除了“http:”，网址还可以以其他一些文字开头，例如“ftp:”“file:”“mailto:”等。</p>
<p>例如在访问Web服务器和FTP服务器时，URL中会包含服务器的域名和要访问的文件的路径名等，而发邮件的URL则包含收件人的邮件地址。此外，根据需要，URL中还会包含用户名、密码、服务器端口号等信息。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202110535275.png" alt="image-20211202110535275"></p>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202110626952.png" alt="image-20211202110626952"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202110745977.png" alt="image-20211202110745977"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>http请求消息格式：</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>第一行的末尾需要写上HTTP的版本号，这是为了表示该消息是基于哪个版本的HTTP规格编写的。到此为止，第一行就结束了。</p>
<p>第二行开始为消息头。</p>
<p>消息头的规格中定义了很多项目，如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等</p>
<p>写完消息头之后，还需要添加一个完全没有内容的空行，然后写上需要发送的数据。这一部分称为消息体，也就是消息的主体。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202110925426.png" alt="image-20211202110925426"></p>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202110942395.png" alt="image-20211202110942395"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202111001672.png" alt="image-20211202111001672"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202111025785.png" alt="image-20211202111025785"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202111040151.png" alt="image-20211202111040151"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>响应消息的格式以及基本思路和请求消息是相同的（图1.5（b）），差别只在第一行上。在响应消息中，第一行的内容为状态码和响应短语，用来表示请求的执行结果是成功还是出错。状态码和响应短语表示的内容一致，但它们的用途不同。状态码是一个数字，它主要用来向程序告知执行的结果（表1.3）；相对地，响应短语则是一段文字，用来向人们告知执行的结果。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202111232902.png" alt="image-20211202111232902"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202111252681.png" alt="image-20211202111252681"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202111306338.png" alt="image-20211202111306338"></p>
<h3 id="◆-1-2-向dns服务器查询web服务器的ip地址" tabindex="-1"><a class="header-anchor" href="#◆-1-2-向dns服务器查询web服务器的ip地址" aria-hidden="true">#</a> ◆ 1.2 向DNS服务器查询Web服务器的IP地址</h3>
<p>生成HTTP消息之后，接下来我们需要委托操作系统将消息发送给Web服务器。尽管浏览器能够解析网址并生成HTTP消息，但它本身并不具备将消息发送到网络中的功能，因此这一功能需要委托操作系统来实现</p>
<p>查询网址中服务器域名对应的IP地址。在委托操作系统发送消息时，必须要提供的不是通信对象的域名，而是它的IP地址。因此，在生成HTTP消息之后，下一个步骤就是根据域名查询IP地址。</p>
<p>互联网和公司内部的局域网都是基于TCP/IP的思路来设计的</p>
<p>就是由一些小的子网，通过路由器[插图]连接起来组成一个大的网络。这里的子网可以理解为用集线器[插图]连接起来的几台计算机，我们将它看作一个单位，称为子网。将子网通过路由器连接起来，就形成了一个网络。</p>
<p>在网络中，所有的设备都会被分配一个地址。这个地址就相当于现实中某条路上的“××号××室”。其中“号”对应的号码是分配给整个子网的，而“室”对应的号码是分配给子网中的计算机的，这就是网络中的地址。“号”对应的号码称为网络号，“室”对应的号码称为主机号，这个地址的整体称为IP地址。通过IP地址我们可以判断出访问对象服务器的位置，从而将消息发送到服务器。</p>
<p>发送者发出的消息首先经过子网中的集线器，转发到距离发送者最近的路由器上。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202111458294.png" alt="image-20211202111458294"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>接下来，路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器，即消息再次经过子网内的集线器被转发到下一个路由器（图1.8②）。前面的过程不断重复，最终消息就被传送到了目的地。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202111822033.png" alt="image-20211202111822033"></p>
<p>在IP地址的规则中，网络号和主机号连起来总共是32比特，但这两部分的具体结构是不固定的。在组建网络时，用户可以自行决定它们之间的分配关系，因此，我们还需要另外的附加信息来表示IP地址的内部结构，这一附加信息称为子网掩码。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>子网掩码的格式如图1.10②所示，是一串与IP地址长度相同的32比特数字，其左边一半都是1，右边一半都是0。其中，子网掩码为1的部分表示网络号，子网掩码为0的部分表示主机号。将子网掩码按照和IP地址一样的方式以每8比特为单位用圆点分组后写在IP地址的右侧。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202111947263.png" alt="image-20211202111947263"></p>
<p>子网掩码表示网络号与主机号之间的边界。</p>
<p>主机号部分的比特全部为0或者全部为1时代表两种特殊的含义。主机号部分全部为0代表整个子网而不是子网中的某台设备（图1.9（d））。此外，主机号部分全部为1代表向子网上所有设备发送包，即广播。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202112112828.png" alt="image-20211202112112828"></p>
<p>互联网中存在无数的路由器，它们之间相互配合，根据IP地址来判断应该把数据传送到什么地方。那么如果我们不用IP地址而是改用名称会怎么样呢？IP地址的长度为32比特，也就是4字节，相对地，域名最短也要几十个字节，最长甚至可以达到255字节。换句话说，使用IP地址只需要处理4字节的数字，而域名则需要处理几十个到255个字节的字符，这增加了路由器的负担，传送数据也会花费更长的时间</p>
<p>现在我们使用的方案是让人来使用名称，让路由器来使用IP地址。为了填补两者之间的障碍，需要有一个机制能够通过名称来查询IP地址，或者通过IP地址来查询名称，这样就能够在人和机器双方都不做出牺牲的前提下完美地解决问题。这个机制就是DNS。</p>
<p>向DNS服务器发出查询，也就是向DNS服务器发送查询消息，并接收服务器返回的响应消息。换句话说，对于DNS服务器，我们的计算机上一定有相应的DNS客户端，而相当于DNS客户端的部分称为DNS解析器，或者简称解析器。通过DNS查询IP地址的操作称为域名解析，因此负责执行解析（resolution）这一操作的就叫解析器（resolver）了。</p>
<p>解析器实际上是一段程序，它包含在操作系统的Socket库中。</p>
<p>库就是一堆通用程序组件的集合，其他的应用程序都需要使用其中的组件。库有很多好处。首先，使用现成的组件搭建应用程序可以节省编程工作量；其次，多个程序使用相同的组件可以实现程序的标准化。</p>
<p>Socket库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。</p>
<p>Socket库中包含很多用于发送和接收数据的程序组件。Socket库是用于调用网络功能的程序组件集合。</p>
<p>解析器的用法非常简单。Socket库中的程序都是标准组件，只要从应用程序中进行调用就可以了。具体来说，在编写浏览器等应用程序的时候，只要像图1.11这样写上解析器的程序名称“gethostbyname”以及Web服务器的域名“www.lab.glasscom.com”就可以了，这样就完成了对解析器的调用。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202112534721.png" alt="image-20211202112534721"></p>
<p>调用解析器后，解析器会向DNS服务器发送查询消息，然后DNS服务器会返回响应消息。响应消息中包含查询到的IP地址，解析器会取出IP地址，并将其写入浏览器指定的内存地址中。</p>
<p><strong>根据域名查询IP地址时，浏览器会使用Socket库中的解析器。</strong></p>
<p>网络应用程序（在我们的场景中就是指浏览器）调用解析器时，程序的控制流程就会转移到解析器的内部。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202113109275.png" alt="image-20211202113109275"></p>
<p>当控制流程转移到解析器后，解析器会生成要发送给DNS服务器的查询消息。这个过程与浏览器生成要发送给Web服务器的HTTP请求消息的过程类似，解析器会根据DNS的规格，生成一条表示“请告诉我www.lab.glasscom.com的IP地址的数据，并将它发送给DNS服务器。发送消息这个操作并不是由解析器自身来执行，而是要委托给操作系统内部的协议栈来执行。这是因为和浏览器一样，解析器本身也不具备使用网络收发数据的功能。解析器调用协议栈后，控制流程会再次转移，协议栈会执行发送消息的操作，然后通过网卡将消息发送给DNS服务器。</p>
<p>总之，如果要访问的Web服务器已经在DNS服务器上注册，那么这条记录就能够被找到，然后其IP地址会被写入响应消息并返回给客户端（图1.12⑥）。接下来，消息经过网络到达客户端，再经过协议栈被传递给解析器（图1.12⑦⑧），然后解析器读取出消息取出IP地址，并将IP地址传递给应用程序（图1.12⑨）。实际上，解析器会将取出的IP地址写入应用程序指定的内存地址中，用“&lt;内存地址&gt;”来表示，在实际的程序代码中应该写的是代表这一内存地址的名称。</p>
<p>到这里，解析器的工作就完成了，控制流程重新回到应用程序（浏览器）。现在应用程序已经能够从内存中取出IP地址了，所以说IP地址是用这种方式传递给应用程序的。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>Windows中的设置如图所示，解析器会根据这里设置的DNS服务器IP地址来发送消息。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202113327225.png" alt="image-20211202113327225"></p>
<h3 id="◆-1-3-全世界dns服务器的大接力" tabindex="-1"><a class="header-anchor" href="#◆-1-3-全世界dns服务器的大接力" aria-hidden="true">#</a> ◆ 1.3 全世界DNS服务器的大接力</h3>
<p>DNS服务器的基本工作就是接收来自客户端的查询消息，然后根据消息的内容返回响应。</p>
<p>来自客户端的查询消息包含以下3种信息。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（a）域名服务器、邮件服务器（邮件地址中@后面的部分）的名称</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（b） Class在最早设计DNS方案时，DNS在互联网以外的其他网络中的应用也被考虑到了，而Class就是用来识别网络的信息。不过，如今除了互联网并没有其他的网络了，因此Class的值永远是代表互联网的IN</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（c）记录类型表示域名对应何种类型的记录。例如，当类型为A时，表示域名对应的是IP地址；当类型为MX时，表示域名对应的是邮件服务器。对于不同的记录类型，服务器向客户端返回的信息也会不同。</p>
<p>DNS服务器上事先保存有前面这3种信息对应的记录数据</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202113645636.png" alt="image-20211202113645636"></p>
<p>例如，如果要查询www.lab.glasscom.com这个域名对应的IP地址，客户端会向DNS服务器发送包含以下信息的查询消息。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（a）域名=www.lab.glasscom.com</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（b） Class = IN</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（c）记录类型=A</p>
<p>在查询IP地址时我们使用A这个记录类型，而查询邮件服务器时则要使用MX类型。这是因为在DNS服务器上，IP地址是保存在A记录中的，而邮件服务器则是保存在MX记录中的。例如，对于一个邮件地址tone@glasscom.com，当需要知道这个地址对应的邮件服务器时，我们需要提供@后面的那一串名称。查询消息的内容如下。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（a）域名=glasscom.com</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（b） Class = IN</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（c）记录类型=MX</p>
<p>DNS服务器会返回10和mail.glasscom.com这两条信息。当记录类型为MX时，DNS服务器会在记录中保存两种信息，分别是邮件服务器的域名和优先级。此外，MX记录的返回消息还包括邮件服务器mail.glasscom.com的IP地址。</p>
<p>前面只介绍了A和MX这两个记录类型，实际上还有很多其他的类型。例如根据IP地址反查域名的PTR类型，查询域名相关别名的CNAME类型，查询DNS服务器IP地址的NS类型，以及查询域名属性信息的SOA类型等。</p>
<p>互联网中存在着不计其数的服务器，将这些服务器的信息全部保存在一台DNS服务器中是不可能的，因此一定会出现在DNS服务器中找不到要查询的信息的情况。下面来看一看此时DNS服务器是如何工作的。</p>
<p>就是将信息分布保存在多台DNS服务器中，这些DNS服务器相互接力配合，从而查找出要查询的信息。</p>
<p>DNS服务器中的所有信息都是按照域名以分层次的结构来保存的。</p>
<p>对于公司域来说，例如现在需要为每一个事业集团配备一台DNS服务器，分别管理各事业集团自己的信息，但我们之前也说过一个域是不可分割的，这该怎么办呢？没关系，我们可以在域的下面创建下级域，然后再将它们分别分配给各个事业集团。比如，假设公司的域为example.co.jp，我们可以在这个域的下面创建两个子域，即sub1. example.co.jp和sub2.example.co.jp，然后就可以将这两个下级域分配给不同的事业集团来使用。如果公司下级的组织不是事业部而是子公司，对于域来说也是没有区别的。因为域并不代表“事业集团”这一特定组织，无论是子公司还是什么别的组织名称，都可以分配相应的域。实际上，互联网中的域也是一样，通过创建下级的域来分配给不同的国家、公司和组织使用。通过实际的域名可能更容易理解，比如www.nikkeibp.co.jp这个域名，最上层的jp代表分配给日本这个国家的域；下一层的co是日本国内进行分类的域，代表公司；再下层的nikkeibp就是分配给某个公司的域；最下层的www就是服务器的名称。</p>
<p>互联网中有数万台DNS服务器，肯定不能一台一台挨个去找。我们可以采用下面的办法。首先，将负责管理下级域的DNS服务器的IP地址注册到它们的上级DNS服务器中，然后上级DNS服务器的IP地址再注册到更上一级的DNS服务器中，以此类推。也就是说，负责管理lab.glasscom.com这个域的DNS服务器的IP地址需要注册到glasscom.com域的DNS服务器中，而glasscom.com域的DNS服务器的IP地址又需要注册到com域的DNS服务器中。这样，我们就可以通过上级DNS服务器查询出下级DNS服务器的IP地址，也就可以向下级DNS服务器发送查询请求了。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202114152329.png" alt="image-20211202114152329"></p>
<p>在互联网中，com和jp的上面还有一级域，称为根域。根域不像com、jp那样有自己的名字，因此在一般书写域名时经常被省略，如果要明确表示根域，应该像www.lab.glasscom.com．这样在域名的最后再加上一个句点，而这个最后的句点就代表根域。</p>
<p>根域的DNS服务器中保管着com、jp等的DNS服务器的信息。由于上级DNS服务器保管着所有下级DNS服务器的信息，所以我们可以从根域开始一路往下顺藤摸瓜找到任意一个域的DNS服务器。</p>
<p>将根域的DNS服务器信息保存在互联网中所有的DNS服务器中。这样一来，任何DNS服务器就都可以找到并访问根域DNS服务器了。因此，客户端只要能够找到任意一台DNS服务器，就可以通过它找到根域DNS服务器。</p>
<p>分配给根域DNS服务器的IP地址在全世界仅有13个。</p>
<p>客户端首先会访问最近的一台DNS服务器（也就是客户端的TCP/IP设置中填写的DNS服务器地址），假设我们要查询www.lab.glasscom.com这台Web服务器的相关信息（图1.16①）。由于最近的DNS服务器中没有存放www.lab.glasscom.com这一域名对应的信息，所以我们需要从顶层开始向下查找。最近的DNS服务器中保存了根域DNS服务器的信息，因此它会将来自客户端的查询消息转发给根域DNS服务器（图1.16②）。根域服务器中也没有www.lab.glasscom.com这个域名，但根据域名结构可以判断这个域名属于com域，因此根域DNS服务器会返回它所管理的com域中的DNS服务器的IP地址，意思是“虽然我不知道你要查的那个域名的地址，但你可以去com域问问看”。接下来，最近的DNS服务器又会向com域的DNS服务器发送查询消息（图1.16③）。com域中也没有www.lab.glasscom.com这个域名的信息，和刚才一样，com域服务器会返回它下面的glasscom.com域的DNS服务器的IP地址。以此类推，只要重复前面的步骤，就可以顺藤摸瓜找到目标DNS服务器（图1.16⑤），只要向目标DNS服务器发送查询消息，就能够得到我们需要的答案，也就是www.lab.glasscom.com的IP地址了。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202114334570.png" alt="image-20211202114334570"></p>
<h4 id="_1-3-4-通过缓存加快dns服务器的响应" tabindex="-1"><a class="header-anchor" href="#_1-3-4-通过缓存加快dns服务器的响应" aria-hidden="true">#</a> 1.3.4 通过缓存加快DNS服务器的响应</h4>
<p>在真实的互联网中，一台DNS服务器可以管理多个域的信息，因此并不是像图1.16这样每个域都有一台自己的DNS服务器。图中，每一个域旁边都写着一台DNS服务器，但现实中上级域和下级域有可能共享同一台DNS服务器。在这种情况下，访问上级DNS服务器时就可以向下跳过一级DNS服务器，直接返回再下一级DNS服务器的相关信息。</p>
<p>有时候并不需要从最上级的根域开始查找，因为DNS服务器有一个缓存功能，可以记住之前查询过的域名。如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应，接下来的查询可以从缓存的位置开始向下进行。相比每次都从根域找起来说，缓存可以减少查询所需的时间。</p>
<p>当要查询的域名不存在时，“不存在”这一响应结果也会被缓存。</p>
<p>DNS服务器中保存的信息都设置有一个有效期，当缓存中的信息超过有效期后，数据就会从缓存中删除。而且，在对查询进行响应时，DNS服务器也会告知客户端这一响应的结果是来自缓存中还是来自负责管理该域名的DNS服务器。</p>
<h3 id="◆-1-4-委托协议栈发送消息" tabindex="-1"><a class="header-anchor" href="#◆-1-4-委托协议栈发送消息" aria-hidden="true">#</a> ◆ 1.4 委托协议栈发送消息</h3>
<p>知道了IP地址之后，就可以委托操作系统内部的协议栈向这个目标IP地址，也就是我们要访问的Web服务器发送消息了。要发送给Web服务器的HTTP消息是一种数字信息（digital data），因此也可以说是委托协议栈来发送数字信息。收发数字信息这一操作不仅限于浏览器，对于各种使用网络的应用程序来说都是共通的。因此，这一操作的过程也不仅适用于Web，而是适用于任何网络应用程序。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>和向DNS服务器查询IP地址的操作一样，这里也需要使用Socket库中的程序组件。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>收发数据的两台计算机之间连接了一条数据通道，数据沿着这条通道流动，最终到达目的地。我们可以把数据通道想象成一条管道，将数据从一端送入管道，数据就会到达管道的另一端然后被取出。数据可以从任何一端被送入管道，数据的流动是双向的。不过，这并不是说现实中真的有这么一条管道，只是为了帮助大家理解数据收发操作的全貌。</p>
<p>**在进行收发数据操作之前，双方需要先建立起这条管道才行。建立管道的关键在于管道两端的数据出入口，这些出入口称为套接字。**我们需要先创建套接字，然后再将套接字连接起来形成管道。实际的过程是下面这样的。首先，服务器一方先创建套接字，然后等待客户端向该套接字连接管道。当服务器进入等待状态时，客户端就可以连接管道了。具体来说，客户端也会先创建一个套接字，然后从该套接字延伸出管道，最后管道连接到服务器端的套接字上。当双方的套接字连接起来之后，通信准备就完成了。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202115032241.png" alt="image-20211202115032241"></p>
<p>管道在连接时是由客户端发起的，但在断开时可以由客户端或服务器任意一方发起。其中一方断开后，另一方也会随之断开，当管道断开后，套接字也会被删除。到此为止，通信操作就结束了。</p>
<p>收发数据的操作分为若干个阶段，可以大致总结为以下4个。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（1）创建套接字（创建套接字阶段）</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（2）将管道连接到服务器端的套接字上（连接阶段）</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（3）收发数据（通信阶段）</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（4）断开管道并删除套接字（断开阶段）</p>
<p>浏览器等应用程序并不会自己去做连接管道、放入数据这些工作，而是委托协议栈来代劳。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>内部分为创建套接字、连接Web服务器、发送数据、接收数据、断开连接几个阶段。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（1）</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>首先是套接字创建阶段。客户端创建套接字的操作非常简单，只要调用Socket库中的socket程序组件[插图]就可以了（图1.18①）。和调用解析器一样，调用socket之后，控制流程会转移到socket内部并执行创建套接字的操作，完成之后控制流程又会被移交回应用程序。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>套接字创建完成后，协议栈会返回一个描述符，应用程序会将收到的描述符存放在内存中。描述符是用来识别不同的套接字的，大家可以作如下理解。我们现在只关注了浏览器访问Web服务器的过程，但实际上计算机中会同时进行多个数据的通信操作，比如可以打开两个浏览器窗口，同时访问两台Web服务器。这时，有两个数据收发操作在同时进行，也就需要创建两个不同的套接字。</p>
<p>同一台计算机上可能同时存在多个套接字，在这样的情况下，我们就需要一种方法来识别出某个特定的套接字，这种方法就是描述符。我们可以将描述符理解成给某个套接字分配的编号。也许光说编号还不够形象，大家可以想象一下在酒店寄存行李时的场景，酒店服务人员会给你一个号码牌，向服务人员出示号码牌，就可以取回自己寄存的行李，描述符的原理和这个差不多。当创建套接字后，我们就可以使用这个套接字来执行收发数据的操作了。这时，只要我们出示描述符，协议栈就能够判断出我们希望用哪一个套接字来连接或者收发数据了。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202115439789.png" alt="image-20211202115439789"></p>
<p>（2）连接阶段：把管道接上去</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>我们需要委托协议栈将客户端创建的套接字与服务器那边的套接字连接起来。应用程序通过调用Socket库中的名为connect的程序组件来完成这一操作。这里的要点是当调用connect时，需要指定描述符、服务器IP地址和端口号这3个参数。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		第1个参数，即描述符，就是在创建套接字的时候由协议栈返回的那个描述符。connect会将应用程序指定的描述符告知协议栈，然后协议栈根据这个描述符来判断到底使用哪一个套接字去和服务器端的套接字进行连接，并执行连接的操作。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		第2个参数，即服务器IP地址，就是通过DNS服务器查询得到的我们要访问的服务器的IP地址。在DNS服务器的部分已经讲过，在进行数据收发操作时，双方必须知道对方的IP地址并告知协议栈。这个参数就是那个IP地址了。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		第3个参数，即端口号，这个需要稍微解释一下。可能大家会觉得，IP地址就像电话号码，只要知道了电话号码不就可以联系到对方了吗？其实，网络通信和电话还是有区别的，我们先来看一看IP地址到底能用来干什么。IP地址是为了区分网络中的各个计算机而分配的数值。因此，只要知道了IP地址，我们就可以识别出网络上的某台计算机。但是，连接操作的对象是某个具体的套接字，因此必须要识别到具体的套接字才行，而仅凭IP地址是无法做到这一点的。我们打电话的时候，也需要通过“请帮我找一下某某某”这样的方式来找到具体的某个联系人，而端口号就是这样一种方式。当同时指定IP地址和端口号时，就可以明确识别出某台具体的计算机上的某个具体的套接字。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><strong>能不能用前面创建套接字时提到的那个描述符来识别套接字呢？这种方法其实是行不通的，因为描述符是和委托创建套接字的应用程序进行交互时使用的，并不是用来告诉网络连接的另一方的，因此另一方并不知道这个描述符。同样地，客户端也无法知道服务器上的描述符。因此，客户端也无法通过服务器端的描述符去确定位于服务器上的某一个套接字。所以，我们需要另外一个对客户端也同样适用的机制，而这个机制就是端口号。如果说描述符是用来在一台计算机内部识别套接字的机制，那么端口号就是用来让通信的另一方能够识别出套接字的机制。</strong></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>只要指定了事先规定好的端口号，就可以连接到相应的服务器程序的套接字。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>既然确定连接对象的套接字需要使用端口号，那么服务器也得知道客户端的套接字号码才行吧，这个问题是怎么解决的呢？事情是这样的，首先，客户端在创建套接字时，协议栈会为这个套接字随便分配一个端口号。接下来，当协议栈执行连接操作时，会将这个随便分配的端口号通知给服务器。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>描述符：应用程序用来识别套接字的机制</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>IP地址和端口号：客户端和服务器之间用来识别对方套接字的机制</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（3）通信阶段：</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>传递消息当套接字连接起来之后，剩下的事情就简单了。只要将数据送入套接字，数据就会被发送到对方的套接字中。当然，应用程序无法直接控制套接字，因此还是要通过Socket库委托协议栈来完成这个操作。这个操作需要使用write这个程序组件，具体过程如下。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>首先，应用程序需要在内存中准备好要发送的数据。根据用户输入的网址生成的HTTP请求消息就是我们要发送的数据。接下来，当调用write时，需要指定描述符和发送数据（图1.18③），然后协议栈就会将数据发送到服务器。由于套接字中已经保存了已连接的通信对象的相关信息，所以只要通过描述符指定套接字，就可以识别出通信对象，并向其发送数据。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>接着，发送数据会通过网络到达我们要访问的服务器。接下来，服务器执行接收操作，解析收到的数据内容并执行相应的操作，向客户端返回响应消息[插图]。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>当消息返回后，需要执行的是接收消息的操作。接收消息的操作是通过Socket库中的read程序组件委托协议栈来完成的（图1.18③'）。调用read时需要指定用于存放接收到的响应消息的内存地址，这一内存地址称为接收缓冲区。于是，当服务器返回响应消息时，read就会负责将接收到的响应消息存放到接收缓冲区中。由于接收缓冲区是一块位于应用程序内部的内存空间，因此当消息被存放到接收缓冲区中时，就相当于已经转交给了应用程序。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（4）断开阶段：</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>收发数据结束当浏览器收到数据之后，收发数据的过程就结束了。接下来，我们需要调用Socket库的close程序组件进入断开阶段（图1.18④）。最终，连接在套接字之间的管道会被断开，套接字本身也会被删除。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>断开的过程如下。Web使用的HTTP协议规定，当Web服务器发送完响应消息之后，应该主动执行断开操作[插图]，因此Web服务器会首先调用close来断开连接。断开操作传达到客户端之后，客户端的套接字也会进入断开阶段。接下来，当浏览器调用read执行接收数据操作时，read会告知浏览器收发数据操作已结束，连接已经断开。浏览器得知后，也会调用close进入断开阶段。</p>
<p>HTTP协议将HTML文档和图片都作为单独的对象来处理，每获取一次数据，就要执行一次连接、发送请求消息、接收响应消息、断开的过程。因此，如果一个网页中包含很多张图片，就必须重复进行很多次连接、收发数据、断开的操作。对于同一台服务器来说，重复连接和断开显然是效率很低的，因此后来人们又设计出了能够在一次连接中收发多个请求和响应的方法。在HTTP版本1.1中就可以使用这种方法，在这种情况下，当所有数据都请求完成后，浏览器会主动触发断开连接的操作。</p>
<p>浏览器与Web服务器之间收发消息的过程，但实际负责收发消息的是协议栈、网卡驱动和网卡，只有这3者相互配合，数据才能够在网络中流动起来。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>本章测验：</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>1．http://www.nikkeibp.co.jp/中的http代表什么意思？</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		http协议</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>2．下面两个网址有什么不同？</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		a. http://www.nikkeibp.co.jp/sample</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		b. http://www.nikkeibp.co.jp/sample/</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		a中的sample代表文件名，b中的sample代表目录名</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>3．用来识别连接在互联网上的计算机和服务器的地址叫什么？</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		IP地址</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>4．根据Web服务器的域名来查询IP地址时所使用的服务器叫什么？</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		DNS服务器</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>5．向DNS服务器发送请求消息的程序叫什么？</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		解析器</p>
<h2 id="◆-第2章-用电信号传输tcp-ip数据-探索协议栈和网卡" tabindex="-1"><a class="header-anchor" href="#◆-第2章-用电信号传输tcp-ip数据-探索协议栈和网卡" aria-hidden="true">#</a> ◆ 第2章 用电信号传输TCP/IP数据（探索协议栈和网卡）</h2>
<p>1．我们现在使用的以太网中存在不符合国际标准（IEEE802.3/802.2）的部分。</p>
<ol start="2">
<li>TCP/IP是由TCP和IP两个协议的名字组合而成的，最开始这两个协议是合在一起的。</li>
<li>网络包通信技术是20世纪60年代为用计算机进行数据通信而设计出来的。</li>
</ol>
<h3 id="◆-2-1-创建套接字" tabindex="-1"><a class="header-anchor" href="#◆-2-1-创建套接字" aria-hidden="true">#</a> ◆ 2.1 创建套接字</h3>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202134603711.png" alt="image-20211202134603711"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>操作系统内部了，其中包括协议栈。协议栈的上半部分有两块，分别是负责用TCP协议收发数据的部分和负责用UDP协议收发数据的部分，它们会接受应用程序的委托执行收发数据的操作。</p>
<p>像浏览器、邮件等一般的应用程序都是使用TCP收发数据的，而像DNS查询等收发较短的控制数据的时候则使用UDP。</p>
<p>在互联网上传送数据时，数据会被切分成一个一个的网络包，而将网络包发送给通信对象的操作就是由IP来负责的。此外，IP中还包括ICMP协议和ARP协议。ICMP用于告知网络包传送过程中产生的错误以及各种控制消息，ARP用于根据IP地址查询相应的以太网MAC地址。</p>
<p>IP下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收的操作。</p>
<p>在协议栈内部有一块用于存放控制信息的内存空间，这里记录了用于控制通信操作的控制信息，例如通信对象的IP地址、端口号、通信操作的进行状态等。本来套接字就只是一个概念而已，并不存在实体，如果一定要赋予它一个实体，我们可以说这些控制信息就是套接字的实体，或者说存放控制信息的内存空间就是套接字的实体。</p>
<p>套接字中记录了用于控制通信操作的各种控制信息，协议栈则需要根据这些信息判断下一步的行动，这就是套接字的作用。</p>
<p>应用程序调用socket申请创建套接字，协议栈根据应用程序的申请执行创建套接字的操作。</p>
<p>创建套接字时，首先分配一个套接字所需的内存空间，然后向其中写入初始状态。</p>
<p>需要将表示这个套接字的描述符告知应用程序。描述符相当于用来区分协议栈中的多个套接字的号码牌。</p>
<p>收到描述符之后，应用程序在向协议栈进行收发数据委托时就需要提供这个描述符。由于套接字中记录了通信双方的信息以及通信处于怎样的状态，所以只要通过描述符确定了相应的套接字，协议栈就能够获取所有的相关信息，这样一来，应用程序就不需要每次都告诉协议栈应该和谁进行通信了。</p>
<h3 id="◆-2-2-连接服务器" tabindex="-1"><a class="header-anchor" href="#◆-2-2-连接服务器" aria-hidden="true">#</a> ◆ 2.2 连接服务器</h3>
<p>创建套接字之后，应用程序（浏览器）就会调用connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。话说，以太网的网线都是一直连接的状态，我们并不需要来回插拔网线，那么这里的“连接”到底是什么意思呢？连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作</p>
<p>套接字刚刚创建完成的时候，里面并没有存放任何数据，也不知道通信的对象是谁。在这个状态下，即便应用程序要求发送数据，协议栈也不知道数据应该发送给谁。浏览器可以根据网址来查询服务器的IP地址，而且根据规则也知道应该使用80号端口，但只有浏览器知道这些必要的信息是不够的，因为在调用socket创建套接字时，这些信息并没有传递给协议栈。因此，我们需要把服务器的IP地址和端口号等信息告知协议栈，这是连接操作的目的之一。</p>
<p>服务器上也会创建套接字，但服务器上的协议栈和客户端一样，只创建套接字是不知道应该和谁进行通信的。而且，和客户端不同的是，在服务器上，连应用程序也不知道通信对象是谁，这样下去永远也没法开始通信。于是，我们需要让客户端向服务器告知必要的信息，比如“我想和你开始通信，我的IP地址是xxx.xxx. xxx.xxx，端口号是yyyy。”可见，客户端向服务器传达开始通信的请求，也是连接操作的目的之一。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202142323964.png" alt="image-20211202142323964"></p>
<p>连接实际上是通信双方交换控制信息，在套接字中记录这些必要信息并准备数据收发的一连串操作，像上面提到的客户端将IP地址和端口号告知服务器这样的过程就属于交换控制信息的一个具体的例子。所谓控制信息，就是用来控制数据收发操作所需的一些信息，IP地址和端口号就是典型的例子。</p>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202142357125.png" alt="image-20211202142357125"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>当执行数据收发操作时，我们还需要一块用来临时存放要收发的数据的内存空间，这块内存空间称为缓冲区，它也是在连接操作的过程中分配的。</p>
<p>控制信息其实可以大体上分为两类：</p>
<p>​		第一类：是客户端和服务器相互联络时交换的控制信息。这些信息不仅连接时需要，包括数据收发和断开连接操作在内，整个通信过程中都需要，这些内容在TCP协议的规格中进行了定义。</p>
<p>为了避免各种不同的头部发生混淆，我们一般会记作TCP头部、以太网头部、IP头部</p>
<p>客户端和服务器在通信中会将必要的信息记录在头部并相互确认</p>
<p>​		第二类：那就是保存在套接字中，用来控制协议栈操作的信息。应用程序传递来的信息以及从通信对象接收到的信息都会保存在这里，还有收发数据操作的执行状态等信息也会保存在这里，协议栈会根据这些信息来执行每一步的操作。</p>
<p>Windows和Linux操作系统的内部结构不同，协议栈的实现方式不同，必要的控制信息也就不同。但即便如此，两种系统之间依然能够互相通信，同样地，计算机和手机之间也能够互相通信。正如前面所说，协议栈的实现不同，因此我们无法具体说明协议栈里到底保存了哪些控制信息，但可以用命令来显示一些重要的套接字控制信息（图2.2），这些信息无论何种操作系统的协议栈都是共通的，通过理解这些重要信息，就能够理解协议栈的工作方式了。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202142707982.png" alt="image-20211202142707982"></p>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202142732815.png" alt="image-20211202142732815"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>通信操作中使用的控制信息分为两类。（1）头部中记录的信息（2）套接字（协议栈中的内存空间）中记录的信息</p>
<p>TCP模块会与该IP地址对应的对象，也就是与服务器的TCP模块交换控制信息，这一交互过程包括下面几个步骤。首先，客户端先创建一个包含表示开始数据收发操作的控制信息的头部。如表2.1所示，头部包含很多字段，这里要关注的重点是发送方和接收方的端口号。到这里，客户端（发送方）的套接字就准确找到了服务器（接收方）的套接字，也就是搞清楚了我应该连接哪个套接字。然后，我们将头部中的控制位的SYN比特设置为1，大家可以认为它表示连接[插图]。此外还需要设置适当的序号和窗口大小</p>
<p>当TCP头部创建好之后，接下来TCP模块会将信息传递给IP模块并委托它进行发送</p>
<p>IP模块执行网络包发送操作后，网络包就会通过网络到达服务器，然后服务器上的IP模块会将接收到的数据传递给TCP模块，服务器的TCP模块根据TCP头部中的信息找到端口号对应的套接字，也就是说，从处于等待连接状态的套接字中找到与TCP头部中记录的端口号相同的套接字就可以了。当找到对应的套接字之后，套接字中会写入相应的信息，并将状态改为正在连接。上述操作完成后，服务器的TCP模块会返回响应，这个过程和客户端一样，需要在TCP头部中设置发送方和接收方端口号以及SYN比特。此外，在返回响应时还需要将ACK控制位设为1，这表示已经接收到相应的网络包。网络中经常会发生错误，网络包也会发生丢失，因此双方在通信时必须相互确认网络包是否已经送达，而设置ACK比特就是用来进行这一确认的。接下来，服务器TCP模块会将TCP头部传递给IP模块，并委托IP模块向客户端返回响应。</p>
<p>然后，网络包就会返回到客户端，通过IP模块到达TCP模块，并通过TCP头部的信息确认连接服务器的操作是否成功。如果SYN为1则表示连接成功，这时会向套接字中写入服务器的IP地址、端口号等信息，同时还会将状态改为连接完毕。到这里，客户端的操作就已经完成，但其实还剩下最后一个步骤。刚才服务器返回响应时将ACK比特设置为1，相应地，客户端也需要将ACK比特设置为1并发回服务器，告诉服务器刚才的响应包已经收到。当这个服务器收到这个返回包之后，连接操作才算全部完成。</p>
<p>建立连接之后，协议栈的连接操作就结束了，也就是说connect已经执行完毕，控制流程被交回到应用程序。</p>
<h3 id="◆-2-3-收发数据" tabindex="-1"><a class="header-anchor" href="#◆-2-3-收发数据" aria-hidden="true">#</a> ◆ 2.3 收发数据</h3>
<p>数据收发操作是从应用程序调用write将要发送的数据交给协议栈开始的（图2.3③），协议栈收到数据后执行发送操作。协议栈并不关心应用程序传来的数据是什么内容。在协议栈看来，要发送的数据就是一定长度的二进制字节序列而已。协议栈并不是一收到数据就马上发送出去，而是会将数据存放在内部的发送缓冲区中，并等待应用程序的下一段数据。</p>
<p>一次将多少数据交给协议栈是由应用程序自行决定的，协议栈并不能控制这一行为。在这样的情况下，如果一收到数据就马上发送出去，就可能会发送大量的小包，导致网络效率下降，因此需要在数据积累到一定量时再发送出去。至于要积累多少数据才能发送，不同种类和版本的操作系统会有所不同，不能一概而论，但都是根据下面几个要素来判断的。</p>
<p>第一个判断要素是每个网络包能容纳的数据长度，协议栈会根据一个叫作MTU的参数来进行判断。MTU表示一个网络包的最大长度，在以太网中一般是1500字节（图2.5）。MTU是包含头部的总长度，因此需要从MTU减去头部的长度，然后得到的长度就是一个网络包中所能容纳的最大数据长度，这一长度叫作MSS。当从应用程序收到的数据长度超过或者接近MSS时再发送出去，就可以避免发送大量小包的问题了。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<img src="\img\3.网络是怎样连接的\image-20211202143631992.png" alt="image-20211202143631992" style="zoom:80%;" />
<p>MTU：一个网络包的最大长度，以太网中一般为1500字节。MSS：除去头部之后，一个网络包所能容纳的TCP数据的最大长度。</p>
<p>另一个判断要素是时间。当应用程序发送数据的频率不高的时候，如果每次都等到长度接近MSS时再发送，可能会因为等待时间太长而造成发送延迟，这种情况下，即便缓冲区中的数据长度没有达到MSS，也应该果断发送出去。为此，协议栈的内部有一个计时器，当经过一定时间之后，就会把网络包发送出去。</p>
<p>如果仅靠协议栈来判断发送的时机可能会带来一些问题，因此协议栈也给应用程序保留了控制发送时机的余地。应用程序在发送数据时可以指定一些选项，比如如果指定“不等待填满缓冲区直接发送”，则协议栈就会按照要求直接发送数据。像浏览器这种会话型的应用程序在向服务器发送数据时，等待填满缓冲区导致延迟会产生很大影响，因此一般会使用直接发送的选项。</p>
<h4 id="_2-3-2-对较大的数据进行拆分" tabindex="-1"><a class="header-anchor" href="#_2-3-2-对较大的数据进行拆分" aria-hidden="true">#</a> 2.3.2 对较大的数据进行拆分</h4>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202150103460.png" alt="image-20211202150103460"></p>
<p>HTTP请求消息一般不会很长，一个网络包就能装得下，但如果其中要提交表单数据，长度就可能超过一个网络包所能容纳的数据量，比如在博客或者论坛上发表一篇长文就属于这种情况。</p>
<p>这种情况下，发送缓冲区中的数据就会超过MSS的长度，这时我们当然不需要继续等待后面的数据了。发送缓冲区中的数据会被以MSS长度为单位进行拆分，拆分出来的每块数据会被放进单独的网络包中。</p>
<p>根据发送缓冲区中的数据拆分的情况，当判断需要发送这些数据时，就在每一块数据前面加上TCP头部，并根据套接字中记录的控制信息标记发送方和接收方的端口号，然后交给IP模块来执行发送数据的操作，应用程序的数据一般都比较大，因此TCP会按照网络包的大小对数据进行拆分。使用ACK号确认网络包已收到。</p>
<p><strong>确认的原理</strong></p>
<p>TCP模块在拆分数据时，会先算好每一块数据相当于从头开始的第几个字节，接下来在发送这一块数据时，将算好的字节数写在TCP头部中，“序号”字段就是派在这个用场上的。</p>
<p>发送数据的长度也需要告知接收方，不过这个并不是放在TCP头部里面的，因为用整个网络包的长度减去头部的长度就可以得到数据的长度，所以接收方可以用这种方法来进行计算。有了上面两个数值，我们就可以知道发送的数据是从第几个字节开始，长度是多少了。</p>
<p>接收方会将到目前为止接收到的数据长度加起来，计算出一共已经收到了多少个字节，然后将这个数值写入TCP头部的ACK号中发送给发送方，这个返回ACK号的操作被称为确认响应，通过这样的方式，发送方就能够确认对方到底收到了多少数据。</p>
<p>在实际的通信中，序号并不是从1开始的，而是需要用随机数计算出一个初始值，这是因为如果序号都从1开始，通信过程就会非常容易预测，有人会利用这一点来发动攻击。但是如果初始值是随机的，那么对方就搞不清楚序号到底是从多少开始计算的，因此需要在开始收发数据之前将初始值告知通信对象。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202150131050.png" alt="image-20211202150131050"></p>
<p>连接过程中，有一个将SYN控制位设为1并发送给服务器的操作，就是在这一步将序号的初始值告知对方的。实际上，在将SYN设为1的同时，还需要同时设置序号字段的值，而这里的值就代表序号的初始值。</p>
<p>TCP数据收发是双向的，在客户端向服务器发送数据的同时，服务器也会向客户端发送数据</p>
<p>首先客户端先计算出一个序号，然后将序号和数据一起发送给服务器，服务器收到之后会计算ACK号并返回给客户端；相反地，服务器也需要先计算出另一个序号，然后将序号和数据一起发送给客户端，客户端收到之后计算ACK号并返回给服务器。</p>
<p>首先，客户端在连接时需要计算出与从客户端到服务器方向通信相关的序号初始值，并将这个值发送给服务器（图2.9①）。接下来，服务器会通过这个初始值计算出ACK号并返回给客户端（图2.9②）。初始值有可能在通信过程中丢失，因此当服务器收到初始值后需要返回ACK号作为确认。同时，服务器也需要计算出与从服务器到客户端方向通信相关的序号初始值，并将这个值发送给客户端（图2.9②）。接下来像刚才一样，客户端也需要根据服务器发来的初始值计算出ACK号并返回给服务器（图2.9③）。到这里，序号和ACK号都已经准备完成了，接下来就可以进入数据收发阶段了。数据收发操作本身是可以双向同时进行的，但Web中是先由客户端向服务器发送请求，序号也会跟随数据一起发送（图2.9④）。然后，服务器收到数据后再返回ACK号（图2.9⑤）。从服务器向客户端发送数据的过程则正好相反。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202150410176.png" alt="image-20211202150410176"></p>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202150452576.png" alt="image-20211202150452576"></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>TCP采用这样的方式确认对方是否收到了数据，在得到对方确认之前，发送过的包都会保存在发送缓冲区中。如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。</p>
<p>通过这一机制，我们可以确认接收方有没有收到某个包，如果没有收到则重新发送，这样一来，无论网络中发生任何错误，我们都可以发现并采取补救措施（重传网络包）。反过来说，有了这一机制，我们就不需要在其他地方对错误进行补救了。</p>
<p>网卡、集线器、路由器都没有错误补偿机制，一旦检测到错误就直接丢弃相应的包。应用程序也是一样，因为采用TCP传输，即便发生一些错误对方最终也能够收到正确的数据，所以应用程序只管自顾自地发送这些数据就好了。不过，如果发生网络中断、服务器宕机等问题，那么无论TCP怎样重传都不管用。这种情况下，无论如何尝试都是徒劳，因此TCP会在尝试几次重传无效之后强制结束通信，并向应用程序报错。</p>
<p>通过“序号”和“ACK号”可以确认接收方是否收到了网络包。</p>
<h4 id="_2-3-4-根据网络包平均往返时间调整ack号等待时间" tabindex="-1"><a class="header-anchor" href="#_2-3-4-根据网络包平均往返时间调整ack号等待时间" aria-hidden="true">#</a> 2.3.4 根据网络包平均往返时间调整ACK号等待时间</h4>
<p>实际上网络的错误检测和补偿机制非常复杂，首先是返回ACK号的等待时间（这个等待时间叫超时时间）。</p>
<p>当网络传输繁忙时就会发生拥塞，ACK号的返回会变慢，这时我们就必须将等待时间设置得稍微长一点，否则可能会发生已经重传了包之后，前面的ACK号才姗姗来迟的情况。这样的重传是多余的，看上去只是多发一个包而已，但它造成的后果却没那么简单[插图]。因为ACK号的返回变慢大多是由于网络拥塞引起的，因此如果此时再出现很多多余的重传，对于本来就很拥塞的网络来说无疑是雪上加霜。那么等待时间是不是越长越好呢？也不是。如果等待时间过长，那么包的重传就会出现很大的延迟，也会导致网络速度变慢。</p>
<p>TCP采用了动态调整等待时间的方法，这个等待时间是根据ACK号返回所需的时间来判断的。具体来说，TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；相对地，如果ACK号马上就能返回，则相应缩短等待时间。</p>
<p><strong>每发送一个包就等待一个ACK号的方式是最简单也最容易理解的，但在等待ACK号的这段时间中，如果什么都不做那实在太浪费了。为了减少这样的浪费，TCP采用图2.10（b）这样的滑动窗口方式来管理数据发送和ACK号的操作。所谓滑动窗口，就是在发送一个包之后，不等待ACK号返回，而是直接发送后续的一系列包。这样一来，等待ACK号的这段时间就被有效利用起来了。</strong></p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202150858070.png" alt="image-20211202150858070"></p>
<p>如果不等返回ACK号就连续发送包，就有可能会出现发送包的频率超过接收方处理能力的情况。</p>
<p>当接收方的TCP收到包后，会先将数据存放到接收缓冲区中。然后，接收方需要计算ACK号，将数据块组装起来还原成原本的数据并传递给应用程序，如果这些操作还没完成下一个包就到了也不用担心，因为下一个包也会被暂存在接收缓冲区中。如果数据到达的速率比处理这些数据并传递给应用程序的速率还要快，那么接收缓冲区中的数据就会越堆越多，最后就会溢出。缓冲区溢出之后，后面的数据就进不来了，因此接收方就收不到后面的包了，这就和中途出错的结果是一样的，也就意味着超出了接收方处理能力。<strong>我们可以通过下面的方法来避免这种情况的发生。首先，接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口方式的基本思路。</strong></p>
<p><strong>接收方将数据暂存到接收缓冲区中并执行接收操作。当接收操作完成后，接收缓冲区中的空间会被释放出来，也就可以接收更多的数据了，这时接收方会通过TCP头部中的窗口字段将自己能接收的数据量告知发送方。这样一来，发送方就不会发送过多的数据，导致超出接收方的处理能力了</strong>。</p>
<p>接收方在收到数据之后马上就会开始进行处理，如果接收方的性能高，处理速度比包的到达速率还快，缓冲区马上就会被清空，并通过窗口字段告知发送方。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>ACK与窗口的合并：</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>​		要提高收发数据的效率，还需要考虑另一个问题，那就是返回ACK号和更新窗口的时机。如果假定这两个参数是相互独立的，分别用两个单独的包来发送，结果会如何呢？</p>
<p><strong>什么时候需要更新窗口大小呢？当收到的数据刚刚开始填入缓冲区时，其实没必要每次都向发送方更新窗口大小，因为只要发送方在每次发送数据时减掉已发送的数据长度就可以自行计算出当前窗口的剩余长度。因此，更新窗口大小的时机应该是接收方从缓冲区中取出数据传递给应用程序的时候。这个操作是接收方应用程序发出请求时才会进行的，而发送方不知道什么时候会进行这样的操作，因此当接收方将数据传递给应用程序，导致接收缓冲区剩余容量增加时，就需要告知发送方，这就是更新窗口大小的时机。</strong></p>
<p>当接收方收到数据时，如果确认内容没有问题，就应该向发送方返回ACK号，因此我们可以认为收到数据之后马上就应该进行这一操作。</p>
<p>接收方在发送ACK号和窗口更新时，并不会马上把包发送出去，而是会等待一段时间，在这个过程中很有可能会出现其他的通知操作，这样就可以把两种通知合并在一个包里面发送了。举个例子，在等待发送ACK号的时候正好需要更新窗口，这时就可以把ACK号和窗口更新放在一个包里发送，从而减少包的数量。当需要连续发送多个ACK号时，也可以减少包的数量，这是因为ACK号表示的是已收到的数据量，也就是说，它是告诉发送方目前已接收的数据的最后位置在哪里，因此当需要连续发送ACK号时，只要发送最后一个ACK号就可以了，中间的可以全部省略。当需要连续发送多个窗口更新时也可以减少包的数量，因为连续发生窗口更新说明应用程序连续请求了数据，接收缓冲区的剩余空间连续增加。这种情况和ACK号一样，可以省略中间过程，只要发送最终的结果就可以了。</p>
<p>浏览器在委托协议栈发送请求消息之后，会调用read程序（之前的图2.3④）来获取响应消息。然后，控制流程会通过read转移到协议栈[插图]，然后协议栈会执行接下来的操作。和发送数据一样，接收数据也需要将数据暂存到接收缓冲区中，这里的操作过程如下。首先，协议栈尝试从接收缓冲区中取出数据并传递给应用程序，但这个时候请求消息刚刚发送出去，响应消息可能还没返回。响应消息的返回还需要等待一段时间，因此这时接收缓冲区中并没有数据，那么接收数据的操作也就无法继续。这时，协议栈会将应用程序的委托，也就是从接收缓冲区中取出数据并传递给应用程序的工作暂时挂起[插图]，等服务器返回的响应消息到达之后再继续执行接收操作。</p>
<p>协议栈会检查收到的数据块和TCP头部的内容，判断是否有数据丢失，如果没有问题则返回ACK号。然后，协议栈将数据块暂存到接收缓冲区中，并将数据块按顺序连接起来还原出原始的数据，最后将数据交给应用程序。</p>
<p>协议栈会将接收到的数据复制到应用程序指定的内存地址中，然后将控制流程交回应用程序。将数据交给应用程序之后，协议栈还需要找到合适的时机向发送方发送窗口更新。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>能够接收的最大数据量称为窗口大小，它是TCP调优参数中非常有名的一个。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202151441392.png" alt="image-20211202151441392"></p>
<h3 id="◆-2-4-从服务器断开并删除套接字" tabindex="-1"><a class="header-anchor" href="#◆-2-4-从服务器断开并删除套接字" aria-hidden="true">#</a> ◆ 2.4 从服务器断开并删除套接字</h3>
<p>完成数据发送的一方会发起断开过程，这里我们以服务器一方发起断开过程为例来进行讲解。首先，服务器一方的应用程序会调用Socket库的close程序。然后，服务器的协议栈会生成包含断开信息的TCP头部，具体来说就是将控制位中的FIN比特设为1。接下来，协议栈会委托IP模块向客户端发送数据（图2.12①）。同时，服务器的套接字中也会记录下断开操作的相关信息。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202152351912.png" alt="image-20211202152351912"></p>
<p>当收到服务器发来的FIN为1的TCP头部时，客户端的协议栈会将自己的套接字标记为进入断开操作状态。然后，为了告知服务器已收到FIN为1的包，客户端会向服务器返回一个ACK号（图2.12②）。这些操作完成后，协议栈就可以等待应用程序来取数据了。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>过了一会儿，应用程序就会调用read来读取数据[插图]。这时，协议栈不会向应用程序传递数据[插图]，而是会告知应用程序（浏览器）来自服务器的数据已经全部收到了。根据规则，服务器返回请求之后，Web通信操作就全部结束了，因此只要收到服务器返回的所有数据，客户端的操作也就随之结束了。因此，客户端应用程序会调用close来结束数据收发操作，这时客户端的协议栈也会和服务器一样，生成一个FIN比特为1的TCP包，然后委托IP模块发送给服务器（图2.12③）。一段时间之后，服务器就会返回ACK号（图2.12④）。到这里，客户端和服务器的通信就全部结束了。</p>
<p>和服务器的通信结束之后，用来通信的套接字也就不会再使用了，这时我们就可以删除这个套接字了。不过，套接字并不会立即被删除，而是会等待一段时间之后再被删除。</p>
<p>等待这段时间是为了防止误操作，一般来说会等待几分钟之后再删除套接字。下面来举一个最容易理解的例子。假设和图2.12的过程相反，客户端先发起断开，则断开的操作顺序如下。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（1）客户端发送FIN</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（2）服务器返回ACK号</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（3）服务器发送FIN</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>（4）客户端返回ACK号</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>如果最后客户端返回的ACK号丢失了，结果会如何呢？这时，服务器没有接收到ACK号，可能会重发一次FIN。如果这时客户端的套接字已经删除了，会发生什么事呢？套接字被删除，那么套接字中保存的控制信息也就跟着消失了，套接字对应的端口号就会被释放出来。这时，如果别的应用程序要创建套接字，新套接字碰巧又被分配了同一个端口号[插图]，而服务器重发的FIN正好到达，会怎么样呢？本来这个FIN是要发给刚刚删除的那个套接字的，但新套接字具有相同的端口号，于是这个FIN就会错误地跑到新套接字里面，新套接字就开始执行断开操作了。之所以不马上删除套接字，就是为了防止这样的误操作。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p>至于具体等待多长时间，这和包重传的操作方式有关。网络包丢失之后会进行重传，这个操作通常要持续几分钟。如果重传了几分钟之后依然无效，则停止重传。在这段时间内，网络中可能存在重传的包，也就有可能发生前面讲到的这种误操作，因此需要等待到重传完全结束。协议中对于这个等待时间没有明确的规定，一般来说会等待几分钟之后再删除套接字。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><strong>数据收发操作小结：</strong></p>
<p>数据收发操作的第一步是创建套接字。一般来说，服务器一方的应用程序在启动时就会创建好套接字并进入等待连接的状态。客户端则一般是在用户触发特定动作，需要访问服务器的时候创建套接字。在这个阶段，还没有开始传输网络包。</p>
<p>创建套接字之后，客户端会向服务器发起连接操作。首先，客户端会生成一个SYN为1的TCP包并发送给服务器（图2.13①）。这个TCP包的头部还包含了客户端向服务器发送数据时使用的初始序号，以及服务器向客户端发送数据时需要用到的窗口大小[插图]。当这个包到达服务器之后，服务器会返回一个SYN为1的TCP包（图2.13②）。和图2.13①一样，这个包的头部中也包含了序号和窗口大小，此外还包含表示确认已收到包①的ACK号[插图]。当这个包到达客户端时，客户端会向服务器返回一个包含表示确认的ACK号的TCP包（图2.13③）。到这里，连接操作就完成了，双方进入数据收发阶段。</p>
<blockquote>
<blockquote></blockquote>
</blockquote>
<p><img src="@source/docs/theme-reco/img/3.网络是怎样连接的/image-20211202152901708.png" alt="image-20211202152901708"></p>
<p>数据收发阶段的操作根据应用程序的不同而有一些差异，以Web为例，首先客户端会向服务器发送请求消息。TCP会将请求消息切分成一定大小的块，并在每一块前面加上TCP头部，然后发送给服务器（图2.13④）。TCP头部中包含序号，它表示当前发送的是第几个字节的数据。当服务器收到数据时，会向客户端返回ACK号（图2.13⑤）。在最初的阶段，服务器只是不断接收数据，随着数据收发的进行，数据不断传递给应用程序，接收缓冲区就会被逐步释放。这时，服务器需要将新的窗口大小告知客户端。当服务器收到客户端的请求消息后，会向客户端返回响应消息，这个过程和刚才的过程正好相反（图2.13⑥⑦）。</p>
<p>服务器的响应消息发送完毕之后，数据收发操作就结束了，这时就会开始执行断开操作。以Web为例，服务器会先发起断开过程，也可能是客户端先发起。在这个过程中，服务器先发送一个FIN为1的TCP包（图2.13⑧），然后客户端返回一个表示确认收到的ACK号（图2.13⑨）。接下来，双方还会交换一组方向相反的FIN为1的TCP包（图2.13⑩）和包含ACK号的TCP包（图2.13⑪）。最后，在等待一段时间后，套接字会被删除。</p>
<h3 id="◆-2-5-ip与以太网的包收发操作" tabindex="-1"><a class="header-anchor" href="#◆-2-5-ip与以太网的包收发操作" aria-hidden="true">#</a> ◆ 2.5 IP与以太网的包收发操作</h3>
<p>TCP模块在执行连接、收发、断开等各阶段操作时，都需要委托IP模块将数据封装成包发送给通信对象。</p>
<p>包是由头部和数据两部分构成的</p>
<p>头部包含目的地址等控制信息，大家可以把它理解为快递包裹的面单；头部后面就是委托方要发送给对方的数据，也就相当于快递包裹里的货物。</p>
<p>发送方的网络设备会负责创建包，创建包的过程就是生成含有正确控制信息的头部，然后再附加上要发送的数据。接下来，包会被发往最近的网络转发设备。当到达最近的转发设备之后，转发设备会根据头部中的信息判断接下来应该发往哪里。这个过程需要用到一张表，这张表里面记录了每一个地址对应的发送方向，也就是按照头部里记录的目的地址在表里进行查询，并根据查到的信息判断接下来应该发往哪个方向。</p>
<p>包在向目的地移动的过程中，又会到达下一个转发设备，然后又会按照同样的方式被发往下一个转发设备。就这样，经过多个转发设备的接力之后，包最终就会到达接收方的网络设备。</p>
<p>网络中有路由器和集线器两种不同的转发设备，它们在传输网络包时有着各自的分工。</p>
<p>（1）路由器根据目标地址判断下一个路由器的位置（2）集线器在子网中将网络包传输到下一个路由</p>
<p>集线器是按照以太网规则传输包的设备，而路由器是按照IP规则传输包的设备，因此我们也可以作如下理解。（1）IP协议根据目标地址判断下一个IP转发设备的位置（2）子网中的以太网协议将包传输到下一个转发设备</p>
<p>TCP/IP包包含如下两个头部。（a）MAC头部（用于以太网协议）（b）IP头部（用于IP协议）</p>
<p>网络包在传输过程中（图2.16①）会经过集线器，集线器是根据以太网协议工作的设备。为了判断包接下来应该向什么地方传输，集线器里有一张表（用于以太网协议的表），可根据以太网头部中记录的目的地信息查出相应的传输方向。这张图中只有一个集线器，当存在多个集线器时，网络包会按顺序逐一通过这些集线器进行传输。</p>
<p>路由器中有一张IP协议的表，可根据这张表以及IP头部中记录的目的地信息查出接下来应该发往哪个路由器。为了将包发到下一个路由器，我们还需要查出下一个路由器的MAC地址，并记录到MAC头部中，大家可以理解为改写了MAC头部[插图]。这样，网络包就又被发往下一个节点了。</p>
<p>前面讲了IP和以太网的分工，其中以太网的部分也可以替换成其他的东西，例如无线局域网、ADSL、FTTH等，它们都可以替代以太网的角色帮助IP协议来传输网络包</p>
<p>尽管我们说IP模块负责将包发给对方，但实际上将包从发送方传输到接收方的工作是由集线器、路由器等网络设备来完成的[插图]，因此IP模块仅仅是整个包传输过程的入口而已。</p>
<p>包收发操作的起点是TCP模块委托IP模块发送包的操作（图2.17中的“①发送”）。这个委托的过程就是TCP模块在数据块的前面加上TCP头部，然后整个传递给IP模块，这部分就是网络包的内容。</p>
<p>IP模块会添加IP头部和MAC头部这两种头部。IP头部中包含IP协议规定的、根据IP地址将包发往目的地所需的控制信息；MAC头部包含通过以太网的局域网将包传输至最近的路由器所需的控制信息</p>
<p>IP模块负责添加如下两个头部。（1） MAC头部：以太网用的头部，包含MAC地址（2）IP头部：IP用的头部，包含IP地址</p>
<p>封装好的包会被交给网络硬件（图2.17中的“②发送”），例如以太网、无线局域网等。网络硬件可能是插在计算机主板上的板卡，也可能是笔记本电脑上的PCMCIA卡，或者是计算机主板上集成的芯片，不同形态的硬件名字也不一样，本书将它们统称为网卡[插图]。传递给网卡的网络包是由一连串0和1组成的数字信息，网卡会将这些数字信息转换为电信号或光信号，并通过网线（或光纤）发送出去，然后这些信号就会到达集线器、路由器等转发设备，再由转发设备一步一步地送达接收方。</p>
<p>接收的过程和发送的过程是相反的，信息先以电信号的形式从网线传输进来，然后由网卡将其转换为数字信息并传递给IP模块（图2.17中的“③接收”）。接下来，IP模块会将MAC头部和IP头部后面的内容，也就是TCP头部加上数据块，传递给TCP模块。</p>
<p>IP模块也不关心TCP的操作阶段，对于包的乱序和丢失也一概不知。总之，IP的职责就是将委托的东西打包送到对方手里，或者是将对方送来的包接收下来，仅此而已。</p>
<p>无论要收发的包是控制包还是数据包，IP对各种类型的包的收发操作都是相同的。</p>
<p>IP地址实际上并不是分配给计算机的，而是分配给网卡的，因此当计算机上存在多块网卡时，每一块网卡都会有自己的IP地址。很多服务器上都会安装多块网卡，这时一台计算机就有多个IP地址，在填写发送方IP地址时就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪一块网卡来发送这个包，也就相当于判断应该把包发往哪个路由器，因此只要确定了目标路由器，也就确定了应该使用哪块网卡，也就确定了发送方的IP地址。</p>
<p>IP头部的“接收方IP地址”填写通信对象的IP地址。发送方IP地址需要判断发送所使用的网卡，并填写该网卡的IP地址。</p>
<p>IP模块在生成IP头部之后，会在它前面再加上MAC头部。MAC头部是以太网使用的头部，它包含了接收方和发送方的MAC地址等信息。</p>
<p>IP地址的长度为32比特，而MAC地址为48比特</p>
<p>IP模块根据路由表Gateway栏的内容判断应该把包发送给谁。</p>
<p>在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP就是利用广播对所有设备提问：“××这个IP地址是谁的？请把你的MAC地址告诉我。”然后就会有人回答：“这个IP地址是我的，我的MAC地址是××××。</p>
<p>在发送包时，先查询一下ARP缓存，如果其中已经保存了对方的MAC地址，就不需要发送ARP查询，直接使用ARP缓存中的地址，而当ARP缓存中不存在对方MAC地址时，则发送ARP查询。</p>
<p>IP生成的网络包只是存放在内存中的一串数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电或光信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p>
<p>负责执行这一操作的是网卡，但网卡也无法单独工作，要控制网卡还需要网卡驱动程序。驱动程序不只有网卡才有，键盘、鼠标、显卡、声卡等各种硬件设备都有。当然，不同厂商和型号的网卡在结构上有所不同，因此网卡驱动程序也是厂商开发的专用程序[插图]。</p>
<p>打开计算机启动操作系统的时候，网卡驱动程序会对硬件进行初始化操作，然后硬件才进入可以使用的状态。这些操作包括硬件错误检查、初始设置等步骤，这些步骤对于很多其他硬件也是共通的，但也有一些操作是以太网特有的，那就是在控制以太网收发操作的MAC[插图]模块中设置MAC地址。</p>
<p>网卡的ROM中保存着全世界唯一的MAC地址，这是在生产网卡时写入的，将这个值读出之后就可以对MAC模块进行设置，MAC模块就知道自己对应的MAC地址了。</p>
<p>网卡中保存的MAC地址会由网卡驱动程序读取并分配给MAC模块。</p>
<p>网卡驱动从IP模块获取包之后，会将其复制到网卡内的缓冲区中，然后向MAC模块发送发送包的命令。接下来就轮到MAC模块进行工作了。</p>
<p>MAC模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</p>
<p>用电信号来表达数字信息时，我们需要让0和1两种比特分别对应特定的电压和电流</p>
<p>加上报头、起始帧分界符和FCS之后，我们就可以将包通过网线发送出去了（图2.24）。发送信号的操作分为两种，一种是使用集线器的半双工模式，另一种是使用交换机的全双工[插图]模式。</p>
<p>在半双工模式中，为了避免信号碰撞，首先要判断网线中是否存在其他设备发送的信号。如果有，则需要等待该信号传输完毕，因为如果在有信号时再发送一组信号，两组信号就会发生碰撞。当之前的信号传输完毕，或者本来就没有信号在传输的情况下，我们就可以开始发送信号了。首先，MAC模块从报头开始将数字信息按每个比特转换成电信号，然后由PHY，或者叫MAU的信号收发模块发送出去[插图]。在这里，将数字信息转换为电信号的速率就是网络的传输速率，例如每秒将10Mbit的数字信息转换为电信号发送出去，则速率就是10 Mbit/s。</p>
<p>网卡的MAC模块生成通用信号，然后由PHY（MAU）模块转换成可在网线中传输的格式，并通过网线发送出去。</p>
<p>在网卡执行接收包的操作的过程中，计算机并不是一直监控着网卡的活动，而是去继续执行其他的任务。因此，如果网卡不通知计算机，计算机是不知道包已经收到了这件事的。网卡驱动也是在计算机中运行的一个程序，因此它也不知道包到达的状态。在这种情况下，我们需要一种机制能够打断计算机正在执行的任务，让计算机注意到网卡中发生的事情，这种机制就是中断。</p>
<p>中断的工作过程是这样的。首先，网卡向扩展总线中的中断信号线发送信号，该信号线通过计算机中的中断控制器连接到CPU。当产生中断信号时，CPU会暂时挂起正在处理的任务，切换到操作系统中的中断处理程序[插图]。然后，中断处理程序会调用网卡驱动，控制网卡执行相应的接收操作。</p>
<p>网卡驱动被中断处理程序调用后，会从网卡的缓冲区中取出收到的包，并通过MAC头部中的以太类型字段判断协议的类型。现在我们在大多数情况下都是使用TCP/IP协议，但除了TCP/IP之外还有很多其他类型的协议，例如NetWare中使用的IPX/SPX，以及Mac电脑中使用的AppleTalk等协议。这些协议都被分配了不同的以太类型，如0080（十六进制）代表IP协议，网卡驱动就会把这样的包交给TCP/IP协议栈；如果是809B则表示AppleTalk协议，就把包交给AppleTalk协议栈，以此类推[插图]。</p>
<p>假设Web服务器返回了一个网络包，那么协议栈会进行哪些处理呢[插图]？服务器返回的包的以太类型应该是0800，因此网卡驱动会将其交给TCP/IP协议栈来进行处理。接下来就轮到IP模块先开始工作了，第一步是检查IP头部，确认格式是否正确。如果格式没有问题，下一步就是查看接收方IP地址。如果接收网络包的设备是一台Windows客户端计算机，那么服务器返回的包的接收方IP地址应该与客户端网卡的地址一致，检查确认之后我们就可以接收这个包了。</p>
<p>如果接收方IP地址不是自己的地址，那一定是发生了什么错误。客户端计算机不负责对包进行转发，因此不应该收到不是发给自己的包[插图]。当发生这样的错误时，IP模块会通过ICMP消息将错误告知发送方</p>
<p>如果接收方IP地址正确，则这个包会被接收下来，这时还需要完成另一项工作。IP协议有一个叫作分片的功能</p>
<p>简单来说，网线和局域网中只能传输小包，因此需要将大的包切分成多个小包。如果接收到的包是经过分片的，那么IP模块会将它们还原成原始的包。分片的包会在IP头部的标志字段中进行标记，当收到分片的包时，IP模块会将其暂存在内部的内存空间中，然后等待IP头部中具有相同ID的包全部到达，这是因为同一个包的所有分片都具有相同的ID。此外，IP头部还有一个分片偏移量（fragment offset）字段，它表示当前分片在整个包中所处的位置。根据这些信息，在所有分片全部收到之后，就可以将它们还原成原始的包，这个操作叫作分片重组。</p>
<p>IP模块的工作就结束了，接下来包会被交给TCP模块。TCP模块会根据IP头部中的接收方和发送方IP地址，以及TCP头部中的接收方和发送方端口号来查找对应的套接字[插图]。找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如，如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取；如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立和断开连接的操作状态。</p>
<p>◆ 2.6 UDP协议的收发操作</p>
<p>不需要重发的数据用UDP发送更高效</p>
<p>向DNS服务器查询IP地址的时候我们用的也是UDP协议</p>
<p>为了实现可靠性，我们就需要确认对方是否收到了我们发送的数据，如果没有还需要再发一遍。要实现上面的要求，最简单的方法是数据全部发送完毕之后让接收方返回一个接收确认。这样一来，如果没收到直接全部重新发送一遍就好了，根本不用像TCP一样要管理发送和确认的进度。但是，如果漏掉了一个包就要全部重发一遍，怎么看都很低效。为了实现高效的传输，我们要避免重发已经送达的包，而是只重发那些出错的或者未送达的包。TCP之所以复杂，就是因为要实现这一点。</p>
<p>数据很短，用一个包就能装得下。如果只有一个包，就不用考虑哪个包未送达了，因为全部重发也只不过是重发一个包而已，这种情况下我们就不需要TCP这样复杂的机制了。而且，如果不使用TCP，也不需要发送那些用来建立和断开连接的控制包了。此外，我们发送了数据，对方一般都会给出回复，只要将回复的数据当作接收确认就行了，也不需要专门的接收确认包了。</p>
<p>这种情况就适合使用UDP。像DNS查询等交换控制信息的操作基本上都可以在一个包的大小范围内解决，这种场景中就可以用UDP来代替TCP[插图]。UDP没有TCP的接收确认、窗口等机制，因此在收发数据之前也不需要交换控制信息，也就是说不需要建立和断开连接的步骤，只要在从应用程序获取的数据前面加上UDP头部，然后交给IP进行发送就可以了（表2.5）。接收也很简单，只要根据IP头部中的接收方和发送方IP地址，以及UDP头部中的接收方和发送方端口号，找到相应的套接字并将数据交给相应的应用程序就可以了。</p>
<p>遇到错误或者丢包也一概不管。因为UDP只负责单纯地发送包而已，并不像TCP一样会对包的送达状态进行监控，所以协议栈也不知道有没有发生错误。但这样并不会引发什么问题，因此出错时就收不到来自对方的回复，应用程序会注意到这个问题，并重新发送一遍数据。</p>
<p>另一个场景会使用UDP，就是发送音频和视频数据的时候。音频和视频数据必须在规定的时间内送达，一旦送达晚了，就会错过播放时机，导致声音和图像卡顿。如果像TCP一样通过接收确认响应来检查错误并重发，重发的过程需要消耗一定的时间，因此重发的数据很可能已经错过了播放的时机。一旦错过播放时机，重发数据也是没有用的，因为声音和图像已经卡顿了，这是无法挽回的。当然，我们可以用高速线路让重发的数据能够在规定的时间内送达，但这样一来可能要增加几倍的带宽才行</p>
<p>在这些无需重发数据，或者是重发了也没什么意义的情况下，使用UDP发送数据的效率会更高。</p>
<p>◆ CoIumn网络术语其实很简单</p>
<p>字典上说，socket就是凹进去的可以往里面插东西的圆孔。</p>
<p>所以凡是能插东西的孔都可以叫作socket。</p>
<p>你想象一下，假设我们有一段程序，把它“咔”一下插到一个套接字里，于是我们就可以开始通信了，就跟灯泡插进去就亮一样。</p>
<p>套接字的背后就是传输数据的通道，这个通道和我们的通信对象是相连接的，就像流过电线的电流一样，数据就在这个通道中流动，所以我们插进去一个程序，就可以和对方通信了</p>
<p>◆ 第3章 从网络到网络设备——探索集线器、交换机和路由器</p>
<p>1．我们现在使用的以太网线（双绞线）是由美国的室内电话线发展而来的。2．路由器比交换机问世时间更早。</p>
<p>3．对于路由器和交换机，如果包在传输过程中发生错误，会直接丢弃错误的包而不会尝试修复。</p>
<p>不过操作系统中的网络控制软件（协议栈）会对丢弃的包进行重发，数据不会因此丢失。</p>
<p>◆ 3.1 信号在网线和集线器中传输</p>
<p>网络包从客户端计算机发出之后，要经过集线器、交换机和路由器最终进入互联网。实际上，我们家里用的路由器已经集成了集线器和交换机的功能，</p>
<p>防止网线中的信号衰减很重要</p>
<p>从信号流出网卡进入网线开始。网卡中的PHY（MAU）[插图]模块负责将包转换成电信号，信号通过RJ-45接口进入双绞线</p>
<p>以太网信号的本质是正负变化的电压，大家可以认为网卡的PHY（MAU）模块就是一个从正负两个信号端子输出信号的电路。</p>
<p>信号在网线的传输过程中，能量会逐渐损失。网线越长，信号衰减就越严重。</p>
<p>在发送方一端还十分清晰的矩形信号波形，在传输过程不断衰减，波形也会失真，导致接收方难以读取。</p>
<p>以太网中的信号波形是方形的，但损失能量会让信号的拐角变圆，这是因为电信号的频率越高，能量的损失率越大[插图]。信号的拐角意味着电压发生剧烈的变化，而剧烈的变化意味着这个部分的信号频率很高。高频信号更容易损失能量，因此本来剧烈变化的部分就会变成缓慢的变化，拐角也就变圆了。</p>
<p>即便线路条件很好，没有噪声，信号在传输过程中依然会发生失真，如果再加上噪声的影响，失真就会更厉害。噪声根据强度和类型会产生不同的影响，无法一概而论，但如果本来就已经衰减的信号再进一步失真，就会出现对0和1的误判，这就是产生通信错误的原因。</p>
<p>局域网网线使用的是双绞线，其中“双绞”的意思就是以两根信号线为一组缠绕在一起，这种拧麻花一样的设计是为了抑制噪声的影响。</p>
<p>那么双绞线为什么能够抑制噪声呢？首先，我们来看看噪声是如何产生的。产生噪声的原因是网线周围的电磁波，当电磁波接触到金属等导体时，在其中就会产生电流。因此，如果网线周围存在电磁波，就会在网线中产生和原本的信号不同的电流。由于信号本身也是一种带有电压变化的电流，其本质和噪声产生的电流是一样的，所以信号和噪声的电流就会混杂在一起，导致信号的波形发生失真，这就是噪声的影响。</p>
<p>影响网线的电磁波分为两种。一种是由电机、荧光灯、CRT显示器等设备泄漏出来的电磁波，这种电磁波来自网线之外的其他设备，我们来看看双绞线如何抑制这种电磁波的影响。首先，信号线是用金属做成的，当电磁波接触到信号线时，会沿电磁波传播的右旋方向产生电流，这种电流会导致波形发生失真。如果我们将信号线缠绕在一起，信号线就变成了螺旋形，其中两根信号线中产生的噪声电流方向就会相反，从而使得噪声电流相互抵消，噪声就得到了抑制</p>
<p>另一种电磁波是从网线中相邻的信号线泄漏出来的。由于传输的信号本身就是一种电流，当电流流过时就会向周围发出电磁波，这些电磁波对于其他信号线来说就成了噪声。这种内部产生的噪声称为串扰</p>
<p>通过将信号线缠绕在一起的方式，噪声得到了抑制，从结果来看提升了网线的性能，除此之外还有其他一些工艺也能够帮助提升性能。例如在信号线之间加入隔板保持距离，以及在外面包裹可阻挡电磁波的金属屏蔽网等。有了这些工艺的帮助，我们现在可以买到性能指标不同的各种网线。</p>
<p>当信号到达集线器后，会被广播到整个网络中。以太网的基本架构[插图]就是将包发到所有的设备，然后由设备根据接收方MAC地址来判断应该接收哪些包</p>
<p>◆ 3.3 路由器的包转发操作</p>
<p>网络包经过集线器和交换机之后，现在到达了路由器，并在此被转发到下一个路由器。这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。不过在具体的操作过程上，路由器和交换机是有区别的。因为路由器是基于IP设计的，而交换机是基于以太网设计的[插图]</p>
<p>通过更换网卡，计算机不仅可以支持以太网，也可以支持无线局域网，路由器也是一样。如果路由器的端口模块安装了支持无线局域网的硬件，就可以支持无线局域网了。</p>
<p>路由器的各个端口都具有MAC地址和IP地址。</p>
<p>交换机是通过MAC头部中的接收方MAC地址来判断转发目标的，而路由器则是根据IP头部中的IP地址来判断的。由于使用的地址不同，记录转发目标的表的内容也会不同。</p>
<p>◆ 第5章 服务器端的局域网中有什么玄机</p>
<p>防火墙不会检查通信数据的具体内容，因此无法抵御隐藏在通信数据内容中的攻击。</p>
<p>◆ 5.1 Web服务器的部署地点</p>
<p>将Web服务器部署在公司里，但Web服务器不仅可以部署在公司里，也可以像图5.1（c）这样把服务器放在网络运营商等管理的数据中心里，或者直接租用运营商提供的服务器。</p>
<p>数据中心通过高速线路直接连接到互联网的核心部分，因此将服务器部署在这里可以获得很高的访问速度[插图]，当服务器访问量很大时这是非常有效的。此外，数据中心一般位于具有抗震结构的大楼内，还具有自主发电设备，并实行24小时门禁管理，可以说比放在公司里具有更高的安全性。此外，数据中心不但提供安放服务器的场地，还提供各种附加服务，如服务器工作状态监控、防火墙的配置和运营、非法入侵监控等，从这一点来看，其安全性也更高。</p>
<p>◆ 5.2 防火墙的结构和原理</p>
<p>无论服务器部署在哪里，现在一般都会在前面部署一个防火墙，如果包无法通过防火墙，就无法到达服务器。</p>
<p>如何设置包过滤的规则</p>
<p>网络包的头部包含了用于控制通信操作的控制信息，只要检查这些信息，就可以获得很多有用的内容。</p>
<p>在设置包过滤规则时，首先要观察包是如何流动的。通过接收方IP地址和发送方IP地址，我们可以判断出包的起点和终点。</p>
<p>包从互联网流向Web服务器，从互联网发送过来的包其起点是不确定的，但终点是确定的，即Web服务器。因此，我们可以按此来设定规则，允许符合规则的包通过。也就是说，允许起点（发送方IP地址）为任意，终点（接收方IP地址）为Web服务器IP地址的包通过（图5.2中表的第1行）。如果可以确定发送方IP地址，也可以将其加入规则，但这个例子中起点是不确定的，因此可以不将发送方IP地址设为判断条件。</p>
<p>Web使用的TCP协议是双向收发网络包的，因此如果单纯地阻止从Web服务器发往互联网的包，则从互联网访问Web服务器的操作也会受到影响而无法进行。光判断包的流向还不够，我们必须要根据访问的方向来进行判断。这里就需要用到TCP头部中的控制位。TCP在执行连接操作时需要收发3个包[插图]，其中第一个包的TCP控制位中SYN为1，而ACK为0。其他的包中这些值都不同，因此只要按照这个规则就能够过滤到TCP连接的第一个包。</p>
<p>如果这第一个包是从Web服务器发往互联网的，那么我们就阻止它（图5.2表中的第2行）。这样设置之后，当然也不会收到对方返回的第二个响应包，TCP连接操作就失败了。也就是说，只要以Web服务器为起点访问互联网，其连接操作必然会失败，这样一来，我们就阻止了Web服务器对互联网的访问。</p>
<p>从互联网访问Web服务器时，第一个包是接收方为Web服务器</p>
<p>通过接收方IP地址、发送方IP地址、接收方端口号、发送方端口号、TCP控制位这些条件，我们可以判断出通信的起点和终点、应用程序种类，以及访问的方向。</p>
<p>实际上也存在无法将希望允许和阻止的访问完全区分开的情况，其中一个代表性的例子就是对DNS服务器的访问。DNS查询使用的是UDP协议，而UDP与TCP不同，它没有连接操作，因此无法像TCP一样根据控制位来判断访问方向。所以，我们无法设置一个规则，只允许公司内部访问互联网上的DNS服务器，而阻止从互联网访问公司内部的DNS服务器。这一性质不仅适用于DNS，对于所有使用UDP协议的应用程序都是共通的。在这种情况下，只能二者择其一——要么冒一定的风险允许该应用程序的所有包通过，要么牺牲一定的便利性阻止该应用程序的所有包通过[插图]。</p>
<p>为了让公司内网与公开区域之间的网络包自由流动，我们可以将接收方IP地址为公开区域的包设置成全部允许通过。但是，如果在这条规则里没有限定发送方IP地址，那么连来自互联网的包也都会被无条件允许进入公开区域了，这会导致公开区域中的服务器全部暴露在危险状态中。</p>
<p>包过滤方式的防火墙不仅可以允许或者阻止网络包的通过，还具备地址转换功能[插图]，因此还需要进行相关的设置。也就是说，互联网和公司内网之间的包需要进行地址转换才能传输，因此必须要进行相关的设置</p>
<p>包过滤方式的防火墙可根据接收方IP地址、发送方IP地址、接收方端口号、发送方端口号、控制位等信息来判断是否允许某个包通过。</p>
<p>防火墙可以根据包的起点和终点来判断是否允许其通过，但仅凭起点和终点并不能筛选出所有有风险的包。比如，假设Web服务器在收到含有特定数据的包时会引起宕机。但是防火墙只关心包的起点和终点，因此即便包中含有特定数据，防火墙也无法发现，于是包就被放行了。然后，当包到达Web服务器时，就会引发服务器宕机。通过这个例子大家可以看出，只有检查包的内容才能识别这种风险，因此防火墙对这种情况无能为力。</p>
<p>要应对这种情况有两种方法。这个问题的根源在于Web服务器程序的Bug，因此修复Bug防止宕机就是其中一种方法。这类Bug中，危险性较高的会作为安全漏洞公布出来，开发者会很快发布修复了Bug的新版本，因此持续关注安全漏洞信息并更新软件的版本是非常重要的。</p>
<p>另一种方法就是在防火墙之外部署用来检查包的内容并阻止有害包的设备或软件</p>
<p>◆ 5.3 通过将请求平均分配给多台服务器来平衡负载</p>
<p>通过将请求平均分配给多台服务器来平衡负载</p>
<p>当服务器的访问量上升时，增加服务器线路的带宽是有效的，但并不是网络变快了就可以解决所有的问题。高速线路会传输大量的网络包，这会导致服务器的性能跟不上[插图]。尤其是通过CGI等应用程序动态生成数据的情况下，对服务器CPU的负担更重，服务器性能的问题也会表现得越明显。</p>
<p>如果在DNS服务器中填写多个名称相同的记录，则每次查询时DNS服务器都会按顺序返回不同的IP地址。例如，对于域名www.lab.glasscom.com，如果我们给它分配如下3个IP地址。</p>
<p>轮询（round-robin），通过这种方式可以将访问平均分配给所有的服务器。</p>
<p>假如多台Web服务器中有一台出现了故障，这时我们希望在返回IP地址时能够跳过故障的Web服务器，然而普通的DNS服务器并不能确认Web服务器是否正常工作，因此即便Web服务器宕机了，它依然可能会返回这台服务器的IP地址[插图]。</p>
<p>轮询分配还可能会引发一些问题。在通过CGI等方式动态生成网页的情况下，有些操作是要跨多个页面的，如果这期间访问的服务器发生了变化，这个操作就可能无法继续。例如在购物网站中，可能会在第一个页面中输入地址和姓名，在第二个页面中输入信用卡号，这就属于刚才说的那种情况。</p>
<p>要用负载均衡器的IP地址代替Web服务器的实际地址注册到DNS服务器上。假设有一个域名www.lab.glasscom.com，我们将这个域名对应的IP地址设置为负载均衡器的IP地址并注册到DNS服务器上。于是，客户端会认为负载均衡器就是一台Web服务器，并向其发送请求，然后由负载均衡器来判断将请求转发给哪台Web服务器（图5.4）[插图]。这里的关键点不言而喻，那就是如何判断将请求转发给哪台Web服务器。</p>
<p>负载均衡器可以定期采集Web服务器的CPU、内存使用率，并根据这些数据判断服务器的负载状况，也可以向Web服务器发送测试包，根据响应所需的时间来判断负载状况。当然，Web服务器的负载可能会在短时间内上下波动，因此无法非常准确地把握负载状况，反过来说，如果过于密集地去查询服务器的负载，这个查询操作本身就会增加Web服务器的负载。因此也有一种方案是不去查询服务器的负载，而是根据事先设置的服务器性能指数，按比例来分配请求。</p>
<p>当操作跨多个页面时，则不考虑Web服务器的负载，而是必须将请求发送到同一台Web服务器上。要实现这一点，关键在于我们必须要判断一个操作是否跨了多个页面。HTTP的基本工作方式是在发送请求消息之前先建立TCP连接，当服务器发送响应消息后断开连接，下次访问Web服务器的时候，再重新建立TCP连接[插图]。因此，在Web服务器看来，每一次HTTP访问都是相互独立的，无法判断是否和之前的请求相关。</p>
<p>◆ 5.4 使用缓存服务器分担负载</p>
<p>防火墙的目的是防止来自互联网的非法入侵，而要达到这个目的，最可靠的方法就是阻止互联网和公司内网之间的所有包。不过，这样一来，公司员工就无法上外网了，因此还必须想一个办法让必要的包能够通过，这个办法就是利用代理。简单来说，代理的原理如图5.8所示，它会先接收来自客户端的请求消息，然后再转发到互联网中[插图]，这样就可以实现只允许通过必要的网络包了。这时，如果能够利用代理的缓存，那么效果就会更好，因为对于以前访问过的数据，可以直接从位于公司内网的代理服务器获得，这比通过低速线路访问互联网要快很多[插图]。</p>
<p>由于代理在转发过程中可以查看请求的内容，所以可以根据内容判断是否允许访问。也就是说，通过代理可以禁止员工访问危险的网站，或者是与工作内容无关的网站。包过滤方式的防火墙只能根据IP地址和端口号进行判断，因此无法实现这一目的。</p>
<p>在使用正向代理时，一般需要在浏览器的设置窗口中的“代理服务器”一栏中填写正向代理的IP地址，浏览器发送请求消息的过程也会发生相应的变化。在没有设置正向代理的情况下，浏览器会根据网址栏中输入的http://..．字符串判断Web服务器的域名，并向其发送请求消息；当设置了正向代理时，浏览器会忽略网址栏的内容，直接将所有请求发送给正向代理。请求消息的内容也会有一些不同。没有正向代理时，浏览器会从网址中提取出Web服务器域名后面的文件名或目录名，然后将其作为请求的URI进行发送；而有正向代理时，浏览器会像图5.9这样，在请求的URI字段中填写完整的http://..．网址。</p>
<p>使用正向代理需要在浏览器中进行设置，这可以说是识别正向代理的一个特征。</p>
<p>对这种方法进行改良，使得不需要在浏览器中设置代理也可以使用。也就是说，我们可以通过将请求消息中的URI中的目录名与Web服务器进行关联，使得代理能够转发一般的不包含完整网址的请求消息。我们前面介绍的服务器端的缓存服务器采用的正是这种方式，这种方式称为反向代理</p>
<p>◆ 5.5 内容分发服务</p>
<p>缓存服务器部署在服务器端还是客户端，其效果是有差别的。如图5.10（a）所示，当缓存服务器放在服务器端时，可以减轻Web服务器的负载，但无法减少互联网中的流量。这一点上，将缓存服务器放在客户端更有效（图5.10（b））。互联网中会存在一些拥塞点，通过这些地方会比较花时间。如果在客户端部署缓存服务器，就可以不受或者少受这些拥塞点的影响，让网络流量更稳定，特别是当访问内容中含有大图片或视频时效果更明显。</p>
<p>互联网中有很多台DNS服务器，它们通过相互接力来处理DNS查询，这个过程从客户端发送查询消息开始，也就是说客户端会用要访问的Web服务器域名生成查询消息，并发送给自己局域网中的DNS服务器[插图]（图5.12①）。然后，客户端DNS服务器会通过域名的层次结构找到负责管理该域名的DNS服务器，也就是Web服务器端的那个DNS服务器，并将查询消息发送给它（图5.12②）。Web服务器端的DNS服务器收到查询消息后，会查询并返回域名相对应的IP地址。在这台DNS中，有一张管理员维护的域名和IP地址的对应表，只要按照域名查表，就可以找到相应的IP地址（图5.12③）。接下来，响应消息回到客户端的DNS服务器，然后再返回给客户端</p>
<p>怎样判断客户端与缓存服务器之间的距离呢？</p>
<p>方法是这样的。首先，作为准备，需要事先从缓存服务器部署地点的路由器收集路由信息</p>
<p>接下来，DNS服务器根据路由表查询从本机到DNS查询消息的发送方，也就是客户端DNS服务器的路由信息。</p>
<p>通过互联网内部的路由表中的路由信息可以知道先通过运营商X，然后通过运营商Y，最后到达运营商Z这样的信息，通过这样的信息可以大致估算出距离。依次查询所有路由器的路由表之后，我们就可以通过比较找出哪一台路由器距离客户端DNS服务器最近。提供路由表的路由器位于缓存服务器的位置，而客户端DNS服务器也应该和客户端在同一位置，这样就等于估算出了缓存服务器与客户端之间的距离，从而能够判断出哪台缓存服务器距离客户端最近了。实际上，客户端DNS服务器不一定和客户端在同一位置，因此可能无法得出准确的距离，但依然可以达到相当的精度。</p>
<p>还有一个因素会影响缓存服务器的效率，那就是缓存内容的更新方法。</p>
<p>◆ 第6章 请求到达Wdb服务器，响应返回浏览器——短短几秒的“漫长旅程”迎来终点</p>
<p>路由器和交换机是不考虑请求包和响应包之间的关联的，而是将它们作为独立的包来对待，因此请求和响应是有可能通过不同的路由来传输的，具体走哪条路由，是由路由器的路由表和交换机的地址表中的配置来决定的。</p>
<p>由于可以通过端口号来区分服务器上的应用程序，所以一台服务器上可以同时运行多个服务器程序，不仅限于Web和邮件。当然，这样做会增加服务器的负载，因此必须注意服务器的性能。</p>
<p>◆ 6.1 服务器概览</p>
<p>服务器和客户端有什么区别呢？根据用途，服务器可以分为很多种类，其硬件和操作系统与客户端是有所不同的[插图]。但是，网络相关的部分，如网卡、协议栈、Socket库等功能和客户端却并无二致。无论硬件和OS如何变化，TCP和IP的功能都是一样的，或者说这些功能规格都是统一的[插图]</p>
<p>将程序分成两个模块，即等待连接模块（图6.1（a））和负责与客户端通信的模块（图6.1（b））[插图]。当服务器程序启动并读取配置文件完成初始化操作后，就会运行等待连接模块（a）。这个模块会创建套接字，然后进入等待连接的暂停状态。接下来，当客户端连发起连接时，这个模块会恢复运行并接受连接，然后启动客户端通信模块（b），并移交完成连接的套接字。接下来，客户端通信模块（b）就会使用已连接的套接字与客户端进行通信，通信结束后，这个模块就退出了。</p>
<p>连接这个操作是在有一方等待连接的情况下，另一方才能发起连接，如果双方同时发起连接是不行的，因为在对方没有等待连接的状态下，无法单方面进行连接。因此，只有这个部分必须区分发起连接和等待连接这两个不同的角色。从数据收发的角度来看，这就是客户端与服务器的区别，也就是说，发起连接的一方是客户端，等待连接的一方是服务器。</p>
<p>客户端的数据收发需要经过下面4个阶段。（1）创建套接字（创建套接字阶段）（2）用管道连接服务器端的套接字（连接阶段）（3）收发数据（收发阶段）（4）断开管道并删除套接字（断开阶段）</p>
<p>服务器是将阶段（2）改成了等待连接</p>
<p>在执行accept的时候，一般来说服务器端都是处于等待包到达的状态，这时应用程序会暂停运行。在这个状态下，一旦客户端的包到达，就会返回响应包并开始接受连接操作。接下来，协议栈会给等待连接的套接字复制一个副本，然后将连接对象等控制信息写入新的套接字中</p>
<p>那就是在复制出一个新的套接字之后，原来那个处于等待连接状态的套接字会怎么样呢？其实它还会以等待连接的状态继续存在，当再次调用accept，客户端连接包到达时，它又可以再次执行接受连接操作。接受新的连接之后，和刚才一样，协议栈会为这个等待连接的套接字复制一个新的副本，然后让客户端连接到这个新的副本套接字上。像这样每次为新的连接创建新的套接字就是这一步操作的一个关键点。如果不创建新副本，而是直接让客户端连接到等待连接的套接字上，那么就没有套接字在等待连接了，这时如果有其他客户端发起连接就会遇到问题。为了避免出现这样的情况，协议栈采用了这种创建套接字的新副本，并让客户端连接到这个新副本上的方法。</p>
<p>创建新套接字时端口号也是一个关键点。端口号是用来识别套接字的，因此我们以前说不同的套接字应该对应不同的端口号，但如果这样做，这里就会出现问题。因为在接受连接的时候，新创建的套接字副本就必须和原来的等待连接的套接字具有不同的端口号才行。这样一来，比如客户端本来想要连接80端口上的套接字，结果从另一个端口号返回了包，这样一来客户端就无法判断这个包到底是要连接的那个对象返回的，还是其他程序返回的。因此，新创建的套接字副本必须和原来的等待连接的套接字具有相同的端口号。</p>
<p>但是这样一来又会引发另一个问题。端口号是用来识别套接字的，如果一个端口号对应多个套接字，就无法通过端口号来定位到某一个套接字了。当客户端的包到达时，如果协议栈只看TCP头部中的接收方端口号，是无法判断这个包到底应该交给哪个套接字的。</p>
<p>这个问题可以用下面的方法来解决，即要确定某个套接字时，不仅使用服务器端套接字对应的端口号，还同时使用客户端的端口号再加上IP地址，总共使用下面4种信息来进行判断</p>
<p>服务器上可能存在多个端口号相同的套接字，但客户端的套接字都是对应不同端口号的，因此我们可以通过客户端的端口号来确定服务器上的某个套接字。不过，使用不同端口号的规则仅限一台客户端的内部，当有多个客户端进行连接时，它们之间的端口号是可以重复的。因此，我们还必须加上客户端的IP地址才能进行判断。例如，IP地址为198.18.203.154的客户端的1025端口，就和IP地址为198.18.142.86的客户端的1025端口对应不同的套接字。</p>
<p>既然通过客户端IP地址、客户端端口号、服务器IP地址、服务器端口号这4种信息可以确定某个套接字，那么要指代某个套接字时用这4种信息就好了，为什么还要使用描述符呢？这个问题很好，不过我们无法用上面4种信息来代替描述符。原因是，在套接字刚刚创建好，还没有建立连接的状态下，这4种信息是不全的。此外，为了指代一个套接字，使用一种信息（描述符）比使用4种信息要简单。出于上面两个原因，应用程序和协议栈之间是使用描述符来指代套接字的。</p>
<p>使用描述符来指代套接字的原因如下。（1）等待连接的套接字中没有客户端IP地址和端口号（2）使用描述符这一种信息比较简单</p>
<p>◆ 6.2 服务器的接收操作</p>
<p>到达服务器的网络包其本质是电信号或者光信号，接收信号的过程和客户端是一样的。</p>
<p>接收操作的第一步是网卡接收到信号，然后将其还原成数字信息[插图]。局域网中传输的网络包信号是由1和0组成的数字信息与用来同步的时钟信号叠加而成的，因此只要从中分离出时钟信号，然后根据时钟信号进行同步，就可以读取并还原出1和0的数字信息了。</p>
<p>接下来需要根据包末尾的帧校验序列（FCS）来校验错误，即根据校验公式[插图]计算刚刚接收到的数字信息，然后与包末尾的FCS值进行比较。FCS值是在发送时根据转换成电信号之前的数字信息进行计算得到的，因此如果根据信号还原出的数字信息与发送前的信息一致，则计算出的FCS也应该与包末尾的FCS一致。如果两者不一致，则可能是因为噪声等影响导致信号失真，数据产生了错误，这时接收的包是无效的，因此需要丢弃[插图]。</p>
<p>当FCS一致，即确认数据没有错误时，接下来需要检查MAC头部中的接收方MAC地址，看看这个包是不是发给自己的。以太网的基本工作方式是将数据广播到整个网络上，只有指定的接收者才接收数据，因此网络中还有很多发给其他设备的数据在传输，如果包的接收者不是自己，那么就需要丢弃这个包。</p>
<p>接收信号并还原成数字信息的操作就完成了，还原后的数字信息被保存在网卡内部的缓冲区中。上面这些操作都是由网卡的MAC模块[插图]来完成的。</p>
<p>网卡的MAC模块将网络包从信号还原为数字信息，校验FCS并存入缓冲区。</p>
<p>在这个过程中，服务器的CPU并不是一直在监控网络包的到达，而是在执行其他的任务，因此CPU并不知道此时网络包已经到达了。但接下来的接收操作需要CPU来参与，因此网卡需要通过中断将网络包到达的事件通知给CPU。</p>
<p>CPU就会暂停当前的工作，并切换到网卡的任务。然后，网卡驱动会开始运行，从网卡缓冲区中将接收到的包读取出来，根据MAC头部的以太类型字段判断协议的种类，并调用负责处理该协议的软件。这里，以太类型的值应该是表示IP协议，因此会调用TCP/IP协议栈，并将包转交给它</p>
<p>网卡驱动会根据MAC头部判断协议类型，并将包交给相应的协议栈。</p>
<p>当网络包转交到协议栈时，IP模块会首先开始工作，检查IP头部。IP模块首先会检查IP头部的格式是否符合规范，然后检查接收方IP地址，看包是不是发给自己的。当服务器启用类似路由器的包转发功能时[插图]，对于不是发给自己的包，会像路由器一样根据路由表对包进行转发[插图]。</p>
<p>确认包是发给自己的之后，接下来需要检查包有没有被分片[插图]。检查IP头部的内容就可以知道是否分片[插图]，如果是分片的包，则将包暂时存放在内存中，等所有分片全部到达之后将分片组装起来还原成原始包；如果没有分片，则直接保留接收时的样子，不需要进行重组。到这里，我们就完成了包的接收。</p>
<p>接下来需要检查IP头部的协议号字段，并将包转交给相应的模块。例如，如果协议号为06（十六进制），则将包转交给TCP模块；如果是11（十六进制），则转交给UDP模块。</p>
<p>协议栈的IP模块会检查IP头部，（1）判断是不是发给自己的；（2）判断网络包是否经过分片；（3）将包转交给TCP模块或UDP模块。</p>
<p>当TCP头部中的控制位SYN为1时，表示这是一个发起连接的包（图6.7①）。这时，TCP模块会执行接受连接的操作，不过在此之前，需要先检查包的接收方端口号，并确认在该端口上有没有与接收方端口号相同且正在处于等待连接状态的套接字。如果指定端口号没有等待连接的套接字，则向客户端返回错误通知的包</p>
<p>如果存在等待连接的套接字，则为这个套接字复制一个新的副本，并将发送方IP地址、端口号、序号初始值、窗口大小等必要的参数写入这个套接字中，同时分配用于发送缓冲区和接收缓冲区的内存空间。然后生成代表接收确认的ACK号，用于从服务器向客户端发送数据的序号初始值，表示接收缓冲区剩余容量的窗口大小，并用这些信息生成TCP头部，委托IP模块发送给客户端[插图]。</p>
<p>这个包到达客户端之后，客户端会返回表示接收确认的ACK号，当这个ACK号返回服务器后，连接操作就完成了。</p>
<p>这时，服务器端的程序应该进入调用accept的暂停状态，当将新套接字的描述符转交给服务器程序之后，服务器程序就会恢复运行。</p>
<p>如果收到的是发起连接的包，则TCP模块会（1）确认TCP头部的控制位SYN;（2）检查接收方端口号；（3）为相应的等待连接套接字复制一个新的副本；（4）记录发送方IP地址和端口号等信息。</p>
<p>收到数据包时，TCP模块会（1）根据收到的包的发送方IP地址、发送方端口号、接收方IP地址、接收方端口号找到相对应的套接字；（2）将数据块拼合起来并保存在接收缓冲区中；（3）向客户端返回ACK。</p>
<p>在TCP协议的规则中，断开操作可以由客户端或服务器任何一方发起，具体的顺序是由应用层协议决定的。Web中，这一顺序随HTTP协议版本不同而不同，在HTTP1.0中，是服务器先发起断开操作。</p>
<p>服务器程序会调用Socket库的close, TCP模块会生成一个控制位FIN为1的TCP头部，并委托IP模块发送给客户端。当客户端收到这个包之后，会返回一个ACK号。接下来客户端调用close，生成一个FIN为1的TCP头部发给服务器，服务器再返回ACK号，这时断开操作就完成了。HTTP1.1中，是客户端先发起断开操作，这种情况下只要将客户端和服务器的操作颠倒一下就可以了。</p>
<p>无论哪种情况，当断开操作完成后，套接字会在经过一段时间后被删除。</p>
<p>◆ 6.3 Web服务器程序解释请求消息并作出响应</p>
<p>Web服务器的访问控制规则主要有以下3种。（1）客户端IP地址（2）客户端域名（3）用户名和密码</p>
<p>当根据客户端域名设置规则时，需要先根据客户端IP地址查询客户端域名，这需要使用DNS服务器。一般我们使用DNS服务器都是根据域名查询IP地址，其实根据IP地址反查域名也可以使用DNS服务器。具体来说，这个过程是这样的。收到客户端的请求消息后，Web服务器（图6.12①）会委托协议栈告知包的发送方IP地址，然后用这个IP地址生成查询消息并发送给最近的DNS服务器（图6.12②）。接下来，DNS服务器找出负责管辖该IP地址的DNS服务器，并将查询转发给它（图6.12③），查询到相应的域名之后返回结果（图6.12④），然后Web服务器端的DNS服务器再将结果转发给Web服务器（图6.12⑤）。这样一来，我们就可以根据发送方IP地址查询到域名。</p>
<p>为了保险起见，还需要用这个域名查询一下IP地址，看看结果与发送方IP地址是否一致（图6.12⑥）。这是因为有一种在DNS服务器上注册假域名的攻击方式，因此我们需要进行双重检查，如果两者一致则检查相应的访问控制规则，判断是否允许访问。</p>
<p>这种方式需要和DNS服务器进行多次查询，整个过程比较耗时，因此Web服务器的响应速度也会变慢。</p>
<p>Web服务器调用Socket库的write，将响应消息交给协议栈。这时，需要告诉协议栈这个响应消息应该发给谁，但我们并不需要直接告知客户端的IP地址等信息，而是只需要给出表示通信使用的套接字的描述符就可以了。套接字中保存了所有的通信状态，其中也包括通信对象的信息，因此只要有描述符就万事大吉了。</p>
<p>协议栈会将数据拆分成多个网络包，然后加上头部发送出去。这些包中包含接收方客户端的地址，它们将经过交换机和路由器的转发，通过互联网最终到达客户端。</p>
<p>◆ 6.4 浏览器接收响应消息并显示内容</p>
<p>看一看浏览器是如何显示内容的。</p>
<p>首先需要判断响应消息中的数据属于哪种类型。Web可以处理的数据包括文字、图像、声音、视频等多种类型，每种数据的显示方法都不同，因此必须先要知道返回了什么类型的数据，否则无法正确显示。</p>
<p>我们需要一些信息才能判断数据类型，原则上可以根据响应消息开头的Content-Type头部字段的值来进行判断。</p>
<p>当数据类型为文本时，还需要判断编码方式，这时需要用charset附加表示文本编码方式的信息</p>
<p>除了通过Content-Type判断数据类型，还需要检查Content-Encoding头部字段。如果消息中存放的内容是通过压缩或编码技术对原始数据进行转换得到的，那么Content-Encoding的值就表示具体的转换方式，通过这个字段的值，我们可以知道如何将消息中经过转换的数据还原成原始数据。</p>
<p>Content-Type字段使用的表示数据类型的方法是在MIME[插图]规格中定义的，这个规格不仅用于Web，也是邮件等领域中普遍使用的一种方式。不过这种方式也只不过是一种原则性的规范，要通过Content-Type准确判断数据类型，就需要保证Web服务器正确设置Content-Type的值，但现实中并非总是如此。如果Web服务器管理员不当心，就可能会因为设置错误导致Content-Type的值不正确。因此，根据原则检查Content-Type并不能确保总是能够准确判断数据类型。</p>
<p>有时候我们需要结合其他一些信息来综合判断数据类型，例如请求文件的扩展名、数据内容的格式等。比如，我们可以检查文件的扩展名，如果为．html或．htm则看作是HTML文件，或者也可以检查数据的内容，如果是以html开头的则看作是HTML文档。不仅是HTML这样的文本文件，图片也是一样。图片是经过压缩的二进制数据，但其开头也有表示内容格式的信息，我们可以根据这些信息来判断数据的类型。</p>
<p>根据数据类型调用用于显示内容的程序，将数据显示出来就可以了。对于HTML文档、纯文本、图片这些基本数据类型，浏览器自身具有显示这些内容的功能，因此由浏览器自身负责显示。</p>
<p>浏览器需要解释这些标签的含义，按照指定的样式显示文档的内容。实际的显示操作是由操作系统来完成的，浏览器负责对操作系统发出指令，例如在屏幕上的什么位置显示什么文字、使用什么样的字体等。</p>
<p>JPEG和GIF格式的图片是经过压缩的，浏览器需要将其解压后委托操作系统进行显示。</p>
<p>像HTML文档和图片等浏览器可自行显示的数据，就会按照上述方式委托浏览器在屏幕上显示出来。不过，Web服务器可能还会返回其他一些类型的数据，如文字处理、幻灯片等应用程序的数据。这些数据无法由浏览器自行显示，这时浏览器会调用相应的程序。这些程序可以是浏览器的插件，也可以是独立的程序，无论如何，不同类型的数据对应不同的程序，这一对应关系是在浏览器中设置好的，只要按照这一对应关系调用相应的程序，并将数据传递给它就可以了。然后，被调用的程序会负责显示相应的内容。</p>
<p>◆ CoIumn网络术语其实很简单</p>
<p>Web服务器有一种叫CGI（CommonGateway Interface，通用网关接口）的功能</p>
<p>CGI指的不是CGI程序本身，而是连接程序与Web服务器程序的接口规格。所以说，客户端发送的消息是通过CGI这样一个接口，从Web服务器程序进入CGI程序的。</p>
<p>除了CGI之外，还有其他一些通往异世界的入口，这些都叫gateway。</p>
<p>以前，对于相当于路由器这样的东西，有很多不同的叫法。TCP/IP中叫网关，TCP/IP之外的路由器又有别的叫法。即便是现在，像交换机、集线器之类的叫法也不是很明确呢</p>
<p>◆ 附录 网络包的旅程</p>
<p>网络包的旅程</p>
<p>计算机生成的网络包其内容是不变的，但在传输到Web服务器的过程中，其形态会发生变化。</p>
</div></template>


